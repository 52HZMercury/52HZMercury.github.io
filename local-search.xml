<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mamba心脏疾病诊断</title>
    <link href="/2025/09/25/mamba-classify/"/>
    <url>/2025/09/25/mamba-classify/</url>
    
    <content type="html"><![CDATA[<h2 id="1-medmamba复现">1. medmamba复现</h2><p>想首先尝试一下medmamba的实验复现，用做后续的基础架构</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251017161649103.png" alt="网络结构图"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250925140820005.png" alt="实验结果"></p><p>是二维的，不好改，还是改改之前的分割网络看看</p><h2 id="2-echo-mi实验">2. echo-mi实验</h2><h3 id="2-1-idea">2.1 idea</h3><p>使用双切面（二腔室+四腔室）超声心动图数据训练Mamba模型诊断早期心梗的需求，设计了一个创新性的双路径时空融合Mamba架构（Dual-Path Spatiotemporal Fusion Mamba, DPSF-Mamba）。该架构针对性解决多切面心脏超声的时空特征融合问题，核心思路如下：</p><p>一、核心改造思路</p><p>双路径异构特征提取</p><p>独立编码路径：为二腔室（2C）和四腔室（4C）切面分别设计专用Mamba块，适应不同视角的局部结构特征。<br>2C路径：聚焦左心室前壁、心尖部运动异常（早期心梗敏感区域）。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251011130229693.png" alt="image-20251011130229693"></p><p>4C路径：捕获室间隔、侧壁运动及整体心室协调性（诊断关键指标)。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251011130312755.png" alt="image-20251011130312755"></p><p>动态门控融合模块（DGFM）：引入可学习的门控权重，自适应融合双路径特征（公式示例）：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mrow><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mi>g</mi></msub><mo>⋅</mo><mo stretchy="false">[</mo><msub><mi>F</mi><mrow><mn>2</mn><mi>C</mi></mrow></msub><mo separator="true">,</mo><msub><mi>F</mi><mrow><mn>4</mn><mi>C</mi></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>⊙</mo><msub><mi>F</mi><mrow><mn>2</mn><mi>C</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mi>g</mi></msub><mo>⋅</mo><mo stretchy="false">[</mo><msub><mi>F</mi><mrow><mn>2</mn><mi>C</mi></mrow></msub><mo separator="true">,</mo><msub><mi>F</mi><mrow><mn>4</mn><mi>C</mi></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⊙</mo><msub><mi>F</mi><mrow><mn>4</mn><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{fused} = \sigma(W_g \cdot [F_{2C}, F_{4C}]) \odot F_{2C} + (1-\sigma(W_g \cdot [F_{2C}, F_{4C}])) \odot F_{4C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">se</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">W_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 为可训练权重，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 为Sigmoid函数，实现特征重要性动态分配。</p><p>多任务联合优化分类头</p><p>//todo</p><p>二、创新技术优势</p><table><thead><tr><th>模块</th><th>传统Mamba局限</th><th>DPSF-Mamba改进</th><th>临床价值</th></tr></thead><tbody><tr><td>多切面处理</td><td>单一路径忽视视角差异</td><td>双路径异构编码 + 动态融合</td><td>减少视角偏差，提升小病灶敏感性</td></tr><tr><td>时空特征利用</td><td>长序列建模但空间关联弱</td><td>时空切片重组 + 坐标注意力</td><td>同步捕捉运动异常与结构变形</td></tr><tr><td>数据效率</td><td>需大量标注数据</td><td>多任务学习共享特征</td><td>缓解超声标注稀缺问题</td></tr><tr><td>可解释性</td><td>黑盒决策</td><td>门控权重可视化切面贡献度</td><td>辅助医生理解AI诊断依据</td></tr></tbody></table><p>三、预期效果验证方案</p><p>可解释性分析</p><p>绘制门控权重热力图（如下示例），验证模型对病变切面的关注度：</p><p>前壁梗死患者：4C切面权重峰值达0.83（主导诊断）<br>心尖梗死患者：2C切面权重升至0.79</p><p>四、潜在挑战与解决方案</p><p>挑战1：双切面数据不全（如部分患者缺失一个切面）<br>方案：引入跨切面知识蒸馏，用完整数据训练教师网络指导单切面学生网络。<br>挑战2：超声伪影干扰<br>方案：在Mamba前端加入对抗去噪模块（如Conditional GAN）。</p><h3 id="2-2-faec-advance实验">2.2 faec_advance实验</h3><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>faec</td><td>0.71875</td><td>0.7013</td><td>0.3077</td><td>1.0</td><td>0.1818</td><td>1.0</td></tr></tbody></table><p>camus  多切面</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_6   fold_1</td><td>0.8125</td><td>0.858333</td><td>0.769230</td><td>0.714286</td><td>0.833333</td><td>0.8</td></tr><tr><td>Experiment_6   fold_2</td><td>0.75</td><td>0.741666</td><td>0.555555</td><td>0.833333</td><td>0.416666</td><td>0.949999</td></tr><tr><td>Experiment_6   fold_3</td><td>0.8125</td><td>0.899999</td><td>0.699999</td><td>0.875</td><td>0.583333</td><td>0.949999</td></tr><tr><td>Experiment_6   fold_4</td><td>0.78125</td><td>0.852814</td><td>0.588235</td><td>0.833333</td><td>0.454545</td><td>0.952380</td></tr><tr><td>Experiment_6   fold_5</td><td>0.71875</td><td>0.701298</td><td>0.307692</td><td>1.0</td><td>0.1818</td><td>1.0</td></tr><tr><td>Experiment_6 avg</td><td><strong>0.775</strong></td><td><strong>0.8108</strong></td><td><strong>0.5841</strong></td><td><strong>0.8512</strong></td><td><strong>0.4939</strong></td><td><strong>0.9305</strong></td></tr></tbody></table><h2 id="3-MIMamba实验">3. MIMamba实验</h2><p>改造之前的分割网络的mamba用于分类</p><h3 id="3-1-camus数据集">3.1 camus数据集</h3><p>camus A2C的实验</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th></tr></thead><tbody><tr><td>Experiment_4   fold_1</td><td>0.375</td><td>0.533333</td><td>0.545454</td><td>0.375</td><td>1.0</td></tr><tr><td>Experiment_4   fold_2</td><td>0.34375</td><td>0.558441</td><td>0.511628</td><td>0.34375</td><td>1.0</td></tr><tr><td>Experiment_5   fold_1</td><td>0.75</td><td>0.699999</td><td>0.636364</td><td>0.699999</td><td>0.583333</td></tr><tr><td>Experiment_5   fold_2</td><td>0.71875</td><td>0.670995</td><td>0.571428</td><td>0.6</td><td>0.545454</td></tr><tr><td>Experiment_5   fold_3</td><td>0.71875</td><td>0.636363</td><td>0.470588</td><td>0.571428</td><td>0.4</td></tr><tr><td>Experiment_5   fold_4</td><td>0.71875</td><td>0.590909</td><td>0.470588</td><td>0.571428</td><td>0.4</td></tr><tr><td>Experiment_5   fold_5</td><td>0.625</td><td>0.490909</td><td>0.4</td><td>0.4</td><td>0.4</td></tr><tr><td>Experiment_5   avg</td><td><strong>0.70625</strong></td><td><strong>0.617835</strong></td><td><strong>0.509794</strong></td><td><strong>0.568571</strong></td><td><strong>0.425757</strong></td></tr></tbody></table><p>camus 多切面</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_7   fold_1</td><td>0.84375</td><td>0.837499</td><td>0.761904</td><td>0.888888</td><td>0.666666</td><td>0.949999</td></tr><tr><td>Experiment_7   fold_2</td><td>0.75</td><td>0.708333</td><td>0.555555</td><td>0.833333</td><td>0.416666</td><td>0.949999</td></tr><tr><td>Experiment_7  fold_3</td><td>0.8125</td><td>0.8375</td><td>0.727272</td><td>0.8</td><td>0.666666</td><td>0.899999</td></tr><tr><td>Experiment_7   fold_4</td><td><strong>0.8125</strong></td><td><strong>0.818181</strong></td><td><strong>0.75</strong></td><td><strong>0.692307</strong></td><td><strong>0.818181</strong></td><td><strong>0.809523</strong></td></tr><tr><td>Experiment_7   fold_5</td><td>0.71875</td><td>0.714285</td><td>0.307692</td><td>1.0</td><td>0.181818</td><td>1.0</td></tr><tr><td>Experiment_7  (监控acc)</td><td>0.7875</td><td>0.7832</td><td>0.6205</td><td>0.8429</td><td>0.5500</td><td>0.9219</td></tr><tr><td>Experiment_8   fold_1</td><td>0.65625</td><td>0.875</td><td>0.266666</td><td>0.666666</td><td>0.166666</td><td>0.949999</td></tr><tr><td>Experiment_8   fold_2</td><td>0.75</td><td>0.816666</td><td>0.666666</td><td>0.666666</td><td>0.666666</td><td>0.8</td></tr><tr><td>Experiment_8  fold_3</td><td>0.71875</td><td>0.858333</td><td>0.571428</td><td>0.666666</td><td>0.5</td><td>0.85</td></tr><tr><td>Experiment_8   fold_4</td><td>0.65625</td><td>0.8658</td><td>0.0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>Experiment_8   fold_5</td><td><strong>0.6875</strong></td><td><strong>0.796536</strong></td><td><strong>0.583333</strong></td><td><strong>0.538461</strong></td><td><strong>0.636363</strong></td><td><strong>0.714285</strong></td></tr><tr><td>Experiment_8  (监控auc)</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_9   fold_1</td><td>0.75</td><td>0.879166</td><td>0.5</td><td>1.0</td><td>0.333333</td><td>1.0</td></tr><tr><td>Experiment_9   fold_2</td><td>0.65625</td><td>0.695833</td><td>0.153846</td><td>1.0</td><td>0.083333</td><td>1.0</td></tr><tr><td>Experiment_9  fold_3</td><td>0.65625</td><td>0.770833</td><td>0.153846</td><td>1.0</td><td>0.083333</td><td>1.0</td></tr><tr><td>Experiment_9   fold_4</td><td>0.6875</td><td>0.649350</td><td>0.166666</td><td>1.0</td><td>0.090909</td><td>1.0</td></tr><tr><td>Experiment_9   fold_5</td><td>0.75</td><td>0.761904</td><td>0.5</td><td>0.8</td><td>0.363636</td><td>0.952380</td></tr><tr><td>Experiment_9  (precision)</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_10   fold_1</td><td>0.84375</td><td>0.875</td><td>0.814814</td><td>0.733333</td><td>0.916666</td><td>0.8</td></tr><tr><td>Experiment_10   fold_2</td><td><strong>0.78125</strong></td><td><strong>0.75</strong></td><td><strong>0.695652</strong></td><td><strong>0.727272</strong></td><td><strong>0.666666</strong></td><td><strong>0.85</strong></td></tr><tr><td>Experiment_10  fold_3</td><td><strong>0.84375</strong></td><td><strong>0.85</strong></td><td><strong>0.761904</strong></td><td><strong>0.888888</strong></td><td><strong>0.666666</strong></td><td><strong>0.949999</strong></td></tr><tr><td>Experiment_10   fold_4</td><td>0.75</td><td>0.779220</td><td>0.692307</td><td>0.6</td><td>0.818181</td><td>0.714285</td></tr><tr><td>Experiment_10   fold_5</td><td>0.625</td><td>0.675324</td><td>0.625</td><td>0.476190</td><td>0.909090</td><td>0.476190</td></tr><tr><td>Experiment_10  (监控f1)</td><td>0.7688</td><td>0.7859</td><td>0.7179</td><td>0.6851</td><td>0.7955</td><td>0.7581</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_11   fold_1</td><td><strong>0.90625</strong></td><td><strong>0.85</strong></td><td><strong>0.869565</strong></td><td><strong>0.909090</strong></td><td><strong>0.833333</strong></td><td><strong>0.949999</strong></td></tr><tr><td>Experiment_11   fold_2</td><td>0.75</td><td>0.754166</td><td>0.714285</td><td>0.625</td><td>0.833333</td><td>0.699999</td></tr><tr><td>Experiment_11  fold_3</td><td>0.78125</td><td>0.820833</td><td>0.740740</td><td>0.666666</td><td>0.833333</td><td>0.75</td></tr><tr><td>Experiment_11   fold_4</td><td>0.75</td><td>0.744588</td><td>0.714285</td><td>0.588235</td><td>0.909090</td><td>0.666666</td></tr><tr><td>Experiment_11   fold_5</td><td>0.65625</td><td>0.679653</td><td>0.645161</td><td>0.5</td><td>0.909090</td><td>0.523809</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_best</td><td><strong>0.8063</strong></td><td><strong>0.8129</strong></td><td><strong>0.7321</strong></td><td><strong>0.7512</strong></td><td><strong>0.7242</strong></td><td><strong>0.8547</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_15  fold_1</td><td>0.875</td><td>0.870833</td><td>0.846153</td><td>0.785714</td><td>0.916666</td><td>0.85</td></tr><tr><td>Experiment_15  fold_2</td><td>0.8125</td><td>0.762499</td><td>0.769230</td><td>0.714285</td><td>0.833333</td><td>0.8</td></tr><tr><td>Experiment_15  fold_3</td><td>0.84375</td><td>0.854166</td><td>0.761904</td><td>0.888888</td><td>0.666666</td><td>0.949999</td></tr><tr><td>Experiment_15  fold_4</td><td>0.75</td><td>0.709956</td><td>0.6</td><td>0.666666</td><td>0.545454</td><td>0.857142</td></tr><tr><td>Experiment_15  fold_5</td><td>0.75</td><td>0.718614</td><td>0.692307</td><td>0.6</td><td>0.818181</td><td>0.714285</td></tr><tr><td>Experiment_15</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_18  fold_1</td><td>0.78125</td><td>0.725</td><td>0.72</td><td>0.6923</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_23  fold_1</td><td>0.78125</td><td>0.7625</td><td>0.6666</td><td>0.7777</td><td>0.5833</td><td>0.8999</td></tr><tr><td>Experiment_24  fold_1</td><td>0.8125</td><td>0.8166</td><td>0.6999</td><td>0.875</td><td>0.5833</td><td>0.949999</td></tr><tr><td>Experiment_25  fold_1</td><td>0.84375</td><td>0.862499</td><td>0.761904</td><td>0.888888</td><td>0.666666</td><td>0.949999</td></tr></tbody></table><p>使用adaw</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_28  fold_1</td><td>0.8125</td><td>0.791666</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr><tr><td>Experiment_29  fold_1</td><td>0.8125</td><td>0.7958</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr></tbody></table><p>camus mi_mamba  A2C和A4C路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d_state: <span class="hljs-number">16</span>   d_state: <span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_26  fold_1</td><td>0.78125</td><td>0.766666</td><td>0.72</td><td>0.692307</td><td>0.75</td><td>0.8</td></tr></tbody></table><p>换用 adaw</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_27  fold_1</td><td>0.8125</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr></tbody></table><p>camus 多切面  MultiStageFusion</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_12   fold_1</td><td>0.8125</td><td>0.866666</td><td>0.699999</td><td>0.875</td><td>0.583333</td><td>0.949999</td></tr><tr><td>Experiment_12   fold_2</td><td>0.75</td><td>0.720833</td><td>0.666666</td><td>0.666666</td><td>0.666666</td><td>0.8</td></tr><tr><td>Experiment_12  fold_3</td><td>0.78125</td><td>0.75</td><td>0.631579</td><td>0.857142</td><td>0.5</td><td>0.949</td></tr><tr><td>Experiment_13   fold_1</td><td>0.8125</td><td>0.754166</td><td>0.699999</td><td>0.875</td><td>0.583333</td><td>0.949999</td></tr><tr><td>Experiment_14  fold_1</td><td>0.8125</td><td>0.891666</td><td>0.785714</td><td>0.6875</td><td>0.916666</td><td>0.75</td></tr></tbody></table><p>camus 多尺度融合模型</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_17  fold_1</td><td>0.71875</td><td>0.695833</td><td>0.666666</td><td>0.6</td><td>0.75</td><td>0.699999</td></tr></tbody></table><p>camus 分层融合模型mi_mamba_hierarchical_model</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_16  fold_1</td><td>0.78125</td><td>0.8208</td><td>0.7407</td><td>0.666666</td><td>0.833333</td><td>0.75</td></tr><tr><td>Experiment_16  fold_2</td><td>0.6875</td><td>0.5208</td><td>0.375</td><td>0.75</td><td>0.25</td><td>0.9499</td></tr><tr><td>Experiment_16  fold_3</td><td>0.75</td><td>0.8</td><td>0.6</td><td>0.75</td><td>0.5</td><td>0.8999</td></tr><tr><td>Experiment_16  fold_4</td><td>0.75</td><td>0.6883</td><td>0.6</td><td>0.666666</td><td>0.545454</td><td>0.857142</td></tr><tr><td>Experiment_16  fold_5</td><td>0.6875</td><td>0.580086</td><td>0.375</td><td>0.6</td><td>0.272727</td><td>0.904762</td></tr><tr><td>Experiment_19  fold_1</td><td>0.75</td><td>0.758333</td><td>0.5555</td><td></td><td></td><td></td></tr><tr><td>Experiment_20  fold_1</td><td>0.75</td><td>0.7333</td><td>0.6666</td><td>0.666666</td><td>0.666666</td><td>0.8</td></tr><tr><td>Experiment_21  fold_1</td><td>0.78125</td><td>0.75</td><td>0.695652</td><td>0.727272</td><td>0.666666</td><td>0.85</td></tr><tr><td>Experiment_22  fold_1</td><td>0.75</td><td>0.6875</td><td>0.5555</td><td>0.8333</td><td>0.416666</td><td>0.9499</td></tr><tr><td></td><td>0.75</td><td>0.6958</td><td>0.6</td><td>0.75</td><td>0.5</td><td>0.899999</td></tr><tr><td>换用adaw</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_30  fold_1</td><td>0.78125</td><td>0.708333</td><td>0.666666</td><td>0.777777</td><td>0.583333</td><td>0.899999</td></tr></tbody></table><p>cross-ssm</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_32  fold_1</td><td>0.625</td><td>0.475</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>Experiment_33  fold_1</td><td>0.78125</td><td>0.783333</td><td>0.666666</td><td>0.777777</td><td>0.583333</td><td>0.899999</td></tr><tr><td>Experiment_34  fold_1 gate</td><td>0.75</td><td>0.754166</td><td>0.636363</td><td>0.699999</td><td>0.583333</td><td>0.85</td></tr><tr><td>Experiment_35  fold_1 gate w</td><td>0.8125</td><td>0.804166</td><td>0.727272</td><td>0.8</td><td>0.666666</td><td>0.899999</td></tr><tr><td>Experiment_36  fold_1 attn w</td><td>0.75</td><td>0.720833</td><td>0.6</td><td>0.75</td><td>0.5</td><td>0.899999</td></tr><tr><td>Experiment_37  fold_1 gate attn w</td><td>0.8125</td><td>0.825</td><td>0.727272</td><td>0.8</td><td>0.666666</td><td>0.899999</td></tr><tr><td>Experiment_  fold_1 attn gate w</td><td>0.75</td><td>0.774999</td><td>0.636363</td><td>0.699999</td><td>0.583333</td><td>0.85</td></tr></tbody></table><p>从上面的来看cross-ssm效果还可以，继续使用cross-ssm 验证camus填充方式</p><p>cross-ssm   gate attn w</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_39  fold_1  repeat</td><td>0.78125</td><td>0.729166</td><td>0.666666</td><td>0.777777</td><td>0.583333</td><td>0.899999</td></tr><tr><td>Experiment_40  fold_1  interpolate</td><td><strong>0.84375</strong></td><td><strong>0.845833</strong></td><td><strong>0.8</strong></td><td><strong>0.769230</strong></td><td><strong>0.833333</strong></td><td><strong>0.85</strong></td></tr><tr><td>Experiment_40  fold_1  random_repeat</td><td>0.75</td><td>0.754166</td><td>0.666666</td><td>0.666666</td><td>0.666666</td><td>0.8</td></tr><tr><td>Experiment_41  fold_1  cyclic</td><td>0.8125</td><td>0.791666</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr><tr><td>Experiment_42  fold_1  reflect</td><td>0.71875</td><td>0.745833</td><td>0.666666</td><td>0.6</td><td>0.75</td><td>0.699999</td></tr><tr><td>Experiment_43  fold_1  noise</td><td>0.75</td><td>0.745833</td><td>0.692307</td><td>0.642857</td><td>0.75</td><td>0.75</td></tr><tr><td>Experiment_44  fold_1  random</td><td>0.8125</td><td>0.783333</td><td>0.727272</td><td>0.8</td><td>0.666666</td><td>0.899999</td></tr></tbody></table><p>hidden size降低到256再试试</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_60  fold_1  repeat</td><td>0.75</td><td>0.766666</td><td>0.636363</td><td>0.699999</td><td>0.583333</td><td>0.85</td></tr><tr><td>Experiment_61  fold_1  interpolate</td><td>0.78125</td><td>0.829166</td><td>0.666666</td><td>0.777777</td><td>0.583333</td><td>0.899999</td></tr><tr><td>Experiment_62  fold_1  random_repeat</td><td>0.8125</td><td>0.8083</td><td>0.7692</td><td>0.714285</td><td>0.833333</td><td>0.8</td></tr><tr><td>Experiment_63  fold_1  cyclic</td><td>0.78125</td><td>0.716666</td><td>0.72</td><td>0.6923</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_64  fold_1  reflect</td><td>0.78125</td><td>0.795833</td><td>0.666666</td><td>0.777777</td><td>0.583333</td><td>0.899999</td></tr><tr><td>Experiment_65  fold_1  noise</td><td>0.8125</td><td>0.795833</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr><tr><td>Experiment_66  fold_1  random</td><td>0.78125</td><td>0.7875</td><td>0.695652</td><td>0.727272</td><td>0.666666</td><td>0.85</td></tr></tbody></table><p>cross-ssm</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_45  fold_1</td><td>0.84375</td><td>0.858333</td><td>0.761904</td><td>0.888888</td><td>0.666666</td><td>0.949999</td></tr><tr><td>Experiment_45  fold_1</td><td>0.78125</td><td>0.8</td><td>0.72</td><td>0.692307</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_46  fold_1</td><td>0.71875</td><td>0.704166</td><td>0.666666</td><td>0.6</td><td>0.75</td><td>0.699999</td></tr><tr><td>Experiment_47  fold_1</td><td>0.78125</td><td>0.758333</td><td>0.695652</td><td>0.727272</td><td>0.666666</td><td>0.85</td></tr><tr><td>Experiment_48  fold_1 b8</td><td>0.78125</td><td>0.779166</td><td>0.72</td><td>0.692307</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_49  fold_1 b16</td><td>0.78125</td><td>0.758333</td><td>0.740740</td><td>0.666666</td><td>0.833333</td><td>0.75</td></tr><tr><td>增加模型feat[32, 64, 128, 256]</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_50  fold_1 b8</td><td>0.78125</td><td>0.741666</td><td>0.740740</td><td>0.666666</td><td>0.833333</td><td>0.75</td></tr><tr><td>Experiment_51  fold_1 b8</td><td>0.78125</td><td>0.7875</td><td>0.758620</td><td>0.647058</td><td>0.916666</td><td>0.699999</td></tr><tr><td>Experiment_52  fold_1 b8</td><td>0.75</td><td>0.804166</td><td>0.714285</td><td>0.625</td><td>0.833333</td><td>0.699999</td></tr><tr><td>改回了填充到32帧</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_53  fold_1</td><td>0.78125</td><td>0.779166</td><td>0.72</td><td>0.6923</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_54  fold_1</td><td>0.78125</td><td>0.7625</td><td>0.666666</td><td>0.7777</td><td>0.583333</td><td>0.899999</td></tr><tr><td>增大hidden size   512</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_56  fold_1</td><td>0.71875</td><td>0.666666</td><td>0.666666</td><td>0.6</td><td>0.75</td><td>0.699999</td></tr><tr><td>Experiment_57  fold_1</td><td>0.78125</td><td>0.729166</td><td>0.666666</td><td>0.777777</td><td>0.583333</td><td>0.899999</td></tr><tr><td>hidden size   256</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_58  fold_1</td><td>0.78125</td><td>0.754166</td><td>0.740740</td><td>0.666666</td><td>0.833333</td><td>0.75</td></tr><tr><td>hidden size   768</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_59  fold_1</td><td>0.78125</td><td>0.7875</td><td>0.6315</td><td>0.8571</td><td>0.5</td><td>0.9499</td></tr></tbody></table><p>前面的损失都是bce</p><p>损失</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_67  fold_1  focal</td><td>0.6875</td><td>0.770833</td><td>0.545454</td><td>0.6</td><td>0.5</td><td>0.8</td></tr><tr><td>Experiment_68  fold_1  dice</td><td>0.75</td><td>0.779166</td><td>0.6</td><td>0.75</td><td>0.5</td><td>0.899999</td></tr><tr><td>Experiment_69  fold_1  bce_dice</td><td>0.75</td><td>0.729166</td><td>0.636363</td><td>0.699999</td><td>0.583333</td><td>0.85</td></tr><tr><td>Experiment_70  fold_1  tversky</td><td><strong>0.875</strong></td><td><strong>0.829166</strong></td><td><strong>0.846153</strong></td><td><strong>0.785714</strong></td><td><strong>0.916666</strong></td><td><strong>0.85</strong></td></tr><tr><td>Experiment_71  fold_1  asymmetric</td><td>0.78125</td><td>0.766666</td><td>0.72</td><td>0.6923</td><td>0.75</td><td>0.8</td></tr></tbody></table><p>tversky 完整实验</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_70  fold_1</td><td>0.875</td><td>0.829166</td><td>0.846153</td><td>0.785714</td><td>0.916666</td><td>0.85</td></tr><tr><td>Experiment_70  fold_2</td><td>0.75</td><td>0.675</td><td>0.666666</td><td>0.666666</td><td>0.666666</td><td>0.8</td></tr><tr><td>Experiment_70  fold_3</td><td>0.71875</td><td>0.691666</td><td>0.526315</td><td>0.714285</td><td>0.416666</td><td>0.899999</td></tr><tr><td>Experiment_70  fold_4</td><td>0.71875</td><td>0.718614</td><td>0.608695</td><td>0.583333</td><td>0.636363</td><td>0.761904</td></tr><tr><td>Experiment_70  fold_5</td><td>0.5625</td><td>0.597402</td><td>0.533333</td><td>0.421052</td><td>0.727272</td><td>0.476190</td></tr></tbody></table><p><strong>还是改为16帧吧</strong></p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_74  fold_1</td><td>0.84375</td><td>0.770833</td><td>0.782608</td><td>0.818181</td><td>0.75</td><td>0.899999</td></tr><tr><td>Experiment_74  fold_2</td><td>0.6875</td><td>0.645833</td><td>0.375</td><td>0.75</td><td>0.25</td><td>0.949999</td></tr><tr><td>Experiment_74  fold_3</td><td>0.6875</td><td>0.6875</td><td>0.5454</td><td>0.6</td><td>0.5</td><td>0.8</td></tr><tr><td>Experiment_74  fold_4</td><td>0.78125</td><td>0.744588</td><td>0.666666</td><td>0.699999</td><td>0.636363</td><td>0.857142</td></tr><tr><td>Experiment_74  fold_5</td><td>0.6875</td><td>0.670995</td><td>0.583333</td><td>0.538461</td><td>0.636363</td><td>0.714285</td></tr></tbody></table><p>bce损失</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_75  fold_1</td><td>0.8125</td><td>0.7666</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr><tr><td>Experiment_75  fold_2</td><td>0.6875</td><td>0.637499</td><td>0.444444</td><td>0.666666</td><td>0.333333</td><td>0.899999</td></tr><tr><td>Experiment_75  fold_3</td><td>0.6875</td><td>0.612499</td><td>0.583333</td><td>0.583333</td><td>0.583333</td><td>0.75</td></tr><tr><td>Experiment_75  fold_4</td><td>0.75</td><td>0.766233</td><td>0.555555</td><td>0.714285</td><td>0.454545</td><td>0.904761</td></tr><tr><td>Experiment_75  fold_5</td><td>0.59375</td><td>0.683982</td><td>0.580645</td><td>0.449999</td><td>0.818181</td><td>0.476190</td></tr></tbody></table><p>去掉模块</p><p>bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_76  fold_1</td><td>0.8125</td><td>0.8292</td><td>0.7273</td><td>0.8</td><td>0.6667</td><td>0.8999</td></tr><tr><td>Experiment_76  fold_2</td><td>0.75</td><td>0.7083</td><td>0.6923</td><td>0.6429</td><td>0.75</td><td>0.75</td></tr><tr><td>Experiment_76  fold_3</td><td>0.75</td><td>0.7916</td><td>0.6364</td><td>0.6999</td><td>0.5833</td><td>0.85</td></tr><tr><td>Experiment_76  fold_4</td><td>0.78125</td><td>0.7359</td><td>0.6666</td><td>0.6999</td><td>0.6363</td><td>0.8571</td></tr><tr><td>Experiment_76  fold_5</td><td>0.4375</td><td>0.5757</td><td>0.5263</td><td>0.3703</td><td>0.9090</td><td>0.1904</td></tr></tbody></table><p>只加上gated</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_77  fold_1</td><td>0.6875</td><td>0.7375</td><td>0.6666</td><td>0.5555</td><td>0.8333</td><td>0.6</td></tr><tr><td>Experiment_77  fold_2</td><td>0.7187</td><td>0.6666</td><td>0.64</td><td>0.6153</td><td>0.6666</td><td>0.75</td></tr><tr><td>Experiment_77  fold_3</td><td>0.5937</td><td>0.5916</td><td>0.6285</td><td>0.4782</td><td>0.9166</td><td>0.4</td></tr><tr><td>Experiment_77  fold_4</td><td>0.5625</td><td>0.6147</td><td>0.5882</td><td>0.4347</td><td>0.9090</td><td>0.3809</td></tr><tr><td>Experiment_77  fold_5</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>只加上attn</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_78  fold_1</td><td>0.75</td><td>0.7541</td><td>0.6666</td><td>0.6666</td><td>0.6666</td><td>0.8</td></tr><tr><td>Experiment_78  fold_2</td><td>0.71875</td><td>0.6916</td><td>0.64</td><td>0.6153</td><td>0.6666</td><td>0.75</td></tr><tr><td>Experiment_78  fold_3</td><td>0.625</td><td>0.6208</td><td>0.6</td><td>0.5</td><td>0.75</td><td>0.55</td></tr><tr><td>Experiment_78  fold_4</td><td>0.7187</td><td>0.5930</td><td>0.5263</td><td>0.625</td><td>0.4545</td><td>0.8571</td></tr><tr><td>Experiment_78  fold_5</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-1-1-mamba-echoprime-video">3.1.1 mamba+echoprime video</h4><p>使用两个分支对两个切面的数据进行提取，echo_prime和mamba进行提取，最后一起送入分类器</p><p>mamba: A2C切面的数据</p><p>echo_prime: A4C切面的数据</p><p>融合: 通道拼接</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_79  fold_1</td><td>0.7813</td><td>0.7333</td><td>0.6667</td><td>0.7777</td><td>0.5833</td><td>0.90</td></tr><tr><td>Experiment_79  fold_2</td><td>0.78125</td><td>0.774999</td><td>0.5882</td><td>1.0</td><td>0.4166</td><td>1.0</td></tr><tr><td>Experiment_79  fold_3</td><td>0.875</td><td>0.9208</td><td>0.818181</td><td>0.899999</td><td>0.75</td><td>0.949999</td></tr><tr><td>Experiment_79  fold_4</td><td>0.84375</td><td>0.839826</td><td>0.761904</td><td>0.8</td><td>0.727272</td><td>0.904761</td></tr><tr><td>Experiment_79  fold_5</td><td>0.78125</td><td>0.757575</td><td>0.6666</td><td>0.699999</td><td>0.636363</td><td>0.857142</td></tr><tr><td>Experiment_79</td><td>0.8125</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>保留<code>2*2*2</code>的空间结构</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_80  fold_1</td><td>0.78125</td><td>0.695833</td><td>0.666666</td><td>0.777777</td><td>0.5833</td><td>0.8999</td></tr><tr><td>Experiment_80  fold_2</td><td>0.78125</td><td>0.787499</td><td>0.695652</td><td>0.727272</td><td>0.666666</td><td>0.85</td></tr><tr><td>Experiment_80  fold_3</td><td>0.875</td><td>0.8958</td><td>0.846153</td><td>0.785714</td><td>0.916666</td><td>0.85</td></tr><tr><td>Experiment_80  fold_4</td><td>0.84375</td><td>0.839826</td><td>0.782608</td><td>0.75</td><td>0.818181</td><td>0.857142</td></tr><tr><td>Experiment_80  fold_5</td><td>0.8125</td><td>0.787878</td><td>0.6666</td><td>0.8571</td><td>0.5454</td><td>0.9523</td></tr><tr><td>Experiment_80</td><td>0.8188</td><td>0.8014</td><td>0.7315</td><td>0.7796</td><td>0.7060</td><td>0.8818</td></tr></tbody></table><p>保留<code>4*4*4</code>的空间结构</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_81  fold_1</td><td>0.8125</td><td>0.875</td><td>0.6999</td><td>0.875</td><td>0.5833</td><td>0.9499</td></tr><tr><td>Experiment_81  fold_2</td><td>0.8125</td><td>0.775</td><td>0.7272</td><td>0.8</td><td>0.666666</td><td>0.899999</td></tr><tr><td>Experiment_81  fold_3</td><td>0.875</td><td>0.879166</td><td>0.8333</td><td>0.8333</td><td>0.8333</td><td>0.8999</td></tr><tr><td>Experiment_81  fold_4</td><td>0.84375</td><td>0.848484</td><td>0.7826</td><td>0.75</td><td>0.818181</td><td>0.857142</td></tr><tr><td>Experiment_81  fold_5</td><td>0.84375</td><td>0.7922</td><td>0.7619</td><td>0.8</td><td>0.727272</td><td>0.904761</td></tr><tr><td>Experiment_80</td><td><strong>0.8375</strong></td><td><strong>0.8139</strong></td><td><strong>0.7610</strong></td><td><strong>0.8117</strong></td><td><strong>0.7257</strong></td><td><strong>0.9023</strong></td></tr></tbody></table><p>交换特征提取器</p><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_82  fold_1</td><td>0.90625</td><td>0.879166</td><td>0.879999</td><td>0.846153</td><td>0.916666</td><td>0.899999</td></tr><tr><td>Experiment_82  fold_2</td><td>0.78125</td><td>0.741666</td><td>0.695652</td><td>0.727272</td><td>0.666666</td><td>0.85</td></tr><tr><td>Experiment_82  fold_3</td><td>0.8125</td><td>0.8666</td><td>0.7692</td><td>0.714285</td><td>0.8333</td><td>0.8</td></tr><tr><td>Experiment_82  fold_4</td><td>0.90625</td><td>0.9220</td><td>0.842105</td><td>1.0</td><td>0.727272</td><td>1.0</td></tr><tr><td>Experiment_82  fold_5</td><td>0.75</td><td>0.6666</td><td>0.5</td><td>0.8</td><td>0.363636</td><td>0.9523</td></tr><tr><td>Experiment_82</td><td>0.8312</td><td>0.8152</td><td>0.7373</td><td>0.8175</td><td>0.6976</td><td>0.8805</td></tr></tbody></table><p>学习率</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_83  fold_5  1e-4</td><td>0.71875</td><td>0.6320</td><td>0.3077</td><td>1.0</td><td>0.1818</td><td>1.0</td></tr><tr><td>Experiment_84  fold_5  1e-6</td><td>0.78125</td><td>0.7445</td><td>0.5882</td><td>0.8333</td><td>0.454545</td><td>0.952380</td></tr></tbody></table><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_84  fold_1</td><td>0.9375</td><td>0.904166</td><td>0.916666</td><td>0.916666</td><td>0.916666</td><td>0.949999</td></tr><tr><td>Experiment_84  fold_2</td><td>0.78125</td><td>0.699999</td><td>0.72</td><td>0.692307</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_84  fold_3</td><td>0.84375</td><td>0.816666</td><td>0.8</td><td>0.769230</td><td>0.833333</td><td>0.85</td></tr><tr><td>Experiment_84  fold_4</td><td>0.90625</td><td>0.8961</td><td>0.8571</td><td>0.8999</td><td>0.818181</td><td>0.952380</td></tr><tr><td>Experiment_84  fold_5</td><td>0.78125</td><td>0.7445</td><td>0.5882</td><td>0.8333</td><td>0.454545</td><td>0.952380</td></tr><tr><td>Experiment_84   95%</td><td><strong>0.8500</strong></td><td><strong>0.8249</strong></td><td><strong>0.7857</strong></td><td><strong>0.8148</strong></td><td><strong>0.7586</strong></td><td><strong>0.9020</strong></td></tr></tbody></table><h4 id="3-1-2-mamba-echoprime-text-video">3.1.2 mamba+echoprime text video</h4><p>在mamba的decoder部分加入三层知识向量</p><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构  损失bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_102  fold_1</td><td>0.9375</td><td>0.895833</td><td>0.916666</td><td>0.916666</td><td>0.916666</td><td>0.949999</td></tr><tr><td>Experiment_102  fold_2</td><td>0.78125</td><td>0.7374</td><td>0.6666</td><td>0.7777</td><td>0.5833</td><td>0.8999</td></tr><tr><td>Experiment_102  fold_3</td><td>0.78125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_102  fold_4</td><td>0.875</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_102  fold_5</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_102</td><td>0.816</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在mamba的decoder部分加入知识向量和echo prime视频提取部分都加入知识向量</p><p>学习率1e-5</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_103  fold_1</td><td>0.90625</td><td>0.8791</td><td>0.8799</td><td>0.8461</td><td>0.9166</td><td>0.8999</td></tr><tr><td>Experiment_103  fold_2</td><td>0.78125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_103  fold_3</td><td>0.8125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_103  fold_4</td><td>0.875</td><td>0.8744</td><td>0.8</td><td>0.8888</td><td>0.7272</td><td>0.9523</td></tr><tr><td>Experiment_103  fold_5</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_103</td><td>0.825</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>损失asymmetric   学习率1e-5</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_104  fold_1</td><td>0.90625</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_104  fold_2</td><td>0.78125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_104  fold_5</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>学习率</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_105  fold_5   1e-6</td><td>0.71875</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_106  fold_5   1e-5</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_107  fold_5   1e-4</td><td>0.71875</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_108  fold_5   3e-4</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_109  fold_5   3e-5</td><td>0.6875</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_110  fold_5   3e-6</td><td>0.71875</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>效果好差，还是只加一层知识向量吧</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_111  fold_5   1e-6</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在A4C的mamba的瓶颈层加入知识向量，同时A2C的video encoder也加入知识向量</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_112  fold_1</td><td>0.9375</td><td>0.925</td><td>0.916666</td><td>0.916666</td><td>0.916666</td><td>0.9499</td></tr><tr><td>Experiment_112  fold_2</td><td>0.78125</td><td>0.7374</td><td>0.6666</td><td>0.7777</td><td>0.5833</td><td>0.8999</td></tr><tr><td>Experiment_112  fold_3</td><td>0.78125</td><td>0.7958</td><td>0.72</td><td>0.6923</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_112  fold_4</td><td>0.875</td><td>0.8701</td><td>0.8181</td><td>0.818181</td><td>0.818181</td><td>0.9047</td></tr><tr><td>Experiment_112  fold_5</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_112</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>b16</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_113  fold_1</td><td>0.90625</td><td>0.9208</td><td>0.8799</td><td>0.8461</td><td>0.9166</td><td>0.8999</td></tr><tr><td>Experiment_113  fold_2</td><td>0.78125</td><td>0.725</td><td>0.72</td><td>0.6923</td><td>0.75</td><td>0.8</td></tr><tr><td>Experiment_113  fold_3</td><td>0.75</td><td>0.8125</td><td>0.7142</td><td>0.625</td><td>0.8333</td><td>0.6999</td></tr><tr><td>Experiment_113  fold_4</td><td>0.90625</td><td>0.8658</td><td>0.8571</td><td>0.8999</td><td>0.8181</td><td>0.9523</td></tr><tr><td>Experiment_113  fold_5</td><td>0.78125</td><td>0.6666</td><td>0.6666</td><td>0.6999</td><td>0.6363</td><td>0.8571</td></tr><tr><td>Experiment_113</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>交换A2C和A4C  十分拉跨</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_114  fold_1</td><td>0.75</td><td>0.8458</td><td>0.7333</td><td>0.6111</td><td>0.9166</td><td>0.6499</td></tr><tr><td>Experiment_114  fold_2</td><td>0.8125</td><td>0.875</td><td>0.7692</td><td>0.7142</td><td>0.8333</td><td>0.8</td></tr><tr><td>Experiment_114  fold_3</td><td>0.78125</td><td>0.825</td><td>0.7586</td><td>0.6470</td><td>0.9166</td><td>0.6999</td></tr><tr><td>Experiment_114  fold_4</td><td>0.6875</td><td>0.7748</td><td>0.6428</td><td>0.5294</td><td>0.8181</td><td>0.6190</td></tr><tr><td>Experiment_114  fold_5</td><td>0.75</td><td>0.6926</td><td>0.6666</td><td>0.6153</td><td>0.7272</td><td>0.7619</td></tr></tbody></table><p>在mamba的decoder部分加入知识向量和echo prime video encoder 加入知识向量</p><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构  损失bce</p><p>学习率1e-6  b8</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_115  fold_1</td><td>0.9375</td><td>0.9125</td><td>0.9166</td><td>0.9166</td><td>0.9166</td><td>0.9499</td></tr><tr><td>Experiment_115  fold_2</td><td>0.8125</td><td>0.7333</td><td>0.75</td><td>0.75</td><td>0.75</td><td>0.85</td></tr><tr><td>Experiment_115  fold_3</td><td>0.8125</td><td>0.8041</td><td>0.7272</td><td>0.8</td><td>0.6666</td><td>0.8999</td></tr><tr><td>Experiment_115  fold_4</td><td>0.90625</td><td>0.9004</td><td>0.8571</td><td>0.8999</td><td>0.8181</td><td>0.9523</td></tr><tr><td>Experiment_115  fold_5</td><td>0.78125</td><td>0.7835</td><td>0.5882</td><td>0.8333</td><td>0.4545</td><td>0.9523</td></tr><tr><td>Experiment_115   95%</td><td><strong>0.8500</strong></td><td><strong>0.8315</strong></td><td><strong>0.7778</strong></td><td><strong>0.8400</strong></td><td><strong>0.7241</strong></td><td><strong>0.9216</strong></td></tr></tbody></table><h3 id="3-2-hmc数据集">3.2 hmc数据集</h3><p>简单的先尝试，效果非常的糟糕</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_73  fold_1</td><td>0.84375</td><td>0.884057</td><td>0.888888</td><td>0.909090</td><td>0.869565</td><td>0.777777</td></tr><tr><td>Experiment_73  fold_2</td><td>0.75</td><td>0.744588</td><td>0.826086</td><td>0.759999</td><td>0.904761</td><td>0.454545</td></tr><tr><td>Experiment_73  fold_3</td><td>0.6875</td><td>0.647058</td><td>0.75</td><td>0.652174</td><td>0.882352</td><td>0.466666</td></tr><tr><td>Experiment_73  fold_4</td><td>0.6875</td><td>0.536796</td><td>0.807692</td><td>0.677419</td><td>1.0</td><td>0.090909</td></tr><tr><td>Experiment_73  fold_5</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-2-1-mamba-echoprime-video">3.2.1 mamba+echoprime video</h4><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_85  fold_1</td><td>0.90625</td><td>0.913043</td><td>0.936170</td><td>0.916666</td><td>0.956521</td><td>0.777777</td></tr><tr><td>Experiment_85  fold_2</td><td>0.78125</td><td>0.787878</td><td>0.829268</td><td>0.85</td><td>0.8095</td><td>0.7272</td></tr><tr><td>Experiment_85  fold_3</td><td>0.8125</td><td>0.8784</td><td>0.8235</td><td>0.8235</td><td>0.8235</td><td>0.8</td></tr><tr><td>Experiment_85  fold_4</td><td>0.8125</td><td>0.8095</td><td>0.85</td><td>0.8947</td><td>0.8095</td><td>0.8182</td></tr><tr><td>Experiment_85  fold_5</td><td>0.84375</td><td>0.878787</td><td>0.87179</td><td>0.9444</td><td>0.8095</td><td>0.9090</td></tr><tr><td>Experiment_85</td><td>0.83125</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>损失改为tversky</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_86  fold_2</td><td>0.78125</td><td>0.813852</td><td>0.820512</td><td>0.888888</td><td>0.761904</td><td>0.818181</td></tr></tbody></table><p>损失改为focal</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_87  fold_2</td><td>0.78125</td><td>0.8</td><td>0.8108</td><td>0.9375</td><td>0.714285</td><td>0.9090</td></tr></tbody></table><p>损失改为dice</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_88  fold_2</td><td>0.78125</td><td>0.783549</td><td>0.820512</td><td>0.888888</td><td>0.761904</td><td>0.818181</td></tr></tbody></table><p>损失改为bce_dice</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_89  fold_2</td><td>0.78125</td><td>0.805194</td><td>0.8205</td><td>0.8888</td><td>0.7619</td><td>0.818181</td></tr></tbody></table><p>损失改为asymmetric</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_90  fold_1</td><td>0.90625</td><td>0.932367</td><td>0.936170</td><td>0.916666</td><td>0.956521</td><td>0.777777</td></tr><tr><td>Experiment_90  fold_2</td><td>0.8125</td><td>0.8484</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.7272</td></tr><tr><td>Experiment_90  fold_3</td><td>0.84375</td><td>0.843137</td><td>0.864864</td><td>0.8</td><td>0.941176</td><td>0.733333</td></tr><tr><td>Experiment_90  fold_4</td><td>0.8125</td><td>0.835497</td><td>0.85</td><td>0.894736</td><td>0.809523</td><td>0.818181</td></tr><tr><td>Experiment_90  fold_5</td><td>0.84375</td><td>0.861471</td><td>0.883720</td><td>0.863636</td><td>0.904761</td><td>0.727272</td></tr><tr><td>Experiment_90</td><td><strong>0.84375</strong></td><td><strong>0.864175</strong></td><td><strong>0.888351</strong></td><td><strong>0.866628</strong></td><td><strong>0.891956</strong></td><td><strong>0.753332</strong></td></tr></tbody></table><p>改为交叉注意力融合</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_95  fold_1</td><td>0.84375</td><td>0.903381</td><td>0.883720</td><td>0.949999</td><td>0.826086</td><td>0.888888</td></tr><tr><td>Experiment_95  fold_2</td><td>0.78125</td><td>0.779220</td><td>0.851063</td><td>0.769230</td><td>0.952380</td><td>0.454545</td></tr><tr><td>Experiment_95  fold_3</td><td>0.8125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_95  fold_4</td><td>0.78125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_95  fold_5</td><td>0.8125</td><td>0.818181</td><td>0.857142</td><td>0.857142</td><td>0.857142</td><td>0.727272</td></tr><tr><td>Experiment_95</td><td>拉跨</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>加权融合</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_96  fold_1</td><td>0.90625</td><td>0.937198</td><td>0.936170</td><td>0.916666</td><td>0.9565</td><td>0.7777</td></tr><tr><td>Experiment_96  fold_2</td><td>0.8125</td><td>0.826839</td><td>0.857142</td><td>0.857142</td><td>0.857142</td><td>0.727272</td></tr><tr><td>Experiment_96  fold_3</td><td>0.8125</td><td>0.882352</td><td>0.849999</td><td>0.739130</td><td>1.0</td><td>0.6</td></tr><tr><td>Experiment_96  fold_4</td><td>0.8125</td><td>0.826839</td><td>0.85</td><td>0.894736</td><td>0.809523</td><td>0.818181</td></tr><tr><td>Experiment_96  fold_5</td><td>0.84375</td><td>0.857142</td><td>0.883720</td><td>0.863636</td><td>0.904761</td><td>0.727272</td></tr><tr><td>Experiment_96</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Adaw优化器</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_97  fold_1</td><td>0.90625</td><td>0.927536</td><td>0.930232</td><td>1.0</td><td>0.869565</td><td>1.0</td></tr><tr><td>Experiment_97  fold_2</td><td>0.78125</td><td>0.831168</td><td>0.810810</td><td>0.9375</td><td>0.714285</td><td>0.909090</td></tr><tr><td>Experiment_97  fold_3</td><td>0.78125</td><td>0.882352</td><td>0.774193</td><td>0.857142</td><td>0.705882</td><td>0.866666</td></tr><tr><td>Experiment_97  fold_4</td><td>0.8125</td><td>0.844155</td><td>0.842105</td><td>0.941176</td><td>0.761904</td><td>0.909090</td></tr><tr><td>Experiment_97  fold_5</td><td>0.8125</td><td>0.883116</td><td>0.85</td><td>0.894736</td><td>0.809523</td><td>0.818181</td></tr><tr><td>Experiment_97</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>SGD</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_98  fold_1</td><td>0.8125</td><td>0.816425</td><td>0.869565</td><td>0.869565</td><td>0.869565</td><td>0.666666</td></tr><tr><td>Experiment_98  fold_2</td><td>0.65625</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>RMSprop</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_99  fold_1</td><td>0.90625</td><td>0.913043</td><td>0.930232</td><td>1.0</td><td>0.869565</td><td>1.0</td></tr><tr><td>Experiment_99  fold_2</td><td>0.78125</td><td>0.822510</td><td>0.810810</td><td>0.9375</td><td>0.714285</td><td>0.909090</td></tr></tbody></table><p>Adagrad</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_100  fold_1</td><td>0.78125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_100  fold_2</td><td>0.65625</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>还是改回MADGRAD优化器</p><p>做了点数据增强</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_101  fold_1</td><td>0.875</td><td>0.9565</td><td>0.916666</td><td>0.879999</td><td>0.956521</td><td>0.666666</td></tr><tr><td>Experiment_101  fold_2</td><td>0.8125</td><td>0.7922</td><td>0.85</td><td>0.8947</td><td>0.8095</td><td>0.818181</td></tr><tr><td>Experiment_101  fold_3</td><td>0.84375</td><td>0.886274</td><td>0.871794</td><td>0.772727</td><td>1.0</td><td>0.666666</td></tr><tr><td>Experiment_101  fold_4</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_101  fold_5</td><td>0.8125</td><td>0.8311</td><td>0.875</td><td>0.7777</td><td>1.0</td><td>0.4545</td></tr></tbody></table><p>mamba: A2C切面的数据</p><p>echo_prime: A4C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构</p><p>损失还是asymmetric</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_92  fold_1</td><td>0.90625</td><td>0.971014</td><td>0.936170</td><td>0.916666</td><td>0.956521</td><td>0.7777</td></tr><tr><td>Experiment_92  fold_2</td><td>0.84375</td><td>0.805194</td><td>0.888888</td><td>0.833333</td><td>0.952380</td><td>0.636363</td></tr><tr><td>Experiment_92  fold_3</td><td>0.75</td><td>0.7960</td><td>0.7647</td><td>0.7647</td><td>0.7647</td><td>0.7333</td></tr><tr><td>Experiment_92  fold_4</td><td>0.78125</td><td>0.826839</td><td>0.810810</td><td>0.9375</td><td>0.714285</td><td>0.909090</td></tr><tr><td>Experiment_92  fold_5</td><td>0.84375</td><td>0.878787</td><td>0.878048</td><td>0.899999</td><td>0.857142</td><td>0.818181</td></tr><tr><td>Experiment_92</td><td>0.825</td><td>效果拉跨</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构</p><p>损失还是asymmetric</p><p>但是使用的是dec0作为mamba的输出</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_93  fold_1</td><td>0.90625</td><td>0.942028</td><td>0.938775</td><td>0.884615</td><td>1.0</td><td>0.666666</td></tr><tr><td>Experiment_93  fold_2</td><td>0.8125</td><td>0.792207</td><td>0.85</td><td>0.894736</td><td>0.809523</td><td>0.818181</td></tr><tr><td>Experiment_93  fold_3</td><td>0.8125</td><td>0.870588</td><td>0.823529</td><td>0.823529</td><td>0.823529</td><td>0.8</td></tr><tr><td>Experiment_93  fold_4</td><td>0.8125</td><td>0.805194</td><td>0.857142</td><td>0.857142</td><td>0.857142</td><td>0.727272</td></tr><tr><td>Experiment_93  fold_5</td><td>0.84375</td><td>0.874458</td><td>0.878048</td><td>0.89999</td><td>0.857142</td><td>0.818181</td></tr><tr><td>Experiment_93</td><td>0.8375</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>保留<code>6*6*6</code>的空间结构</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_93  fold_1</td><td>0.90625</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_93  fold_3</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构</p><p>损失还是asymmetric</p><p>但是使用的是dec2作为mamba的输出</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_94  fold_1</td><td>0.90625</td><td>0.946859</td><td>0.936170</td><td>0.916666</td><td>0.956521</td><td>0.777777</td></tr><tr><td>Experiment_94  fold_2</td><td>0.78125</td><td>0.796536</td><td>0.829268</td><td>0.85</td><td>0.809523</td><td>0.727272</td></tr><tr><td>Experiment_94  fold_3</td><td>0.84375</td><td>0.925490</td><td>0.848484</td><td>0.875</td><td>0.823529</td><td>0.866666</td></tr><tr><td>Experiment_94  fold_4</td><td>0.75</td><td>0.779220</td><td>0.809523</td><td>0.809523</td><td>0.809523</td><td>0.636363</td></tr><tr><td>Experiment_94  fold_5</td><td>0.8125</td><td>0.861471</td><td>0.857142</td><td>0.857142</td><td>0.857142</td><td>0.727272</td></tr></tbody></table><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_95  fold_1     1e-8</td><td>0.90625</td><td>0.9565</td><td>0.938775</td><td>0.884615</td><td>1.0</td><td>0.666666</td></tr><tr><td>Experiment_95  fold_3     1e-8</td><td>0.8125</td><td>0.921568</td><td>0.849999</td><td>0.739130</td><td>1.0</td><td>0.6</td></tr></tbody></table><h4 id="3-2-2-mamba-echoprime-text-video">3.2.2 mamba+echoprime text video</h4><p>加入知识向量</p><p>mamba: A4C切面的数据</p><p>echo_prime: A2C切面的数据</p><p>都加入了知识向量</p><p>融合: 通道拼接</p><p>保留<code>4*4*4</code>的空间结构</p><p>学习率1e-6  b8   损失：bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_116  fold_1</td><td>0.90625</td><td>0.8067</td><td>0.9387</td><td>0.8846</td><td>1.0</td><td>0.6666</td></tr><tr><td>Experiment_116  fold_2</td><td>0.78125  (0.81)</td><td>0.818181</td><td>0.8108</td><td>0.9375</td><td>0.7142</td><td>0.9090</td></tr><tr><td>Experiment_116  fold_3</td><td>0.8125 (0.84)</td><td>0.8509</td><td>0.8</td><td>0.9230</td><td>0.7058</td><td>0.9333</td></tr><tr><td>Experiment_116  fold_4</td><td>0.8125</td><td>0.8614</td><td>0.85</td><td>0.8947</td><td>0.8095</td><td>0.8181</td></tr><tr><td>Experiment_116  fold_5</td><td>0.84375</td><td>0.8484</td><td>0.8837</td><td>0.8636</td><td>0.9047</td><td>0.7272</td></tr><tr><td>Experiment_116</td><td>0.83125</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_127  fold_1</td><td>0.90625</td><td>0.8792</td><td>0.9387</td><td>0.8846</td><td>1.0</td><td>0.6666</td></tr><tr><td>Experiment_127  fold_2</td><td>0.8125</td><td>0.9264</td><td>0.8333</td><td>1.0</td><td>0.7142</td><td>1.0</td></tr><tr><td>Experiment_127  fold_3</td><td>0.8125</td><td>0.8666</td><td>0.8</td><td>0.9230</td><td>0.7058</td><td>0.9333</td></tr><tr><td>Experiment_127  fold_4</td><td>0.75</td><td>0.8138</td><td>0.7894</td><td>0.8823</td><td>0.7142</td><td>0.8181</td></tr><tr><td>Experiment_127  fold_5</td><td>0.8125</td><td>0.8225</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.7272</td></tr><tr><td>Experiment_127</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>学习率1e-6  b16   损失：bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_128  fold_1</td><td>0.875</td><td>0.9178</td><td>0.9166</td><td>0.8799</td><td>0.9565</td><td>0.6666</td></tr><tr><td>Experiment_128  fold_2</td><td>0.75</td><td>0.7878</td><td>0.7894</td><td>0.8823</td><td>0.7142</td><td>0.8181</td></tr><tr><td>Experiment_128  fold_3</td><td>0.84375</td><td>0.9098</td><td>0.8387</td><td>0.9285</td><td>0.7647</td><td>0.9333</td></tr><tr><td>Experiment_128  fold_4</td><td>0.78125</td><td>0.8225</td><td>0.8108</td><td>0.9375</td><td>0.7142</td><td>0.9090</td></tr><tr><td>Experiment_128  fold_5</td><td>0.84375</td><td>0.8658</td><td>0.8780</td><td>0.8999</td><td>0.8571</td><td>0.8181</td></tr><tr><td>Experiment_128</td><td>0.81875</td><td>0.86072</td><td>0.84474</td><td>0.90562</td><td>0.78136</td><td>0.84722</td></tr></tbody></table><p>学习率1e-6  b12   损失：bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_129  fold_1</td><td>0.90625</td><td>0.9371</td><td>0.9361</td><td>0.9166</td><td>0.9565</td><td>0.7777</td></tr><tr><td>Experiment_129  fold_2</td><td>0.75</td><td>0.7922</td><td>0.7999</td><td>0.8421</td><td>0.7619</td><td>0.7272</td></tr><tr><td>Experiment_129  fold_3</td><td>0.84375</td><td>0.8549</td><td>0.8387</td><td>0.9285</td><td>0.7647</td><td>0.9333</td></tr><tr><td>Experiment_129  fold_4</td><td>0.75</td><td>0.7965</td><td>0.7894</td><td>0.8823</td><td>0.7142</td><td>0.8181</td></tr><tr><td>Experiment_129  fold_5</td><td>0.84375</td><td>0.8614</td><td>0.8717</td><td>0.9444</td><td>0.8095</td><td>0.9090</td></tr><tr><td>Experiment_129</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>学习率1e-6  b4   损失：bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_130  fold_1</td><td>0.90625</td><td>0.9516</td><td>0.9333</td><td>0.9545</td><td>0.9130</td><td>0.8888</td></tr><tr><td>Experiment_130  fold_2</td><td>0.78125</td><td>0.7835</td><td>0.8372</td><td>0.8181</td><td>0.8571</td><td>0.6363</td></tr><tr><td>Experiment_130  fold_3</td><td>0.84375</td><td>0.8784</td><td>0.8387</td><td>0.9285</td><td>0.7647</td><td>0.9333</td></tr><tr><td>Experiment_130  fold_4</td><td>0.78125</td><td>0.8</td><td>0.8205</td><td>0.8888</td><td>0.7619</td><td>0.8181</td></tr><tr><td>Experiment_130  fold_5</td><td>0.84375</td><td>0.8484</td><td>0.8717</td><td>0.9444</td><td>0.8095</td><td>0.9090</td></tr><tr><td>Experiment_130</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_131  fold_1</td><td>0.9375</td><td>0.9565</td><td>0.9545</td><td>1.0</td><td>0.9130</td><td>1.0</td></tr><tr><td>Experiment_131  fold_2</td><td>0.8125</td><td>0.8701</td><td>0.85</td><td>0.8947</td><td>0.8095</td><td>0.8181</td></tr><tr><td>Experiment_131  fold_3</td><td>0.875</td><td>0.9568</td><td>0.8947</td><td>0.8095</td><td>1.0</td><td>0.9333</td></tr><tr><td>Experiment_131  fold_4</td><td>0.8125</td><td>0.8744</td><td>0.85</td><td>0.8947</td><td>0.8095</td><td>0.8181</td></tr><tr><td>Experiment_131  fold_5</td><td>0.875</td><td>0.8961</td><td>0.8999</td><td>0.9473</td><td>0.8571</td><td>0.9090</td></tr><tr><td>Experiment_131</td><td><strong>0.8625</strong></td><td><strong>0.9108</strong></td><td><strong>0.8899</strong></td><td><strong>0.9093</strong></td><td><strong>0.8778</strong></td><td><strong>0.8558</strong></td></tr></tbody></table><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_131  fold_5   v1</td><td>0.84375</td><td>0.8831</td><td>0.8717</td><td>0.9444</td><td>0.8095</td><td>0.9090</td></tr><tr><td>Experiment_131  fold_5   v2</td><td>0.84375</td><td>0.9047</td><td>0.8780</td><td>0.8999</td><td>0.8571</td><td>0.8181</td></tr></tbody></table><p>使用dec2作为输出</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_126  fold_1</td><td>0.90625</td><td>0.8937</td><td>0.9387</td><td>0.8846</td><td>1.0</td><td>0.6666</td></tr><tr><td>Experiment_126  fold_2</td><td>0.8125</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.7272</td></tr><tr><td>Experiment_126  fold_3</td><td>0.75</td><td>0.8117</td><td>0.75</td><td>0.8</td><td>0.7058</td><td>0.8</td></tr><tr><td>Experiment_126  fold_4</td><td>0.6875</td><td>0.7662</td><td>0.75</td><td>0.7894</td><td>0.7142</td><td>0.6363</td></tr><tr><td>Experiment_126  fold_5</td><td>0.84375</td><td>0.8354</td><td>0.8718</td><td>0.9444</td><td>0.8095</td><td>0.9090</td></tr><tr><td>Experiment_126</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>学习率1e-5  b8   损失：bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_125  fold_1</td><td>0.875</td><td>0.8743</td><td>0.9166</td><td>0.8799</td><td>0.9565</td><td>0.6666</td></tr><tr><td>Experiment_125  fold_2</td><td>0.75</td><td>0.8051</td><td>0.7777</td><td>0.9333</td><td>0.6666</td><td>0.9090</td></tr><tr><td>Experiment_125  fold_3</td><td>0.78125</td><td>0.8705</td><td>0.7407</td><td>1.0</td><td>0.5882</td><td>1.0</td></tr><tr><td>Experiment_125  fold_4</td><td>0.71875</td><td>0.7445</td><td>0.7567</td><td>0.875</td><td>0.6666</td><td>0.8181</td></tr><tr><td>Experiment_125  fold_5</td><td>0.84375</td><td>0.8311</td><td>0.8837</td><td>0.8636</td><td>0.9047</td><td>0.7272</td></tr><tr><td>Experiment_125</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>损失：asymmetric</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_117  fold_1</td><td>0.90625</td><td>0.8405</td><td>0.9387</td><td>0.8846</td><td>1.0</td><td>0.6666</td></tr><tr><td>Experiment_117  fold_2</td><td>0.75</td><td>0.7229</td><td>0.7777</td><td>0.9333</td><td>0.6666</td><td>0.9090</td></tr><tr><td>Experiment_117  fold_3</td><td>0.8125  (0.84)</td><td>0.8823</td><td>0.8421</td><td>0.7619</td><td>0.9411</td><td>0.6666</td></tr><tr><td>Experiment_117  fold_4</td><td>0.8125</td><td>0.8528</td><td>0.8421</td><td>0.9411</td><td>0.7619</td><td>0.9090</td></tr><tr><td>Experiment_117  fold_5</td><td>0.84375</td><td>0.8354</td><td>0.8837</td><td>0.8636</td><td>0.9047</td><td>0.7272</td></tr><tr><td>Experiment_117</td><td>0.825</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>损失weighted_bce  2.0</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_118  fold_1</td><td>0.875</td><td>0.8937</td><td>0.9166</td><td>0.8799</td><td>0.9565</td><td>0.6666</td></tr><tr><td>Experiment_118  fold_2</td><td>0.78125</td><td>0.818181</td><td>0.8205</td><td>0.8888</td><td>0.7619</td><td>0.8181</td></tr><tr><td>Experiment_118  fold_3</td><td>0.8125</td><td>0.8431</td><td>0.8</td><td>0.9230</td><td>0.7058</td><td>0.9333</td></tr><tr><td>Experiment_118  fold_4</td><td>0.75</td><td>0.8354</td><td>0.7894</td><td>0.8823</td><td>0.7142</td><td>0.8181</td></tr><tr><td>Experiment_118  fold_5</td><td>0.84375</td><td>0.8441</td><td>0.8837</td><td>0.8636</td><td>0.9047</td><td>0.7272</td></tr><tr><td>Experiment_118</td><td>0.8125</td><td>0.8469</td><td>0.8420</td><td>0.8875</td><td>0.7886</td><td>0.7931</td></tr></tbody></table><p>损失weighted_bce  0.75</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_119  fold_1</td><td>0.90625</td><td>0.8550</td><td>0.9387</td><td>0.8846</td><td>1.0</td><td>0.6666</td></tr><tr><td>Experiment_119  fold_2</td><td>0.78125</td><td>0.8138</td><td>0.8108</td><td>0.9375</td><td>0.7142</td><td>0.9090</td></tr><tr><td>Experiment_119  fold_3</td><td>0.84375</td><td>0.9098</td><td>0.8571</td><td>0.8333</td><td>0.8823</td><td>0.8</td></tr><tr><td>Experiment_119  fold_4</td><td>0.8125</td><td>0.8528</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.7272</td></tr><tr><td>Experiment_119  fold_5</td><td>0.8125</td><td>0.8528</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.7272</td></tr><tr><td>Experiment_119</td><td>0,83125</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>损失weighted_bce  0.5</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_120  fold_1</td><td>0.84375</td><td>0.8550</td><td>0.8936</td><td>0.875</td><td>0.9130</td><td>0.6666</td></tr><tr><td>Experiment_120  fold_2</td><td>0.75</td><td>0.8268</td><td>0.7777</td><td>0.9333</td><td>0.6666</td><td>0.9090</td></tr><tr><td>Experiment_120  fold_3</td><td>0.875</td><td>0.9058</td><td>0.8888</td><td>0.8421</td><td>0.9411</td><td>0.8</td></tr><tr><td>Experiment_120  fold_4</td><td>0.75</td><td>0.8398</td><td>0.7894</td><td>0.8823</td><td>0.7142</td><td>0.8181</td></tr><tr><td>Experiment_120  fold_5</td><td>0.78125</td><td>0.8398</td><td>0.8292</td><td>0.85</td><td>0.8095</td><td>0.7272</td></tr><tr><td>Experiment_120</td><td>0.8</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>使用的dec0作为mamba的输出</p><p>学习率1e-6  b8   损失：bce</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_121  fold_1</td><td>0.875</td><td>0.9227</td><td>0.9166</td><td>0.8799</td><td>0.9565</td><td>0.6666</td></tr><tr><td>Experiment_121  fold_2</td><td>0.8125</td><td>0.8051</td><td>0.875</td><td>0.7777</td><td>1.0</td><td>0.4545</td></tr><tr><td>Experiment_121  fold_3</td><td>0.875</td><td>0.8862</td><td>0.8823</td><td>0.8823</td><td>0.8823</td><td>0.8666</td></tr><tr><td>Experiment_121  fold_4</td><td>0.6875</td><td>0.6839</td><td>0.7222</td><td>0.8666</td><td>0.6190</td><td>0.8181</td></tr><tr><td>Experiment_121  fold_5</td><td>0.875</td><td>0.8917</td><td>0.9047</td><td>0.9047</td><td>0.9047</td><td>0.8181</td></tr><tr><td>Experiment_121</td><td>0.825</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>使用的dec0作为mamba的输出</p><p>学习率1e-6  b8 损失：asymmetric</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_122  fold_4</td><td>0.6875</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>学习率:1e-4</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_123  fold_1</td><td>0.875</td><td>0.8550</td><td>0.9166</td><td>0.8799</td><td>0.9565</td><td>0.6666</td></tr><tr><td>Experiment_123  fold_2</td><td>0.75</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_123  fold_3</td><td>0.84375</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_123  fold_4</td><td>0.71875</td><td>0.7532</td><td>0.7428</td><td>0.9285</td><td>0.6190</td><td>0.9090</td></tr><tr><td>Experiment_123  fold_5</td><td>0.8125</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Experiment_123</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>学习率1e-4  b8   损失：bce   少加几层知识向量</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_124  fold_1</td><td>0.90625</td><td>0.8599</td><td>0.9387</td><td>0.8846</td><td>1.0</td><td>0.6666</td></tr><tr><td>Experiment_124  fold_2</td><td>0.78125</td><td>0.8</td><td>0.8205</td><td>0.8888</td><td>0.7619</td><td>0.8181</td></tr><tr><td>Experiment_124  fold_3</td><td>0.84375</td><td>0.9568</td><td>0.8387</td><td>0.9285</td><td>0.7647</td><td>0.9333</td></tr><tr><td>Experiment_124  fold_4</td><td>0.71875</td><td>0.7532</td><td>0.7428</td><td>0.9285</td><td>0.6190</td><td>0.9090</td></tr><tr><td>Experiment_124  fold_5</td><td>0.8125</td><td>0.8311</td><td>0.8571</td><td>0.8571</td><td>0.8571</td><td>0.7272</td></tr><tr><td>Experiment_124</td><td>0.8125</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-3-省医院数据">3.3 省医院数据</h3><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_provincial_test  fold_5</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>A2C  A4C</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_provincial_test  fold_1</td><td>0.75</td><td>0.7219</td><td>0.8108</td><td>0.75</td><td>0.8823</td><td>0.5454</td></tr><tr><td>Experiment_provincial_test  fold_2</td><td>0.75</td><td>0.8556</td><td>0.8205</td><td>0.7272</td><td>0.9411</td><td>0.4545</td></tr><tr><td>Experiment_provincial_test  fold_3</td><td>0.8214</td><td>0.8214</td><td>0.8484</td><td>0.7368</td><td>1.0</td><td>0.6428</td></tr><tr><td>Experiment_provincial_test  fold_4</td><td>0.6666</td><td>0.4671</td><td>0.7804</td><td>0.7272</td><td>0.8421</td><td>0.25</td></tr><tr><td>Experiment_provincial_test  fold_5</td><td>0.7407</td><td>0.6882</td><td>0.7878</td><td>0.8125</td><td>0.7647</td><td>0.6999</td></tr><tr><td>Experiment_provincial_test</td><td>0.74</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>6切面的数据  mamba</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_provincial_1  fold_1</td><td>0.8571</td><td>0.8877</td><td>0.8823</td><td>0.8823</td><td>0.8823</td><td>0.8181</td></tr><tr><td>Experiment_provincial_1  fold_2</td><td>0.8571</td><td>0.9197</td><td>0.875</td><td>0.9333</td><td>0.8235</td><td>0.9090</td></tr><tr><td>Experiment_provincial_1  fold_3</td><td>0.8214</td><td>0.8775</td><td>0.8275</td><td>0.8</td><td>0.8571</td><td>0.7857</td></tr><tr><td>Experiment_provincial_1  fold_4</td><td>0.7692</td><td>0.5486</td><td>0.8571</td><td>0.75</td><td>1.0</td><td>0.25</td></tr><tr><td>Experiment_provincial_1  fold_5</td><td>0.7307</td><td>0.6405</td><td>0.7741</td><td>0.8571</td><td>0.7058</td><td>0.7777</td></tr><tr><td>Experiment_provincial_1</td><td>0.8088</td><td>0.7881</td><td>0.8452</td><td>0.8353</td><td>0.8554</td><td>0.7358</td></tr></tbody></table><p>6切面的数据  mamba  三分类</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_provincial_3  fold_1</td><td>0.75</td><td>0.6893</td><td>0.75</td><td>0.75</td><td>0.75</td><td></td></tr><tr><td>Experiment_provincial_3  fold_2</td><td>0.7142</td><td>0.8654</td><td>0.7142</td><td>0.7142</td><td>0.7142</td><td></td></tr><tr><td>Experiment_provincial_3  fold_3</td><td>0.75</td><td>0.8795</td><td>0.75</td><td>0.75</td><td>0.75</td><td></td></tr><tr><td>Experiment_provincial_3  fold_4</td><td>0.8076</td><td>0.6731</td><td>0.8076</td><td>0.8076</td><td>0.8076</td><td></td></tr><tr><td>Experiment_provincial_3  fold_5</td><td>0.7307</td><td>0.6515</td><td>0.7307</td><td>0.7307</td><td>0.7307</td><td></td></tr><tr><td>Experiment_provincial_3</td><td>0.7505</td><td>0.7518</td><td>0.7505</td><td>0.7505</td><td>0.7505</td><td></td></tr></tbody></table><p>6切面的数据  echoprime  32F</p><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>Experiment_provincial_2  fold_1</td><td>0.8125</td><td>0.9047</td><td>0.8571</td><td>0.75</td><td>1.0</td><td>0.5714</td></tr><tr><td>Experiment_provincial_2  fold_2</td><td>0.8125</td><td>0.6727</td><td>0.8799</td><td>0.7857</td><td>1.0</td><td>0.4</td></tr><tr><td>Experiment_provincial_2  fold_3</td><td>0.8125</td><td>0.8166</td><td>0.8</td><td>0.6666</td><td>1.0</td><td>0.6999</td></tr><tr><td>Experiment_provincial_2  fold_4</td><td>0.8125</td><td>0.5</td><td>0.8888</td><td>0.8</td><td>1.0</td><td>0.25</td></tr><tr><td>Experiment_provincial_2  fold_5</td><td>0.625</td><td>0.55</td><td>0.7692</td><td>0.625</td><td>1.0</td><td>0.0</td></tr><tr><td>Experiment_provincial_2</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="4-sota实验">4. sota实验</h2><h3 id="4-1-camus">4.1 camus</h3><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>BI-Mamba</td><td>78.75</td><td>73.45</td><td>64.87</td><td>85.01</td><td>54.85</td><td>/</td></tr><tr><td>CARL</td><td>83.75</td><td>60.33</td><td>73.42</td><td><strong>85.56</strong></td><td>67.42</td><td>/</td></tr><tr><td>MV-Swin-T</td><td>62.50</td><td>57.14</td><td>60.42</td><td>61.65</td><td>62.17</td><td>/</td></tr><tr><td>CTT-Net</td><td>62.50</td><td>70.04</td><td>70.70</td><td>62.96</td><td><strong>82.62</strong></td><td>/</td></tr><tr><td>MIMamba</td><td><strong>85.00</strong></td><td><strong>83.15</strong></td><td><strong>77.78</strong></td><td>84.00</td><td>72.41</td><td><strong>92.16</strong></td></tr></tbody></table><h3 id="4-2-hmc">4.2 hmc</h3><table><thead><tr><th>name</th><th>acc</th><th>auc</th><th>f1</th><th>precision</th><th>recall</th><th>specificity</th></tr></thead><tbody><tr><td>SAF-Net</td><td>78.13</td><td>\</td><td>81.57</td><td>88.26</td><td>77.64</td><td>/</td></tr><tr><td>BI-Mamba</td><td>77.50</td><td>73.07</td><td>83.85</td><td>78.12</td><td>91.59</td><td>/</td></tr><tr><td>CARL</td><td>85.62</td><td>45.56</td><td>87.30</td><td>86.43</td><td><strong>93.13</strong></td><td>/</td></tr><tr><td>MV-Swin-T</td><td>75.63</td><td>80.62</td><td>76.82</td><td>70.63</td><td>73.83</td><td>/</td></tr><tr><td>CTT-Net</td><td>72.50</td><td>78.39</td><td>71.38</td><td>73.54</td><td>71.00</td><td>/</td></tr><tr><td>LVSnake</td><td>83.09</td><td>\</td><td>87.17</td><td>86.49</td><td>90.11</td><td>/</td></tr><tr><td>MIMamba</td><td><strong>86.25</strong></td><td><strong>91.08</strong></td><td><strong>88.99</strong></td><td><strong>90.93</strong></td><td>87.78</td><td><strong>0.8558</strong></td></tr></tbody></table><h2 id="5-示意图">5. 示意图</h2><p>Exp_115可视化ROC</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251029165752231.png" alt="image-20251029165752231"></p>]]></content>
    
    
    <categories>
      
      <category>医学影像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>论文</tag>
      
      <tag>分类</tag>
      
      <tag>mamba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTA数据集分割实验</title>
    <link href="/2025/09/11/CTA-seg/"/>
    <url>/2025/09/11/CTA-seg/</url>
    
    <content type="html"><![CDATA[<h2 id="数据预处理">数据预处理</h2><p>直接读取文件夹随机按照8:2进行划分</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">part</span> = <span class="hljs-string">&#x27;Abdominal_Infrarenal&#x27;</span><br><span class="hljs-attr">part</span> = <span class="hljs-string">&#x27;Abdominal_Suprarenal&#x27;</span><br><span class="hljs-attr">part</span> = <span class="hljs-string">&#x27;Ascending_Arch&#x27;</span><br><span class="hljs-attr">part</span> = <span class="hljs-string">&#x27;Descending_Thoracic&#x27;</span><br></code></pre></td></tr></table></figure><p>上述四个部位都是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Total: 78, Training: 62, Validation: 16<br></code></pre></td></tr></table></figure><p>直接使用nii.gz文件，在最开始时，内存中直接先预处理和加载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><span class="hljs-keyword">from</span> monai.transforms <span class="hljs-keyword">import</span> (<br>    AsDiscrete,<br>    EnsureChannelFirstd,<br>    Compose,<br>    CropForegroundd,<br>    LoadImaged,<br>    Orientationd,<br>    RandFlipd,<br>    RandCropByPosNegLabeld,<br>    RandShiftIntensityd,<br>    ScaleIntensityRanged,<br>    Spacingd,<br>    RandRotate90d,<br>    Rand3DElasticd,<br>    ResizeWithPadOrCropd,<br>    AdjustContrastd<br>)<br><br>config_path = <span class="hljs-string">&quot;config/config.yaml&quot;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(config_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    config = yaml.safe_load(f)<br><br><span class="hljs-comment"># compose将transforms组合在一起</span><br><span class="hljs-comment"># 图像尺寸为[1, 259, 223, 74]</span><br>train_transforms = Compose(<br>    [<br>        <span class="hljs-comment"># 加载图片的值和元数据，参数keys是data_dicts中设置的keys，表示对image还是label做变换</span><br>        LoadImaged(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], image_only=<span class="hljs-literal">False</span>),<br>        <span class="hljs-comment"># 自动添加一个通道的维度，保证通道在第一维度</span><br>        EnsureChannelFirstd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>]),<br>        <span class="hljs-comment"># 对图像进行一个方向变换，转为RAS坐标</span><br>        Orientationd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], axcodes=<span class="hljs-string">&quot;RAS&quot;</span>),<br>        <span class="hljs-comment"># 对图像进行重采样，体素间距重采样为[1.5, 1.5, 2.0]</span><br>        Spacingd(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            pixdim=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;spacing&#x27;</span>][<span class="hljs-string">&#x27;pixdim&#x27;</span>],<br>            mode=(config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;spacing&#x27;</span>][<span class="hljs-string">&#x27;mode&#x27;</span>]),<br>        ),<br>        <span class="hljs-comment"># 对图像值强度进行归一化，由a的范围归一到b，，不在a范围的值设置为0</span><br>        ScaleIntensityRanged(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>],<br>            a_min=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;a_min&#x27;</span>],<br>            a_max=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;a_max&#x27;</span>],<br>            b_min=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;b_min&#x27;</span>],<br>            b_max=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;b_max&#x27;</span>],<br>            clip=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;clip&#x27;</span>],<br>        ),<br>        <span class="hljs-comment"># 根据key所指定的大于0的部分，对于图像的有效部分进行裁剪</span><br>        CropForegroundd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], source_key=<span class="hljs-string">&quot;label&quot;</span>,<br>                        margin=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;crop_foreground&#x27;</span>][<span class="hljs-string">&#x27;margin&#x27;</span>]),<br>        ResizeWithPadOrCropd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], spatial_size=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;resize&#x27;</span>][<span class="hljs-string">&#x27;spatial_size&#x27;</span>],<br>                             mode=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;resize&#x27;</span>][<span class="hljs-string">&#x27;mode&#x27;</span>]),<br>        <span class="hljs-comment"># AdjustContrastd(keys=[&quot;image&quot;], gamma = 2),</span><br>        <span class="hljs-comment"># 将图像裁剪为4个子图</span><br>        RandCropByPosNegLabeld(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            label_key=<span class="hljs-string">&quot;label&quot;</span>,<br>            spatial_size=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;rand_crop&#x27;</span>][<span class="hljs-string">&#x27;spatial_size&#x27;</span>],<br>            pos=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;rand_crop&#x27;</span>][<span class="hljs-string">&#x27;pos&#x27;</span>],<br>            neg=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;rand_crop&#x27;</span>][<span class="hljs-string">&#x27;neg&#x27;</span>],  <span class="hljs-comment"># 设置为0，因为我们没有背景样本</span><br>            num_samples=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;rand_crop&#x27;</span>][<span class="hljs-string">&#x27;num_samples&#x27;</span>],<br>            image_key=<span class="hljs-string">&quot;image&quot;</span>,<br>            image_threshold=<span class="hljs-number">0</span>,<br>        ),<br>        <span class="hljs-comment"># 随机旋转，按着0轴旋转，旋转概率为0.1</span><br>        RandFlipd(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            spatial_axis=[<span class="hljs-number">0</span>],<br>            prob=<span class="hljs-number">0.5</span>,<br>        ),<br>        <span class="hljs-comment"># 随机旋转，按着1轴旋转，旋转概率为0.1</span><br>        RandFlipd(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            spatial_axis=[<span class="hljs-number">1</span>],<br>            prob=<span class="hljs-number">0.5</span>,<br>        ),<br>        <span class="hljs-comment"># 随机旋转，按着2轴旋转，旋转概率为0.1</span><br>        RandFlipd(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            spatial_axis=[<span class="hljs-number">2</span>],<br>            prob=<span class="hljs-number">0.5</span>,<br>        ),<br>        <span class="hljs-comment"># 随机旋转，概率为0.1，旋转次数为3</span><br>        RandRotate90d(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            prob=<span class="hljs-number">0.5</span>,<br>            max_k=<span class="hljs-number">4</span>,<br>        ),<br>        <span class="hljs-comment"># 随机强度转换，强度偏移量为[-0.1, 0.1]，概率为0.5</span><br>        RandShiftIntensityd(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>],<br>            offsets=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;rand_shift_intensity&#x27;</span>][<span class="hljs-string">&#x27;offsets&#x27;</span>],<br>            prob=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;rand_shift_intensity&#x27;</span>][<span class="hljs-string">&#x27;prob&#x27;</span>],<br>        ),<br>    ]<br>)<br><br>val_transforms = Compose(<br>    [<br>        <span class="hljs-comment"># 加载图片的值和元数据，参数keys是data_dicts中设置的keys，表示对image还是label做变换</span><br>        LoadImaged(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], image_only=<span class="hljs-literal">False</span>),<br>        <span class="hljs-comment"># 自动添加一个通道的维度，保证通道在第一维度</span><br>        EnsureChannelFirstd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>]),<br>        <span class="hljs-comment"># 对图像进行一个方向变换，转为RAS坐标</span><br>        Orientationd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], axcodes=<span class="hljs-string">&quot;RAS&quot;</span>),<br>        <span class="hljs-comment"># 对图像进行重采样，体素间距重采样为[1.5, 1.5, 2.0]</span><br>        Spacingd(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>],<br>            pixdim=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;spacing&#x27;</span>][<span class="hljs-string">&#x27;pixdim&#x27;</span>],<br>            mode=(config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;spacing&#x27;</span>][<span class="hljs-string">&#x27;mode&#x27;</span>]),<br>        ),<br>        <span class="hljs-comment"># 对图像值强度进行归一化，由a的范围归一到b，，不在a范围的值设置为0</span><br>        ScaleIntensityRanged(<br>            keys=[<span class="hljs-string">&quot;image&quot;</span>],<br>            a_min=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;a_min&#x27;</span>],<br>            a_max=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;a_max&#x27;</span>],<br>            b_min=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;b_min&#x27;</span>],<br>            b_max=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;b_max&#x27;</span>],<br>            clip=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;scale_intensity&#x27;</span>][<span class="hljs-string">&#x27;clip&#x27;</span>],<br>        ),<br>        <span class="hljs-comment"># 根据key所指定的大于0的部分，对于图像的有效部分进行裁剪</span><br>        CropForegroundd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], source_key=<span class="hljs-string">&quot;label&quot;</span>,<br>                        margin=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;crop_foreground&#x27;</span>][<span class="hljs-string">&#x27;margin&#x27;</span>]),<br>        ResizeWithPadOrCropd(keys=[<span class="hljs-string">&quot;image&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;all_lab&quot;</span>], spatial_size=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;resize&#x27;</span>][<span class="hljs-string">&#x27;spatial_size&#x27;</span>],<br>                             mode=config[<span class="hljs-string">&#x27;transforms&#x27;</span>][<span class="hljs-string">&#x27;resize&#x27;</span>][<span class="hljs-string">&#x27;mode&#x27;</span>]),<br>    ]<br>)<br><br></code></pre></td></tr></table></figure><h3 id="增加DIS部位">增加DIS部位</h3><p>DIS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Total: <span class="hljs-number">56</span>, Training: <span class="hljs-number">44</span>, Validation: <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>DIS_Abdominal_Infrarenal</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Total: 29, Training: 23, Validation: 6<br></code></pre></td></tr></table></figure><p>DIS_Abdominal_Suprarenal</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Total: 30, Training: 24, Validation: 6<br></code></pre></td></tr></table></figure><p>DIS_Ascending_Arch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Total: 36, Training: 28, Validation: 8<br></code></pre></td></tr></table></figure><p>DIS_Descending_Thoracic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Total: 46, Training: 36, Validation: 10<br></code></pre></td></tr></table></figure><h2 id="实验">实验</h2><table><thead><tr><th>exp</th><th>test_dsc</th><th>test_iou</th></tr></thead><tbody><tr><td>V2</td><td>0.725165</td><td>0.568831</td></tr></tbody></table><h3 id="使用basicunet">使用basicunet</h3><p><strong>将img和all_lab在通道维度进行拼接</strong></p><p>Abdominal_Infrarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_2</td><td>0.758985</td></tr></tbody></table><p>Abdominal_Suprarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_3</td><td>0.823703</td></tr></tbody></table><p>Ascending_Arch部位</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_1</td><td>0.884087</td></tr></tbody></table><p>Descending_Thoracic</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_5</td><td>0.700073</td></tr><tr><td>exp_6</td><td>0.656711</td></tr></tbody></table><p>DIS</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_17</td><td>0.818056</td></tr></tbody></table><p>DIS_Abdominal_Infrarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_18</td><td>0.701003</td></tr></tbody></table><p>DIS_Abdominal_Suprarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_19</td><td>0.836815</td></tr></tbody></table><p>DIS_Ascending_Arch</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_20</td><td>0.821586</td></tr></tbody></table><p>DIS_Descending_Thoracic</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_21</td><td>0.672169</td></tr></tbody></table><h3 id="使用segmamba">使用segmamba</h3><p>Abdominal_Infrarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_8</td><td>0.768712</td></tr></tbody></table><p>Abdominal_Suprarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_9</td><td>0.847736</td></tr></tbody></table><p>Ascending_Arch部位</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_10</td><td>0.899080</td></tr></tbody></table><p>Descending_Thoracic</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_7</td><td>0.755863</td></tr></tbody></table><p>DIS</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_22</td><td>0.819693</td></tr></tbody></table><p>DIS_Abdominal_Infrarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_23</td><td>0.633685</td></tr><tr><td>exp_31</td><td>0.893325</td></tr></tbody></table><p>DIS_Abdominal_Suprarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_24</td><td>0.884835</td></tr></tbody></table><p>DIS_Ascending_Arch</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_25</td><td>0.872596</td></tr></tbody></table><p>DIS_Descending_Thoracic</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_26</td><td>0.828840</td></tr></tbody></table><h3 id="使用echomamba">使用echomamba</h3><p>Abdominal_Infrarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_11</td><td>0.763986</td></tr></tbody></table><p>Abdominal_Suprarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_12</td><td>0.797840</td></tr><tr><td>exp_16</td><td>0.797988</td></tr></tbody></table><p>Ascending_Arch部位</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_14</td><td>0.878406</td></tr></tbody></table><p>Descending_Thoracic</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_15</td><td>0.730438</td></tr></tbody></table><p>DIS</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_26</td><td>0.754187</td></tr></tbody></table><p>DIS_Abdominal_Infrarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_27</td><td>0.843867</td></tr></tbody></table><p>DIS_Abdominal_Suprarenal</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_28</td><td>0.926013</td></tr></tbody></table><p>DIS_Ascending_Arch</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_29</td><td>0.799774</td></tr><tr><td>exp_32</td><td>0.929628</td></tr></tbody></table><p>DIS_Descending_Thoracic</p><table><thead><tr><th>exp</th><th>test_dsc</th></tr></thead><tbody><tr><td>exp_30</td><td>0.809732</td></tr></tbody></table><h3 id="汇总">汇总</h3><table><thead><tr><th></th><th>U-net</th><th>EchoMamba</th><th>SegMamba</th></tr></thead><tbody><tr><td>Abdominal_Infrarenal</td><td>75.90</td><td>76.40</td><td>76.87</td></tr><tr><td>Abdominal_Suprarenal</td><td>82.37</td><td>79.80</td><td>84.77</td></tr><tr><td>Ascending_Arch</td><td>88.41</td><td>87.84</td><td>89.91</td></tr><tr><td>Descending_Thoracic</td><td>70.01</td><td>73.04</td><td>75.59</td></tr><tr><td>DIS</td><td>81.81</td><td>75.42</td><td>81.97</td></tr><tr><td>DIS_Abdominal_Infrarenal</td><td>70.10</td><td>84.39</td><td>89.33</td></tr><tr><td>DIS_Abdominal_Suprarenal</td><td>83.68</td><td>92.60</td><td>88.48</td></tr><tr><td>DIS_Ascending_Arch</td><td>87.26</td><td>92.96</td><td>87.26</td></tr><tr><td>DIS_Descending_Thoracic</td><td>67.22</td><td>80.97</td><td>82.88</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>医学影像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>语义分割</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ</title>
    <link href="/2024/12/08/RocketMQ/"/>
    <url>/2024/12/08/RocketMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="一、RockeMQ是什么">一、RockeMQ是什么</h2><p><img src="https://static001.geekbang.org/infoq/ef/ef30fda4951f78891f25a4615cdea81b.png" alt="img"></p><ul><li>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点</li><li>Producer、Consumer、队列都可以分布式；</li><li>Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 topic 对应的队列集合；</li><li>能够保证严格的消息顺序；</li><li>提供丰富的消息拉取模式；</li><li>高效的订阅者水平扩展能力；</li><li>实时的消息订阅机制；</li><li>亿级消息堆积能力；</li><li>较少的依赖。</li></ul><h2 id="二、RocketMQ基本概念">二、RocketMQ基本概念</h2><h3 id="2-1-消息模型（Message-Model）">2.1 消息模型（Message Model）</h3><p>RocketMQ 主要由 Producer、Broker、Consumer 三部分组成，其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker。MessageQueue 用于存储消息的物理地址，每个 Topic 中的消息地址存储于多个 MessageQueue 中。ConsumerGroup 由多个 Consumer 实例构成。</p><h3 id="2-2-消息生产者（Producer）">2.2 消息生产者（Producer）</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到 broker 服务器。RocketMQ 提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要 Broker 返回确认信息，单向发送不需要。</p><h3 id="2-3-消息消费者（Consumer）">2.3 消息消费者（Consumer）</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h3 id="2-4-主题（Topic）">2.4 主题（Topic）</h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。</p><h3 id="2-5-代理服务器（Broker-Server）">2.5 代理服务器（Broker Server）</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在 RocketMQ 系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h3 id="2-6-名字服务（Name-Server）">2.6 名字服务（Name Server）</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的 BrokerIP 列表。多个 Namesrv 实例组成集群，但相互独立，没有信息交换。</p><h3 id="2-7-拉取式消费（Pull-Consumer）">2.7 拉取式消费（Pull Consumer）</h3><p>Consumer 消费的一种类型，应用通常主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p><h3 id="2-8-推动式消费（Push-Consumer）">2.8 推动式消费（Push Consumer）</h3><p>Consumer 消费的一种类型，该模式下 Broker 收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p><h3 id="2-9-生产者组（Producer-Group）">2.9 生产者组（Producer Group）</h3><p>同一类 Producer 的集合，这类 Producer 发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h3 id="2-10-消费者组（Consumer-Group）">2.10 消费者组（Consumer Group）</h3><p>同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h3 id="2-11-集群消费（Clustering）">2.11 集群消费（Clustering）</h3><p>集群消费模式下,相同 Consumer Group 的每个 Consumer 实例平均分摊消息。</p><h3 id="2-12-广播消费（Broadcasting）">2.12 广播消费（Broadcasting）</h3><p>广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。</p><h3 id="2-13-普通顺序消息（Normal-Ordered-Message）">2.13 普通顺序消息（Normal Ordered Message）</h3><p>普通顺序消费模式下，消费者通过同一个消息队列（Topic 分区，称作 Message Queue）收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h3 id="2-14-严格顺序消息（Strictly-Ordered-Message）">2.14 严格顺序消息（Strictly Ordered Message）</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h3 id="2-15-消息（Message）">2.15 消息（Message）</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ 中每个消息拥有唯一的 Message ID，且可以携带具有业务标识的 Key。系统提供了通过 Message ID 和 Key 查询消息的功能。</p><h3 id="2-16-标签（Tag）">2.16 标签（Tag）</h3><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统。消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h2 id="三、RocketMQ-特性-features">三、RocketMQ 特性(features)</h2><h3 id="3-1-订阅与发布">3.1 订阅与发布</h3><p>消息的发布是指某个生产者向某个 topic 发送消息；消息的订阅是指某个消费者关注了某个 topic 中带有某些 tag 的消息，进而从该 topic 消费数据。</p><h3 id="3-2-消息顺序">3.2 消息顺序</h3><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ 可以严格的保证消息有序。顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个 Topic 下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p><ul><li>全局顺序</li><li>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景；</li><li>分区顺序</li><li>对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。</li><li>适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li></ul><h3 id="3-3-消息过滤">3.3 消息过滤</h3><p>RocketMQ 的消费者可以根据 Tag 进行消息过滤，也支持自定义属性过滤。消息过滤目前是在 Broker 端实现的，优点是减少了对于 Consumer 无用消息的网络传输，缺点是增加了 Broker 的负担、而且实现相对复杂。</p><h3 id="3-4-消息可靠性">3.4 消息可靠性</h3><p>RocketMQ 支持消息的高可靠，影响消息可靠性的几种情况：</p><ol><li>Broker 非正常关闭；</li><li>Broker 异常 Crash；</li><li>OS Crash；</li><li>机器掉电，但是能立即恢复供电情况；</li><li>机器无法开机（可能是 cpu、主板、内存等关键设备损坏）；</li><li>磁盘设备损坏；</li></ol><p>1、2、3、4 四种情况都属于硬件资源可立即恢复情况，RocketMQ 在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。5、6 属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ 在这两种情况下，通过异步复制，可保证 99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与 Money 相关的应用。注：RocketMQ 从 3.0 版本开始支持同步双写。</p><h3 id="3-5-至少一次">3.5 至少一次</h3><p>至少一次(At least Once)指每个消息必须投递一次。Consumer 先 Pull 消息到本地，消费完成后，才向服务器返回 ack，如果没有消费一定不会 ack 消息，所以 RocketMQ 可以很好的支持此特性。</p><h3 id="3-6-回溯消费">3.6 回溯消费</h3><p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒。</p><h3 id="3-7-事务消息">3.7 事务消息</h3><p>RocketMQ 事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ 的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><h3 id="3-8-定时消息">3.8 定时消息</h3><p>定时消息（延迟队列）是指消息发送到 broker 后，不会立即被消费，等待特定时间投递给真正的 topic。broker 有配置项 messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18 个 level。可以配置自定义 messageDelayLevel。注意，messageDelayLevel 是 broker 的属性，不属于某个 topic。发消息时，设置 delayLevel 等级即可：msg.setDelayLevel(level)。level 有以下三种情况：</p><ul><li>level == 0，消息为非延迟消息；</li><li>1 &lt;= level &lt;= maxLevel，消息延迟特定时间，例如 level == 1，延迟 1s；</li><li>level &gt; maxLevel，则 leve l== maxLevel，例如 level == 20，延迟 2h。</li></ul><p>定时消息会暂存在名为 SCHEDULE_TOPIC_XXXX 的 topic 中，并根据 delayTimeLevel 存入特定的 queue，queueId = delayTimeLevel – 1，即一个 queue 只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker 会调度地消费 SCHEDULE_TOPIC_XXXX，将消息写入真实的 topic。需要注意的是，定时消息会在第一次写入和调度写入真实 topic 时都会计数，因此发送数量、tps 都会变高。</p><h3 id="3-9-消息重试">3.9 消息重试</h3><p>Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer 消费消息失败通常可以认为有以下几种情况：</p><ul><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过 10 秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如 db 连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用 sleep 30s，再消费下一条消息，这样可以减轻 Broker 重试消息的压力。</li></ul><p>RocketMQ 会为每个消费组都设置一个 Topic 名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个 Topic 的重试队列是针对消费组，而不是针对每个 Topic 设置的），用于暂时保存因为各种异常而导致 Consumer 端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ 对于重试消息的处理是先保存至 Topic 名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行 Delay 后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><h3 id="3-10-消息重投">3.10 消息重投</h3><p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway 没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在 RocketMQ 中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer 负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p><ul><li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为 2，因此生产者会最多尝试发送 retryTimesWhenSendFailed + 1 次。不会选择上次失败的 broker，尝试向其他 broker 发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现 RemotingException、MQClientException 和部分 MQBrokerException 时会重投。</li><li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他 broker，仅在同一个 broker 上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或 slave 不可用（返回状态非 SEND_OK），是否尝试发送到其他 broker，默认 false。十分重要消息可以开启。</li></ul><h3 id="3-11-流量控制">3.11 流量控制</h3><p>生产者流控，因为 broker 处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p><p><strong>生产者流控：</strong></p><ul><li>commitLog 文件被锁时间超过 osPageCacheBusyTimeOutMills 时，参数默认为 1000ms，返回流控。</li><li>如果开启：</li><li>transientStorePoolEnable == true</li><li>并且 broker 为异步刷盘的主机，且 transientStorePool 中资源不足，拒绝当前 send 请求，返回流控。</li><li>broker 每隔 10ms 检查 send 请求队列头部请求的等待时间，如果超过 waitTimeMillsInSendQueue，默认 200ms，拒绝当前 send 请求，返回流控。</li><li>broker 通过拒绝 send 请求方式实现流量控制。</li></ul><p>注意，生产者流控，不会尝试消息重投。</p><p><strong>消费者流控：</strong></p><ul><li>消费者本地缓存消息数超过 pullThresholdForQueue 时，默认 1000。</li><li>消费者本地缓存消息大小超过 pullThresholdSizeForQueue 时，默认 100MB。</li><li>消费者本地缓存消息跨度超过 consumeConcurrentlyMaxSpan 时，默认 2000。</li><li>消费者流控的结果是降低拉取频率。</li></ul><h3 id="3-12-死信队列">3.12 死信队列</h3><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。RocketMQ 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在 RocketMQ 中，可以通过使用 console 控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p><h2 id="四、RocketMQ-设计">四、RocketMQ 设计</h2><p><strong>消息存储</strong></p><p><img src="https://static001.geekbang.org/infoq/0e/0e6110227a231ecacf1f34afc4c281bb.png" alt="img"></p><p>消息存储是 RocketMQ 中最为复杂和最为重要的一部分，接下来分别从 RocketMQ 的消息存储整体架构、RocketMQ 中两种不同的刷盘方式来展开叙述。</p><p><strong>消息存储整体架构</strong></p><p>消息存储架构图中最重要的三个跟消息存储相关的文件构成</p><ul><li><p>CommitLog</p><p>消息主体以及元数据的存储主体，存储 Producer 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认 1G, 文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G=1073741824；当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件</p></li><li><p>ConsumeQueue</p><p>消息消费队列，引入的目的主要是提高消息消费的性能，由于 RocketMQ 是基于主题 topic 的订阅模式，消息消费是针对主题进行的，如果要遍历 commitlog 文件中根据 topic 检索消息是非常低效的。Consumer 即可根据 ConsumeQueue 来查找待消费的消息。</p><p>其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset，消息大小 size 和消息 Tag 的 HashCode 值。consumequeue 文件可以看成是基于 topic 的 commitlog 索引文件，故 consumequeue 文件夹的组织方式如下：topic/queue/file 三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。</p><p>同样 consumequeue 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 commitlog 物理偏移量、4 字节的消息长度、8 字节 tag hashcode，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 ConsumeQueue 文件大小约 5.72M；</p></li><li><p>IndexFile</p><p>IndexFile（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。Index 文件的存储位置是：{fileName}，文件名 fileName 是以创建时的时间戳命名的，固定的单个 IndexFile 文件大小约为 400M，一个 IndexFile 可以保存 2000W 个索引，IndexFile 的底层存储设计为在文件系统中实现 HashMap 结构，故 rocketmq 的索引文件其底层实现为 hash 索引。</p></li></ul><p>在 RocketMQ 的消息存储整体架构图中可以看出，RocketMQ 采用的是混合型的存储结构，即为 Broker 单个实例下所有的队列共用一个日志数据文件（即为 CommitLog）来存储。RocketMQ 的混合型存储结构(多个 Topic 的消息实体内容都存储于一个 CommitLog 中)针对 Producer 和 Consumer 分别采用了数据和索引部分相分离的存储结构，Producer 发送消息至 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 CommitLog 中。只要消息被刷盘持久化至磁盘文件 CommitLog 中，那么 Producer 发送的消息就不会丢失。正因为如此，Consumer 也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker 允许等待 30s 的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ 的具体做法是，使用 Broker 端的后台服务线程—ReputMessageService 不停地分发请求并异步构建 ConsumeQueue（逻辑消费队列）和 IndexFile（索引文件）数据。</p><p><strong>消息刷盘</strong></p><p><img src="https://static001.geekbang.org/infoq/3d/3d5e4e95535ecf80788040eae6d06f39.png" alt="img"></p><ul><li><p>同步刷盘</p><p>只有在消息真正持久化至磁盘后 RocketMQ 的 Broker 端才会真正返回给 Producer 端一个成功的 ACK 响应。同步刷盘对 MQ 消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</p></li><li><p>异步刷盘</p><p>能够充分利用 OS 的 PageCache 的优势，只要消息写入 PageCache 即可将成功的 ACK 返回给 Producer 端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了 MQ 的性能和吞吐量。</p></li></ul><h2 id="五、RocketMQ-技术架构">五、RocketMQ 技术架构</h2><p><img src="https://static001.geekbang.org/infoq/ec/ec009f6d1d44d24ac6245e806f993c50.png" alt="img"></p><p>RocketMQ 架构上主要分为四部分，如上图所示:</p><ul><li><p>Producer：</p><p>消息发布的角色，支持分布式集群方式部署。Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p></li><li><p>NameServer：</p><p>NameServer 是一个非常简单的 Topic 路由注册中心，其角色类似 Dubbo 中的 zookeeper，支持 Broker 的动态注册与发现。</p><p>主要包括两个功能：Broker 管理，NameServer 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查 Broker 是否还存活；路由信息管理，每个 NameServer 将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息。然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费。NameServer 通常也是集群的方式部署，各实例间相互不进行信息通讯。</p><p>Broker 是向每一台 NameServer 注册自己的路由信息，所以每一个 NameServer 实例上面都保存一份完整的路由信息。当某个 NameServer 因某种原因下线了，Broker 仍然可以向其它 NameServer 同步其路由信息，Producer,Consumer 仍然可以动态感知 Broker 的路由的信息。</p></li><li><p>BrokerServer：</p><p>Broker 主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker 包含了以下几个重要子模块。</p><ul><li><p>Remoting Module：</p><p>整个 Broker 的实体，负责处理来自 clients 端的请求。</p></li><li><p>Client Manager：</p><p>负责管理客户端(Producer/Consumer)和维护 Consumer 的 Topic 订阅信息。</p></li><li><p>Store Service：</p><p>提供方便简单的 API 接口处理消息存储到物理硬盘和查询功能。</p></li><li><p>HA Service：</p><p>高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能。</p></li><li><p>Index Service：</p><p>根据特定的 Message key 对投递到 Broker 的消息进行索引服务，以提供消息的快速查询。</p></li></ul></li></ul><p><img src="https://static001.geekbang.org/infoq/bc/bcccd76bb145efdad562728ff6ce5fd8.png" alt="img"></p><h2 id="六、RocketMQ-部署架构">六、RocketMQ 部署架构</h2><p><img src="https://static001.geekbang.org/infoq/45/4558cb2472b8632868204bc3280141b1.png" alt="img"></p><p><strong>RocketMQ 网络部署特点</strong></p><ul><li>NameServer 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li><li>Broker 部署相对复杂，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId 为 0 表示 Master，非 0 表示 Slave。</li><li>Master 也可以部署多个。每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer。注意：当前 RocketMQ 版本在部署架构上支持一 Master 多 Slave，但只有 BrokerId=1 的从服务器才会参与消息的读负载。</li><li>Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。Producer 完全无状态，可集群部署。</li><li>Consumer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳。</li><li>Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，消费者在向 Master 拉取消息时，Master 服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读 I/O），以及从服务器是否可读等因素建议下一次是从 Master 还是 Slave 拉取。</li></ul><p>结合部署架构图，描述集群工作流程：</p><ul><li>启动 NameServer，NameServer 起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</li><li>Broker 启动，跟所有的 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</li><li>收发消息前，先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</li><li>Producer 发送消息，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息。</li><li>Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</li></ul><h2 id="七、RocketMQ-集群部署">七、RocketMQ 集群部署</h2><h3 id="7-1-集群模式">7.1 集群模式</h3><p><strong>单 Master 模式</strong></p><p>这种方式风险较大，一旦 Broker 重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p><ul><li>优点：本地开发测试，配置简单，同步刷盘消息不会丢失。</li><li>缺点：不可靠，如果宕机会导致服务不可用。</li></ul><p><strong>多 Master 模式</strong></p><p>一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master，这种模式的优缺点如下：</p><ul><li>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li></ul><p><strong>多 Master 多 Slave 模式（异步）</strong></p><p>每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p><ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；</li><li>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息。</li></ul><p><strong>多 Master 多 Slave 模式（同步）</strong></p><p>每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p><ul><li>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li><li>缺点：性能比异步复制模式略低（大约低 10%左右），发送单个消息的 RT 会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li></ul><p><strong>DLedger 集群模式</strong></p><p>RocketMQ-on-DLedger Group 是指一组相同名称的 Broker，至少需要 3 个节点，通过 Raft 自动选举出一个 Leader，其余节点 作为 Follower，并在 Leader 和 Follower 之间复制数据以保证高可用。</p><p>RocketMQ-on-DLedger Group 能自动容灾切换，并保证数据一致。RocketMQ-on-DLedger Group 是可以水平扩展的，也即可以部署任意多个 RocketMQ-on-DLedger Group 同时对外提供服务。</p><ul><li>优点：多节点（至少三个）组成集群，其中一个为 Leader 节点，其余为 Follower 节点组成高可用，能够自动容灾切换。</li><li>缺点：集群成本增加(同一个 group 最少新增一台机器)、RocketMQ4.5 及以后版本才支持。</li></ul><h3 id="7-2-本地测试环境快速搭建-单-Master-模式">7.2 本地测试环境快速搭建(单 Master 模式)</h3><p>环境准备</p><ol><li>jdk1.8+</li><li>rocketmq-all-4.5.0-bin-release</li></ol><p>安装步骤</p><p>1、解压 rocketmq-all-4.5.1-bin-release.zip 到指定目录,如下：</p><p><img src="https://static001.geekbang.org/infoq/36/36303167397808be0b24282de70f07f5.png" alt="img"></p><p>benchmark:基础测试脚本目录 / lib:运行依赖包</p><p>bin:命令运维脚本目录 / conf:配置目录</p><p>2、进入 bin 目录下编辑 <a href="http://runserver.sh">runserver.sh</a> 和 <a href="http://runborker.sh">runborker.sh</a> 两个文件，调整一下 namesrv 和 broker 的启动的 jvm 内存参数。具体参数大小根据系统环境配置情况而定：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> runserver.<span class="hljs-keyword">sh</span><br>JAVA_OPT=<span class="hljs-string">&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br><br><span class="hljs-keyword">vim</span> runroker.<span class="hljs-keyword">sh</span><br>JAVA_OPT=<span class="hljs-string">&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m&quot;</span>  <br><span class="hljs-keyword">p</span><span class="hljs-variable">s:broker</span>端本地环境不建议开启堆外内存<br></code></pre></td></tr></table></figure><p>3、根据情况配置 broker 的一些参数</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vala">brokerClusterName = DefaultCluster<br>brokerName = broker-a<br><span class="hljs-meta"># 0表示master &gt;0表示slave</span><br>brokerId = <span class="hljs-number">0</span><br><span class="hljs-meta"># 几点开始删除文件</span><br>deleteWhen = <span class="hljs-number">04</span><br><span class="hljs-meta"># 文件保留时间，默认48小时</span><br>fileReservedTime = <span class="hljs-number">48</span><br><span class="hljs-meta"># Broker 的角色</span><br><span class="hljs-meta">#- ASYNC_MASTER 异步复制Master</span><br><span class="hljs-meta">#- SYNC_MASTER 同步双写Master</span><br><span class="hljs-meta">#- SLAVE</span><br>brokerRole = ASYNC_MASTER<br><span class="hljs-meta">#刷盘方式</span><br><span class="hljs-meta"># ASYNC_FLUSH 异步刷盘</span><br><span class="hljs-meta"># SYNC_FLUSH 同步刷盘</span><br>flushDiskType = ASYNC_FLUSH<br><br>备注:<br><span class="hljs-meta"># 存储路径</span><br>storePathRootDir=xxx/store<br><span class="hljs-meta"># commitLog存储路径</span><br>storePathCommitLog=xxx/store/commitlog<br><span class="hljs-meta"># 消费队列存储路径</span><br>storePathConsumeQueue=xx/store/pathconsumequeue<br><span class="hljs-meta"># 消息索引存储路径</span><br>storePathIndex=xxx/store/pathindex<br><span class="hljs-meta"># checkpoint 文件存储</span><br>storeCheckpoint=xxx/store/checkpoint<br><span class="hljs-meta"># abort 文件存储</span><br>abortFile=xxx/store/abort<br></code></pre></td></tr></table></figure><p>备注：</p><ul><li>xxx 默认等于 System.getProperty(“user.home”) +File.separator+“store”</li><li>更多其他配置：</li><li>MessageStoreConfig、BrokerConfig 源码类</li><li>根据实际情况配置存储路径，storePathCommitLog 占用空间相对最大</li></ul><p>4、启动 rocketmq, 先启动 namesrv 再启动 broker</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">--后台启动namesrv  <br>nohup <span class="hljs-keyword">sh</span> mqnamesrv &amp;  <br>--后台启动broker  <br>export NAMESRV_ADDR=localhos<span class="hljs-variable">t:9876</span>  <br>--如果你在brocker.<span class="hljs-keyword">conf</span>文件中配置了namesrvAddr = localhos<span class="hljs-variable">t:9876</span>就直接用下面的命令  <br>nohup <span class="hljs-keyword">sh</span> mqbroker -<span class="hljs-keyword">c</span> /xxx/rocketmq-<span class="hljs-keyword">all</span>-<span class="hljs-number">4.5</span>.<span class="hljs-number">1</span>-bin-release/<span class="hljs-keyword">conf</span>/broker.<span class="hljs-keyword">conf</span> &amp;  <br>--否则用这个命令  <br>nohup <span class="hljs-keyword">sh</span> mqbroker -n localhos<span class="hljs-variable">t:9876</span> -<span class="hljs-keyword">c</span> /xxx/rocketmq-<span class="hljs-keyword">all</span>-<span class="hljs-number">4.5</span>.<span class="hljs-number">1</span>-bin-release/<span class="hljs-keyword">conf</span>/<br></code></pre></td></tr></table></figure><p>5、查看进程和日志看是否启动成功</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span>-l  <span class="hljs-keyword">or </span>查看 namesrv.log 和 <span class="hljs-keyword">broker.log </span>日志<br></code></pre></td></tr></table></figure><h2 id="八、本地源码快速搭建调试">八、本地源码快速搭建调试</h2><p><strong>源码获取</strong></p><blockquote><p><a href="https://github.com/apache/rocketmq/releases">https://github.com/apache/rocketmq/releases</a></p><p>该网址可下载 source 包，也可以 fork 仓库。</p></blockquote><p><strong>启动 RocketMQ Namesrv</strong></p><p>参考 NameServerInstanceTest 的 startup 方法，编写 main 方法，demo 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameServerInstanceTest</span> </span>&#123;<br>    .....<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> NamesrvConfig namesrvConfig = <span class="hljs-keyword">new</span> NamesrvConfig(); <br>        <span class="hljs-keyword">final</span> NettyServerConfig nettyServerConfig = <span class="hljs-keyword">new</span> NettyServerConfig();<br>        nettyServerConfig.setListenPort(<span class="hljs-number">9876</span>); <span class="hljs-comment">//设置端口</span><br>        <span class="hljs-comment">// 创建 NamesrvController，启动</span><br>        NamesrvController namesrvController = <span class="hljs-keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);<br>        namesrvController.initialize();<br>        namesrvController.start();<br>        Thread.sleep(Long.MAX_VALUE); <span class="hljs-comment">//挂起</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注:</p><p>运行 main 方法, 显示以下关键字说明启动成功</p><ul><li>NettyEventExecutor service started</li><li>FileWatchService service started</li></ul><p><strong>启动 RocketMQ Broker</strong></p><p>参考 BrokerControllerTest 的 testBrokerRestart 方法，编写 main 方法，demo 如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrokerControllerTest</span> </span>&#123;<br>    .....<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) throws Exception &#123;<br>        NettyServerConfig nettyServerConfig = <span class="hljs-keyword">new</span> <span class="hljs-type">NettyServerConfig</span>();<br>        nettyServerConfig.setListenPort(<span class="hljs-number">10911</span>);<br>        BrokerConfig brokerConfig = <span class="hljs-keyword">new</span> <span class="hljs-type">BrokerConfig</span>();  <span class="hljs-comment">// BrokerConfig 配置</span><br>        brokerConfig.setNamesrvAddr(<span class="hljs-string">&quot;127.0.0.1:9876&quot;</span>); <span class="hljs-comment">// 配置nameServer地址</span><br>        MessageStoreConfig messageStoreConfig = <span class="hljs-keyword">new</span> <span class="hljs-type">MessageStoreConfig</span>();<br>        <span class="hljs-comment">// 创建 BrokerController 对象，并启动</span><br>        BrokerController brokerController = <span class="hljs-keyword">new</span> <span class="hljs-type">BrokerController</span>(<span class="hljs-comment">//</span><br>                brokerConfig,<br>                nettyServerConfig, <br>                <span class="hljs-keyword">new</span> <span class="hljs-type">NettyClientConfig</span>(),<br>                messageStoreConfig);<br>        brokerController.initialize();<br>        brokerController.start();<br>        Thread.sleep(Long.MAX_VALUE); <span class="hljs-comment">//挂起</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注:</p><p>运行 main 方法,不报错即可，但是在：NameServerInstanceTest(nameServer)中，发现以下关键字日志，表明 broker 注册 nameServer 成功：new topic registered…等</p><p><strong>启动 RocketMQ Producer</strong></p><p>参考:org.apache.rocketmq.example.quickstart.Producer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException, IOException </span>&#123;<br><br>        DefaultMQProducer producer = <span class="hljs-keyword">new</span> DefaultMQProducer(<span class="hljs-string">&quot;please_rename_unique_group_name&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Launch the instance.</span><br><span class="hljs-comment">         */</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;127.0.0.1:9876&quot;</span>); <span class="hljs-comment">// 配置nameServer地址</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i 可以随便配置</span><br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Create a message instance, specifying topic, tag and message body.</span><br><span class="hljs-comment">                 */</span><br>                Message msg = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-comment">/* Topic */</span>,<br>                    <span class="hljs-string">&quot;TagA&quot;</span> <span class="hljs-comment">/* Tag */</span>,<br>                    (<span class="hljs-string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="hljs-comment">/* Message body */</span><br>                );<br><span class="hljs-comment">//                msg.setDelayTimeLevel(10);</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Call send message to deliver message to one of brokers.</span><br><span class="hljs-comment">*/</span><br>SendResult sendResult = producer.send(msg);<br><br>                System.out.printf(<span class="hljs-string">&quot;%s%n&quot;</span>, sendResult);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Shut down once the producer instance is not longer in use.</span><br><span class="hljs-comment">         */</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注：</p><p>运行 main 方法, 发现日志中包含：</p><p>SendResult [sendStatus=SEND_OK…即发送成功</p><p>**启动 RocketMQ Consumer，**参考：</p><p>org.apache.rocketmq.example.quickstart.Consumer</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException, MQClientException &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Instantiate with specified consumer group name.</span><br><span class="hljs-comment">         */</span><br>        DefaultMQPushConsumer consumer = <span class="hljs-keyword">new</span> DefaultMQPushConsumer(<span class="hljs-string">&quot;please_rename_unique_group_name_1&quot;</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Specify name server addresses.</span><br><span class="hljs-comment">         * &lt;p/&gt;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR</span><br><span class="hljs-comment">         * &lt;pre&gt;</span><br><span class="hljs-comment">         * &#123;@code</span><br><span class="hljs-comment">         * consumer.setNamesrvAddr(&quot;name-server1-ip:9876;name-server2-ip:9876&quot;);</span><br><span class="hljs-comment">         * &#125;</span><br><span class="hljs-comment">         * &lt;/pre&gt;</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Specify where to start in case the specified consumer group is a brand new one.</span><br><span class="hljs-comment">         */</span><br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;127.0.0.1:9876&quot;</span>); <span class="hljs-comment">// 配置nameServer地址</span><br>        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Subscribe one more more topics to consume.</span><br><span class="hljs-comment">         */</span><br>        consumer.subscribe(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *  Register callback to execute on arrival of messages fetched from brokers.</span><br><span class="hljs-comment">         */</span><br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">MessageListenerConcurrently</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-function"><span class="hljs-title">consumeMessage</span>(<span class="hljs-params">List&lt;MessageExt&gt; msgs,</span></span><br><span class="hljs-params"><span class="hljs-function">                ConsumeConcurrentlyContext context</span>)</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *  Launch the consumer instance.</span><br><span class="hljs-comment">         */</span><br>        consumer.start();<br><br>        System.out.printf(<span class="hljs-string">&quot;Consumer Started.%n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注：</p><p>运行 main 方法, 发现日志中包含：Receive New Messages…即消费成功</p><h2 id="九、总结">九、总结</h2><p>rocketMq 作为低延迟、高并发、高可用、高可靠的分布式消息中间件，其详细知识点非常多，如需深入，建议源码入坑。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gelato</title>
    <link href="/2024/10/29/Gelato/"/>
    <url>/2024/10/29/Gelato/</url>
    
    <content type="html"><![CDATA[<p>总流程</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241105152704486.png" alt="image-20241105152704486"></p><h2 id="Websocket模块">Websocket模块</h2><h3 id="服务端推送web方案">服务端推送web方案</h3><h4 id="短轮询">短轮询</h4><p>web端不停地间隔一段时间像服务端发一个http请求，如果有新消息，就会在某次请求返回</p><p>适用于</p><ol><li>扫码登陆</li><li>客户端使用量不大</li></ol><p>缺点</p><ol><li>大量无效请求</li><li>服务端请求压力大</li></ol><h4 id="长轮询">长轮询</h4><p>优点:相比短轮询模式</p><ol><li>大幅降低短轮询模式中客户端高频无用的轮询导致的网络开销和功耗开销</li><li>降低了服务端处理请求的 QPS</li></ol><p>缺点:</p><ol><li>无效请求:长轮询在超时时间内没有获取到消息时，会结束返回，因此仍然没有完全解决客户端“无效”请求的问题。</li><li>服务端压力大:服务端总挂(hang)住请求，只是降低了入口请求的 QPS，并没有减少对后端资源轮询的压力。假如有 1000 个请求在等待消息，可能意味着有 1000 个线程在不断轮询消息存储资源。(轮询转移到了后端)</li></ol><h4 id="Websocket长连接">Websocket长连接</h4><p>长轮询和短轮询都算作是服务端没法主动向客户端推送的一种曲线救国的方式，那最好的方案，就是能不能解决这个问题，因此诞生了websocket。<br>实现原理：客户端和服务器之间维持一个TCP/IP长连接，全双工通道。</p><p><a href="https://blog.csdn.net/devcloud/article/details/124681914">如何使用Tomcat实现WebSocket即时通讯服务服务端_tomcat websocket-CSDN博客</a></p><p><a href="https://blog.csdn.net/mahao25/article/details/127418543">netty对websocket协议的实现_netty实现websocket-CSDN博客</a></p><p>为啥我选netty不用tomcat?</p><ol><li>netty是nio基于事件驱动 的多路框架，使用单线程或少量线程处理大量的并发连接。相比之下，<br>Tomcat 是基于多线程的架构，每个连接都会分配一个线程,适用于处理相对较少的并发连接。最近<br>的 Tomcat 版本(如 Tomcat 8、9)引入了 NIO(New I/0)模型。所以这个点并不是重点。</li><li>Netty 提供了丰富的功能和组件，可以灵活地构建自定义的网络应用。它具有强大的编解码器和处理<br>器，可以轻松处理复杂的协议和数据格式。Netty的扩展性也非常好，可以根据需要添加自定义的组<br>件。比如我们可以用netty的pipeline方便的进行前置后置的处理，可以用netty的心跳处理器来检查连<br>接的状态。这些都是netty的优势。</li></ol><h3 id="netty实现websocket">netty实现websocket</h3><p><strong>心跳包</strong><br>如果用户突然关闭网页，是不会有断开通知给服务端的。那么服务端永远感知不到用户下线。因此需要客<br>户端维持一个心跳，当指定时间没有心跳，服务端主动断开，进行用户下线操作。<br>直接接入netty的现有组件<code>newIdleStateHand1er(30，0，θ)</code>可以实现30秒链接没有读请求，就主动<br>关闭链接。我们的web前端需要保持每10s发送一个心跳包。</p><p><strong>请求处理</strong></p><p>自己实现的处理器<code>NettyWebSocketServerHandler</code>接受<code>websocket</code>信息。根据消息类型进行路由处理。<br>目前请求对websocket依赖很低，只做这一件事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//反序列化请求报文</span><br>        WSBaseReq wsBaseReq = JSONUtil.toBean(msg.text(), WSBaseReq.class);<br>        <span class="hljs-comment">//解析type</span><br>        WSReqTypeEnum wsReqTypeEnum = WSReqTypeEnum.of(wsBaseReq.getType());<br>        <span class="hljs-comment">//根据type做不同的处理</span><br>        <span class="hljs-keyword">switch</span> (wsReqTypeEnum) &#123;<br>            <span class="hljs-keyword">case</span> LOGIN:<br>                <span class="hljs-keyword">this</span>.webSocketService.handleLoginReq(ctx.channel());<br>                log.info(<span class="hljs-string">&quot;请求二维码 = &quot;</span> + msg.text());<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> HEARTBEAT:<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                log.info(<span class="hljs-string">&quot;未知类型&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="websocket前后端交互">websocket前后端交互</h3><p>我们用websocket的目的，主要是用于后端推送前端，前端能用http的就尽量用http。这样的好处是，http丰富<br>的拦截器，注解，请求头等功能，可以更好地实现或者是收口我们想要的功能。尽量对websocket的依赖降到最<br>低。前后端的交互用的是json串，里面通过type标识次此次的事件类型。</p><p>前端请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    type:<span class="hljs-number">1</span>,<br>    data:&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.请求登录二维码</p><p>2.心跳检测</p><p>3用户认证</p><p>后端返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    type:<span class="hljs-number">1</span>,<br>    datajson:jsondata<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">WSRespTypeEnum</span> </span>&#123;<br>    LOGIN_URL(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;登录二维码返回&quot;</span>, WSLoginUrl.class),<br>    LOGIN_SCAN_SUCCESS(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;用户扫描成功等待授权&quot;</span>, <span class="hljs-keyword">null</span>),<br>    LOGIN_SUCCESS(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;用户登录成功返回用户信息&quot;</span>, WSLoginSuccess.class),<br>    MESSAGE(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;新消息&quot;</span>, WSMessage.class),<br>    ONLINE_OFFLINE_NOTIFY(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;上下线通知&quot;</span>, WSOnlineOfflineNotify.class),<br>    INVALIDATE_TOKEN(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;使前端的token失效，意味着前端需要重新登录&quot;</span>, <span class="hljs-keyword">null</span>),<br>    BLACK(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;拉黑用户&quot;</span>, WSBlack.class),<br>    MARK(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;消息标记&quot;</span>, WSMsgMark.class),<br>    RECALL(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;消息撤回&quot;</span>, WSMsgRecall.class),<br>    APPLY(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;好友申请&quot;</span>, WSFriendApply.class),<br>    MEMBER_CHANGE(<span class="hljs-number">11</span>, <span class="hljs-string">&quot;成员变动&quot;</span>, WSMemberChange.class),<br>    ;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class dataClass;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, WSRespTypeEnum&gt; cache;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        cache = Arrays.stream(WSRespTypeEnum.values()).collect(Collectors.toMap(WSRespTypeEnum::getType, Function.identity()));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WSRespTypeEnum <span class="hljs-title">of</span><span class="hljs-params">(Integer type)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cache.get(type);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用户模块">用户模块</h2><h3 id="用户表设计">用户表设计</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250417160859261.png" alt="image-20250417160859261"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.abin.mallchat.common.user.domain.entity;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;<br><span class="hljs-keyword">import</span> lombok.*;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 用户表</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@TableName(value = &quot;user&quot;, autoResultMap = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long UID_SYSTEM = <span class="hljs-number">1L</span>;<span class="hljs-comment">//系统uid</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户昵称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;name&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户头像</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;avatar&quot;)</span><br>    <span class="hljs-keyword">private</span> String avatar;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 性别 1为男性，2为女性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;sex&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer sex;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信openid用户标识</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;open_id&quot;)</span><br>    <span class="hljs-keyword">private</span> String openId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上下线状态 1在线 2离线</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;active_status&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer activeStatus;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最后上下线时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;last_opt_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastOptTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最后上下线时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(value = &quot;ip_info&quot;, typeHandler = JacksonTypeHandler.class)</span><br>    <span class="hljs-keyword">private</span> IpInfo ipInfo;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 佩戴的徽章id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;item_id&quot;)</span><br>    <span class="hljs-keyword">private</span> Long itemId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户状态 0正常 1拉黑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;status&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;create_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;update_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshIp</span><span class="hljs-params">(String ip)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ipInfo == <span class="hljs-keyword">null</span>) &#123;<br>            ipInfo = <span class="hljs-keyword">new</span> IpInfo();<br>        &#125;<br>        ipInfo.refreshIp(ip);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="IM顶层设计">IM顶层设计</h2><h3 id="消息可靠ACK">消息可靠ACK</h3><h3 id="消息重复">消息重复</h3><p>发送消息幂等</p><p>​发送消息的一个随机md5，保证幂等标识 1s内的去重保证，</p><p>接收消息幂等</p><p>​消息的唯一性，靠消息id来判断</p><p>离线消息推送</p><h3 id="推拉模式">推拉模式</h3><p>推拉结合</p><p>客户端维护一个游标，需要保证唯一性和有效性，全局递增的id</p><h3 id="单聊群聊">单聊群聊</h3><p>抽象出一个房间表，房间id就是会话id</p><p>表设计<a href="https://drawsql.app/teams/-328/diagrams/-6">单聊群聊 | DrawSQL</a></p><p><a href="https://drawsql.app/teams/-328/diagrams/-7">会话表 | DrawSQL</a></p><h3 id="消息已读未读">消息已读未读</h3><p>微信最大只展示99条未读数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span><br>(<br>    <span class="hljs-keyword">select</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">from</span> msg<br>    <span class="hljs-keyword">where</span> room_id <span class="hljs-operator">=</span> 我房间 <span class="hljs-keyword">and</span> create_time<span class="hljs-operator">&gt;</span>我阅读<br>    Limit <span class="hljs-number">100</span><br>)<br></code></pre></td></tr></table></figure><p>这样未读数最多扫描100条</p><p><a href="https://drawsql.app/teams/-328/diagrams/-8">消息表 | DrawSQL</a></p><p>redis 存储token</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241114185112346.png" alt="image-20241114185112346"></p><h2 id="消息模块">消息模块</h2><p>rocketMQ</p><h3 id="rocketmq">rocketmq</h3><p>rocketmq 使用docker-compose部署</p><p>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi data/rocketmq/broker/conf/broker.conf<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 所属集群名字</span><br>brokerClusterName=Defaultcluster<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> broker名字</span><br>brokerName=broker-a<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 0表示master &gt;0表示slave</span><br>brokerId=0<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> nameServer地址，分号分割</span><br><span class="hljs-meta">#</span><span class="bash"> namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br>namesrvAddr=rocketmq-namesrv:9876<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">这个很有讲究 如果是正式环境 这里一定要填写内网地址（安全）</span><br><span class="hljs-meta">#</span><span class="bash">如果是用于测试或者本地这里建议要填外网地址，因为你的本地代码是无法连接到阿里云内网，只能连接外网。</span><br>brokerIP1=47.96.119.233<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 在发送消息时，自动创建服务器不存在的topic,默认创建的队列数</span><br>defaultTopicQueueNums=4<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 是否允许Broker自动创建Topic，建议线下开启，线上关闭</span><br>autoCreateTopicEnable=true<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 是否允许broker 自动创建订阅组，建议线下开启，线上关闭</span><br>autoCreateSubscriptionGroup=true<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">Broker 对外服务的监听端口,</span><br>listenPort=10911<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 此参数控制是否开启密码，不开启设置<span class="hljs-literal">false</span></span><br>aclEnable=false<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 删除文件时间点，默认凌晨4点</span><br>deleteWhen=04<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 文件保留时间，默认48小时</span><br>fileReservedTime=120<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> commitLog 每个文件的大小默认1G</span><br>mapedFileSizeCommitLog=1073741824<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span><br>mapedFileSizeConsumeQueue=300000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> destroyMapedFileIntervalForcibly=120000</span><br><span class="hljs-meta">#</span><span class="bash"> redeleteHangedFileInterval=120000</span><br><span class="hljs-meta">#</span><span class="bash"> 检测物理文件磁盘空间</span><br>diskMaxUsedSpaceRatio=88<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Broker 的角色</span><br><span class="hljs-meta">#</span><span class="bash"> - ASYNC_MASTER 异步复制Master</span><br><span class="hljs-meta">#</span><span class="bash"> - SYNC_MASTER 同步双写Master</span><br><span class="hljs-meta">#</span><span class="bash"> - SLAVE</span><br>brokerRole=ASYNC_MASTER<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 刷盘方式</span><br><span class="hljs-meta">#</span><span class="bash"> - ASYNC_FLUSH 异步刷盘</span><br><span class="hljs-meta">#</span><span class="bash"> - SYNC_FLUSH 同步刷盘</span><br>flushDiskType=ASYNC_FLUSH<br></code></pre></td></tr></table></figure><p>创建acl文件，用于开启用户名密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi data/rocketmq/broker/conf/plain_acl.yml<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">全局白名单，如果配置了则不需要走acl校验，慎重配置</span><br>globalwhiteRemoteAddresses:<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> - 47.180.93.*</span><br><span class="hljs-meta">#</span><span class="bash"> - 156.254.120.</span><br>accounts:<br>  - accesskey: RocketMQ<br>    secretkey: 12345678<br>    whiteRemoteAddress:<br>    admin: false<br>    defaultTopicPerm: DENY<br>    defaultGroupPerm: SUB<br>    topicPerms:<br>      -topiCA=DENY<br>      -topicB=PUB|SUB<br>      -topicC=SUB<br>    groupPerms :<br>    # the group should convert to retry topic<br>      -groupA=DENY<br>      -groupB=PUB|SUB<br>      -groupC=SUB<br>      <br>  - accessKey: galileoim<br>    # 密码不能小于6位数<br>    secretKey: 12345678<br>    whiteRemoteAddress:<br>    # if it is admin,it could access all resources 上面的用于教学，我们用超级管理员账号<br>    admin: true<br></code></pre></td></tr></table></figure><p>给console加上账号密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi data/rocketmq/console/data/users.properties<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">Define Admin</span><br><span class="hljs-meta">#</span><span class="bash"> 用户名和密码规则：[用户名=密码，权限],这里的权限为1表示管理员，0表示普通用户</span><br>galileoim=123456,1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">Define Users</span><br><span class="hljs-meta">#</span><span class="bash">user1=user1</span><br><span class="hljs-meta">#</span><span class="bash">user1=user1</span><br></code></pre></td></tr></table></figure><p>创建yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi data/rocketmq/docker-compose.yml<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3.5&#x27;<br>services:<br>  rocketmq-namesrv:<br>    image: foxiswho/rocketmq:4.8.0<br>    container_name: rocketmq-namesrv<br>    restart: always<br>    ports:<br>      - 9876:9876<br>    volumes:<br>      - ./namesrv/logs/nameserver-a:/home/rocketmq/logs<br>      - ./namesrv/store:/home/rocketmq/store<br>    environment:<br>      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -Xms128m -Xmx128m -Xmn64m&quot;<br>    command: [&quot;sh&quot;,&quot;mqnamesrv&quot;]<br>    networks:<br>      rocketmq_net:<br>        aliases:<br>          - rocketmq-namesrv<br><br>  rocketmq-broker:<br>    image: foxiswho/rocketmq:4.8.0<br>    container_name: rocketmq-broker<br>    restart: always<br>    ports:<br>      - 10909:10909<br>      - 10911:10911<br>    volumes:<br>      - ./broker/logs:/home/rocketmq/logs<br>      - ./broker/store:/home/rocketmq/store<br>      - ./broker/conf/plain_acl.yml:/home/rocketmq/rocketmq-4.8.0/conf/plain_acl.yml<br>      - ./broker/conf/broker.conf:/etc/rocketmq/broker.conf<br>    environment:<br>      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -Xms128m -Xmx128m -Xmn64m&quot;<br>    command: [&quot;sh&quot;,&quot;mqbroker&quot;,&quot;-c&quot;,&quot;/etc/rocketmq/broker.conf&quot;]<br>    depends_on:<br>      - rocketmq-namesrv<br>    networks:<br>      rocketmq_net:<br>        aliases:<br>          - rocketmq-broker<br><br>  rocketmq-console:<br>    image: iamverygood/rocketmq-console:4.7.1<br>    container_name: rocketmq-console<br>    restart: always<br>    ports:<br>      - 8180:8080<br>    volumes:<br>      - ./console/data:/tmp/rocketmq-console/data<br>    environment:<br>      JAVA_OPTS: &quot;-Drocketmq.namesrv.addr=rocketmq-namesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;<br>      # -Drocketmq.config.loginRequired=true -Drocketmq.config.aclEnabled=true -Drocketmq.config.accessKey=galileoim -Drocketmq.config.secretKey=12345678<br>    depends_on:<br>      - rocketmq-namesrv<br>    networks:<br>      rocketmq_net:<br>        aliases:<br>          - rocketmq-console<br>networks:<br>  rocketmq_net:<br>    name: rocketmq_net<br>    driver: bridge<br></code></pre></td></tr></table></figure><p>打开<strong>9876</strong>，<strong>10911</strong>，<strong>8180</strong>这几个端口</p><p>到对应目录下启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /data/rocketmq<br>docker-compose up -d<br></code></pre></td></tr></table></figure><h3 id="本地消息表">本地消息表</h3><p>确保本地操作和第三方保证一致  确保数据库操作和MQ一致，请求超时导致不一致性   使用超时态，使用定时重试 保证分布式一致性</p><p>我们讨论了分布式一致性的背最。导致不一致的场景(网络)。以及如何去保证一致性，讨论到持久化，重试，幂等。以及<br>保证一致性的几个方案，其中引出了本地消息表这种常见的方案。通过高度抽象，把对第三方的操作，!<br>转为对本地<br>方法执行的保证。通过操作记录和本地其他事务一同入库，持久化，通过spring的定时任务保证重试，通过<br>spring容器的getbean，来找到对应的方法，执行反射调用。<br>本文不但带你了解了常用的本息消息表企业级框架搭建方案。同时还了解了分布式不一致的具体背景。这些点，都<br>是在面试的时候，面试官会考验你对分布式的基本素养，需要用心去理解。</p><h2 id="其他">其他</h2><h3 id="线程池">线程池</h3><p>线程池配置和使用</p><p>Executor 框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.william.galileoim.common.common.config;<br><br><span class="hljs-keyword">import</span> org.william.galileoim.common.common.factory.MyThreadFactory;<br><span class="hljs-keyword">import</span> org.william.galileoim.transaction.annotation.SecureInvokeConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Primary;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Executor;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 线程池配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AsyncConfigurer</span>, <span class="hljs-title">SecureInvokeConfigurer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 项目共用线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GALILEOIM_EXECUTOR = <span class="hljs-string">&quot;galileoimExecutor&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * websocket通信线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String WS_EXECUTOR = <span class="hljs-string">&quot;websocketExecutor&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AICHAT_EXECUTOR = <span class="hljs-string">&quot;aichatExecutor&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getAsyncExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> galileoimExecutor();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getSecureInvokeExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> galileoimExecutor();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(GALILEOIM_EXECUTOR)</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title">galileoimExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(<span class="hljs-number">10</span>);<br>        executor.setMaxPoolSize(<span class="hljs-number">10</span>);<br>        executor.setQueueCapacity(<span class="hljs-number">200</span>);<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;galileoim-executor-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<span class="hljs-comment">//满了调用线程执行，认为重要任务</span><br>        executor.setThreadFactory(<span class="hljs-keyword">new</span> MyThreadFactory(executor));<br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(WS_EXECUTOR)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title">websocketExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(<span class="hljs-number">16</span>);<br>        executor.setMaxPoolSize(<span class="hljs-number">16</span>);<br>        executor.setQueueCapacity(<span class="hljs-number">1000</span>);<span class="hljs-comment">//支持同时推送1000人</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;websocket-executor-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<span class="hljs-comment">//满了直接丢弃，默认为不重要消息推送</span><br>        executor.setThreadFactory(<span class="hljs-keyword">new</span> MyThreadFactory(executor));<br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(AICHAT_EXECUTOR)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title">chatAiExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(<span class="hljs-number">10</span>);<br>        executor.setMaxPoolSize(<span class="hljs-number">10</span>);<br>        executor.setQueueCapacity(<span class="hljs-number">15</span>);<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;aichat-executor-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<span class="hljs-comment">//满了直接丢弃，默认为不重要消息推送</span><br>        executor.setThreadFactory(<span class="hljs-keyword">new</span> MyThreadFactory(executor));<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="拦截">拦截</h3><p>使用拦截器拦截请求   本地threadlocal存储jwt的token</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SimLVSeg With Mamba 实验</title>
    <link href="/2024/09/26/SimLVSegWithMamba/"/>
    <url>/2024/09/26/SimLVSegWithMamba/</url>
    
    <content type="html"><![CDATA[<h2 id="1-主体框架-SimLVSeg">1. 主体框架-SimLVSeg</h2><p>SimLVSeg使基于视频的网络能够从稀疏注释的超声心动图视频中进行一致的LV分割。SimLVSeg包括具有时间掩蔽的自监督预训练，然后是为从稀疏注释中进行LV分割而定制的弱监督学习。我们展示了SimLVSeg如何在最大的2D+时间超声心动图数据集（EchoNet-Dynamics）上实现93.32%（95%CI 93.21-93.43%）的DICE评分，同时更高效，从而优于最先进的解决方案。SimLVSeg兼容两种类型的视频分割网络：2D超级图像和3D分割。为了展示我们方法的有效性，我们提供了广泛的消融研究，包括预训练设置和各种深度学习主干。我们进一步进行了分布外测试，以展示SimLVSeg在未见分布（CAMUS数据集）上的推广能力。该代码可在<a href="https://github.com/fadamsyah/SimLVSeg%E4%B8%8A%E5%85%AC%E5%BC%80%E8%8E%B7%E5%8F%96%E3%80%82">https://github.com/fadamsyah/SimLVSeg上公开获取。</a></p><p>SimLVSeg使基于视频的网络能够进行LV分段，从而增强性能和更高的时间一致性。SimLVSeg由两个训练阶段组成：具有时间掩蔽的自我监督预训练和LV分割的弱监督学习，专门设计用于解决稀疏注释（标记）超声心动图视频的挑战。</p><h3 id="结构">结构</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240926151034932.png" alt="3D U-Net架构"></p><p>超声心动图视频由堆叠的2D图像组成。将时间轴视为第三维允许3D模型在超声心动图剪辑上分割LV。因此，3D U-Net被用作架构。如图4所示，我们使用具有残余单元的CNN 作为编码器，其具有5个级，其中级输出被传递到解码器。剩余单元包括两个Conv 2D层、两个实例规范层、两个PReLU激活函数和一个跳过连接。</p><h3 id="数据集">数据集</h3><p>EchoNet-Dynamics是最大的公开2D+Time心脏超声心动图，其显示了人体心脏的顶部四腔视图。提供了约10，030个心脏超声心动图视频，固定帧大小为112 x 112。</p><p>视频长度从28帧到1002帧不等，涵盖多个心跳周期，但只有两个被注释（ED和ES帧）。图1中给出了示例超声心动图序列</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240926151357434.png" alt="image-20240926151357434"></p><h3 id="实验">实验</h3><p>作者同时还做了多个消融实验，验证不同的主干网络对该框架性能的影响，实验数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240926152157446.png" alt="Table 2 各种编码器主干的消融研究"></p><p>如表2所示，实验表明性能对编码器主干是稳健的。</p><div class = "note note-danger">注意：这里torch记得用加cuda版本</div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">CUDA 11.6</span><br>pip install torch==1.12.1+cu116 torchvision==0.13.1+cu116 torchaudio==0.12.1 --extra-index-url https://download.pytorch.org/whl/cu116<br></code></pre></td></tr></table></figure><h2 id="2-心脏分割模型">2. 心脏分割模型</h2><h3 id="2-1-模型修改-SegMamba">2.1 模型修改-SegMamba</h3><p>SegMamba也是一个分析3D超声心动图的网路，不同的是原论文中实验采用的体积数据，而不是2D图像数据加时间。因此，将SegMamba移植过来作为主干网络时，将时间作为第三个轴，即输入的帧数作为<strong>高</strong>，SegMamba在原论文实验中表现同样十分优异。详细的集成后代码可以在这里找到<a href="https://github.com/52HZMercury/SimLVSeg-with-SegMamba">https://github.com/52HZMercury/SimLVSeg-with-SegMamba</a></p><p>使用的环境</p><p>py3.8  torch 1.12</p><div class="info info-danger">通道数的变化</div><p>首先需要注意的就是原论文中，SegMamba第一层是使用的4个通道，这里需要初始化为3个通道进行输入，这里解决之后，多半会遇到tensor对不上的问题，接着往下看</p><div class="info info-danger">tensor对不上</div><p>这里tensor对不上的主要原因就是EchoNet-Dynamics数据集是每帧112<em>112的，而SegMamba在原论文中是长宽高为128 * 128 * 128的输入。解决的方法就是把util代码里面的读取视频的代码输出时resize一下，改为128</em>128，至于还有一个128，在SimLVSeg中输入时将帧改为128即可，即对应的<strong>高</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_video</span>(<span class="hljs-params">filename: <span class="hljs-built_in">str</span></span>) -&gt; np.ndarray:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Loads a video from a file.</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        filename (str): filename of video</span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        A np.ndarray with dimensions (channels=3, frames, height, width). The</span><br><span class="hljs-string">        values will be uint8&#x27;s ranging from 0 to 255.</span><br><span class="hljs-string">    Raises:</span><br><span class="hljs-string">        FileNotFoundError: Could not find `filename`</span><br><span class="hljs-string">        ValueError: An error occurred while reading the video</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(filename):<br>        <span class="hljs-keyword">raise</span> FileNotFoundError(filename)<br>    capture = cv2.VideoCapture(filename)<br>    <br>    frame_count = <span class="hljs-built_in">int</span>(capture.get(cv2.CAP_PROP_FRAME_COUNT))<br>    frame_width = <span class="hljs-built_in">int</span>(capture.get(cv2.CAP_PROP_FRAME_WIDTH))<br>    frame_height = <span class="hljs-built_in">int</span>(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))<br>    <br>    <span class="hljs-comment"># v = np.zeros((frame_count, frame_height, frame_width, 3), np.uint8)</span><br>    v = np.zeros((frame_count, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">3</span>), np.uint8)<br><br>    <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(frame_count):<br>        ret, frame = capture.read()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Failed to load frame #&#123;&#125; of &#123;&#125;.&quot;</span>.<span class="hljs-built_in">format</span>(count, filename))<br>        <span class="hljs-comment">#112*112</span><br>        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)<br><br>        <span class="hljs-comment"># 缩放为128</span><br>        frame = cv2.resize(frame, (<span class="hljs-number">128</span>,<span class="hljs-number">128</span>))<br>        v[count, :, :] = frame<br>    <br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><div class="info info-danger">爆显存</div><p>在经历上面的操作后，在实验时，可能会遇到爆显存的错误(3090)，这里的解决方法是，改小精度，将原来的32位改为了16位</p><h4 id="实验结果">实验结果</h4><p>Table.2.    DSC(Dice Similarity Coefficient)</p><table><thead><tr><th>Step</th><th>DSC</th><th>loss</th></tr></thead><tbody><tr><td>2235</td><td>0.863</td><td>0.138</td></tr><tr><td>2980</td><td>0.922</td><td>0.079</td></tr><tr><td>4470</td><td>0.914</td><td>0.084</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>5689</td><td>0.923</td><td>0.078</td></tr></tbody></table><blockquote><p>Both SimLVSeg-3D and SimLVSeg-SI outperform the state-of-the-art,suggesting that the superior performance can be attributed to the SimLVSeg design rather than the selection of the underlying network architectures.</p></blockquote><p>原作者在论文中说是SimLVSeg设计优秀所以性能较好而不是主干网络的选择，从移植SegMamba的实验结构来看确实如此。</p><h4 id="改小参数量">改小参数量</h4><p>具体的措施有：将通道数改为原来的1/2，并转为32位精度计算</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241024150535221.png" alt="改小参数量后"></p><h4 id="加入通道注意力模块">加入通道注意力模块</h4><div class = "note note-success">Squeeze-and-Excitation Networks</div><p><strong>序言</strong></p><p>在本文中，作者研究了网络设计的一个不同方面-通道之间的关系。引入了一个新的架构单元，称之为挤压和激发（SE）块，其目标是通过显式建模其卷积特征通道之间的相互依赖性来提高网络产生的表示的质量。为此，作者提出了一种允许网络执行特征重新校准的机制，通过该机制，网络可以学习使用全局信息来选择性地强调信息特征并抑制不太有用的特征</p><p>在传统的CNN架构中，通常采用卷积层和池化层来提取图像特征。然而，这种方法并没有明确地对特征通道之间的关系进行建模，导致一些通道对于特定任务的贡献相对较小，而其他通道则更重要。SE模块旨在解决这个问题。</p><p><strong>方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241017160341322.png" alt="Fig. 1. A Squeeze-and-Excitation block."></p><p>SE构建块的结构如图1所示。</p><p><strong>Squeeze操作</strong></p><p>这个操作对应上图中的Fsq函数。上面提到了，要找到通道之间的关系，那就是要用到所有通道的信息。论文中简单起见，把每个通道都压缩成一个点，直接求平均，相当于就是这个通道的特征值。这个求平均的过程就是所谓的Squeeze。表达为公式就是：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>u</mi><mi>c</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>H</mi><mo>×</mo><mi>W</mi></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>H</mi></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>W</mi></munderover><msub><mi>u</mi><mi>c</mi></msub><mtext>（</mtext><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">z_c = F_{sq}(u_c)= \frac{1}{ H × W} \sum_{i=1}^H\sum_{j=1}^Wu_c（i,j）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2421em;vertical-align:-1.4138em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">）</span></span></span></span></span></p><p>uc表示特征图U中的某个通道，zc表示经过压缩之后的向量Z。从公式中可以看出，每个尺寸为H*W的featrue map通道，经过全局平均之后，就只剩一个像素点。所以，一个的featrue map经过squeeze之后，就变成了一个的vector, 计作Z。</p><p><strong>Excitation</strong></p><p>特征图经过压缩后，第二步就是综合这些通道的特征值。论文提出，这个综合方法需要满足两个条件：1.要可以表达非线性关系 2.要可以提取处非互斥的关系 所以，论文提出了一个计算方法：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mo>=</mo><msub><mi>F</mi><mrow><mi>e</mi><mi>x</mi></mrow></msub><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mn>2</mn></msub><mi>δ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mn>1</mn></msub><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s = F_{ex}(z,W) = \sigma(g(z,W)) = \sigma(W_2\delta(W_1z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">))</span></span></span></span></span></p><p>从上面可以看出，这个Excitation就是两个全联接层,第一个连接层把1* 1* C的vector Z变成一个1* 1* C/r的向量。然后后面跟一个ReLU激活 层。· 第二个连接层把1* 1* C/r的vector重新恢复为一个1* 1* C的向量。然后后面跟一个Sigmod 的激活层。</p><p><strong>Scale</strong></p><p>最后，根据图1，作为Squeeze和Excitation操作之后，还需要和原特征图U进行合并，也就是上面提到的“重新校准特征图”。这个合并方法也特别简单，就是把这个向量直接原特征图相乘。</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>c</mi></msub><mo stretchy="true">~</mo></mover><mo>=</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>u</mi><mi>c</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>c</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>s</mi><mi>c</mi></msub><msub><mi>u</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">\widetilde{x_c} = F_{scale}(u_c,s_c) = s_cu_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8406em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6906em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.26em" viewBox="0 0 600 260" preserveAspectRatio="none"><path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">sc</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>从上面的excitation可以得知，s是一个的向量，与一个1* 1* C的特征图相乘的话，再从上面的公式可以看出，就是按通道数一个一个的去把s中的每个元素拿出来与特征图的对 应通道进行相乘，就是一个标量乘以矩阵，所以可以理解就是一个scale的操作，放大缩小而已。讲到这里，感觉就是SE就是提取出了通道中某些特征，或者说某些注意力特征，通过这个s’也就是表示通道的权重的向量，去把这个权重乘以对应的特征图通道，来放大或缩小这个通道的作用。从这个角度上来看，确实就叫做通道注意力机制。</p><p>下面给出了SE与Inception和ResNet合并的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241017162611928.png" alt="Fig. 2.原始Inception模块（左）和SEInception模块（右）的模式"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241017162643314.png" alt="Fig. 3.原始残差模块（左）和SEResNet模块（右）的架构。"></p><p><strong>总结</strong></p><p>总而言之，SE模块通过引入Squeeze和Excitation操作，通过自适应地学习每个通道的权重，增强了神经网络的表达能力和性能，使网络能够更有效地学习和利用特征通道之间的关系。</p><p>通道再次降低为初始的1/3，即24M的模型,同时加入通道注意力模块,即上面的压缩激励</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241031132249277.png" alt="降低为原来的1/3"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241031131654163.png" alt="image-20241031131654163"></p><h4 id="加入MSAA模块">加入MSAA模块</h4><div class = "note note-success"> CM-UNet: Hybrid CNN-Mamba UNet for Remote Sensing Image Semantic Segmentation</div><p>加入多尺度注意力聚合模块MSAA</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241031191639676.png" alt="加入MSAA后"></p><p><strong>提出CM-UNet框架</strong>：基于Mamba架构的CM-UNet框架，通过整合CNN和Mamba模块，能够在遥感图像语义分割任务中高效捕捉局部和全局信息。</p><p><strong>设计CSMamba块</strong>：CSMamba块结合了通道和空间注意力机制，将Mamba模块扩展为能够处理图像长程依赖的组件，提升了特征选择和信息融合的精度。</p><p><strong>多尺度注意力聚合模块（MSAA）</strong>：引入MSAA模块，聚合编码器的多尺度特征，通过空间和通道的双重聚合提高特征表达能力，替代传统的跳跃连接，更好地支持解码器的多层次信息融合。</p><p><strong>多输出监督机制</strong>：在解码器的不同层次引入多输出监督，确保各层次逐步细化分割图，从而提升最终分割精度。</p><p><strong>整体结构</strong></p><p>​    CM-UNet模型结构由ResNet编码器、多尺度注意力聚合模块（MSAA）和CSMamba解码器组成。编码器负责提取多层次特征，MSAA模块融合多尺度特征以增强表达，解码器则利用CSMamba块通过通道和空间注意力机制高效捕捉长程依赖关系，最终生成精细的分割图，并在各层解码器中加入多输出监督以优化分割结果。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241031155302597.png" alt="Fig. 2. Framework of the proposed CM-UNet for remote sensing image semantic segmentation. (a) CM-UNet. (b) CSMamba Block. (c) 2D-SSM Module."></p><p><strong>CNN编码器</strong>：采用ResNet结构作为编码器，用于提取多层次的特征信息。与传统UNet不同，CM-UNet的编码器使用的是多尺度特征提取，以便为后续模块提供更丰富的上下文信息。</p><p><strong>多尺度注意力聚合模块（MSAA）</strong>：在编码器和解码器之间，使用MSAA模块对多尺度特征进行聚合。这个模块通过空间和通道注意力机制对不同尺度的特征进行融合，增强特征表达能力，并取代了UNet中的跳跃连接。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241031155837437.png" alt="Fig. 3. The Multi-Scale Attention Aggregation (MSAA) module."></p><p><strong>CSMamba解码器</strong>：解码器采用CSMamba块，该模块结合通道和空间注意力机制，以及Mamba结构的线性时间复杂度特性，能够有效捕获图像的长程依赖关系。CSMamba解码器逐步上采样特征并生成输出分割图。同时引入多输出监督，在各层解码器中加入监督信号，确保分割图在不同层次上得到精细化生成。</p><h4 id="参数量降为24-1M">参数量降为24.1M</h4><p>CVPR 2024 的MemSAM</p><blockquote><p>Deng X, Wu H, Zeng R, et al. MemSAM: Taming Segment Anything Model for Echocardiography Video Segmentation[C]//Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2024: 9622-9631.</p></blockquote><p>该论文实验结果</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241129162620958.png" alt="image-20241129162620958"></p><p>camus-semi和camus-full</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250122092934985.png" alt="image-20250122092934985"></p><p>后续实验参见后续数据集实验部分</p><h3 id="2-2-模型修改-LightM-UNet">2.2 模型修改-LightM-UNet</h3><p>运行环境版本：</p><p>LightM-UNet，这是一个基于Mamba的轻量级U形分割模型，它在显著降低参数和计算成本的同时实现了最先进的性能,参数大大减小</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241112173154849.png" alt="image-20241112173154849"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241114135927092.png" alt="image-20241114135927092"></p><p>所提出的LightM-UNet的总体架构如图所示。给定一个输入图像 ，其中 、、 和  分别表示3D医疗图像的通道数、高度、宽度和切片数</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241114140118136.png" alt="image-20241114140118136"></p><p>LightM-UNet首先使用深度可分卷积（DWConv）层进行浅层特征提取，生成浅层特征图。随后，LightM-UNet结合三个连续的编码器块（Encoder Blocks）从图像中提取深层特征。在每个编码器块之后，特征图中的通道数翻倍，而分辨率减半。</p><p><strong>Encoder Block</strong></p><p>感觉encoder都差不多</p><p>为了最小化参数数量和计算成本，LightM-UNet采用了仅包含Mamba结构的编码器块来从图像中提取深层特征。</p><p>具体来说，给定一个特征图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mi>l</mi></msup><mo>∈</mo><msup><mi>R</mi><mrow><mi>C</mi><mo>×</mo><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mi>D</mi></mrow></msup></mrow><annotation encoding="application/x-tex">F^l \in R^{C \times H \times W \times D }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mn>32</mn><mo>×</mo><msup><mn>2</mn><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">C = 32 \times2^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mi>H</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H = H / 2^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>W</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W = W / 2^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mi>D</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">D = D / 2^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>，以及，编码器块首先将特征图展平并转置成的形状，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">L = H \times W \times D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>。</p><p>随后，编码器块使用个连续的RVM层来捕捉全局信息，在最后一个RVM层中通道数增加。此后，编码器块重新调整并转置特征图的形状为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mn>2</mn><mo separator="true">,</mo><mi>H</mi><mo separator="true">,</mo><mi>W</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C \times 2,H,W,D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>，紧接着进行最大池化操作以降低特征图的分辨率。</p><p>最终，第l个编码器块输出新的特征图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">F^{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，其形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mn>2</mn><mo separator="true">,</mo><mi>H</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>W</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>D</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C \times 2,H/2,W/2,D/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord">/2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">/2</span><span class="mclose">)</span></span></span></span>。</p><p><strong>Residual Vision Mamba Layer (RVM Layer)</strong></p><p>LightM-UNet提出了RVM层以增强原始的SSM块，用于图像深层语义特征提取。具体来说，LightM-UNet利用先进的残差连接和调整因子进一步增强了SSM的长距离空间建模能力，几乎不引入新的参数和计算复杂性。</p><p><strong>实验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241114184622536.png" alt="image-20241114184622536"></p><p>LightM-UNet以其极低的参数数量脱颖而出，仅使用了1.09M个参数。与nnU-Net和U-Mamba相比，参数分别减少了99.14%和99.55%</p><h4 id="加入通道注意力特征融合">加入通道注意力特征融合</h4><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241119155343122.png" alt="image-20241119155343122"></p><p>同时实验时加入mIOU评价指标</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241128123310222.png" alt="image-20241128123310222"></p><h3 id="2-3-更改扫描方式">2.3 更改扫描方式</h3><p>选择一：Right Diagonal (RD 扫描)</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250228152647449.png" alt="image-20250228152647449"></p><p>选择二：Right Diagonal Two-way(RD 双向扫描)</p><p>聚焦于图的中心</p><p>选择三：使用Hilbert曲线 (Hilbert 扫描)</p><p>通过递归的分形结构，将高维空间（如二维平面）连续地映射到一维直线上，同时尽可能保持局部区域的邻近性,Hilbert曲线以及其离散近似表示方法都非常实用，因为其将多维空间转换为一维空间的方法很好地保留了空间邻近性。（x，y）是一个单元方格中的点，d代表该点在Hilbert曲线上的位置，而由于其空间的邻近性，在单元格上近似的点，其对应Hilbert的d值也比较接近。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250228153319794.png" alt="image-20250228153319794"></p><p>要想更改扫描方式，因为该曲线只支持2的幂的边长，该数据为112 * 112 的规格，最为接近的2的幂为128。因此必须先得把数据集的数据填充到128 *128的规格，尝试了两种填充方式：</p><ul><li>直接resize</li><li>使用0填充图像的右边和底边</li></ul><p>其中直接resize可能导致一定程度上标签的错位，猜测会不如第二种使用0填充的方式。具体的实验数据可参看3.3 Echo-Pediatric实验部分。</p><p>跑一轮需要三百多个小时，继续优化</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250313183512859.png" alt="image-20250313183512859"></p><p>选择四：moore 曲线扫描</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250320133405712.png" alt="image-20250320133405712"></p><p>和希尔伯特曲线类似，是希尔伯特曲线的循环版本，不过是从中间开始，首尾闭合</p><h2 id="3-数据集实验">3. 数据集实验</h2><p>SAM的</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250411150318395.png" alt="image-20250411150318395"></p><h3 id="3-1-EchoNet-Dynamic">3.1 EchoNet-Dynamic</h3><p>小segmamba实验结果(DiceLoss)</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241202155209382.png" alt="image-20241202155209382"></p><p>DICE和IOU都比该文高，其中DICE高0.11个点，IOU高0.84</p><p>其他的损失函数</p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>diceloss</td><td><strong>0.9289</strong></td><td><strong>0.8673</strong></td><td><strong>0.0718</strong></td></tr><tr><td>jaccard</td><td>0.9276</td><td>0.8650</td><td>0.1353</td></tr><tr><td>jaccard</td><td>0.9267</td><td>0.8635</td><td>0.1367</td></tr><tr><td>tversky</td><td>0.9272</td><td>0.8643</td><td>0.0687</td></tr></tbody></table><p>效果一般</p><p>改为使用<strong>moore扫描</strong></p><p>方向实验</p><table><thead><tr><th>segmamba-MRscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>dice + Adaw_4bt-4lr 32F 0 + -       v191</td><td>0.9323</td><td>0.8733</td><td></td></tr><tr><td>-                                                         v194</td><td><strong>0.932656</strong></td><td><strong>0.873810</strong></td><td></td></tr><tr><td>dice + Adaw_4bt-4lr 32F 3 + -       v192</td><td>0.9321</td><td>0.8729</td><td></td></tr><tr><td>-                                                         v199</td><td>0.9325</td><td>0.8736</td><td></td></tr><tr><td>dice + Adaw_4bt-4lr 32F 2 + -       v193</td><td>0.9325</td><td>0.8736</td><td></td></tr><tr><td>-                                                         v200</td><td>0.9323</td><td>0.8732</td><td></td></tr></tbody></table><p>还是 0 + - 最好</p><p>学习率实验</p><table><thead><tr><th>segmamba-MRscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>dice  + Adaw_16bt-4lr  32F  0 + -</td><td></td><td></td><td></td></tr><tr><td>-</td><td></td><td></td><td></td></tr><tr><td>dice  + Adaw_16bt-8lr  32F  0 + -</td><td></td><td></td><td></td></tr><tr><td>-</td><td></td><td></td><td></td></tr><tr><td>dice  + Adaw_16bt-16lr  32F  0 + -</td><td></td><td></td><td></td></tr><tr><td>-</td><td></td><td></td><td></td></tr></tbody></table><p>损失实验</p><table><thead><tr><th>segmamba-MRscan 0 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>0.8 dice + 0.2 jaccard + Adaw_4bt-4lr 32F                         v209</td><td>0.9321</td><td>0.8729</td><td>0.0798</td></tr><tr><td>-                                                                                                 v212</td><td>0.9327</td><td>0.8739</td><td>0.0792</td></tr><tr><td>0.4 dice + 0.3 jaccard + 0.3 focal + Adaw_4bt-4lr 32F       v210</td><td>0.932578</td><td>0.873673</td><td>0.07737</td></tr><tr><td>-                                                                                                 v213</td><td>0.932525</td><td>0.873580</td><td>0.07741</td></tr><tr><td>0.2 dice + 0.2 jaccard + 0.6 focal + Adaw_4bt-4lr 32F       v211</td><td>0.932560</td><td>0.873642</td><td>0.0561</td></tr><tr><td>-                                                                                                  v214</td><td>0.9324</td><td>0.8734</td><td>0.0562</td></tr><tr><td>mean 0.3 dice + 0.1 jaccard + 0.3 tversky + 0.3 focal         v230</td><td>0.9267</td><td>0.8658</td><td></td></tr></tbody></table><h3 id="3-2-CAMUS">3.2 CAMUS</h3><p>重写dataset改为该数据集后，DICE和IOU都出现错误：表现为大于1。</p><p>猜想：每个病人只有十几帧，但是segmamba是按128帧设计的，因此输入的是128帧，多出的帧采用零填充，导致有用数据太少。</p><p>方案：使用每个病人原始的数据，进行重复，直到填满128帧。</p><p>并不是这个原因，是因为拼接的函数有点问题，改完之后可以正常显示数据，但是还不完善，只能使用一个batchsize</p><p>下面再来测试几种填充之后的实验差别</p><table><thead><tr><th>填充方式</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>type1</td><td>0.9123</td><td>0.8459</td><td>0.0950</td></tr><tr><td>type2</td><td>0.9301</td><td>0.8708</td><td>0.0779</td></tr><tr><td>type3</td><td>0.9234</td><td>0.8603</td><td>0.0846</td></tr><tr><td>type4</td><td>0.9265</td><td>0.8650</td><td>0.0859</td></tr></tbody></table><p>综合来看type2的padding效果最好，后续在type2上继续实验</p><p>将所有的消融实验做一个表格，包括</p><table><thead><tr><th>segmamba-24.1M</th><th>DICE</th><th>IOU</th><th>loss</th></tr></thead><tbody><tr><td>type1 + Adaw + diceloss</td><td>0.912</td><td>0.845</td><td>0.095</td></tr><tr><td>type2 + Adaw + diceloss</td><td>0.930</td><td>0.870</td><td>0.077</td></tr><tr><td>type3 + Adaw + diceloss</td><td>0.923</td><td>0.860</td><td>0.084</td></tr><tr><td>type4 + Adaw + diceloss</td><td>0.926</td><td>0.865</td><td>0.085</td></tr><tr><td>type5 + Adaw + diceloss</td><td>0.912</td><td>0.845</td><td>0.095</td></tr><tr><td>type2 + Adaw + jaccard</td><td>0.932</td><td>0.873</td><td>0.129</td></tr><tr><td><strong>type2 + Adaw + jaccard+ 2lr</strong></td><td><strong>0.935</strong></td><td><strong>0.878</strong></td><td><strong>0.126</strong></td></tr><tr><td>type3 + Adaw + hccdice</td><td>0.931</td><td>0.871</td><td>0.080</td></tr><tr><td>type3 + Adaw + jaccard</td><td>0.932</td><td>0.873</td><td>0.135</td></tr><tr><td>type3 + Adaw + jaccard + 2lr</td><td>0.934</td><td>0.877</td><td>0.125</td></tr><tr><td>type3 + Adaw + jaccard + 3lr</td><td>0.932</td><td>0.873</td><td>0.128</td></tr><tr><td>type3 + Adaw + tversky + 2lr</td><td>0.930</td><td>0.870</td><td>0.076</td></tr><tr><td>type3 + SGD + diceloss</td><td>0.921</td><td>0.857</td><td>0.078</td></tr><tr><td>type3 + SGD + jaccard</td><td>0.919</td><td>0.850</td><td>0.149</td></tr><tr><td>type4 + Adaw +  jaccard</td><td>0.933</td><td>0.875</td><td>0.127</td></tr><tr><td>type6 + Adaw +  jaccard + 2lr</td><td>0.928</td><td>0.866</td><td>0.140</td></tr></tbody></table><p><strong>使用CAMUS数据集官方划分的训练集，验证集和测试集</strong></p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>全监督</td><td>0.9377</td><td>0.8828</td><td>0.1208</td></tr><tr><td>全监督_4bt-4lr</td><td>0.9406</td><td>0.8879</td><td>0.1193</td></tr><tr><td>弱监督A</td><td>0.9391</td><td>0.8852</td><td>0.1150</td></tr><tr><td>弱监督B</td><td>0.2071</td><td>0.1155</td><td>0.9697</td></tr></tbody></table><blockquote><p>这里的弱监督A是训练的时候只提取了两帧(舒张末期和收缩末期)，在验证测试时也只测试了这两帧；弱监督B也是训练的时候只提取两帧，但是验证和测试时是全周期数据，可以看到，效果非常的垃圾。。。</p></blockquote><p><strong>使用SAM模型划分的训练集，验证集和测试集</strong></p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>dice+Adaw_4bt-3lr</td><td>0.9427</td><td>0.8917</td><td>0.0681</td></tr><tr><td>jaccard+Adaw_4bt-4lr</td><td><strong>0.9431</strong></td><td><strong>0.8924</strong></td><td><strong>0.1143</strong></td></tr><tr><td>jaccard+Adaw_4bt-3lr</td><td>0.9414</td><td>0.8893</td><td>0.1215</td></tr></tbody></table><p>在3D_UNet上</p><table><thead><tr><th>3D_UNet</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>dice+Adaw_2lr+split_SAM</td><td>0.9430</td><td>0.8922</td><td>0.0933</td></tr><tr><td>dice+Adaw_4lr+split_SAM</td><td>0.9457</td><td>0.8970</td><td>0.0633</td></tr><tr><td>dice+Adaw_2lr+split_CAMUS</td><td>0.9351</td><td>0.8782</td><td>0.0954</td></tr><tr><td>dice+Adaw_4lr+split_CAMUS</td><td>0.9440</td><td>0.8940</td><td>0.0631</td></tr></tbody></table><p>改进hibertScan后   使用SAM的划分方式  segmamba-HBscan</p><table><thead><tr><th>segmamba-HBscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice +  SGD</td><td>0.9346</td><td>0.8773</td><td>0.0655</td></tr><tr><td>hccdice  +  Adaw_4bt-4lr</td><td>0.9397</td><td>0.8863</td><td>0.0690</td></tr><tr><td>jaccard   + Adaw_4bt-4lr</td><td>0.9376</td><td>0.8825</td><td>0.1283</td></tr><tr><td>hccdice  + Adaw_4bt-5lr</td><td>0.9421</td><td>0.8906</td><td>0.0634</td></tr><tr><td>hccdice  + Adaw_4bt-6lr</td><td>0.9402</td><td>0.8872</td><td>0.0651</td></tr><tr><td>hccdice  + Adaw_4bt-5.5lr</td><td>0.9394</td><td>0.8858</td><td>0.0659</td></tr><tr><td>tversky   + Adaw_4bt-5lr</td><td>0.9385</td><td>0.8842</td><td>0.0675</td></tr><tr><td>tversky  + Adaw_4bt-5lr  type6  all  32F</td><td>0.9430</td><td>0.8923</td><td>0.0580</td></tr><tr><td>tversky  + Adaw_4bt-5lr  type2  all  32F</td><td>0.9418</td><td>0.8900</td><td>0.0642</td></tr><tr><td>hccdice  + Adaw_4bt-5lr  type6  all  32F</td><td>0.9398</td><td>0.8865</td><td>0.0637</td></tr><tr><td>hccdice  + Adaw_8bt-7.07lr  type6  32F</td><td>0.9386</td><td>0.8844</td><td>0.0673</td></tr><tr><td>hccdice  + Adaw_12bt-8.65lr  type6  32F</td><td>0.9361</td><td>0.8800</td><td>0.0706</td></tr><tr><td>hccdice  + Adaw_4bt-5lr type2  EDES  32F</td><td>0.9408</td><td>0.8882</td><td>0.0648</td></tr><tr><td>hccdice  + Adaw_4bt-5lr type2  all  32F</td><td>0.9424</td><td>0.8911</td><td>0.0618</td></tr><tr><td>hccdice  + Adaw_16bt-5lr type2  all  32F</td><td>0.9368</td><td>0.8812</td><td>0.0996</td></tr><tr><td>hccdice  + Adaw_16bt-15lr type2  all  32F</td><td>0.9397</td><td>0.8863</td><td>0.0659</td></tr><tr><td>hccdice  + Adaw_16bt-20lr type2  all  32F</td><td>0.9410</td><td>0.8886</td><td>0.0624</td></tr><tr><td>hccdice  + Adaw_16bt-25lr type2  all  32F</td><td>0.9390</td><td>0.8850</td><td>0.0633</td></tr></tbody></table><p>segmamba-MRscan</p><table><thead><tr><th>segmamba-MRscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>tversky   + Adaw_4bt-5lr type2 all 32F</td><td>0.9420</td><td>0.8903</td><td>0.0612</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F</td><td>0.9421</td><td>0,8906</td><td>0.0613</td></tr><tr><td>hccdice   + Adaw_4bt-5lr type2 all 32F</td><td>0.9412</td><td>0.8890</td><td>0.0631</td></tr><tr><td>hccdice   + Adaw_4bt-5lr type6 all 32F</td><td>0.9374</td><td>08823</td><td>0.0660</td></tr><tr><td>jaccard   + Adaw_4bt-5lr type2 all 32F</td><td>0.9402</td><td>0.8872</td><td>0.1222</td></tr><tr><td>jaccard   + Adaw_4bt-5lr type6 all 32F</td><td>0.9399</td><td>0.8866</td><td>0.1174</td></tr><tr><td>dice   + Adaw_4bt-5lr type2 all 32F</td><td>0.9408</td><td>0.8883</td><td>0.0630</td></tr><tr><td>dice   + Adaw_4bt-5lr type6 all 32F</td><td>0.9395</td><td>0.8859</td><td>0.0640</td></tr><tr><td>tversky   + SGD-0.1lr type2 all 32F</td><td></td><td></td><td></td></tr><tr><td>tversky   + SGD-0.1lr type6 all 32F</td><td></td><td></td><td></td></tr><tr><td>tversky   + Adaw_4bt-5lr type2 all 32F   35epoch</td><td>0.9403</td><td>0.8874</td><td>0.0634</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F    35epoch</td><td>0.9410</td><td>0.8885</td><td>0.0615</td></tr></tbody></table><p>采用不同扫描方向实验这里都统一采用  tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch     0:西 1:北 2:东 3:南</p><p>第一轮的数据可能是没加MRscan的数据。。。</p><table><thead><tr><th>segmamba-MRscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>0 + -    *</td><td>0.9427 / 0.9408/0.9396/0.9413</td><td>/</td><td>/</td></tr><tr><td>1 + -</td><td>0.9367 / 0.9401/0.9400/0.9394</td><td>0.8868</td><td>0.0635</td></tr><tr><td>2 + -    *</td><td><strong>0.9416 / 0.9435/0.9421/0.9426</strong></td><td><strong>0.8931</strong></td><td><strong>0.0589</strong></td></tr><tr><td>3 + -    *</td><td>0.9425 / 0.9418/0.9426/0.9421</td><td>0.8914</td><td>0.0602</td></tr><tr><td>0 - +    *</td><td>0.9418 / 0.9405/0.9421/0.9416</td><td>0.8906</td><td>0.0597</td></tr><tr><td>1 - +</td><td>0.9385 / 0.9407/0.9405/0.9384</td><td>/</td><td>/</td></tr><tr><td>2 - +</td><td>0.9401 / 0.9413/0.9391/0.9401</td><td>0.8892</td><td>0.0617</td></tr><tr><td>3 - +</td><td>0.9410 / 0.9413/0.9391/0.9410</td><td>/</td><td>/</td></tr></tbody></table><p>消融实验 减去MRscan 采用 tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch</p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>tversky   + Adaw_4bt-5lr type2 all 32F</td><td>0.9438</td><td>/</td><td>/</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F</td><td>0.9434</td><td>0.8929</td><td>0.059</td></tr><tr><td>tversky   + Adaw_4bt-5lr type2 all 32F  35epoch</td><td></td><td></td><td></td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F  35epoch</td><td>0.9409</td><td>0.8884</td><td>0.0636</td></tr><tr><td>后面统一采用tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch</td><td></td><td></td><td></td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch</td><td>0.9407</td><td>0.8881</td><td>0.0621</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch</td><td>0.9409</td><td>0.8884</td><td>0.0614</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch</td><td>0.9420</td><td>0.8904</td><td>0.0617</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F 60Epoch</td><td></td><td></td><td></td></tr></tbody></table><p>学习率实验</p><table><thead><tr><th>segmamba-MRscan 2 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>tversky   + Adaw_4bt-4lr type6 all 32F</td><td>0.942372</td><td>0.8910</td><td>0.0631</td></tr><tr><td>-</td><td>0.941797</td><td>0.8899</td><td>0.0627</td></tr><tr><td>tversky   + Adaw_4bt-5lr type6 all 32F</td><td>0.941884</td><td>0.8901</td><td>0.0606</td></tr><tr><td>-</td><td>0.941728</td><td>0.8898</td><td>0.0621</td></tr></tbody></table><p>损失实验  mean</p><table><thead><tr><th>segmamba-MRscan 2 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>tversky</td><td>0.9391</td><td>0.8864</td><td></td></tr><tr><td>-</td><td>0.9392</td><td></td><td></td></tr><tr><td>0.3 dice + 0.1 jaccard + 0.3 tversky + 0.3 focal        v228</td><td>0.9391</td><td>0.8863</td><td></td></tr><tr><td>-                                                                                       v229</td><td>0.9339</td><td>0.8772</td><td></td></tr></tbody></table><h3 id="3-3-Echo-Pediatric">3.3 Echo-Pediatric</h3><p>该数据需要首先进行预处理，使用split列中的数字划分训练集，验证集和测试集。这里使用的是&lt;8的数据为训练集，==8的为验证集，其余的为测试集。</p><p>除此之外，该数据集中有部分脏数据需要进行处理，比如VolumeTracings.csv中部分X,Y数据为空，Frame为No Systolic,需要删除，以及部分数据标注时有误，只有144帧，但标注时标注了序号为第144帧，导致越界错误。</p><p>先使用了jaccard的dsc只有0.9063，iou为0.8288；考虑到这个数据集和echodynamic类似。因此，接着使用diceloss进行测试，效果差不多，dsc为0.9045，iou为0.8256</p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>jaccard+Adaw</td><td>0.9063</td><td>0.8288</td><td>0.0938</td></tr><tr><td>diceloss+Adaw</td><td>0.9045</td><td>0.8256</td><td>0.1748</td></tr></tbody></table><p>数据集的处理有点问题，重新跑一遍：</p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>jaccard+Adaw_4lr</td><td>0.9039</td><td>0.8246</td><td>0.1757</td></tr><tr><td>jaccard+Adaw_6lr</td><td>0.9041</td><td>0.8250</td><td>0.1752</td></tr><tr><td>jaccard+SGD</td><td>0.9084</td><td>0.8323</td><td>0.1677</td></tr><tr><td>diceloss+SGD</td><td>0.9068</td><td>0.8295</td><td>0.0932</td></tr><tr><td><strong>hccdice+Adaw_4lr</strong></td><td><strong>0.9115</strong></td><td><strong>0.8374</strong></td><td><strong>0.0892</strong></td></tr></tbody></table><p>3D_Unet模型  Adaw</p><table><thead><tr><th>3D_Unet</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>3D_Unet+jaccard</td><td>0.9090</td><td>0.8332</td><td>0.1688</td></tr><tr><td>3D_Unet+diceloss</td><td>0.9112</td><td>0.8369</td><td>0.0906</td></tr></tbody></table><p>其他模型  都是Adaw+DiceLoss</p><table><thead><tr><th>model name</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>LightMUNet</td><td>0.8855</td><td>0.7946</td><td>0.1145</td></tr><tr><td>TMamba3D</td><td>/</td><td>/</td><td>/</td></tr><tr><td>SegFormer3D</td><td>0.9123</td><td>0.8388</td><td>0.0876</td></tr><tr><td>UKAN3D</td><td>0.9091</td><td>0.8334</td><td>0.0910</td></tr></tbody></table><p>UNet_IDC3D模型</p><table><thead><tr><th>model name</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>UNet_IDC3D+diceLoss</td><td>0.9112</td><td>0.8368</td><td>/</td></tr><tr><td>UNet_IDC3D+hccdice</td><td>0.9137</td><td>0.8412</td><td>0.0866</td></tr></tbody></table><p>改进为希尔伯特曲线扫描后的segmamba-HBscan</p><p>填充到128*128规格的两种方式的实验</p><table><thead><tr><th>segmamba-24.1M</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice+Adaw_4lr (resize 128)</td><td>0.9084</td><td>0.8323</td><td>0.0923</td></tr><tr><td>hccdice+Adaw_4lr (padding 128)</td><td>0.9122</td><td>0.8386</td><td>0.0884</td></tr><tr><td>hccdice  + Adaw_4bt-5lr  32F</td><td>0.9137</td><td>0.8412</td><td>0.0870</td></tr><tr><td>tversky  + Adaw_4bt-5lr  32F</td><td>0.9105</td><td>0.8357</td><td>0.0835</td></tr></tbody></table><p>segmamba-HBscan</p><table><thead><tr><th>segmamba-HBscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice+Adaw_4lr</td><td>0.9126</td><td>0.8393</td><td>0.0882</td></tr><tr><td>jaccard+Adaw_4lr</td><td>0.9115</td><td>0.8374</td><td>0.1628</td></tr><tr><td>hccdice+Adaw_4bt-5lr  32F</td><td>0.9139</td><td>0.8415</td><td>0.0868</td></tr><tr><td>hccdice+SGD_4bt-0.1lr</td><td>0.9128</td><td>0.8396</td><td>0.0877</td></tr><tr><td>hccdice+SGD_16bt-0.3lr  32F</td><td>/</td><td>/</td><td>/</td></tr><tr><td>tversky  + Adaw_4bt-5lr  32F</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><p>moore曲线的扫描方式 segmamba-MRScan</p><table><thead><tr><th>segmamba-MRscan</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-5lr  32F</td><td>0.9110</td><td>0.8367</td><td>0.0898</td></tr><tr><td>tversky  + Adaw_4bt-5lr  32F</td><td>0.9104</td><td>0.8356</td><td>0.0809</td></tr></tbody></table><p>更换了不同的扫描方向</p><table><thead><tr><th>segmamba-MRscan  2 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-5lr  32F</td><td>0.9112</td><td>0.8370</td><td>0.0897</td></tr><tr><td>-</td><td>0.9119</td><td>0.8381</td><td>0.8882</td></tr><tr><td>-</td><td>0.9113</td><td>0.8371</td><td>0.0895</td></tr><tr><td>hccdice  + Adaw_4bt-4lr  32F</td><td>0.913840</td><td>0.8413</td><td>0.0870</td></tr><tr><td>-</td><td>0.9122</td><td>0.8386</td><td>0.0886</td></tr><tr><td>hccdice  + Adaw_4bt-6lr  32F</td><td>0.9124</td><td>0.8389</td><td>0.0884</td></tr><tr><td>hccdice  + SGD_ 4bt-0.1lr 32F</td><td>0.913801</td><td>0.8412</td><td>0.0866</td></tr><tr><td>hccdice  + SGD_ 4bt-0.15lr 32F</td><td>0.9085</td><td>0.8324</td><td>0.09198</td></tr></tbody></table><table><thead><tr><th>segmamba-MRscan  3 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-4lr  32F</td><td>0.9135</td><td>0.8409</td><td>0.0871</td></tr><tr><td>-</td><td>0.9142</td><td>0.8420</td><td>0.0866</td></tr><tr><td>hccdice  + SGD_ 4bt-0.1lr 32F</td><td>0.9120</td><td>0.8383</td><td>0.0884</td></tr><tr><td>-</td><td>0.9044</td><td>0.8255</td><td>0.0964</td></tr></tbody></table><table><thead><tr><th>segmamba-MRscan  0 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-4lr  32F</td><td>0.9148</td><td>0.8430</td><td>0.0859</td></tr><tr><td>-</td><td>0.9149</td><td>0.8431</td><td>0.0859</td></tr><tr><td>hccdice  + SGD_ 4bt-0.1lr 32F</td><td>0.9082</td><td>0.8319</td><td>0.0923</td></tr><tr><td>-</td><td>0.9127</td><td>0.8395</td><td>0.0876</td></tr></tbody></table><table><thead><tr><th>segmamba-MRscan  0 - +</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-4lr  32F</td><td>0.9126</td><td>0.8393</td><td>0.0884</td></tr><tr><td>-</td><td>0.9115</td><td>0.8375</td><td>0.0895</td></tr><tr><td>hccdice  + SGD_ 4bt-0.1lr 32F</td><td>0.9131</td><td>0.8402</td><td>0.0872</td></tr><tr><td>-</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><table><thead><tr><th>segmamba-MRscan  3 - +</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-4lr  32F</td><td>0.9120</td><td>0.8383</td><td>0.0887</td></tr></tbody></table><p>不同的损失测试</p><table><thead><tr><th>segmamba-MRscan  0 + -</th><th>dsc</th><th>iou</th><th>loss</th></tr></thead><tbody><tr><td>hccdice  + Adaw_4bt-4lr  32F</td><td>0.9114</td><td>0.8373</td><td>0.0895</td></tr><tr><td>tversky  + Adaw_4bt-4lr  32F</td><td>0.9093</td><td>0.8337</td><td>0.0861</td></tr><tr><td>-</td><td>0.9089</td><td>0.8331</td><td>0.0848</td></tr><tr><td>dice  + Adaw_4bt-4lr  32F</td><td>0.9151</td><td>0.8434</td><td>0.0852</td></tr><tr><td>-</td><td>0.9151</td><td>0.8435</td><td>0.0851</td></tr><tr><td>jaccard  + Adaw_4bt-4lr  32F  v179</td><td>0.916061</td><td>0.8451</td><td>0.1551</td></tr><tr><td>-</td><td>0.9158</td><td>0.8448</td><td>0.1556</td></tr><tr><td>focal  + Adaw_4bt-4lr  32F</td><td>0.9133</td><td>0.8405</td><td>0.0096</td></tr><tr><td>-</td><td>0.9153</td><td>0.8439</td><td>0.0091</td></tr><tr><td>0.5 dice+0.5 Jaccard + Adaw_4bt-4lr  32F</td><td>0.9134</td><td>0.8407</td><td>0.1233</td></tr><tr><td>-</td><td>0.915999</td><td>0.8450</td><td>0.1198</td></tr><tr><td>0.8 dice+ 0.2 Jaccard + Adaw_4bt-4lr  32F</td><td><strong>0.9167</strong></td><td><strong>0.8462</strong></td><td><strong>0.0976</strong></td></tr><tr><td>-</td><td>0.9159</td><td>0.8448</td><td>0.0986</td></tr><tr><td>0.2 dice+ 0.8 Jaccard + Adaw_4bt-4lr  32F</td><td>0.9160</td><td>0.8451</td><td>0.1410</td></tr><tr><td>-</td><td>0.9137</td><td>0.8412</td><td>0.1446</td></tr><tr><td><strong>0.4 dice + 0.3 jaccard + 0.3 focal + Adaw_4bt-4lr 32F</strong>      v201</td><td>0.9165</td><td>0.8458</td><td>0.0974</td></tr><tr><td>-                                                                                               v205</td><td>0.9157</td><td>0.8445</td><td>0.0985</td></tr><tr><td>0.6 dice + 0.2 jaccard + 0.2 focal + Adaw_4bt-4lr 32F      v202</td><td>0.9145</td><td>0.8426</td><td>0.0961</td></tr><tr><td>v206</td><td>0.9117</td><td>0.8378</td><td>0.0993</td></tr><tr><td>0.2 dice + 0.6 jaccard + 0.2 focal + Adaw_4bt-4lr 32F      v203</td><td>0.9143</td><td>0.8422</td><td>0.1261</td></tr><tr><td>-                                                                                                v207</td><td>0.9152</td><td>0.8436</td><td>0.1250</td></tr><tr><td>0.2 dice + 0.2 jaccard + 0.6 focal + Adaw_4bt-4lr 32F      v204</td><td>0.9163</td><td>0.8455</td><td>0.0719</td></tr><tr><td>-                                                                                                v208</td><td>0.9161</td><td>0.8452</td><td>0.0727</td></tr><tr><td>(mean)0.3 dice + 0.1jaccard + 0.3 tversky + 0.3 focal      v231</td><td>0.9079</td><td>0.8359</td><td></td></tr><tr><td>(mean)-                                                                                    v232</td><td>0.9071</td><td>0.8340</td><td></td></tr></tbody></table><h2 id="4-sota实验">4. sota实验</h2><h3 id="4-1-Echo-Dynamic">4.1 Echo-Dynamic</h3><table><thead><tr><th>model name</th><th>dsc</th><th>iou</th><th>assd</th><th>HD95</th></tr></thead><tbody><tr><td>3d u-net    v304</td><td>93.22</td><td>87.30</td><td>1.12</td><td>2.74</td></tr><tr><td>SwinUnet</td><td>87.79</td><td>80.14</td><td>5.71</td><td>6.61</td></tr><tr><td>SegFormer3D    v305</td><td>93.09</td><td>87.07</td><td>1.13</td><td>2.73</td></tr><tr><td>H2Former</td><td>90.21</td><td>82.46</td><td>5.12</td><td>3.78</td></tr><tr><td>LightMUNet    v348</td><td>92.67</td><td>86.34</td><td>1.21</td><td>2.95</td></tr><tr><td>UKAN3D    v341</td><td>93.20</td><td>87.27</td><td>1.12</td><td>2.67</td></tr><tr><td>MedSAM</td><td>86.47</td><td>79.19</td><td>4.88</td><td>7.97</td></tr><tr><td>SAMUS</td><td>91.79</td><td>84.32</td><td>3.22</td><td>5.35</td></tr><tr><td>MemSAM</td><td>92.78</td><td>85.89</td><td>2.71</td><td>4.57</td></tr><tr><td>ours</td><td>93.28</td><td>87.41</td><td>1.10</td><td>2.68</td></tr></tbody></table><table><thead><tr><th>UKAN3D</th><th>dsc</th><th>iou</th><th>assd</th><th>HD95</th></tr></thead><tbody><tr><td>v308</td><td>93.24</td><td>87.35</td><td>/</td><td>/</td></tr><tr><td>v322</td><td>93.24</td><td>87.34</td><td>1.14</td><td>2.79</td></tr><tr><td><strong>v341</strong></td><td>93.20</td><td>87.27</td><td>1.12</td><td>2.69</td></tr><tr><td>v344</td><td>93.21</td><td>87.29</td><td>1.12</td><td>2.71</td></tr><tr><td>v345</td><td>93.26</td><td>87.37</td><td>1.11</td><td>2.70</td></tr></tbody></table><table><thead><tr><th>LightMUnet</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th></tr></thead><tbody><tr><td>v306</td><td>92.80</td><td>86.57</td><td>1.18</td><td>2.91</td></tr><tr><td>v348</td><td>92.67</td><td>86.34</td><td>1.21</td><td>2.95</td></tr></tbody></table><h3 id="4-1-CAMUS">4.1 CAMUS</h3><table><thead><tr><th>model name</th><th>dsc</th><th>iou</th><th>assd</th><th>HD95</th></tr></thead><tbody><tr><td>3d u-net   v321</td><td>93.78</td><td>88.28</td><td>2.82</td><td>8.93</td></tr><tr><td>SwinUnet</td><td>88.84</td><td>80.33</td><td>2.60</td><td>6.10</td></tr><tr><td>SegFormer3D    v312</td><td>93.46</td><td>87.72</td><td>2.13</td><td>4.27</td></tr><tr><td>H2Former</td><td>91.31</td><td>84.30</td><td>2.05</td><td>5.27</td></tr><tr><td>LightMUNet   v314</td><td>92.35</td><td>85.79</td><td>1.60</td><td>3.67</td></tr><tr><td>UKAN3D   v347</td><td>93.88</td><td>88.46</td><td>1.74</td><td>3.84</td></tr><tr><td>MedSAM</td><td>85.42</td><td>75.14</td><td>3.34</td><td>8.42</td></tr><tr><td>SAMUS</td><td>91.11</td><td>83.94</td><td>2.07</td><td>5.08</td></tr><tr><td>MemSAM</td><td>93.31</td><td>87.61</td><td>1.57</td><td>3.82</td></tr><tr><td>ours</td><td>94.30</td><td>89.21</td><td>1.36</td><td>2.93</td></tr></tbody></table><table><thead><tr><th>UKAN3D</th><th>dsc</th><th>iou</th><th>assd</th><th>HD95</th></tr></thead><tbody><tr><td>v325</td><td>93.66</td><td>88.08</td><td>3.19</td><td>11.6</td></tr><tr><td>v347</td><td>93.88</td><td>88.46</td><td>1.74</td><td>3.84</td></tr></tbody></table><h3 id="4-3-Echo-Pediatric">4.3 Echo-Pediatric</h3><table><thead><tr><th>model name</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>3d u-net  v41</td><td>0.9090</td><td>0.8332</td><td></td><td></td><td></td></tr><tr><td>LightMUNet V45</td><td>0.8856</td><td>0.7946</td><td></td><td></td><td></td></tr><tr><td>SegFormer3D  v50</td><td>0.9123</td><td>0.8388</td><td></td><td></td><td></td></tr><tr><td>UKAN3D V48</td><td>0.9092</td><td>0.8335</td><td></td><td></td><td></td></tr><tr><td>ours</td><td>0.9243</td><td>0.8593</td><td></td><td></td><td></td></tr></tbody></table><p>v2</p><table><thead><tr><th>model name</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th></tr></thead><tbody><tr><td>3d u-net   v331</td><td>91.34</td><td>84.06</td><td>1.64</td><td>4.02</td></tr><tr><td>SegFormer3D  v328</td><td>91.23</td><td>83.87</td><td>1.60</td><td>3.91</td></tr><tr><td>LightMUNet   v327</td><td>90.85</td><td>83.24</td><td>1.70</td><td>4.28</td></tr><tr><td>UKAN3D   v330</td><td>91.48</td><td>84.30</td><td>1.58</td><td>3.91</td></tr><tr><td>ours</td><td>91.65</td><td>84.58</td><td>1.55</td><td>3.85</td></tr></tbody></table><table><thead><tr><th>3d u-net</th><th>dsc</th><th>iou</th><th>assd</th><th>HD95</th></tr></thead><tbody><tr><td>v326</td><td>0.9156</td><td>0.8444</td><td>/</td><td>/</td></tr><tr><td>v331</td><td>0.9155</td><td>0.8442</td><td>1.8086</td><td>4.9218</td></tr><tr><td>v332</td><td>0.9158</td><td>0.8446</td><td>/</td><td>/</td></tr><tr><td>v336</td><td>0.9134</td><td>0.8406</td><td>1.64</td><td>4.02</td></tr></tbody></table><table><thead><tr><th>UKAN3D</th><th>dsc</th><th>iou</th><th>assd</th><th>HD95</th></tr></thead><tbody><tr><td>v329</td><td>0.9157</td><td>0.8445</td><td>/</td><td>/</td></tr><tr><td>v330</td><td>0.9154</td><td>0.8444</td><td>1.6026</td><td>3.9676</td></tr><tr><td>v337</td><td>0.9148</td><td>0.8430</td><td>1.5821</td><td>3.9149</td></tr></tbody></table><h2 id="5-消融实验">5. 消融实验</h2><ul><li>24.1 baseline</li><li>moore扫描模块</li><li>融合损失</li></ul><p>表格示意</p><p><code>+</code> fusionLoss:   0.4 dice + 0.3 jaccard + 0.3 focal</p><p><code>+</code> fusionLossV2:   0.4 dice + 0.1 jaccard + 0.5 focal (舍)</p><p><code>-</code>fusionLoss:   dice</p><p><code>+</code>mooreScan:   mooreScan</p><p><code>-</code>mooreScan:   横向扫描resize</p><h3 id="5-1-Echo-Dynamic">5.1 Echo-Dynamic</h3><p>选用方向: 0 + -</p><table><thead><tr><th>扫描方式</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th></tr></thead><tbody><tr><td>- mooreScan  - fusionLoss   (baseline)</td><td>0.9213</td><td>0.8542</td><td>1.2950</td><td>3.5227</td></tr><tr><td>+ mooreScan  - fusionLoss</td><td>0.9324</td><td>0.8734</td><td>1.1086</td><td>2.6753</td></tr><tr><td>- mooreScan  + fusionLoss</td><td>0.9317</td><td>0.8722</td><td>1.1223</td><td>2.7157</td></tr><tr><td>+ mooreScan  + fusionLoss</td><td>0.9328</td><td>0.8741</td><td>1.1050</td><td>2.6789</td></tr></tbody></table><table><thead><tr><th>- mooreScan  - fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v251</td><td>0.9321</td><td>0.8728</td><td>1.1146</td><td>2.7019</td><td>0.9347</td></tr><tr><td>v255</td><td>0.9320</td><td>0.8727</td><td>1.1144</td><td>2.7012</td><td>0.9345</td></tr><tr><td>v286</td><td>0.9316</td><td>0.8720</td><td>1.1216</td><td>2.7196</td><td>0.9338</td></tr><tr><td>v30</td><td>0.9276</td><td>0.8650</td><td></td><td></td><td></td></tr><tr><td>v33</td><td>0.9272</td><td>0.8643</td><td></td><td></td><td></td></tr><tr><td>v357</td><td>0.9259</td><td>0.8620</td><td>1.3182</td><td>3.5017</td><td></td></tr><tr><td><strong>V366</strong></td><td>0.9214</td><td>0.8542</td><td>1.2950</td><td>3.5227</td><td></td></tr></tbody></table><table><thead><tr><th>+ mooreScan  - fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v191</td><td>0.9323</td><td>0.8733</td><td>1.1086</td><td>2.6854</td><td>0.9337</td></tr><tr><td><strong>v249</strong></td><td>0.9324</td><td>0.8734</td><td>1.1086</td><td>2.6753</td><td>0.9350</td></tr></tbody></table><table><thead><tr><th>- mooreScan  + fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v248</td><td>0.9325</td><td>0.8737</td><td>/</td><td>/</td><td>/</td></tr><tr><td><strong>v252</strong></td><td>0.9317</td><td>0.8722</td><td>1.1223</td><td>2.7157</td><td>0.9380</td></tr><tr><td>v254</td><td>0.9325</td><td>0.8736</td><td>1.1086</td><td>2.6940</td><td>0.9356</td></tr></tbody></table><table><thead><tr><th>+ mooreScan  + fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v210</td><td>0.9326</td><td>0.8737</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v246</td><td>0.9327</td><td>0.8739</td><td>1.1053</td><td>2.6756</td><td>0.9374</td></tr><tr><td><strong>v253</strong></td><td>0.9328</td><td>0.8741</td><td>1.1050</td><td>2.6789</td><td>0.9368</td></tr></tbody></table><table><thead><tr><th>- mooreScan  + fusionLossV2</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v262</td><td>0.9326</td><td>0.8737</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v263</td><td>0.9322</td><td>0.8731</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><table><thead><tr><th>+ mooreScan  + fusionLossV2</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v256</td><td>0.9322</td><td>0.8730</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v257</td><td>0.9326</td><td>0.8737</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><h3 id="5-2-CAMUS">5.2 CAMUS</h3><p>选用方向：0 + -</p><table><thead><tr><th>扫描方式</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th></tr></thead><tbody><tr><td>- mooreScan  - fusionLoss   (baseline)</td><td>0.9266</td><td>0.8632</td><td>1.9351</td><td>3.8131</td></tr><tr><td>+ mooreScan  - fusionLoss</td><td>0.9416</td><td>0.8896</td><td>1.3347</td><td>2.8828</td></tr><tr><td>- mooreScan  + fusionLoss</td><td>0.9393</td><td>0.8855</td><td>1.3134</td><td>2.9897</td></tr><tr><td>+ mooreScan  + fusionLoss (ours)</td><td>0.9430</td><td>0.8921</td><td>1.3594</td><td>2.9324</td></tr></tbody></table><table><thead><tr><th>- mooreScan  - fusionLoss (baseline)</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v271</td><td>0.9416</td><td>0.8897</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v273</td><td>0.9412</td><td>0.8890</td><td>/</td><td>/</td><td>/</td></tr><tr><td>V284</td><td>0.9376</td><td>0.8824</td><td>1.4344</td><td>3.1161</td><td>0.9690</td></tr><tr><td>v285</td><td>0.9392</td><td>0.8853</td><td>1.4322</td><td>3.1237</td><td>0.9731</td></tr><tr><td>v11</td><td>0.9123</td><td>0.8459</td><td></td><td></td><td></td></tr><tr><td>v10</td><td>0.9301</td><td>0.8708</td><td></td><td></td><td></td></tr><tr><td>v12</td><td>0.9234</td><td>0.8603</td><td></td><td></td><td></td></tr><tr><td>v13</td><td>0.9265</td><td>0.8650</td><td></td><td></td><td></td></tr><tr><td>v362</td><td>0.9212</td><td>0.8538</td><td></td><td></td><td></td></tr><tr><td>v363</td><td>0.9280</td><td>0.8658</td><td>1.7142</td><td>3.5434</td><td></td></tr><tr><td>v364</td><td>0.9257</td><td>0.8617</td><td>1.7747</td><td>3.6552</td><td></td></tr><tr><td>v371</td><td>0.9345</td><td>0.8772</td><td></td><td></td><td></td></tr><tr><td>v372</td><td>0.9318</td><td>0.8723</td><td></td><td></td><td></td></tr><tr><td><strong>v373</strong></td><td>0.9266</td><td>0.8632</td><td>1.9351</td><td>3.8131</td><td></td></tr></tbody></table><table><thead><tr><th>+ mooreScan  - fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v274</td><td>0.9404</td><td>0.8875</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v275</td><td>0.9410</td><td>0.8885</td><td>/</td><td>/</td><td>/</td></tr><tr><td><strong>v276</strong></td><td>0.9416</td><td>0.8896</td><td>1.3347</td><td>2.8828</td><td>0.9708</td></tr><tr><td>v280</td><td>0.9415</td><td>0.8895</td><td>1.3756</td><td>3.1272</td><td>0.9717</td></tr></tbody></table><table><thead><tr><th>- mooreScan  + fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v277</td><td>0.9428</td><td>0.8918</td><td>/</td><td>/</td><td>/</td></tr><tr><td><strong>v278</strong></td><td>0.9393</td><td>0.8855</td><td>1.3134</td><td>2.9897</td><td>0.9644</td></tr><tr><td>v281</td><td>0.9428</td><td>0.8918</td><td>1.3577</td><td>2.8974</td><td>0.9456</td></tr><tr><td>v283</td><td>0.9402</td><td>0.8871</td><td>1.3599</td><td>2.9843</td><td>0.9688</td></tr></tbody></table><table><thead><tr><th>+ mooreScan  + fusionLoss (ours)</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v233</td><td>0.9394</td><td>0.8859</td><td>1.3565</td><td>2.9882</td><td>0.9674</td></tr><tr><td>v234</td><td>0.9423</td><td>0.8909</td><td>1.3285</td><td>2.8963</td><td>0.9715</td></tr><tr><td>v270</td><td>0.9419</td><td>0.8902</td><td>/</td><td>/</td><td>/</td></tr><tr><td><strong>v268</strong></td><td>0.9430</td><td>0.8921</td><td>1.3594</td><td>2.9324</td><td>0.9732</td></tr><tr><td>v269</td><td>0.9424</td><td>0.8912</td><td>1.3493</td><td>2.9682</td><td>0.9729</td></tr></tbody></table><h3 id="5-3-Echo-Pediatric">5.3 Echo-Pediatric</h3><p>选用方向0 + -</p><table><thead><tr><th>扫描方式</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th></tr></thead><tbody><tr><td>- mooreScan  - fusionLoss   (baseline)</td><td>0.9137</td><td>0.8411</td><td>1.7467</td><td>4.4969</td></tr><tr><td>+ mooreScan  - fusionLoss</td><td>0.9218</td><td>0.8550</td><td>1.6444</td><td>3.9509</td></tr><tr><td>- mooreScan  + fusionLoss</td><td>0.9231</td><td>0.8572</td><td>1.6132</td><td>3.9279</td></tr><tr><td>+ mooreScan  + fusionLoss</td><td>0.9243</td><td>0.8593</td><td>1.5865</td><td>3.9167</td></tr></tbody></table><table><thead><tr><th>- mooreScan  - fusionLoss (baseline)</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v241</td><td>/</td><td>/</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v242</td><td>0.9145</td><td>0.8425</td><td></td><td></td><td></td></tr><tr><td><strong>v245</strong></td><td>0.9137</td><td>0.8411</td><td>1.7467</td><td>4.4969</td><td>0.9267</td></tr><tr><td>v38</td><td>0.9063</td><td>0.8288</td><td></td><td></td><td></td></tr><tr><td>v39</td><td>0.9045</td><td>0.8256</td><td></td><td></td><td></td></tr><tr><td>v42</td><td>0.9039</td><td>0.8246</td><td></td><td></td><td></td></tr><tr><td>v43</td><td>0.9041</td><td>0.8250</td><td></td><td></td><td></td></tr><tr><td>v352</td><td>0.9101</td><td>0.8351</td><td></td><td></td><td></td></tr><tr><td>v353</td><td>0.9004</td><td>0.8188</td><td></td><td></td><td></td></tr><tr><td>v354</td><td>0.9048</td><td>0.8262</td><td>1.7822</td><td>4.4320</td><td></td></tr><tr><td>v355</td><td>0.9052</td><td>0.8268</td><td>1.7902</td><td>4.4417</td><td></td></tr><tr><td>v367</td><td>0.9229</td><td>0.8568</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>+ mooreScan  - fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v235</td><td>0.9138</td><td>0.8413</td><td>1.6069</td><td>3.9439</td><td>0.9303</td></tr><tr><td>v236</td><td>0.9151</td><td>0.8436</td><td>1.5794</td><td>3.9623</td><td>0.9247</td></tr><tr><td><strong>v374</strong></td><td>0.9218</td><td>0.8550</td><td>1.6444</td><td>3.9509</td><td></td></tr></tbody></table><table><thead><tr><th>- mooreScan  + fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v239</td><td>0.9150</td><td>0.8433</td><td>1.5740</td><td>3.8816</td><td>0.9266</td></tr><tr><td>v240</td><td>0.9151</td><td>0.8435</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v243</td><td>0.9148</td><td>0.8430</td><td>1.5646</td><td>3.8466</td><td>0.9229</td></tr><tr><td>v356</td><td>0.9112</td><td>0.8368</td><td>1.6730</td><td>4.2085</td><td></td></tr><tr><td>v375</td><td>0.9241</td><td>0.8589</td><td>1.5877</td><td>3.9464</td><td></td></tr><tr><td>v376</td><td>0.9178</td><td>0.8481</td><td>1.6531</td><td>4.0372</td><td></td></tr><tr><td><strong>v377</strong></td><td>0.9231</td><td>0.8572</td><td>1.6132</td><td>3.9279</td><td></td></tr></tbody></table><table><thead><tr><th>+ mooreScan  + fusionLoss</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v216</td><td>0.9084</td><td>0.8367</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v217</td><td>0.9073</td><td>0.8352</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v201</td><td>0.9165</td><td>0.8458</td><td>1.5507</td><td>3.8580</td><td>0.9250</td></tr><tr><td>v266</td><td>0.9141</td><td>0.8418</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v267</td><td>0.9137</td><td>0.8411</td><td>/</td><td>/</td><td>/</td></tr><tr><td><strong>v368</strong></td><td>0.9243</td><td>0.8593</td><td>1.5865</td><td>3.9167</td><td></td></tr></tbody></table><table><thead><tr><th>- mooreScan  + fusionLossV2</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v260</td><td>0.9160</td><td>0.8450</td><td>1.5611</td><td>3.8918</td><td>0.9167</td></tr><tr><td>v261</td><td>0.9163</td><td>0.8455</td><td>1.5586</td><td>3.8783</td><td>0.9237</td></tr><tr><td>V264</td><td>0.9154</td><td>0.8440</td><td>/</td><td>/</td><td>/</td></tr><tr><td>V265</td><td>0.9162</td><td>0.8454</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><table><thead><tr><th>+ mooreScan  + fusionLossV2</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v258</td><td>0.9161</td><td>0.8451</td><td>/</td><td>/</td><td>/</td></tr><tr><td>v259</td><td>0.9148</td><td>0.8430</td><td>1.5939</td><td>3.9800</td><td>0.9208</td></tr></tbody></table><h2 id="6-对比实验">6. 对比实验</h2><ul><li>不同曲线的扫描</li></ul><p>儿科数据集</p><p>横线</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250512153518940.png" alt="image-20250512153518940"></p><table><thead><tr><th>Scan</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v242</td><td>0.9145</td><td>0.8425</td><td>1.5811</td><td>3.9611</td><td>0.9178</td></tr><tr><td><strong>v245</strong></td><td>0.9137</td><td>0.8411</td><td>1.75</td><td>4.50</td><td></td></tr><tr><td>v355</td><td>0.9052</td><td>0.8268</td><td>1.7902</td><td>4.4417</td><td></td></tr></tbody></table><p>竖线</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250512154129170.png" alt="image-20250512154129170"></p><table><thead><tr><th>Scan</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v288</td><td>0.9149</td><td>0.8432</td><td>1.5771</td><td>3.9424</td><td>0.9224</td></tr><tr><td>v292</td><td>0.9138</td><td>0.8413</td><td>1.6080</td><td>3.9769</td><td>0.9190</td></tr><tr><td><strong>v365</strong></td><td>0.9061</td><td>0.8283</td><td>1.7608</td><td>4.3131</td><td>0.9284</td></tr></tbody></table><p>斜线</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250512153546250.png" alt="image-20250512153546250"></p><table><thead><tr><th>Scan</th><th>dsc</th><th>iou</th><th>assd</th><th>hd95</th><th>sen</th></tr></thead><tbody><tr><td>v290</td><td>0.9149</td><td>0.8431</td><td>1.5956</td><td>3.9276</td><td>0.9250</td></tr><tr><td>v298</td><td>0.9135</td><td>0.8408</td><td>1.6367</td><td>4.1488</td><td>0.9254</td></tr><tr><td><strong>v302</strong></td><td>0.9121</td><td>0.8384</td><td>1.6534</td><td>4.1673</td><td>0.9204</td></tr><tr><td>v303</td><td>0.9145</td><td>0.8425</td><td>1.5952</td><td>3.9662</td><td>0.9183</td></tr></tbody></table><h2 id="7-修改意见">7. 修改意见</h2><p><strong>AE（执行编辑）</strong>：审稿人对本文进行了详细评估，其意见如下。根据审稿人的反馈和我本人对稿件的评估，本文应仔细修改。作者应确保方法细节、实验设置等得到清晰阐明。请针对审稿人的意见提供逐点说明。请注意，最终录用取决于您修改的质量以及审稿人对您修改的完全满意。</p><p><strong>审稿人 #1：</strong></p><p><strong>总结</strong>：该稿件目前形式存在方法缺乏清晰度、实验验证不足以及声称未得到充分证实等显著问题。<br><strong>主要问题：</strong></p><ol><li><strong>方法清晰度和可复现性不足：</strong><ol><li>图 2 模糊不清：图 2(a)、2(b) 和 2© 之间的关系不明确。图 2© 是描绘了两个连续的编码器层，还是 CASS 模块本身的详细示意图？</li><li>缺失架构细节：关键组件未定义。&quot;Stem&quot;模块未描述。此外，未说明解码器中&quot;跳跃连接&quot;是如何实现的（例如，逐元素相加、拼接或任何其他融合方法）。</li><li>CASS/SSM 集成不清晰：图 2© 尤其令人困惑，因为它似乎只显示了扫描操作，而没有明确集成状态空间模型块，而这是基于 Mamba 的架构的基础。</li><li>强烈建议作者修改所有方法图和描述以提高清晰度，并公开其代码以确保可复现性。</li></ol></li><li>论文指出摩尔曲线阶数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mrow><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow></mrow><annotation encoding="application/x-tex">k \in {3, 4, 5, 6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span></span></span></span></span> 是基于特征图大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>×</mo><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i \times W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &quot;自动&quot;选择的。然而，这种选择机制没有明确定义。公式 (5) 和 (6) 描述了曲线的属性，但没有提供用于在不同编码器层级选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的显式映射函数或规则。</li><li><strong>WFL 模块的消融实验和细节不足：</strong><ol><li>缺失超参数：公式 (7) 中损失分量的权重 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, y, z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 从未指定。也缺少关于不同权重分布如何影响分割性能的分析。</li><li>缺失组件消融实验：缺少一个关键的消融研究。作者应消融 WFL 的各个组件（例如，基线 vs. +Jaccard vs. +Dice vs. +Focal）以证明所有三个组件的必要性。</li><li>基线损失函数不明确：对于 M1 实验（无 WFL），论文没有说明使用了哪种损失函数作为替代。</li></ol></li><li><strong>实验对比不完整：</strong><ol><li>缺失扫描策略比较：核心声称是摩尔曲线的优越性。这应该与其他常见的空间填充曲线扫描方法进行基准测试，最著名的是希尔伯特曲线。</li><li>相关工作空白：相关工作部分未能讨论其他引入了替代扫描策略的基于 Mamba 的模型，这将是最相关的基线比较。</li><li>统计显著性：许多报告的性能提升是微小的。作者必须进行统计显著性检验（例如，报告配对 t 检验的 p 值），特别是对于&quot;我们的方法&quot;与&quot;前三名 SOTA 方法&quot;以及&quot;我们的方法&quot;与 M1/M2 的关键比较，以确认改进具有统计相关性。</li></ol></li><li><strong>效率声称无充分依据</strong>：作者声称&quot;模型效率和实时处理&quot;，但仅报告了参数量。这是不够的。需要进行计算效率的综合比较，包括 GFLOPs、推理时间和训练时间，并与 SOTA 方法一起在表格中呈现。</li><li><strong>可视化有限</strong>：提供的可视化（图 4, 6）仅显示了消融实验结果。为了证实优越性的声称，论文必须包括所提方法与对比 SOTA 方法在所有三个数据集的具有挑战性的案例上的定性视觉比较。建议使用高对比度的轮廓线。</li></ol><p><strong>次要问题：</strong></p><ol><li>消融描述中的矛盾：第 4.4 节中存在明显矛盾。文本描述 M2 为&quot;在 M1 中保留 WFL 模块，同时移除 CASS…&quot;。然而，表 3 显示 M1 具有 CASS 而没有 WFL。这一定是文本中的笔误，需要更正。</li><li>注意力可视化模糊：在图 5 中，&quot;注意力机制&quot;热图的来源模糊不清。作者应说明此可视化源自网络的哪个部分（例如，哪一层，哪种注意力）。此外，应叠加真实分割掩码作为 ROI 的参考。</li><li>缺失实现细节：<ol><li>张量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>×</mo><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C \times H \times W \times D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 的输入维度 D 在数据集预处理或方法部分从未指定。</li><li>图 2© 的逻辑非常令人困惑。它在视觉上暗示两个&quot;有噪声的&quot;特征图相结合产生了一个干净的 ROI，这是不直观的，需要明确的解释。</li></ol></li></ol><p><strong>审稿人 #2：</strong></p><p>本文提出了 EchoMamba，一种基于摩尔曲线引导的三维状态空间模型，用于超声心动图视频中的左心室分割，具有显著的创新性，但也存在需要修改的关键空白。</p><p><strong>优点：</strong></p><ol><li>曲线自适应选择性扫描模块将摩尔曲线与 Mamba 集成，有效解决了传统线性扫描的端-始不连续性问题，与心动周期的时空周期性相吻合。多阶曲线映射平衡了全局解剖拓扑和局部边缘特征，缓解了超声图像各向异性分辨率的问题。</li><li>加权融合损失结合了 Jaccard、Dice 和 Focal 损失，针对超声心动图中类别不平衡和边界模糊的关键痛点。</li><li>在三个数据集上的实验表明，相较于 SOTA 方法，在 Dice、IoU 和边界指标上表现更优，同时 24.1M 的参数量保持了轻量级潜力，利于临床部署。</li></ol><p><strong>主要关切：</strong></p><ol><li><strong>方法清晰度与可复现性</strong><br>WFL 的权重仅在数学上定义但未说明理由：是凭经验选择的吗？没有消融或对比实验验证最优值，削弱了损失函数的严谨性。<br>摩尔曲线生成（例如，坐标转换到 [0, L-1]×[0, L-1]）和曲线阶数选择（3-6）缺乏原理说明。CASS 与 Mamba 状态更新之间的交互仍不清楚。</li><li><strong>实验设计缺陷</strong><br>表 2 中，参数量错误地将&quot;我们的方法&quot;加粗，尽管 24.1M 并非最小（例如，UKAN3D：9.1M，SegFormer3D：7.5M）。表 3 也对非最优数据加粗（例如，CAMUS 的 ASSD 中&quot;我们的方法&quot;是 1.36，而 M2 的是 1.31），误导读者——必须更正格式。<br>60 个训练周期的充分性未得到验证：没有提供收敛曲线或分析来确认模型达到了稳定性能，可能危及结果的可靠性。</li><li><strong>其他</strong><br>注意力热图模糊；隐藏状态演化缺乏解剖结构映射，降低了临床可信度。</li></ol><p><strong>修改建议：</strong></p><ol><li>更正表 2 和表 3 中的加粗，严格与最优性能对齐：仅对每个指标在所有对比方法中排名第一的值加粗（例如，在表 2 中，移除&quot;我们的方法&quot;在&quot;参数量&quot;下的加粗，因为它不是最小的；在表 3 中，调整如 CAMUS ASSD 等指标的加粗以突出表现最佳的条目）。</li><li>验证 60 个训练周期的充分性：要么提供收敛曲线（例如，训练/验证损失、Dice 系数随周期的变化趋势）以确认模型在 60 个周期达到了稳定性能，要么进行更多周期（例如 200 或更多）的补充实验以排除不完全收敛对结果的影响。</li><li>将扫描策略消融研究（比较摩尔、扫描、垂直和对角线扫描）扩展到所有三个数据集，而不仅限于 EchoNet-Peds。这将验证摩尔曲线扫描在不同数据分布下的普适性。</li><li>提高可视化图的清晰度（例如，图 4, 5, 6）：增加图像分辨率以确保分割轮廓、注意力热图区域以及扫描策略之间的差异等细节可辨。</li></ol><p><strong>审稿人 #3：</strong></p><p>该稿件提出了一种基于摩尔空间填充曲线引导的状态空间方法，用于超声心动图视频中的左心室分割。该方法结合了曲线自适应选择性扫描（闭环摩尔扫描）、跨编码器尺度的多阶映射策略以及加权损失（Jaccard + Dice + Focal）。在 EchoNet-Dynamic、CAMUS 和 EchoNet-Peds 上的实验报告了有竞争力的数值，并显示摩尔扫描优于几种简单替代方案。该方向很有前景，但在方法规范、基线的公平性、临床相关性、泛化性、效率报告和可复现性方面存在重大空白。我建议<strong>重大修改</strong>。此外，请考虑重命名该方法：&quot;EchoMamba&quot;这一名称已在其他已发表工作中出现，可能会在索引和引用中引起混淆。</p><ol><li>基线套件遗漏了几个 2024-2025 年强大且广泛采用的比较器。除了已引用的 CNN/Transformer/扩散和 SAM 衍生的基线外，请包括：(i) 具有可靠时空记忆提示的 MemSAM；(ii) MedSAM 或类似的高容量基础模型作为通用基线；(iii) 近期基于 Mamba/SSM 的医学分割模型（例如，SegMamba 变体）。匹配训练预算和硬件，并报告精度-速度-内存的权衡。没有这些，增量价值难以判断。</li><li>论文解释了空间摩尔映射，但没有说明用于形成 SSM 输入的时空交织方式：特征是逐帧扫描然后跨时间拼接、跨帧交织，还是以滑动窗口方式打包；循环状态如何跨帧传递；以及如何处理重置/填充；还有训练和推理中使用的窗口长度。</li><li>Jaccard、Dice 和 Focal 分量的权重，以及 Focal 参数（α, γ），未按数据集报告，也未说明其选择理由。</li><li>声称优于 SAM 风格和扩散基线的说法需要更强的公平性文档。对于每个比较器，请指定提示协议（点/框，记忆长度，关键帧策略）、微调程度、数据增强和计算预算对等性。对于非提示模型（例如 UKAN3D 或 Transformer 基线），记录推荐的超参数、早停标准和模型选择标准。没有这些，比较可能有利于所提出的方法。</li><li>核心假设——闭环扫描改善了 ES↔ED 边界稳定性和周期性一致性——主要得到通用分割指标和定性可视化的支持。请添加相位条件指标（例如，按心脏相位分箱的 Dice/HD95）和临床有意义的结果，如 EDV/ESV/EF 误差和相关性，以证明切实的临床益处。</li><li>包括跨数据集/设备迁移（例如，在 EchoNet-Dynamic 上训练 → 在 CAMUS 上测试），按供应商/帧率分层，并评估非周期性模式（例如，心律失常）或提供代理分析。报告关键增益的置信区间和统计显著性。讨论部分承认对非周期性运动的适应性有限——请量化这一局限性。</li><li>报告吞吐量（fps）、每序列延迟、内存使用情况和 FLOPs/MACs，最好有设备上的测量结果（例如，笔记本/移动 GPU）。在相同硬件和数值精度下，绘制与代表性 Transformer/Mamba/SAM 基线的精度-速度边界图。这对于旨在实时或近实时使用的视频分割系统至关重要。</li><li>定义所有常数（例如，公式中的 ε），并阐明多阶映射中的舍入/边界规则。关于摩尔路径是&quot;可学习的&quot;的陈述是模糊的，因为摩尔曲线是确定性的：请澄清实际学习的是什么（例如，阶数选择、门控或参数化遍历）。记录完整的预处理/后处理（裁剪、归一化、时间采样）、确切的数据分割和训练计划。发布代码/配置和训练好的权重以便验证。</li><li>加强实验设计以反映当前文献并相应调整框架：(a) 添加具有时序记忆提示的 MemSAM；(b) 包括 MedSAM（如果可行，还包括嵌入式/高效变体）以说明临床可部署性；© 添加 SegMamba 或密切相关的 SSM 基线作为代表。一些医学领域模型，如 VM-UNet / Mamba-UNet/ LoG-VMamba/ LKM-UNet/H-vmunet, nnunet。</li></ol><p><strong>总结</strong></p><table><thead><tr><th style="text-align:left">主要方向</th><th style="text-align:left">核心修改意见（总结）</th><th style="text-align:left">建议的解决措施</th></tr></thead><tbody><tr><td style="text-align:left"><strong>方法清晰度与可复现性</strong></td><td style="text-align:left"><strong>审稿人1, 2, 3均指出：</strong> 方法描述模糊，关键细节缺失（如Stem模块、跳跃连接方式、CASS与Mamba的集成、摩尔曲线选择机制、WFL超参数、时空处理逻辑），导致难以理解和复现。</td><td style="text-align:left">1. <strong>彻底重写方法章节</strong>：用更清晰的文字和重新绘制的图表（如Fig.2）详细解释每个模块。 2. <strong>补充所有缺失细节</strong>：明确说明架构设计、超参数值（如WFL的x,y,z）、摩尔曲线阶数k的选择规则、输入张量维度D等。 3. <strong>公开代码和模型</strong>：在修订稿中承诺并在录用后立即公开代码和配置，这是最有力的回应。</td></tr><tr><td style="text-align:left"><strong>实验充分性与公平性</strong></td><td style="text-align:left"><strong>审稿人1, 3均指出：</strong> - 基线对比不足，缺少与近期SOTA方法（如MemSAM, MedSAM, SegMamba变体）的对比。 - 扫描策略对比不完整（缺少与Hilbert曲线等的比较）。 - 效率声称不完整（仅参数量，缺FLOPs、推理时间等）。</td><td style="text-align:left">1. <strong>增补sota实验</strong>：加入审稿人3建议的多个最新基线模型（如MemSAM, Mamba-UNet，LKM-UNet，SegMamba），并在相同条件下进行公平比较。 2. <strong>扩展对比实验</strong>：将摩尔曲线与希尔伯特曲线等更多扫描策略进行对比，并在所有三个数据集上进行验证。 3. <strong>补充效率数据</strong>：在结果表格中增加GFLOPs、推理速度（FPS）和内存消耗等指标，全面评估效率。</td></tr><tr><td style="text-align:left"><strong>论证严谨性与统计支持</strong></td><td style="text-align:left"><strong>审稿人1, 2, 3均指出：</strong> - 性能提升的统计显著性未验证。 - WFL等组件的必要性未通过充分的消融实验证明。 - 训练周期（60 epochs）是否足够未验证。</td><td style="text-align:left">1. <strong>进行统计检验</strong>：对关键对比结果（如vs. SOTA, vs. M1/M2）进行统计显著性检验（如p值），并在文中报告。 2. <strong>深化消融研究</strong>：增加对WFL各损失分量的逐项消融，证明其组合的必要性。 3. <strong>证明训练充分性</strong>：在补充材料中提供训练/验证集的损失和Dice系数收敛曲线，证明60 epochs已足够。</td></tr><tr><td style="text-align:left"><strong>结果可视化与临床相关性</strong></td><td style="text-align:left"><strong>审稿人1, 2, 3均指出：</strong> - 定性对比不足，缺少与SOTA方法的可视化效果图。 - 现有可视化（如注意力热图）模糊，缺乏解释。 - 缺乏临床指标（如EF评估误差）来证明实际价值。</td><td style="text-align:left">1. <strong>增加定性对比</strong>：提供所提方法与主要SOTA基线在挑战性案例上的分割效果对比图，用高对比度轮廓清晰展示优势。 2. <strong>优化并解释可视化</strong>：提高图片分辨率，清晰说明注意力热图源自网络的哪个部分，并叠加GT轮廓作为参考。 3. <strong>补充临床指标</strong>：计算并报告左心室容积（EDV, ESV）和射血分数（EF）的误差与相关性，强化学术价值。</td></tr><tr><td style="text-align:left"><strong>格式、表述与细节纠正</strong></td><td style="text-align:left"><strong>审稿人1, 2, 3均指出：</strong> - 表格中的加粗格式错误（对非最优结果加粗）。 - 文本中存在矛盾描述（如M1/M2的配置）。 - 方法名称“EchoMamba”可能已被占用。</td><td style="text-align:left">1. <strong>彻底检查并修正</strong>：仔细检查所有表格，确保只对性能最优的指标加粗。 2. <strong>统一并更正文本</strong>：修正关于M1/M2描述的矛盾之处，确保全文表述一致。 3. <strong>考虑重命名</strong>：认真考虑审稿人3的建议，为方法寻找一个更具独特性的新名称，以避免混淆。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>医学影像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>语义分割</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPapers</title>
    <link href="/2024/09/06/readpapers/"/>
    <url>/2024/09/06/readpapers/</url>
    
    <content type="html"><![CDATA[<h2 id="SegMamba">SegMamba</h2><p>通道注意力的本质是什么，mamba采用“并行扫描算法”而非“卷积”来进行模型的循环计算，其是否也考虑了通道维度上的内容，是否存在和原始的CNN一样对所有通道上的内容一视同仁的问题</p><p><strong>摘要</strong></p><p>摘要。Transformer 架构在建模全局关系方面表现出色。然而，它在处理高维医学图像时带来了巨大的计算挑战。Mamba 作为一种状态空间模型 (SSM)，最近成为一种用于对序列数据中的长距离依赖关系进行建模的著名方法，凭借其出色的内存效率和计算速度在自然语言处理领域表现出色。受其成功的启发，我们推出了 SegMamba，一种新颖的 3D 医学图像分割 Mamba 模型，旨在有效捕获每个尺度的全体积特征内的长距离依赖关系。与基于 Transformer 的方法相比，我们的 SegMamba 在整个体积特征建模方面表现出色，即使体积特征的分辨率为 64 × 64 × 64（序列长度约为 260k），也能保持卓越的处理速度。在三个数据集上进行的综合实验证明了我们的 SegMamba 的有效性和效率。此外，为了促进 3D 结直肠癌 (CRC) 分割研究，我们贡献了一个新的大规模数据集（名为 CRC-500）。SegMamba 的代码和有关 CRC-500 数据集的信息可在以下位置找到：<a href="https://github.com/gexing/SegMamba">https://github.com/gexing/SegMamba</a></p><p><strong>模型</strong></p><p>SegMamba 主要由三个组件组成：1）具有多个三向空间 Mamba 块的 3D 特征编码器，用于对不同尺度的全局信息进行建模；2）基于卷积层的 3D 解码器，用于预测分割结果；3）跳跃连接，用于将全局多尺度特征连接到解码器以实现特征重用。图 2 说明了所提出的 SegMamba 的概览。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240906134037404.png" alt="Fig. 2. The overview of the proposed SegMamba."></p><p>对于 3D 医学图像分割而言，全局特征和多尺度特征建模至关重要。Transformer 架构可以提取全局信息，但在处理过长的特征序列时会产生很大的计算负担。为了减少序列长度，基于 Transformer 架构的方法（例如 UNETR）直接将分辨率为 D × H × W 的 3D 输入下采样为 D 16 × H 16 × W 16。然而，这种方法限制了编码多尺度特征的能力，而多尺度特征对于通过解码器预测分割结果至关重要。为了克服这个限制，我们设计了一个 TSMamba 模块，以实现多尺度和全局特征建模，同时在训练和推理期间保持高效率。</p><p>编码器由一个 stem 层和多个 TSMamba 块组成。stem 层提取第一个尺度特征 z0 ∈ R 48× D 2 × H 2 × W 2。 然后，z0 被输入到每个 TSMamba 块和相应的下采样层。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240912152351742.png" alt="Fig. 3. (a) The gated spatial convolution. (b) The tri-orientated Mamba."></p><p>门控空间卷积 (GSC) Mamba 层通过将 3D 特征展平为 1D 序列来对特征依赖性进行建模。因此，为了在 Mamba 层之前提取空间关系，我们设计了一个门控空间卷积 (GSC) 模块。如图 3 (a) 所示，输入的 3D 特征被送入两个卷积块（一个卷积块包含一个范数、一个卷积和一个非线性层），卷积核大小分别为 3×3×3 和 1×1×1。<br>然后将这两个特征逐像素相乘，以类似于门机制 [13] 的信息传输进行控制。最后，使用卷积块进一步融合特征，同时利用残差连接重用输入特征。</p><p>三向 Mamba (ToM) 在 TSMamba 模块中，为了有效地对高维特征的全局信息进行建模，我们设计了一个三向 Mamba 模块，从三个方向计算特征依赖关系。如图 3 (b) 所示，我们将 3D 输入特征展平为三个序列，以执行相应的特征交互并获得融合的 3D 特征。</p><p><strong>结论</strong></p><p>提出了第一种基于 Mamba 的通用 3D 医学图像分割方法，称为 SegMamba。我们设计了一个三向 Mamba (ToM) 模块来增强 3D 特征的顺序建模。然后，为了有效地对空间特征进行建模，我们进一步设计了一个门控空间卷积 (GSC) 模块，以在每个 ToM 模块之前增强空间维度中的特征表示。</p><p><strong>复现实验</strong></p><p>经过一周的安装和配置环境，终于把这个代码给跑了起来，在这里再骂一遍python狗屎的各种版本。超！在看复现数据之前，先了解相关的评价指标</p><p><strong>Dice系数</strong></p><p>Dice系数是一种集合相似度度量函数，通常用于计算两个样本的相似度，取值范围在[0,1]</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>i</mi><mi>c</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mn>2</mn><mi mathvariant="normal">∣</mi><mi>X</mi><mo>∩</mo><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Dice =  \frac{2|X\cap Y|}{|X| + |Y|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ce</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中 |X∩Y| 是X和Y之间的交集，|X|和|Y|分表表示X和Y的元素的个数，其中，分子的系数为2，是因为分母存在重复计算X和Y之间的共同元素的原因</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>I</mi><mi>o</mi><mi>U</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mo>∩</mo><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mo>∪</mo><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">MIoU = \frac{|X\cap Y|}{|X \cup Y|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>MIoU之前已经了解过了，对于二分类的任务来说，二者思想都是<code>交集/并集</code>，但<code>dice</code>并不是在分母上减去交集，而是<code>将交集在分子上算了两次</code>。</p><p>对于多分类来说，<code>Dice</code>是将预测结果转为了<code>多通道</code>，而<code>MIoU</code>只在<code>一个通道</code>上计算。</p><p><strong>Dice Loss</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>2</mn><mi mathvariant="normal">∣</mi><mi>X</mi><mo>∩</mo><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">d = 1 - \frac{2|X\cap Y|}{|X| + |Y|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>这种<a href="https://so.csdn.net/so/search?q=%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">损失函数</a>被称为 **Soft Dice Loss，**因为我们直接使用预测概率而不是使用阈值或将它们转换为二进制mask。Soft Dice Loss 将每个类别分开考虑，然后平均得到最后结果</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240913160120781.png" alt="image-20240913160120781"></p><div class = "note note-danger">注意</div><p>(1)训练误差曲线非常混乱，很难看出关于收敛的信息。尽管可以检查在验证集上的误差来避开此问题。</p><p>(2)Dice Loss比较适用于样本极度不均的情况，一般的情况下，使用 Dice Loss 会对反向传播造成不利的影响，容易使训练变得不稳定。</p><p>所以在一般情况下，还是使用交叉熵损失函数。</p><p><strong>豪斯多夫距离（Hausdorff distance）</strong></p><p>一般使用dice衡量区域的重合程度，使用95%的HD（ Hausdorff Distance）去<span class="label label-danger">衡量边界</span>的重合程度，之所以取95%，是因为要滤去5%的离群点。</p><div class = "note note-success">Hausdorff_95 (95% HD) 原理</div><p><strong>Hausdorff distance</strong>是描述两组点集之间相似程度的一种量度，它是两个点集之间距离的一种定义形式：假设有两组集合A={a1,…,ap},B={b1,…,bq},则这两个点集合之间的Hausdorff distance定义为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(A,B)=max(h(A,B),h(B,A))             (1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">))</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>其中,</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mtext>‖</mtext><mi>a</mi><mo>−</mo><mi>b</mi><mtext>‖</mtext></mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(A,B)=maxa∈A{minb∈B‖a−b‖} (2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal">minb</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">‖</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mord">‖</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mtext>‖</mtext><mi>b</mi><mo>−</mo><mi>a</mi><mtext>‖</mtext></mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(A,B)=maxb∈B{mina∈A‖b−a‖} (3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathnormal">mina</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mord">‖</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span><span class="mord">‖</span></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></p><p>‖·‖是点集A和B点集间的距离范式。(如:L2或Euclidean距离).</p><p><img src="https://pic2.zhimg.com/v2-0f431a4c9e8cf45575d953e2b72fec49_r.jpg" alt="image-20240913160120781"></p><p><strong>数据集</strong></p><p>BraTS2023 数据集 共包含 1,251 个 3D 脑部 MRI 体积。每个体积包括四种模态（即 T1、T1Gd、T2、T2-FLAIR）和三个分割目标（TC：肿瘤核心、WT：整个肿瘤、ET：增强肿瘤）</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240912163301804.png" alt="论文给出的实验数据"></p><p>这里复现使用的环境为pytroch 2.01,causal-conv1d 1.0.0 , mamba 1.2.0.post1 (site-page里面mamba-ssm换成了mamba 1.0.1)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">用官方项目里的mamba_ssm替换安装在conda环境里的mamba_ssm</span><br>cp -rf mamba_1.0.1/mamba_ssm/ /home/gx/anaconda3/envs/cn_slvs/lib/python3.8/site-packages/<br></code></pre></td></tr></table></figure><p>下表就是复现实验的部分<span class = "label label-success">Dice</span>数据：</p><table><thead><tr><th style="text-align:center">Epoch</th><th style="text-align:center">tc</th><th style="text-align:center">wt</th><th style="text-align:center">et</th><th style="text-align:center">avg</th></tr></thead><tbody><tr><td style="text-align:center">19</td><td style="text-align:center">0.8111</td><td style="text-align:center">0.8987</td><td style="text-align:center">0.7715</td><td style="text-align:center">0.8270</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">0.8550</td><td style="text-align:center">0.9313</td><td style="text-align:center">0.8168</td><td style="text-align:center">0.8676</td></tr><tr><td style="text-align:center">35</td><td style="text-align:center">0.8839</td><td style="text-align:center">0.9208</td><td style="text-align:center">0.8588</td><td style="text-align:center">0.8878</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">119</td><td style="text-align:center">0.9089</td><td style="text-align:center">0.9292</td><td style="text-align:center">0.8559</td><td style="text-align:center">0.8980</td></tr></tbody></table><p>使用<strong>TensorBoard</strong>进行数据可视化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tensorboard --logdir=&lt;directory_name&gt;<br><span class="hljs-comment"># 将 directory_name 标记替换为保存数据的目录。 默认是“logs”</span><br><span class="hljs-comment"># 然后用浏览器打开http://localhost:6006/查看</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240917131419158.png" alt="mean_dice"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240917131533080.png" alt="tc"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240917131712635.png" alt="wt"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240917131751752.png" alt="et"></p><h2 id="SwinUMamba">SwinUMamba</h2><p><strong>摘要</strong></p><p>摘要：准确的医学图像分割需要融合从局部特征到全局依赖的多尺度信息。然而，现有的方法对远程全局信息建模是具有挑战性的，其中卷积神经网络（CNN）受到其局部感受野的限制，视觉变换器（ViTs）受到其注意力机制的高二次复杂性的影响。最近，基于Mamba的模型以其在长序列建模方面的出色能力而受到广泛关注。一些研究表明，这些模型在各种任务中的性能优于流行的视觉模型，具有更高的精度，更低的内存消耗和更少的计算负担。然而，现有的基于Mamba的模型大多是从头开始训练，并且没有探索预训练的力量。本文介绍了一种新的Mambabased模型Swin-Umamba，它是专门为医学图像分割任务设计的，利用基于ImageNet的预训练的优势。我们的实验结果揭示了基于ImageNet的训练在提高Mamba性能方面的重要作用-SwinUAmba与CNN、ViT和最新的基于Mamba的模型相比，表现出上级性能。值得注意的是，在AbdomenMRI、Encoscopy和Microscopy数据集上，Swin-UAmamba比其最接近的对手U-Mamba_Enc的平均得分高出2.72%。Swin-UAmamba的代码和模型可在www.example.com上公开获得<a href="https://github.com/JiarunLiu/Swin-UMamba%E3%80%82">https://github.com/JiarunLiu/Swin-UMamba。</a></p><p><strong>引言</strong></p><p>在本文中，我们提出了一个基于Mamba的网络Swin-UMamba，用于2D医学图像分割。Swin-UMamba使用一个通用的编码器，将预训练的视觉模型的强大功能与一个精心设计的解码器集成在一起，用于医学图像分割任务。此外，我们提出了一个变体结构SwinUMamba†，带有一个基于Mamba的解码器，为高效应用提供更少的参数和更低的FLOP。我们的贡献可以总结如下：</p><p><em>模型</em></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240920152738522.png" alt="Fig. 1. The overall architecture of Swin-UMamba. Swin-UMamba can leverage the power of vision foundation models by loading the weights of pretrained models. Each block within the blue box was initialized with the ImageNet pretrained weights."></p><p>Swin-Umamba的三个核心部分分别是：1）数据集（即ImageNet），用于提取不同尺度的特征; 2）解码器，具有多个上采样块，用于预测分割结果; 3）跳过连接，用于弥合低级细节和高级语义之间的差距。我们将在下面的章节中介绍Swin-Umamba的详细结构。</p><p><em>VSS块</em></p><p>基于[24]的见解，我们将视觉状态空间（VSS）块作为Swin-UMAMBA中的基本单元。VSS块通过采用2D选择性扫描（SS 2D）来解决与2D图像数据相关的挑战。</p><p>Swin-Umamba的编码器可以分为5个阶段。第一阶段是茎阶段。它包含一个卷积层，用于2×下采样，具有7×7内核，填充大小为3，Swin-Umamba的第一阶段与VMamba不同，因为我们更喜欢一个逐渐向下的过程，采样过程，每个阶段进行2×下采样。该策略旨在保留低级别细节，这对医学图像分割很重要[8，32]。第二阶段使用2 × 2补丁大小的补丁嵌入层，将特征分辨率保持在原始图像的1/ 4×，这与VMamba中的嵌入特征相同。后续阶段遵循VMamba-Tiny的设计，其中每个阶段由用于2×下采样的补丁合并层和用于高级特征提取的多个VSS块组成。与ViT不同，由于VSS块的因果性质，我们没有采用Swin-Umamba中的位置嵌入[24]。</p><p><em>模型结构</em></p><p>阶段2到阶段5的VSS块的数量分别为{2，2，9，2}。每个阶段之后的特征维度相对于阶段二次增加，导致D = {48，96，192，384，768}。我们使用来自VMamba-Tiny的ImageNet预训练权重初始化VSS块和补丁合并层，如图1所示。值得注意的是，由于片大小和输入通道的差异，片嵌入块没有用预先训练的权重初始化。</p><p>我们遵循常用的U形结构，使用密集的跳跃连接来构建Swin-UAmamba。U-Net及其变体在医学图像分割任务中表现出了显着的效率。该架构利用跳跃连接来恢复低级别细节，并采用编码器-解码器结构来提取高级信息。为了增强U-Net中的原生上采样块，我们引入了两个修改：1）具有剩余连接的额外卷积块以处理跳过连接特征，以及2）每个尺度的额外分割头用于深度监督[33]。</p><p><em>SwinUMamba†</em></p><p>为了进一步探索Mamba在医学语义分割中的潜力，我们提出了一种基于Mamba解码器的Swin-Umamba变体，即SwinUMamba†。我们将证明SwinUMamba†可以获得与Swin-Umamba相比具有竞争力的结果，同时使用更少的网络参数和更低的计算负担，Swin-Umamba中源自输入图像和2×下采样特征的跳过连接被删除，因为没有对应于它们的解码块。此外，在1×、1/ 4×、1/ 8×和1/ 16×分辨率下应用了深度监控，并结合了额外的分割头（即，将高维特征映射到K的1 × 1卷积）。结合所有这些修改，网络参数的数量从60 M减少到28 M，在AbdomenMRI数据集上，FLOP从68.0G减少到18.9G。关于网络参数和FLOP数量的进一步统计数据见表1、表2和表3。SwinUMamba†的结构见图2。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240920154002183.png" alt="Fig. 2. The overall architecture of Swin-UMamba†."></p><p><strong>结论</strong></p><p>本研究旨在揭示基于ImageNet的预训练对Mambabased模型在二维医学图像分割中的影响。我们提出了一种新的Mambabased模型Swin-UAmamba及其变体SwinUMamba†，两者都能够利用预训练模型的分割任务的能力。我们在各种医学图像分割数据集上的实验表明，基于ImageNet的预训练对基于Mamba的模型有几个优点，包括上级分割精度、稳定的收敛性、过拟合问题的缓解、数据效率和较低的计算资源消耗。我们相信，我们的研究结果突出了预训练在增强基于Mamba的模型在视觉任务中的性能和效率方面的重要性。</p><h2 id="Mean-teachers-model">Mean teachers  model</h2><blockquote><p>Tarvainen A, Valpola H. Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results[J]. Advances in neural information processing systems, 2017, 30.</p></blockquote><p>该算法中教师模型不同学生模型一样，并不是每个step都进行权重更新，而是将学生模型连续训练若干step后产生的权重平均值作为更新权重。教师模型使用学生模型的EMA权重，而不是与学生模型共享权重。论文中表示平均模型权重往往会产生一个比直接使用最终权重更精确的模型。它可以在每一个step完成后即刻聚合之前学习到的所有信息，而不仅仅在每一个epoch。此外，由于EMA提高了所有层的输出质量，而不仅仅是最后一层的输出，因此模型能够更好地表征中层乃至高层语义信息。这些方面造就了该模型相对于Temporal ensemble的两个优势。首先，更准确的标签使学生和教师模型之间发生更快的反馈循环，从而产生更好的精度。其次，这种方法适用于大型数据集和在线学习。</p><ol><li>对数据进行两种不同的加噪。</li><li>将不同噪声增强后的两幅图像分别输入到学生模型的和教师模型。</li><li>对输出使用softmax激活，计算学生模型输出与教师模型输出的一致性损失函数， 如果原图像存在label，则还与label计算交叉熵信息损失。</li><li>用梯度下降法更新学生模型的权重，教师模型的权重用学生权重的指数移动平均法（EMA）更新（一部分权重来自历史的教师模型权重，另一部分来自于当前的学生模型的权重）：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241126163522672.png" alt="image-20241126163522672"></p><p><strong>模型缺点</strong>：</p><ul><li>教师模型的选择对模型性能至关重要。选择一个不合适的教师模型可能会导致性能下降。因此，需要进行一些实验来确定最佳的教师模型。</li><li>Mean Teacher 模型仍然需要一些有标签的数据来进行监督训练，尤其是在初期阶段。这意味着它不适用于完全无监督的情况。</li><li>Mean Teacher 假设有标签和无标签的数据是从相同的数据分布中生成的。如果这个假设不成立，模型性能可能会受到影响。</li><li>Mean Teacher 模型对数据中的噪声和异常值比较敏感。这可能导致模型在存在异常数据的情况下性能下降。</li></ul><h2 id="ABD半监督医学图像分割">ABD半监督医学图像分割</h2><blockquote><p>Chi H, Pang J, Zhang B, et al. Adaptive Bidirectional Displacement for Semi-Supervised Medical Image Segmentation[C]//Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2024: 4070-4080.</p></blockquote><div class = "note note-info">论文标题<ul>    <div>Adaptive Bidirectional Displacement for Semi-Supervised Medical Image Segmentation</div></ul><ul>    <div>自适应双向位移半监督医学图像分割</div></ul>    代码链接：<ul>    <div>https://github.com/chyupc/ABD</div></ul></div><p><strong>摘要</strong></p><p>本文提出了一种自适应双向置换（ABD）方法，用于解决半监督医学图像分割（SSMIS）中的一致性学习挑战。该方法通过设计基于可靠预测置信度的双向补丁置换，生成新的样本，有效抑制了不可控区域，同时保留了输入扰动的影响。此外，为了增强模型对潜在不可控内容的学习能力，提出了针对标记图像的逆置信度双向置换操作，生成了包含更多不可靠信息的样本，以促进模型学习。实验表明，ABD方法在半监督医学图像分割任务中取得了新的最优性能，显著提升了不同基线方法的表现。</p><p><em>本文贡献：</em></p><p>作者设计了基于可靠预测置信度的双向补丁置换操作。这一创新点在于，它利用了模型对未标记数据的预测结果，根据置信度将图像划分为可靠和不可靠区域，并通过置换这些区域的补丁来生成新的训练样本。这种方法有效地抑制了不可控区域的影响，同时保留了输入扰动对模型训练的积极作用。</p><p><strong>逆置信度置换策略：</strong> 针对标记数据，作者提出了逆置信度双向置换操作。这一策略通过在高置信度区域内选择相对不可靠的补丁，在低置信度区域内选择相对可靠的补丁进行置换，生成了包含更多不可靠信息的样本。这一创新点有助于模型学习如何更好地处理潜在的不可控内容，提高了模型的泛化能力。</p><p>**实验验证与性能提升：**作者在多个医学图像分割数据集上进行了实验验证，结果表明ABD方法显著提升了半监督医学图像分割的性能。通过与其他先进方法进行比较，ABD方法展现出了优越的性能表现，验证了其在实际应用中的有效性。</p><p>**消融实验与组件重要性分析：**为了深入探究ABD方法中各个组件的重要性，作者们进行了消融实验。通过移除基于可靠预测置信度的双向补丁置换和逆置信度双向置换操作，并观察模型性能的变化，作者们发现这两个组件都对ABD方法的性能提升起到了关键作用。这一分析进一步验证了ABD方法的创新性和有效性。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241126172507003.png" alt="image-20241126172507003"></p><p><strong>自适应双向置换(ABD)方法</strong></p><p>为了应对半监督医学图像分割中的一致性学习挑战，研究者们提出了一种创新的自适应双向置换（ABD）方法。该方法的核心在于通过设计双向置换操作，生成多样化的训练样本，从而提高模型的一致性学习能力和性能。</p><p>在ABD方法中，首先针对未标记数据设计了基于可靠预测置信度的双向补丁置换。具体而言，对于每个未标记的图像，模型会先对其进行预测，并根据预测结果的置信度将图像划分为可靠区域和不可靠区域。随后，在可靠区域内选择具有高置信度的补丁，并在不可靠区域内选择具有低置信度的补丁进行置换。这种双向置换操作有助于抑制不可控区域的影响，同时保留输入扰动对模型训练的积极作用。</p><p><strong>逆置信度双向置换操作</strong></p><p>此外，为了进一步增强模型对潜在不可控内容的学习能力，研究者们还提出了针对标记图像的逆置信度双向置换操作。对于每个标记图像，模型同样会先对其进行预测，并根据预测结果的置信度将图像划分为高置信度区域和低置信度区域。然后，在高置信度区域内选择具有低置信度的补丁（即相对不可靠的补丁），在低置信度区域内选择具有高置信度的补丁（即相对可靠的补丁）进行置换。这种逆置信度双向置换操作能够生成包含更多不可靠信息的样本，从而促使模型学习如何更好地处理这些潜在的不可控内容。</p><p>通过这两种置换操作，ABD方法能够生成多样化的训练样本，这些样本不仅包含了原始的图像信息，还引入了额外的扰动和不确定性。这些扰动和不确定性有助于模型在训练过程中学习到更加鲁棒和泛化的特征表示，从而提高其在一致性学习任务中的性能。</p><h2 id="QuadMamba">QuadMamba</h2><blockquote><p>Xie F, Zhang W, Wang Z, et al. QuadMamba: Learning Quadtree-based Selective Scan for Visual State Space Model[J]. arXiv preprint arXiv:2410.06806, 2024.</p></blockquote><h2 id="MemSAM">MemSAM</h2><blockquote><p>Deng X, Wu H, Zeng R, et al. MemSAM: Taming Segment Anything Model for Echocardiography Video Segmentation[C]//Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2024: 9622-9631.</p></blockquote><p><strong>引言</strong></p><p>根据世界卫生组织（WHO）的统计，心血管疾病是全球死亡的主要原因。超声心动图是评估心血管功能的重要而独特的工具。由于其便携性、低成本和实时性，超声心动图通常被用作临床实践中的一线检查方法。然而，超声心动图通常需要经验丰富的医生进行手动评估，评估质量严重依赖于医生的专业知识。因此，手动评估之间和观察者之间的差异往往很大。此外，评估需要手动跟踪心室大小，这既费力又费时，而且容易出错。在这方面，临床实践非常需要自动化评估方法</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241205155220803.png" alt="图 1. 超声心动图视频分割的挑战：（a）轮廓模糊，（b）斑点噪声，以及（c-d）跨帧（同一视频的两帧）的比例变化。"></p><p>超声心动图评估和诊断通常基于对射血分数和心室容积的解释，这需要从超声心动图视频中准确分割出左心室心内膜等关键结构。然而，自动超声心动图分割一直是一项具有挑战性的任务。</p><p>首先，如图 1 (a,b) 所示，由于超声成像的限制，有很多不利因素影响超声心动图视频的质量，例如低信噪比、斑点噪声、边缘丢失以及由致密肌肉和肋骨等结构引起的阴影，难以识别关键解剖结构的边界。其次，视频内和视频之间的心脏结构形状和尺度变化很大（见图 1 (c,d)）。最后，超声心动图视频的注释是一项劳动密集且耗时的工程，因此医生通常只注释收缩末期和舒张末期帧。最后，我们必须对注释有限且稀疏的超声心动图视频进行分割。</p><p>近年来，许多深度学习方法被提出用于超声心动图视频分割，但由于超声视频质量低、标注有限，这些方法仍然无法取得令人满意的效果。最近，一种大型视觉模型——Segment Anything Model (SAM) 被提出并在许多自然图像分割任务中取得了显著的成功。</p><p>一些研究人员试图将其应用于医学图像分割任务，以利用 SAM 强大的表征能力来缓解训练样本不足的问题。然而，这些研究大多集中在二维图像上，如何将 SAM 应用于医学视频分割仍是一项尚未探索且具有挑战性的任务。将 SAM 直接应用于视频会忽略时间线索，并可能导致时间不一致的分割。例如，如图 1 所示，快速变化的超声心动图视频在目标物体的形状和尺度上存在明显的时间不连续性。此外，大量斑点噪声和伪影造成的边界模糊将极大地阻碍 SAM 释放其表征能力。</p><p>在本文中，我们通过将 SAM 应用于医学视频提出了一种新颖的超声心动图视频分割模型，与自然视频相比，医学视频具有一些独特的特征。我们模型的核心技术是一种时间感知和抗噪声的提示方案。</p><p>具体来说，我们使用包含空间和时间信息的时空记忆来提示当前帧的分割，因此我们将提出的模型称为 MemSAM。在提示过程中，携带时间线索的记忆会逐帧顺序提示视频分割。同时，随着记忆提示传播高级特征，它避免了由掩码传播引起的错误识别问题并提高了表示一致性。为了应对斑点噪声的挑战，我们提出了一种记忆强化机制，该机制利用预测的掩码来提高记忆质量，然后再进行存储。我们在 SAMUS（一种基于 SAM 的医学基础模型）上构建了我们的模型，这使我们的模型更适应医疗数据。最后，我们在两个公开可用的数据集上进行了广泛的实验。我们的贡献可以总结如下：</p><ul><li>我们提出了一种基于 SAM 的新型超声心动图视频分割模型。我们模型的核心组件是一种新的提示方法，它能够提供空间和时间线索，以提高表示一致性和分割准确性。</li><li>我们进一步提出了记忆强化模块，在存储记忆之前对其进行增强，从而减轻记忆提示过程中斑点噪声和运动伪影的不利影响。</li><li>我们在两个公共数据集上对我们的方法进行了广泛的评估，与现有模型相比，我们的模型表现出了最先进的性能。特别是，我们的模型在注释有限的情况下实现了与完全监督方法相当的性能。</li></ul><p><strong>实验</strong></p><p>我们在两个广泛使用的公开超声心动图数据集 CAMUS 和 EchoNet-Dynamic 上评估了我们的方法。</p><p><strong>CAMUS 数据集</strong>包含 500 个案例，其中包括 2D 心尖双腔和心尖四腔视图视频。CAMUS 为所有帧提供注释。</p><p><strong>EchoNet-Dynamic 数据集</strong>包含 10,030 个 2D 心尖双腔视图视频。每个视频以积分的形式提供左心室的面积。仅标记收缩末期和舒张末期。</p><p>为了全面评估我们的方法在半监督视频分割中的有效性，CAMUS 数据集被改编为两个变体：CAMUS-Full 和 CAMUS-Semi。CAMUS-Full 在训练期间使用所有帧的注释，而 CAMUS-Semi 仅使用舒张末期 (ED) 和收缩末期 (ES) 帧的注释。在测试期间，这两个数据集都使用完整的注释进行评估。我们从数据集中均匀采样视频，将它们裁剪为每帧 10 帧。裁剪确保 ED 帧是第一帧，ES 帧是最后一帧，分辨率调整为 256×256。对于 CAMUS 数据集，我们按 7:1:2 的比例将其分为训练集、验证集和测试集，而我们对 EchoNet-Dynamic 数据集使用原始分割。</p><p>我们采用了广泛使用的指标，例如平均 Dice 系数 (mDice) 和平均并集 (mIoU) 进行分割评估，以及豪斯多夫距离-95% (HD95) 和平均对称表面距离 (ASSD)。我们还报告了这些指标的标准差。此外，我们还报告了左心室射血分数 (LVEF) 的三个统计指标。我们根据 CAMUS 数据集中提供的辛普森双平面圆盘方法 (SMOD) 估计预测 LVEF。</p><p>请注意，不同的实施方法会对最终的 LVEF 结果产生重大影响。SMOD 从心尖二腔和四腔视图的舒张末期和收缩末期时间实例估计 LVEF。与辛普森的单平面规则相比，SMOD 的估计解决方案更准确、更可靠。对于预测和真实 LVEF，我们计算皮尔逊相关系数 (corr)、平均偏差 (bias) 和标准误差 (std)。</p><p><strong>与最先进方法的比较</strong></p><p>我们广泛选取了不同类型的比较方法，包括传统图像分割模型和医学基础模型。三种传统图像分割模型分别为基于CNN的UNet、基于Transformer的SwinUNet和CNN-Transformer混合的H2Former。医学适应的SAM模型包括MedSAM、MSA、SAMed、SonoSAM和SAMUS。其中SonoSAM和SAMUS专注于超声图像。</p><p><strong>定量比较。</strong> 定量比较结果如表 1 所示。在这些最先进的方法中，H2Former 和 SAMUS 在两个数据集上表现相对较好，分别得益于 CNN-Transformer 架构和超声图像优化。然而，如果不利用稀缺注释下视频的时间属性，这些模型仍然落后于我们的方法。实验验证了我们的方法在有限的注释下实现了最先进的性能。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241205161005071.png" alt="image-20241205161005071"></p><p>为了进一步评估我们的方法，我们在 CAMUS-Semi 和 CAMUS-Full 数据集上以相同的设置对其进行了比较。结果如图 5 所示。可以看出，UNet 和 H2Former 等传统方法以及 SonoSAM 和 SAMUS 等超声波专业方法在完整注释的情况下恢复了不错的结果。虽然我们的方法从半监督到全监督设置都有边际收益，但它在这两种情况下仍然优于其他竞争对手。值得注意的是，医学基础模型需要在完全监督下逐帧提示，而我们只需要一个点提示。实验验证了我们的方法使用更少的外部提示实现了与稀疏标签的完整注释相当的性能。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241205161308103.png" alt="图 5. 所提出的方法与最先进的方法在 CAMUS-Semi 和 CAMUS-Full 数据集上的分割性能"></p><p><strong>结论</strong></p><p>在本文中，我们提出了一种用于超声心动图视频分割的新型半监督视频分割框架，旨在有效地将 SAM 扩展到视频领域，并在有限的注释和提示下实现与全监督相当的性能。然而，当初始帧图像非常差时，我们的方法会导致整个视频序列无法准确分割。未来的研究可以研究实现更稳健初始化的技术，并在更多领域测试我们的方法的有效性，并可以进一步探索降低计算成本和轻量化模型的方法。</p><h2 id="CAF-MambaSegNet">CAF-MambaSegNet</h2><p>2D 不好改，之后再看</p><p>提出了一种名为CAF-MambaSegNet的无卷积和自注意力的语义分割网络，通过设计Mamba-based Channel Aggregator和Spatial Aggregator以及Linearly Interconnected Factorized Mamba (LIFM) Block，展示了在心脏图像分割中不依赖传统CNN和Transformer的方法，旨在减少计算复杂度和参数数量。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241108172721598.png" alt="image-20241108172721598"></p><p><strong>创新点：</strong></p><p>1.提出了无卷积和自注意力的CAF-MambaSegNet网络，创新地使用Mamba-based Channel Aggregator和Spatial Aggregator进行特征提取。</p><p>2.引入了Linearly Interconnected Factorized Mamba (LIFM) Block，以减少计算复杂度并增强决策函数。</p><p>3.展示了在心脏图像分割任务中，线性复杂度和减少参数数量的方法可以取得与现有方法相当的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241108172929244.png" alt="image-20241108172929244"></p><h2 id="LKM-UNet">LKM-UNet</h2><div class = "note note-success">MICCAI 2024</div><p>可以用于3D，但不好改</p><p>作者提出了一种新的基于 Mamba 的 UNet 模型(LKM-UNet)，用于 2D 和 3D 医学图像分割</p><p><strong>摘要</strong></p><p>LKM-UNet 的一个区别特征是其使用大型 Mamba 内核，与基于小内核的 CNN 和 Transformers 相比，在局部空间建模方面表现出色，同时保持了与二次复杂性的自注意力相比的优越效率。此外，我们设计了一种新颖的层次化和双向 Mamba 块，以进一步增强 Mamba 对视觉输入的全局和邻域空间建模能力。</p><p><strong>方法</strong></p><p>LKM-UNet</p><p>除了常见的 UNet 组成，包括深度可分离卷积、编码器下采样层、解码器上采样层和跳跃连接外，LKM-UNet 通过在编码器中插入提出的大内核 Mamba（LM）块来改进 UNet 的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241024160346858.png" alt="Fig. 1. An overview of our proposed LKM-UNet."></p><p>在每个阶段之后，生成的特征图  被编码为 (2C,D/2,H/2,W/2)</p><p>LM-block</p><p>LM 块是用于进一步空间建模每个阶段不同尺度的特征图的核心组件。与之前使用 CNN 进行局部像素级建模和 Transformer 进行长距离块级依赖性建模的方法不同，LM 块可以同时完成像素级和块级建模，得益于 Mamba 的线性复杂性。更重要的是，较低的复杂性允许设置更大的内核（窗口）以获得更大的感受野，这将提高局部建模的效率.</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241024161331002.png" alt="image-20241024161331002"></p><p>在大内核分割策略下，感受野被扩大，模型可以获得更多局部像素的细节。然而，图像被分割成非重叠的子内核。因此，我们需要一个机制来实现不同子内核之间的通信，以进行长距离依赖性建模。块级 SSM（PaM）。我们引入了一个块级 SSM 层，以在不同的子内核之间传递信息.</p><p>与基于前向扫描方向 SSM 层的原始 Mamba 块不同，LM 块中的每个 SSM 层（包括 PiM 和 PaM）都是双向的。图 2(b) 显示了差异。在原始 Mamba 中，作为一个连续模型，一些信息遗忘发生在早期进入的元素上，而最后进入 Mamba 的元素将保留更多的信息。因此，具有单一扫描方向的原始 Mamba 将更多地关注后部块，而不是通常包含更多器官和病变的特征图的中心区域。为此，我们提出了一个双向 Mamba 结构，通过同时进行前向和后向扫描并叠加输出结果。BiM 有两个优点。首先，模型可以更多地关注图像中心区域的信息块，而不是角落区域。其次，对于每个块，绝对位置信息和与其他块的相对位置信息可以被网络很好地建模。</p><h2 id="Deformable-Attention">Deformable Attention</h2><blockquote><p>Xia Z, Pan X, Song S, et al. Vision transformer with deformable attention[C]//Proceedings of the IEEE/CVF conference on computer vision and pattern recognition. 2022: 4794-4803.</p></blockquote><h2 id="Serp-Mamba">Serp-Mamba</h2><blockquote><p>Wang H, Chen Y, Chen W, et al. Serp-Mamba: Advancing High-Resolution Retinal Vessel Segmentation with Selective State-Space Model[J]. arXiv preprint arXiv:2409.04356, 2024.</p></blockquote><p>蛇形交织自适应（SIA）扫描机制和模糊度驱动的双重重校准（ADDR）模块</p><p>消融实验</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250403150551337.png" alt="image-20250403150551337"></p><p>（i）基线：我们采用经典的U形U-Mamba骨干网络作为基线模型;（ii）M1：我们包括SIA扫描机制，并且没有ADDR模块，以测试SIA是否能够使Mamba块在沿沿着可学习的血管路径扫描之后提高分割的准确性;（iii）M2：我们去除了SIA扫描机制，并在M1的基础上加入了ADDR模块，以验证ADDR在解决类别不平衡问题和增强血管连续性; (iv) ours：我们的Serp-Mamba包括SIA扫描机制和ADDR模块。</p><h2 id="MaIR">MaIR</h2><blockquote><p>Li B, Zhao H, Wang W, et al. MaIR: A Locality-and Continuity-Preserving Mamba for Image Restoration[J]. arXiv preprint arXiv:2412.20066, 2024.</p></blockquote><p>消融对比几种扫描方式</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250403162345395.png" alt="image-20250403162345395"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250403162051390.png" alt="image-20250403162051390"></p><h2 id="Dual-Correlation-aware-Mamba">Dual Correlation-aware Mamba</h2><p>Dual Correlation-Aware Mamba  for Microvascular Obstruction  Identification in Non-contrast Cine  Cardiac Magnetic Resonance</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251119173559189.png" alt="image-20251119173559189"></p><p>该研究提出双相关感知 Mamba（DCM）方法，实现非对比 cine 心脏磁共振（CMR）的微血管阻塞（MVO）识别，解决现有方法运动特征提取不足和忽视区域壁运动异常（RWMA）的问题，性能优于现有竞品，为肾损伤患者提供了可行的非对比检测方案。</p><p><strong>研究背景与核心问题</strong></p><ul><li>MVO 是急性心肌梗死的关键预后因素，晚期钆增强（LGE）-CMR 是诊断金标准，但不适用于占比 20% 的肾损伤患者。</li><li>非对比 cine CMR 可捕捉心脏周期运动，有望替代 LGE，但 MVO 在单帧不可见，需分析多帧运动特征。</li><li>现有方法存在两大局限：隐式建模运动动态导致特征提取不充分，忽视 MVO 引发的 RWMA 这一关键诊断依据。</li></ul><p><strong>核心方法设计</strong></p><ul><li><strong>整体框架</strong>：通过 3D CNN 提取 cine 序列特征，经两阶段 DCM 块（含 AFC 和 DFC 模块）增强运动特征，最终通过平均池化和分类器输出 MVO 检测结果。</li><li><strong>Adjacent Frame Correlation（AFC）模块</strong>：计算相邻帧间相关性，预测像素位移偏移量，显式建模心脏运动动态，结合双向时间 Mamba 聚合特征。</li><li><strong>Diastolic Frame Correlation（DFC）模块</strong>：以舒张期帧为全局参考，学习其与其他帧的相关性，突出 RWMA，通过双向空间 Mamba 聚合运动信息。</li><li><strong>损失函数</strong>：采用交叉熵损失 + 均值平方误差损失（权重 0.05），结合粗粒度掩码正则化优化训练。</li></ul><p><strong>实验结果</strong></p><ul><li><strong>数据集</strong>：816 例急性心肌梗死患者数据，按训练集（550 例）和测试集（266 例）随机划分，以 AUC、特异性、准确率等为评价指标。</li><li><strong>性能对比</strong>：DCM 的 AUC 达 0.7687，在各项指标上均超过 VST、CGMR 等现有方法，且参数量（39.91M）更具优势。</li><li><strong>消融实验</strong>：AFC 和 DFC 模块均对性能有显著贡献；舒张期帧是最优参考帧；两阶段框架结构实现最佳性能；可学习偏移量和最优窗口半径（[2,1]）提升了运动建模效果。</li></ul><p><strong>结论与展望</strong></p><ul><li>DCM 通过显式建模运动动态和参考舒张期帧引导学习，有效提升了非对比 cine CMR 的 MVO 识别能力。</li><li>未来将进一步优化 MVO 轮廓描绘，并探索其与其他引发心肌异常的心脏病变的鉴别方法。</li></ul><h2 id="XFMamba">XFMamba</h2><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251119172536127.png" alt="image-20251119172536127"></p><p>XFMamba 是一款基于状态空间模型（Mamba）的纯 Mamba 跨融合架构，专为多视图医学图像分类设计，在 MURA、CheXpert、CBIS-DDSM 三大数据集上表现优于现有卷积和 Transformer 基方法，兼顾分类精度与计算效率。</p><p><strong>核心贡献</strong></p><ol><li>首次将 Mamba（状态空间模型）成功应用于多视图医学图像分类任务。</li><li>提出两阶段 Mamba 融合机制，高效提取并无缝整合多视图信息。</li><li>经三大不同临床场景数据集验证，确立了 Mamba 在多视图医学成像领域的性能基准。</li></ol><p><strong>架构设计</strong></p><ul><li><p><strong>四阶段多尺度编码器</strong>：以 VMamba 为骨干，含两个并行分支，分别处理两种不同视图的输入图像。通过图像分块、三次下采样和视觉状态空间模块（VSSM），提取四级多尺度特征。</p></li><li><p>两阶段融合模块：</p><ol><li><p>浅层融合（CVSM 块）：通过跨视图交织机制交换局部特征，结合通道注意力重加权，增强视图间局部关联。</p><p>CVSM 的核心创新是<strong>基于通道掩码的跨视图交织机制</strong>，解决 “局部跨视图特征关联捕捉” 与 “计算效率” 的矛盾：</p><ul><li>设计二进制通道掩码<code>M(C)</code>（Eq.4）：对两个视图的深层特征（如<code>Xv1⁴</code>、<code>Xv2⁴</code>），按通道奇偶性进行 “选择性交织”—— 偶数通道替换为另一视图的对应通道，奇数通道保留本视图通道。这种方式无需额外参数或复杂计算，即可实现 “视图间局部特征交换”，避免传统交叉注意力的高计算成本。</li><li>引入 “交叉通道注意力重加权”：复用 Squeeze-and-Excitation（SE）机制，但创新地将 “单视图自注意力” 改为 “跨视图互注意力”—— 用视图 v1 的全局上下文注意力来调整视图 v2 的通道权重，反之亦然。这一设计确保 “融合后的特征能优先保留两视图中与病灶相关的关键信息”，而非简单平均</li></ul></li><li><p>深层融合（MVCM 块）：聚合浅层融合输出，通过多视图选择性扫描和融合乘法机制，生成全局整合的融合特征。</p><p>CVSM 仅解决 “局部特征交互”，而 MVCM 针对 “全局多视图信息整合” 设计，核心创新在于<strong>多分支协同与状态空间模型（SSM）的定制化改造</strong>：</p><ul><li>三分支输入设计：将 CVSM 输出的两视图特征（Xv1⁵、Xv2⁵）与 “两视图直接融合特征” 作为三个并行分支，同时输入 MVCM。这种设计避免 “单一分支丢失视图特异性信息”，确保融合时既保留单视图细节，又能捕捉全局关联。</li><li>定制化多视图 SSM 模块：改造传统 SSM 的 “单序列处理” 为 “多序列协同处理”—— 引入融合分支的系统矩阵<code>C_fuse</code>，用其解码两个单视图分支的隐藏状态（Eq.5），即 “用全局融合特征的上下文来引导单视图特征的优化”（🔶1-46、🔶1-49）。这一改造让 SSM 从 “单视图长距离依赖建模” 升级为 “多视图全局关联建模”，确保融合特征的整体性。</li><li>融合乘法机制：对归一化后的单视图特征与融合特征进行乘法交互，自适应学习 “融合特征对单视图特征的增益权重”，而非传统的简单加法或拼接（🔶1-50）。这种方式能动态强化 “两视图共识的关键特征”（如病灶区域），抑制 “视图特异性噪声”（如成像 artifacts）</li></ul></li></ol></li></ul><p><strong>实验验证</strong></p><ul><li><strong>数据集与设置</strong>：覆盖肌肉骨骼 X 线、胸部 X 线、乳腺钼靶三大场景，统一将图像 resize 为 224×224，基于 PyTorch 训练，提供 tiny、small、base 三种模型变体。</li><li><strong>性能表现</strong>：small 和 base 变体在所有数据集上 AUROC 值最高；tiny 变体参数更少（39.29M），计算量（FLOPs）最低，仍在 MURA、CheXpert 数据集上优于多数对比方法。</li><li><strong>消融实验</strong>：两阶段融合模块缺一不可，移除后性能下降 0.4%~0.92%；多视图融合比单视图（提升 1.03%~2.17%）、早期 / 晚期融合（提升 0.92%~0.94%）更有效。</li></ul><h2 id="DGMIR">DGMIR</h2><p>DGMIR: Dual-Guided Multimodal  Medical Image Registration Based  on Multi-view Augmentation and On-Site  Modality Removal</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251119172922776.png" alt="image-20251119172922776"></p><h4 id="整体结构">整体结构</h4><ul><li>编码器为四阶段架构，输出两组多尺度特征图；解码器采用粗到细策略，每阶段整合 MFRG 和 MORG 模块。</li><li>形变场预测采用迭代融合策略，结合前一阶段子形变场与当前阶段输出，保证连续性。</li></ul><h4 id="核心模块原理">核心模块原理</h4><ul><li>MFRG：融合特征通道的均值、最大值统计信息，计算模态间交叉相关性和模态内自相关性，通过校准因子自适应增强有效特征。</li><li>MORG：结合普通卷积与空洞卷积提取多感受野特征，通过均值卷积分离模态特征并移除，保留结构信息。</li></ul>]]></content>
    
    
    <categories>
      
      <category>医学影像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>语义分割</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超声心动图调研</title>
    <link href="/2024/09/03/UltrasoundCardiogram/"/>
    <url>/2024/09/03/UltrasoundCardiogram/</url>
    
    <content type="html"><![CDATA[<h2 id="超声心动图是什么">超声心动图是什么</h2><h3 id="基本原理">基本原理</h3><p>超声心动图主要是通过超声波探头发出超声波，超声波在人体组织中传播，遇到不同的组织界面会产生反射波，这些反射波被探头接收后，经过计算机处理，转化为图像显示在屏幕上。由于心脏是一个不断跳动的器官，超声心动图可以实时观察心脏的结构和运动情况。</p><h3 id="检查类型">检查类型</h3><ol><li>M 型超声心动图：可以记录心脏各结构随时间变化的运动曲线，主要用于测量心脏各腔室的大小和心功能指标。</li><li>二维超声心动图：能够提供心脏的二维切面图像，清晰显示心脏的形态、结构和瓣膜的活动情况。</li><li>多普勒超声心动图：包括彩色多普勒和频谱多普勒。彩色多普勒可以显示心脏内血流的方向和速度，帮助判断是否存在瓣膜反流、狭窄等异常；频谱多普勒可以定量分析血流速度和压力差等参数。</li></ol><h3 id="临床应用">临床应用</h3><ol><li>诊断心脏疾病<ul><li>先天性心脏病：如房间隔缺损、室间隔缺损、动脉导管未闭等，可以明确缺损的位置、大小和分流情况。</li><li>瓣膜性心脏病：判断瓣膜的形态、结构和功能，诊断瓣膜狭窄、关闭不全等病变。</li><li>心肌病：如扩张型心肌病、肥厚型心肌病等，可显示心肌的厚度、运动情况和心腔大小的变化。</li><li>冠心病：可以观察心肌的运动情况，评估心肌缺血和梗死的范围。</li></ul></li><li>评估心功能<ul><li>测量心脏的收缩功能和舒张功能指标，如射血分数、左心室短轴缩短率、E/A 比值等，判断心脏的整体功能状态。</li></ul></li><li>指导治疗和监测疗效<ul><li>在心脏手术前，超声心动图可以提供详细的心脏结构信息，帮助制定手术方案。</li><li>术后可以监测心脏的恢复情况，评估手术效果。</li><li>对于心力衰竭等患者，可定期进行超声心动图检查，调整治疗方案。</li></ul></li></ol><h3 id="优势和局限性">优势和局限性</h3><ol><li>优势<ul><li>无创性：无需侵入人体，对患者无创伤。</li><li>实时性：可以实时观察心脏的动态变化。</li><li>可重复性：可以多次重复检查，便于观察病情变化。</li><li>准确性高：对心脏结构和功能的评估较为准确。</li></ul></li><li>局限性<ul><li>受操作者技术水平影响：检查结果的准确性与操作者的经验和技术水平有一定关系。</li><li>对肥胖、肺气肿等患者图像质量可能较差：超声波在这些患者体内的传播会受到影响，导致图像不清晰。</li><li>不能检测微小血管病变：对于一些微小的冠状动脉病变可能无法检测到。</li></ul></li></ol><h2 id="计算机视觉可以做什么">计算机视觉可以做什么</h2><h3 id="心脏结构检测与分割">心脏结构检测与分割</h3><ol><li><p>心室分割</p><ul><li>准确分割左心室和右心室，确定其形状和大小。这对于评估心脏功能至关重要，例如通过计算心室容积变化来判断收缩和舒张功能。</li><li>可以为医生提供定量的指标，如左心室射血分数等，辅助诊断心力衰竭等疾病。</li></ul><blockquote><p>射血分数是指每搏输出量占心室舒张末期容积量的百分比，分数 =（心室舒张末期容积 - 心室收缩末期容积）/ 心室舒张末期容积 ×100%。可以用于评估心脏功能、诊断疾病、指导治疗、预后判断</p></blockquote></li><li><p>瓣膜分割</p><ul><li>识别和分割心脏瓣膜，如二尖瓣、三尖瓣、主动脉瓣和肺动脉瓣。有助于检测瓣膜的形态异常、狭窄或关闭不全等病变。</li><li>为瓣膜修复或置换手术提供术前规划的重要信息。</li></ul></li></ol><h3 id="心脏运动分析">心脏运动分析</h3><ol><li>心肌运动跟踪<ul><li>跟踪心肌在心动周期中的运动轨迹，分析心肌的收缩和舒张运动模式。可以检测心肌局部运动异常，如心肌缺血或梗死区域的运动减弱或消失。</li><li>为早期诊断冠心病等心血管疾病提供依据。</li></ul></li><li>瓣膜运动分析<ul><li>监测心脏瓣膜的开放和关闭过程，评估瓣膜的运动速度、幅度和协调性。有助于诊断瓣膜功能障碍，如瓣膜脱垂、狭窄或反流等。</li></ul></li></ol><h3 id="疾病诊断与分类">疾病诊断与分类</h3><ol><li>先天性心脏病诊断<ul><li>通过分析超声心动图图像中的心脏结构和血流模式，识别先天性心脏病的特征，如房间隔缺损、室间隔缺损、动脉导管未闭等。</li><li>可以辅助医生进行早期诊断和制定治疗方案。</li></ul></li><li>心肌病分类<ul><li>区分不同类型的心肌病，如扩张型心肌病、肥厚型心肌病和限制型心肌病。通过提取图像特征和分析心脏形态、功能参数，实现对心肌病的准确分类。</li><li>为个性化治疗提供指导。</li></ul></li><li>主动脉狭窄程度预测<ul><li>可以对主动脉狭窄进行早期诊断，及时发现潜在的疾病风险。同时，还可以对患者进行长期监测，观察狭窄程度的变化，评估治疗效果。</li></ul></li></ol><h3 id="标志物检测">标志物检测</h3><ol><li>心脏肿瘤诊断<ul><li>超声心动图可以检测出心脏内或心包内的肿瘤，评估其大小、位置以及与周围组织的关系，为临床治疗提供重要信息。</li></ul></li></ol><h2 id="近三年超声心动图论文调研">近三年超声心动图论文调研</h2><h3 id="MICCAI">MICCAI</h3><p><em><strong>Light-weight spatio-temporal graphs for segmentation and ejection fraction prediction in cardiac ultrasound</strong></em></p><ul><li><strong>摘要</strong></li></ul><p>准确和一致的超声心动图参数预测对于心血管疾病的诊断和治疗是非常重要的，特别是，左心室的分割可用于推导心室容积、射血分数 (EF) 和其他相关测量值。 在本文中，我们提出了一种称为 EchoGraphs 的新自动化方法，用于通过检测解剖关键点来预测射血分数和分割左心室。基于图卷积网络 (GCN) 的直接坐标回归模型用于检测关键点。 GCN 可以学习根据每个关键点的局部外观以及所有关键点组合的全局空间和时间结构来表示心脏形状。我们在 EchoNet 基准数据集上评估了我们的 EchoGraphs 模型。与语义分割相比，GCN 显示出准确的分割和稳健性和推理运行时间的改进。EF 与分割同时计算，我们的方法还获得了最先进的射血分数估计。代码链接:<a href="https://github.com/guybenyosef/EchoGraphs">https://github.com/guybenyosef/EchoGraphs</a></p><ul><li><strong>模型</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905202334805.png" alt="Fig.1. The EchoGraphs model architecture"></p><p>编码器 在图的输入层，每个节点被分配一个特征表示。从原始图像或视频信息,必须提取 1000 维特征向量才能满足这些输入要求。<br>为此，可以使用任何 CNN 网络，架构的选择是速度和准确性之间的权衡。每个节点都分配有 CNN 输出，并按照螺旋序列的顺序与相邻节点特征连接。</p><p><strong>EchoGraphs - 左心室分割和 EF 预测</strong></p><p>单帧分割 图像编码器和图点解码器可用于预测给定单个图像帧的每个关键点 vi 2 V 的像素位置 (x; y) 2 R2，如图 1 上部所示。基于 GCN 配置强制执行的形状约束，输出是沿心肌边界的封闭轮廓，代表左心室的分割</p><p>在已知 ED/ES 的情况下进行多帧分割和 EF 预测 要测量 EF，必须分析多个输入帧。我们扩展了上面讨论的单帧方法，以优化 ED 和 ES 帧上的关键点轮廓。该序列的一个关键属性是连续帧之间左心室的形状一致性。采用与之前关于身体姿势估计的工作类似的方法 [24]，ED 处的每个图形节点都连接到 ES 中的相应节点以模拟时间连接。在两个连续帧之间添加这些时间边缘有助于加强预测分割之间的一致性</p><p>对于这种方法，R(2+1)D 视频编码器 [22] 用于生成特征向量。该网络将 16 帧序列作为输入，其中第一帧为 ED，最后一帧为 ES。包含中间帧比仅使用 ED 和 ES 的两帧方法效果更好，这表明额外的上下文有助于学习。这种方法需要手动识别 ED 和 ES 帧。编码器的输出用作 EF 回归网络和图解码器的输入。这种方法中的 EF 预测来自关键点和附加到特征向量的 EF 回归器</p><p>从未知的 ED/ES 进行多帧分割和 EF 预测如果 ED 和 ES 未知，我们将展示两种可能的方法。首先，上述方法可以组合成一个两阶段解决方案，其中单帧模型首先预测每帧的关键点。这些关键点允许计算心室体积，并且按照 [15] 的方法，可以识别体积的负峰值和正峰值。随后，可以将多帧模型应用于每个峰值对以估计 EF。<br>在第二种方法中，添加了一个 ED/ES 分类器，该分类器获取编码器输出并预测序列中 ED/ES 帧的出现。分类器输出与来自编码器的特征向量连接作为图形解码器的输入。如果检测到 ED 或 ES 帧，则解码器的输出类似于相应的心室轮廓。在推理过程中，应用滑动窗口方法来处理整个视频，并在整个序列中对 EF 结果取平均值。图 1 底部显示了带有/不带有 ED/ES 分类器的多帧方法。</p><p><em><strong>Reinforcement Learning for Active Modality Selection During Diagnosis(2022)</strong></em></p><p>提出了一个RL框架来获得具有成本效益的政策，该政策顺序地提出要获得的最佳模式以产生诊断。使用超声心动图来做验证，不是想要的</p><p><em><strong>Ensembled Prediction of Rheumatic Heart Disease from Ungated Doppler Echocardiography Acquired in Low-Resource Settings(2022)</strong></em></p><p>在低资源环境下获得的非门控超声心动图综合预测风湿性心脏病</p><ul><li><strong>摘要</strong></li></ul><p>风湿性心脏病（RHD）是儿童的一种常见疾病，急性风湿热会导致心脏瓣膜永久性损伤，从而损害心脏泵血的能力。超声心动图是用于检测RHD的流行诊断工具。然而，这项评估的执行需要熟练医生的工作，这就带来了可及性问题，特别是在临床专家接触有限的低收入国家。本文提出了一种新型的、自动化的、基于深度学习的方法，使用彩色超声心动图剪辑来检测RHD。我们首先通过识别两个采集视图（胸旁和顶面）来均匀化非门控超声心动图的分析，然后在心室收缩期间提取左心房区域。然后，我们应用多视图3D卷积神经网络和多视图Transformer的模型集成来检测RHD。该模型使我们的分析受益于时空信息的包含，并使用注意力机制来识别RHD检测的相关时间帧，从而提高准确检测RHD的能力。使用在低资源环境中591名儿童的护理点采集的2，136个彩色超声心动图剪辑评估了该方法的性能，显示平均准确性为0.78，敏感性为0.81，特异性为0.74。这些结果与专家临床医生进行的RHD检测相似，并且优于最先进的方法。因此，我们的新模型有可能改善与临床专家接触有限的患者的RHD检测。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905135347597.png" alt="Fig. 1. RHD检测提出的方法流程图"></p><ul><li><strong>超声心动图均匀化</strong><ul><li>从每个患者收集的大量数据中检索这些视图，我们将每个视频流的第一帧（代表性帧）传递给深度学习分类模型，使用ResNet 50分类</li><li>分析了视频中的所有帧</li><li>利用LinkNet 和VGG 16编码器分割左心房</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905141255878.png" alt="Fig. 3.所采用的3D卷积神经网络（CNN）和Transformer的结构"></p><ul><li><strong>风湿性心脏病的检测</strong></li></ul><p>开发了多视图3D CNN和Transformer的模型集成，以将空间和时间特征与注意力机制融合用以检测RHD检测</p><p><em>多视图3D卷积神经网络</em></p><p>应用3D CNN从两个视图中提取时空信息，将它们融合在单个端到端网络中（图3）。输入数据是从两个视图之一在心室收缩期间捕获的局部左心房区域创建的，重新采样为64 x 64像素x 3个颜色通道x 16帧。这些大小是根据内存管理确定的。每个输入数据都使用两个具有ReLu激活功能的3 x 3 x 3卷积过滤器处理。每个过滤器后面是一个批规格化层和2 x 2 x 2最大池化，每个维度的步进为2。然后，使用两个完全连接的层将从两个视图中提取的特征连接起来并一起处理，其中包括256个具有ReLu激活功能的单元和2个具有Softmax概率功能的单元。该模型采用批量大小64，使用Adam优化算法最大限度地减少二进制交叉熵损失函数，在350个历元期间学习率为0.0001。</p><p><em>多视图Transformer</em></p><p>包括一个Transformer，以嵌入心室收缩期间帧之间的相关依赖关系，并引起人们对重要时间点的注意（图3）。首先，我们应用了两个在ImageNet数据集上预先训练的DenseNet 121 CNN，以从两个视图中捕获低级特征。DenseNet 121 CNN分析了心室收缩期间的帧，重新采样为16帧，尺寸为64 x 64像素x 3个颜色通道。从两个视图中获得的信息通过Transformer模型进行汇总以进行高级分析，类似于[23]中提出的模型。Transformer模型首先将位置信息嵌入到输入特征中以保留顺序信息。然后，该模型使用自我注意模块学习帧之间的关系，然后是一个前向神经网络，该神经网络由两层组成，带有高斯误差线性单元[29]。每个块的输入和输出之间的RST连接用于直接通过网络传递梯度。在每个块之后，应用一个规范化层来提高可概括性并减少处理时间。Transformer模型编码的特征通过全局最大池化操作进行下采样，并通过Softmax概率函数将其反馈到最后一个完全连接的层以预测RHD。在最后一个完全连接的层之前，我们应用了保持率为0.5的dropout。该模型使用批量大小为10和Adam优化算法（学习率为0.0001）进行训练，以在350个历元内最小化二进制交叉熵损失函数。</p><p>3D CNN将心室收缩期间的所有帧作为体积数据来评估RHD，而Transformer则逐帧评估数据。由于两个深度学习模型从不同的角度分析数据，因此我们通过应用最大投票策略将它们的预测分数融合在集成模型中以提高准确性。此外，当可进行多次采集时，正如临床实践中的典型情况，受试者的每个A4 CC/PLAXT视图都有一个以上的视频，其中还可能包括多个心室收缩。</p><ul><li><strong>实验</strong></li></ul><p>使用Keras（版本2.6.0）和TensorFlow（版本2.6.2）实现，并在具有12 GB内存的GeForce GTX TitAN X图形处理器（NVIDIA，圣克拉拉，加利福尼亚州）上进行训练。</p><ul><li><strong>结论</strong></li></ul><p>提出了一种基于自动深度学习的方法来使用非门控多视图彩色超声心动图来检测RHD。首先，我们使用深度学习方法对图像进行均匀化，以减少数据可变性，并将分类器集中在与RHD相关的图像信息上。接下来，我们应用多视图深度学习模型（3D CNN和Transformer）来分析具有注意力机制的帧的时空信息。最后，我们采用整体模型来融合多次心室收缩的预测并获得RHD风险评分。结果表明，我们的方法可以与专家临床医生一样可靠地检测RHD，并且优于检测RHD的最新方法。我们的方法与没有心电图门控的低价手持超声设备兼容，这使得它适用于低资源环境中的RHD筛查。</p><p><em><strong>Multi-frame Attention Network for Left Ventricle Segmentation in 3D Echocardiography(2021)</strong></em></p><p>用于3D超声心动图左心室分割的多帧注意力网络</p><ul><li><strong>摘要</strong></li></ul><p>超声心动图是用于评估患者心血管健康状况的主要成像方式之一。在对超声心动图进行的众多分析中，左心室的分割对于量化射血分数等临床测量至关重要。然而，3D超声心动图中左心室的分割仍然是一项具有挑战性和乏味的任务。本文提出了一种多帧注意力网络来提高3D超声心动图中左心室分割的性能。多帧关注机制允许目标图像之后的图像序列中高度相关的时空特征用于增强分割的性能。51张活体猪3D+时间超声心动图图像上显示的实验结果表明，与其他标准的基于深度学习的医学图像分割模型相比，利用相关时空特征显着提高了左心室分割的性能。</p><ul><li><strong>模型</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905155958243.png" alt="Fig. 1. P多帧注意力网络用于超声心动图 3D 左心室分割"></p><p>图 1 显示了模型输入为目标帧和 4 个参考帧的实例。这允许目标体积帧利用随后的一系列 4 个体积帧来学习时空注意特征。所选系列中的每个体积都将经过具有共享权重的标准编码器架构。对于 5 帧输入，在编码器阶段结束时，将有 5 个特征图，Ft、Ft+1、Ft+2、Ft+3、Ft+4。对应于输入体积的每个特征图的尺寸为 c × w × h × d，其中 c = 通道、w = 宽度、h = 高度和 d = 深度。参考特征图 Ft+1、Ft+2、Ft+3、Ft+4 将分别与目标特征图 Ft 一起使用来计算注意图。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905160710290.png" alt="Fig. 2. 多帧注意力模块的视觉图示"></p><p>注意力图利用了从目标特征图(蓝色)和参考特征图(黄色)中提取的特征之间的相关性。使用利用矩阵乘法，Ft 和 Ft+i（其中 i = 1, . . . , 4）被重塑为 c × whd 的维度。因此，相关性图的维度为 whd × whd。最后用softmax函数对相关图进行归一化，以计算注意力图</p><ul><li><strong>实验</strong></li></ul><p>使用猪体内 3D 超声心动图数据集评估这个多帧注意方法，该数据集由从 14 头猪身上获取的 51 个 3D+时间体积超声心动图序列组成。每头猪在不同时间点进行成像，对应不同的生理状态，该模型是使用 PyTorch 实现的，并在 GTX 1080 Ti GPU 上进行了实验。模型训练完成后，推理时间约为 20 秒。</p><ul><li><strong>结论</strong></li></ul><p>提出了一种用于 3D 超声心动图左心室分割的多帧注意架构。多帧注意网络成功地利用了给定序列中超声心动图图像体积的时空特征，并提取了目标体积和参考体积之间高度相关的特征，即使在信号强度较低时也能指导心肌边界的位置。我们提出的框架还易于扩展，以包含与参考体积一样多的帧。结果表明，利用图像的时空特性可以增强 3D 左心室分割的性能。未来的工作将扩大我们的验证范围，包括临床 3D 超声心动图数据集，以更稳健地训练我们的模型。此外，我们将使用公共 2D 超声心动图数据集评估注意力的有效性，以了解多帧注意网络对不同数据维度的可行性</p><p><em><strong>Towards Efficient Human-Machine Collaboration: Real-Time Correction Effort Prediction for Ultrasound Data Acquisition (2021)</strong></em></p><p>主要是改善采集方面的工作，所提出的框架提供实时校正工作量预测，以帮助超声医师避免数据采集过程中的分割失败。该方法与分割模型的开发无关，可以扩展到其他应用。令人鼓舞的结果证明了优化数据采集的可行性和好处，不仅可以优化人类视觉，还可以优化机器视觉，并直接预测人类工作量而不是传统的质量指标</p><h3 id="CVPR">CVPR</h3><p><em><strong>Reciprocal_Landmark_Detection_and_Tracking_with_Extremely_Few_Annotations</strong></em></p><p>(这篇有点看不懂</p><p>具有极少注释的交互式地标检测与跟踪</p><ul><li><strong>摘要</strong></li></ul><p>在超声心动图中定位解剖标志进行二维测量是心脏疾病诊断的常规临床工作流程的一部分，这些标志的自动定位是非常需要的，以改善工作流程并减少观察者之间的差异。考虑到黄金标准标签的稀疏性质，训练机器学习框架以执行这种定位受到阻碍;只有很少百分比的心脏电影系列帧通常被手动标记以供临床使用。在本文中，我们提出了一个新的端到端–端倒数检测和跟踪模型，专门设计用于处理超声心动图标签的稀疏性质。该模型使用跨整个心脏电影序列生成一致的检测和跟踪的标志，并提出了一个对抗性的训练模型，利用这些注释帧的优势，所提出的互惠模型的优越性进行了一系列的实验证明。</p><ul><li><strong>模型</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905173034834.png" alt="image-20240905173034834"></p><p>该模型可以分为三个部分，特征编码器（蓝色），检测头（橙色）和跟踪头（绿色）。特征编码器和检测头结合在一起可以视为类似Unet的模型，其总体结构类似于Unet。在模型训练阶段，RDT模型的输入是从舒张末期帧开始到收缩末期帧结束的回波序列，对于检测分支，输入是整个帧，而对于跟踪分支，输入是来自两个相邻帧的补丁。网络的输出是LVID的两个预测的界标对位置。</p><p><em>共享特征编码器</em></p><p>特征编码器由六个3×3卷积层组成，每个卷积层后面都有一个整流线性单元（ReLU）。第三个卷积层的步幅等于2。由于单个特征编码器足以用于跟踪头，因此我们将这部分编码器与跟踪和检测分支共享。</p><p><em>探测头和焦点损失</em></p><p>与特征编码器结合在一起的检测头可以看作是一个Unet类结构，它由收缩路径和扩张路径组成，收缩路径遵循卷积网络的典型架构，检测头的开始是另外六层用于特征生成，到共享特征编码器有两个类似的下采样步骤，然而，我们还在这两个步骤中将特征通道的数量增加一倍。扩展路径中的每一步都包括对特征图进行上采样，然后进行2×2卷积（“上卷积”）。前两个上采样层将特征通道的数量减半。我们还将每个上采样层的输出与相应裁剪的收缩路径的特征映射。每个3×3卷积之后是一个ReLU。由于应用了填充，整个神经网络中没有裁剪。对于用于分类的最后两个层，第一个是3×3卷积层，第二个是1×1层，用于将每个48分量特征向量映射到所需数量的地标（这里地标的数量为2）.最后一层的输出是一个二维热图，热图的每个位置代表目标地标的概率</p><p><em>跟踪头和周期损失：</em></p><p>由于跟踪过程仅由舒张末期和收缩末期帧监督，因此我们引入周期损失和运动损失来监督跟踪分支。为了对周期过程进行建模，我们以向前的方式迭代地应用跟踪头T：</p><p>RDT模型的基本思想是在检测任务和跟踪任务之间建立一种相互学习，因为检测任务主要关注单个帧的空间信息，而跟踪任务考虑连续帧之间的时间相关性。然而，检测到的地标对位置和跟踪的地标对位置被假设为相同。因此，我们希望这两个分支产生差异以优化特征编码器φ和检测/跟踪头</p><ul><li><strong>训练步骤</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240905174139243.png" alt="Training Steps"></p><ol><li><p>步骤A.首先，我们训练D、T和φ来正确预测带注释帧的地标对。我们训练网络来最小化应用于带注释帧的三个损失。</p></li><li><p>步骤B.在这一步中，我们针对固定的D和T训练特征编码器φ。通过训练编码器来增加差异，可以生成更多与注释数据不同的未知特征分布。注意，这一步只使用未注释的数据。</p></li><li><p>步骤C.我们训练D和T以最小化具有固定φ的差异。由于此步骤是为了获得均匀和正确的检测/跟踪结果，因此根据经验，对于同一小批量重复此步骤三次。此设置实现了编码器和头之间的折衷该步骤被应用于注释帧和未注释帧两者，以获得针对所有现有特征的检测/跟踪头部的最佳模型权重。</p></li></ol><ul><li><strong>结论</strong></li></ul><p>本文提出了一种新型的互惠地标检测和跟踪模型。该模型旨在解决超声序列的数据和注释稀缺问题。该模型仅需约2，000个注释帧即可实现可靠的地标检测和跟踪（995个序列）进行训练。对于每个序列，只有两个关键帧被注释。该模型通过一种新的对抗性训练方法进行优化，该方法能更好地利用训练数据的有限信息，与现有方法的比较和结果分析验证了该方法的有效性。</p><p>目标如下：</p><p>【本周任务】<br>1、了解超声心动图的相关概念（主要是去了解基于超声心动图有哪些任务可以做，比如分割、射血分数计算、收缩末期和舒张末期左心室容积计算、主动脉狭窄程度预测、标志物检测等）；<br>2、继续学习mamba模型，主要了解怎么调用，可以参考下面的代码仓；<br>3、粗粮阅读SegMamba的论文，主要是了解一下医学图像上的分割任务，论文在下面的链接中；<br>4、调研超声心动图上的分割和标志物检测模型（近三年为主），目标期刊会议：MICCAI、CVPR、AAAI、TMI（期刊）、MIA（期刊）、TIP（期刊）<br>【目标】<br>1、认识超声心脏图以及相关任务；<br>2、了解Mamba模型如何在下游任务使用；<br>3、为后续实验做准备（在调研的过程中找到一两个可以跟进的工作：①Readme文件清晰；②论文中显卡资源不夸张，那种懂不懂4卡A100的就不考虑了；③使用的数据集包含EchoNet、CAMUS、UIC）</p>]]></content>
    
    
    <categories>
      
      <category>医学影像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉 医学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语义分割项目</title>
    <link href="/2024/08/14/%E6%9D%A5%E5%AE%9E%E9%99%85%E5%81%9A%E4%B8%80%E4%B8%AA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/08/14/%E6%9D%A5%E5%AE%9E%E9%99%85%E5%81%9A%E4%B8%80%E4%B8%AA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍语义分割">介绍语义分割</h2><p>应用场景</p><p>会议软件 背景虚化</p><p>智能驾驶</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240814143707560.png" alt="image-20240814143707560"></p><p>医疗影像的分析</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240814143820519.png" alt="image-20240814143820519"></p><p>卫星影像的分析</p><p>什么时候语义分割，什么时候实例分割</p><ul><li>·如果不存在“实例”概念，只需要每个像素分类，用语义分割<br>裂纹、农田遥感、金属金相、血管<br>目标大片、尖细分布，轮廓不规则，</li><li>如果需要区分“实例”，用实例分割<br>脑部肿瘤、细胞核、汽车、行人、动物<br>·</li><li>如果需要目标检测预测框（计数、追踪、流量统计），用实例分<br>目标检测本身就是“实例级”，关键点检测可以视为特殊的“实例分割</li></ul><p>标注：</p><p>使用文本提示，检测、分割、生成一切：https:/github.com/IDEA-Research/Grounded-Segment-Anything</p><p>填充-切：<a href="https://github.com/geekyutao/.Inpaint-.Anything">https://github.com/geekyutao/.Inpaint-.Anything</a><br>追踪一切：https:/github.com/gaomingqi/Track-Anything</p><p>Magic Maker:<a href="https://openxlab.org.cn/apps/detail/xj/magic-maker">https://openxlab.org.cn/apps/detail/xj/magic-maker</a></p><h2 id="数据集">数据集</h2><ul><li>单类别</li></ul><p>组织病理切片肾小球：<a href="https://www.kaggle.com/datasets/baesiann/glomeruli-hubmap-external-1024x1024">https://www.kaggle.com/datasets/baesiann/glomeruli-hubmap-external-1024x1024</a></p><ul><li>多类别</li></ul><p>迪拜卫星航拍六类别：<a href="https://www.kaggle.com/datasets/humansintheloop/semantic-segmentation-of-aerial-imagery">https://www.kaggle.com/datasets/humansintheloop/semantic-segmentation-of-aerial-imagery</a></p><p>其它单类别语义分割数据集</p><p>乳腺癌：<a href="https://www.kaggle.com/datasets/aryashah2k/breast-ultrasound-images-dataset">https://www.kaggle.com/datasets/aryashah2k/breast-ultrasound-images-dataset</a></p><p>电子显微镜粒子：<a href="https://www.kaggle.com/datasets/batuhanyil/electron-microscopy-particle-segmentation">https://www.kaggle.com/datasets/batuhanyil/electron-microscopy-particle-segmentation</a></p><p>农作物病虫害叶片：<a href="https://www.kaggle.com/datasets/fakhrealam9537/leaf-disease-segmentation-dataset">https://www.kaggle.com/datasets/fakhrealam9537/leaf-disease-segmentation-dataset</a></p><p>农作物地块：<a href="https://www.kaggle.com/datasets/khlaifiabilel/pastis">https://www.kaggle.com/datasets/khlaifiabilel/pastis</a></p><p>洪水航拍区域：<a href="https://www.kaggle.com/datasets/faizalkarim/flood-area-segmentation?select=Image">https://www.kaggle.com/datasets/faizalkarim/flood-area-segmentation?select=Image</a></p><p>指甲：<a href="https://www.kaggle.com/datasets/vpapenko/nails-segmentation">https://www.kaggle.com/datasets/vpapenko/nails-segmentation</a></p><p>水下场景：<a href="https://www.kaggle.com/datasets/ashish2001/semantic-segmentation-of-underwater-imagery-suim">https://www.kaggle.com/datasets/ashish2001/semantic-segmentation-of-underwater-imagery-suim</a></p><p>西红柿种子：<a href="https://www.kaggle.com/datasets/juanma9901/tomatoseedsdatasetjm">https://www.kaggle.com/datasets/juanma9901/tomatoseedsdatasetjm</a></p><p>卫星建筑物：<a href="https://www.kaggle.com/datasets/hyyyrwang/buildings-dataset">https://www.kaggle.com/datasets/hyyyrwang/buildings-dataset</a></p><p>荧光显微镜小鼠脑切片发光神经元-实例分割：<a href="https://www.kaggle.com/datasets/nbroad/fluorescent-neuronal-cells">https://www.kaggle.com/datasets/nbroad/fluorescent-neuronal-cells</a></p><p>混凝土裂缝：<a href="https://www.kaggle.com/datasets/jakubniemiec/concrete-crack-images">https://www.kaggle.com/datasets/jakubniemiec/concrete-crack-images</a></p><p>核磁共振脑瘤分割：<a href="https://www.kaggle.com/datasets/awsaf49/brats2020-training-data">https://www.kaggle.com/datasets/awsaf49/brats2020-training-data</a></p><p>腹部CT肝脏病变分割：<a href="https://www.kaggle.com/datasets/andrewmvd/liver-tumor-segmentation">https://www.kaggle.com/datasets/andrewmvd/liver-tumor-segmentation</a></p><p>脑部神经胶质瘤核磁共振：<a href="https://www.kaggle.com/datasets/mateuszbuda/lgg-mri-segmentation">https://www.kaggle.com/datasets/mateuszbuda/lgg-mri-segmentation</a></p><p>其它多类别语义分割数据集</p><p>高分辨率航拍-多类别：<a href="https://www.kaggle.com/datasets/titan15555/uavid-semantic-segmentation-dataset">https://www.kaggle.com/datasets/titan15555/uavid-semantic-segmentation-dataset</a></p><p>无人机航拍：<a href="https://www.kaggle.com/datasets/bulentsiyah/semantic-drone-dataset">https://www.kaggle.com/datasets/bulentsiyah/semantic-drone-dataset</a></p><p>衣物：<a href="https://www.kaggle.com/datasets/rajkumarl/people-clothing-segmentation">https://www.kaggle.com/datasets/rajkumarl/people-clothing-segmentation</a></p><p>海洋生物：<a href="https://www.kaggle.com/datasets/crowww/a-large-scale-fish-dataset">https://www.kaggle.com/datasets/crowww/a-large-scale-fish-dataset</a></p><p>腿和脚趾：<a href="https://www.kaggle.com/datasets/tapakah68/legs-segmentation">https://www.kaggle.com/datasets/tapakah68/legs-segmentation</a></p><p>无人机航拍：<a href="https://www.kaggle.com/datasets/santurini/semantic-segmentation-drone-dataset">https://www.kaggle.com/datasets/santurini/semantic-segmentation-drone-dataset</a></p><p>其它图像分类数据集</p><p>气胸：<a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation">https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation</a></p><p>更多数据集</p><p><a href="https://paperswithcode.com/sota">Browse the State-of-the-Art in Machine Learning | Papers With Code</a></p><p>图像分割发展趋势<br>使用Transformer架构<br>统一语义分割、实例分割、全景分割<br>视觉大模型(SAM)<br>多模态+AIGC（文生图、图生图、图像编辑)</p><p>评价语义分割模型</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240814145838252.png" alt="image-20240814145838252"></p><h2 id="标注数据集">标注数据集</h2><p>Labelme <a href="https://github.com/labelmeai/labelme">labelme</a></p><p>标注前</p><ol><li>标注前，需左上角<code>File</code>开启<code>Save Automatically</code>自动保存</li><li>标注前，需左上角<code>File</code>关闭<code>Save With Image Data</code>，不把图像本身保存至标签文件中</li><li>应提前把所有图像放到同一个文件夹中，再用labelme打开这个文件夹标注</li></ol><p>标注中</p><ol><li>应使标注文件保存至图像相同目录下，标注过程中，不要切换图像和标注文件的目录</li><li>多段线（polygon）应尽可能精细，紧密贴合物体的真实边缘轮廓。</li><li>如果使用AI-Polygon辅助标注，每张图片需先等待SAM分割一切大模型处理几秒钟，才能开始标注。</li><li>如果是实例分割标注：标目标检测框时，画物体的外接矩形框。框的两个点，必须分别是左上角和右下角，顺序不能错。</li><li>如果是目标检测+关键点检测标注：多段线（polygon）的第一个点<code>必须且只能落入一个框中</code>。见视频教程：<a href="https://www.bilibili.com/video/BV19g4y1777q">https://www.bilibili.com/video/BV19g4y1777q</a></li></ol><p>标注后确认</p><ol><li>Labelme标注的json文件最后<code>imagePath</code>图像路径，<strong>只能</strong>是图像名字本身，<strong>不能</strong>有其它的路径和符号（例如<code>../</code>、<code>\\</code>之类的）</li></ol><p>使用这个进行格式转换</p><p><a href="https://github.com/TommyZihao/Label2Everything">TommyZihao/Label2Everything: 常见计算机视觉标注格式相互转换 (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉</title>
    <link href="/2024/08/06/computer%20vision/"/>
    <url>/2024/08/06/computer%20vision/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">前言:依据李沐视频整理</p><h2 id="图像增广">图像增广</h2><p>图像增广在对训练图像进行一系列的随机变化之后，生成相似但不同的训练样本，从而扩大了训练集的规模。 此外，应用图像增广的原因是，随机改变训练样本可以减少模型对某些属性的依赖，从而提高模型的泛化能力。也就是增加一个已有数据集，使得有更多的多样性。例如：</p><ul><li>在语言里面加入各种不同的背景噪声</li><li>改变图片的颜色和形状</li></ul><h3 id="常用的图像增广方法">常用的图像增广方法</h3><p><strong>翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">torchvision.transforms.RandomHorizontalFlip()  <span class="hljs-comment"># 0.5几率 左右翻转</span><br><br>torchvision.transforms.RandomVerticalFlip()  <span class="hljs-comment"># 0.5几率 上下翻转</span><br></code></pre></td></tr></table></figure><p><strong>切割</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torchvision.transforms.RandomResizedCrop(<br>    (<span class="hljs-number">200</span>, <span class="hljs-number">200</span>), scale=(<span class="hljs-number">0.1</span>, <span class="hljs-number">1</span>), ratio=(<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">#随机裁剪一个面积为原始面积10%到100%的区域，该区域的宽高比从0.5～2之间随机取值。 然后，区域的宽度和高度都被缩放到200像素</span><br></code></pre></td></tr></table></figure><p><strong>颜色</strong></p><p>我们可以改变图像颜色的四个方面：亮度、对比度、饱和度和色调。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">torchvision.transforms.ColorJitter(<br>    brightness=<span class="hljs-number">0.5</span>, contrast=<span class="hljs-number">0</span>, saturation=<span class="hljs-number">0</span>, hue=<span class="hljs-number">0</span>) <span class="hljs-comment"># 随机更改图像的亮度，随机值为原始图像的50%(1-0.5)到150%(1+0.5)之间</span><br><br>torchvision.transforms.ColorJitter(<br>    brightness=<span class="hljs-number">0</span>, contrast=<span class="hljs-number">0</span>, saturation=<span class="hljs-number">0</span>, hue=<span class="hljs-number">0.5</span>)  <span class="hljs-comment"># 随机更改图像的色调</span><br><br>color_aug = torchvision.transforms.ColorJitter(<br>    brightness=<span class="hljs-number">0.5</span>, contrast=<span class="hljs-number">0.5</span>, saturation=<span class="hljs-number">0.5</span>, hue=<span class="hljs-number">0.5</span>)<br>apply(img, color_aug) <span class="hljs-comment"># 创建一个RandomColorJitter实例，并设置如何同时随机更改图像的亮度（brightness）、对比度（contrast）、饱和度（saturation）和色调（hue）</span><br></code></pre></td></tr></table></figure><p>结合一下多种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">augs = torchvision.transforms.Compose([<br>    torchvision.transforms.RandomHorizontalFlip(), color_aug, shape_aug])<br>apply(img, augs)<br></code></pre></td></tr></table></figure><h2 id="微调">微调</h2><p>也叫<em>迁移学习</em>（transfer learning），将从<em>源数据集</em>学到的知识迁移到<em>目标数据集</em></p><p><img src="https://zh.d2l.ai/_images/finetune.svg" alt="微调"></p><p>最后一层 不能直接使用，因为标号可能变了</p><p>特征提取模块可能仍然对我的数据有用</p><p>一个目标数据集上的正常训练任务  但是用更强的正则化</p><ul><li>使用更小的学习率</li><li>使用更少的数据迭代</li></ul><p>源数据集远复杂于目标数据，通常微调效果更好</p><p>固定一些层</p><ul><li>低层次的特征跟家通用</li><li>高层次的特征则更跟数据集相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = models.resnet18(pretrained=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 自动下载预训练的模型参数</span><br>model.fc = nn.Linear(model.fc.in_features, n_class) <span class="hljs-comment"># 最后一层的输出种类，换成当前数据集有多少种类</span><br>optimizer = optim.Adam(model.fc.parameters())<br></code></pre></td></tr></table></figure><h2 id="目标检测和边界框">目标检测和边界框</h2><p>在图像分类任务中，我们假设图像中只有一个主要物体对象，我们只关注如何识别其类别。 然而，很多时候图像里有多个我们感兴趣的目标，我们不仅想知道它们的类别，还想得到它们在图像中的具体位置。 在计算机视觉里，我们将这类任务称为<em>目标检测</em>（object detection）或<em>目标识别</em>（object recognition）。</p><p><strong>边界框</strong></p><p>一个边缘框可以通过四个数字定义，边界框是矩形的，由矩形左上角的以及右下角的(x)和(y)坐标决定。 另一种常用的边界框表示方法是边界框中心的((x, y))轴坐标以及框的宽度和高度。</p><p><strong>锚框</strong></p><p>目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边界从而更准确地预测目标的<em>真实边界框</em>（ground-truth bounding box）。 不同的模型使用的区域采样方法可能不同。 这里我们介绍其中的一种方法：以每个像素为中心，生成多个缩放比和宽高比（aspect ratio）不同的边界框。 这些边界框被称为<em>锚框</em>（anchor box）</p><h2 id="目标检测过程">目标检测过程</h2><p>简化的过程：</p><ul><li><p>首先生成大量锚框</p></li><li><p>赋予标号，</p></li><li><p>每个锚框作为一个样本进行训练</p></li></ul><p><em>杰卡德系数</em>（Jaccard）可以衡量锚框和真实边界框之间的相似性。 给定集合A和B，他们的杰卡德系数是他们交集的大小除以他们并集的大小，也就是交并比（IoU）</p><p><img src="https://zh.d2l.ai/_images/iou.svg" alt="杰卡德系数-交并比"></p><p>在预测时，使用NMS来去除冗余的预测。</p><p>比较知名目标检测数据的有COCO(<a href="http://cocodataset.org">cocodataset.org</a>)</p><h2 id="R-CNN">R-CNN</h2><p>区域卷积神经网络（region-based CNN或regions with CNN features，R-CNN）</p><p>R-CNN包括以下四个步骤：</p><ol><li>对输入图像使用<em>选择性搜索</em>来选取多个高质量的提议区域 。这些提议区域通常是在多个尺度下选取的，并具有不同的形状和大小。每个提议区域都将被标注类别和真实边界框；</li><li>选择一个预训练的卷积神经网络，并将其在输出层之前截断。将每个提议区域变形为网络需要的输入尺寸，并通过前向传播输出抽取的提议区域特征；</li><li>将每个提议区域的特征连同其标注的类别作为一个样本。训练多个支持向量机对目标分类，其中每个支持向量机用来判断样本是否属于某一个类别；</li><li>将每个提议区域的特征连同其标注的边界框作为一个样本，训练线性回归模型来预测真实边界框。</li></ol><h3 id="Fast-R-CNN">Fast R-CNN</h3><p>Fast R-CNN引入了<em>兴趣区域汇聚层</em>（RoI pooling）：将卷积神经网络的输出和提议区域作为输入，输出连结后的各个提议区域抽取的特征</p><p><img src="https://zh.d2l.ai/_images/fast-rcnn.svg" alt="fast R-CNN"></p><p><strong>兴趣区域(ROI)池化层</strong></p><p>给定一个锚框，均匀分割成n * m 块，输出每块里的最大值,不管锚框多大，总是输出nm个值.</p><p>作用：让每个锚框编程自己想要的模样,接着使用CNN对图片抽取特征，最后使用ROI池化层对每个锚框生成固定锚框特征。</p><h3 id="Faster-R-CNN">Faster R-CNN</h3><p>为了较精确地检测目标结果，Fast R-CNN模型通常需要在选择性搜索中生成大量的提议区域。 <em>Faster R-CNN</em> 提出将选择性搜索替换为<em>区域提议网络</em>（region proposal network），从而减少提议区域的生成数量，并保证目标检测的精度。</p><p>使用一个区域提议网络来替代启发式搜索来获得更好的锚框</p><p><img src="https://zh.d2l.ai/_images/faster-rcnn.svg" alt="Faster R-CNN"></p><h3 id="Mask-R-CNN">Mask R-CNN</h3><p>如果在训练集中还标注了每个目标在图像上的像素级位置，那么<em>Mask R-CNN</em>能够有效地利用这些详尽的标注信息进一步提升目标检测的精度。如果有像素级别的标号，使用FCN来利用这些信息</p><p><img src="https://zh.d2l.ai/_images/mask-rcnn.svg" alt="Mask R-CNN"></p><p>Mask R-CNN是基于Faster R-CNN修改而来的。 具体来说，Mask R-CNN将兴趣区域汇聚层替换为了 <em>兴趣区域对齐</em>层，使用<em>双线性插值</em>（bilinear interpolation）来保留特征图上的空间信息，从而更适于像素级预测。</p><h2 id="单发多框检测">单发多框检测</h2><p>单发多框检测（SSD）  该模型简单、快速且被广泛使用。尽管这只是其中一种目标检测模型，但本节中的一些设计原则和实现细节也适用于其他模型。</p><p>此模型主要由基础网络组成，其后是几个多尺度特征块。 基本网络用于从输入图像中提取特征，因此它可以使用深度卷积神经网络。</p><p><img src="https://zh.d2l.ai/_images/ssd.svg" alt="单发多框检测模型主要由一个基础网络块和若干多尺度特征块串联而成"></p><p>简单的来总结就是：</p><ul><li><p>ssd通过单神经网络来检测模型</p></li><li><p>以每个像素为中心的产生多个锚框</p></li><li><p>在多个端的输出上进行多尺度的检测</p></li></ul><h2 id="YOLO">YOLO</h2><p>名字由来于<em>you only look once</em>，是Joseph Redmon和Ali Farhadi等人于2015年提出的基于单个神经网络的目标检测系统。在2017年CVPR上，Joseph Redmon和Ali Farhadi又发表的YOLO 2，进一步提高了检测的精度和速度。yolo将图片均匀分成s*s个锚框，每个锚框预测B个边缘框。</p><p>//todo  有需要的话，后面再单独写一篇YOLO的文章</p><h2 id="分割">分割</h2><p>语义分割：</p><p>语义分割将图片中的每个像素分类到对应的类别</p><p>应用：</p><p>背景虚化</p><p>路面分割</p><p>实例分割 区别狗1  狗2</p><p>最重要的语义分割数据集Pascal VOC2012</p><h2 id="转置卷积">转置卷积</h2><p>卷积不会增大输入的高宽，通常要么不变，要么减半</p><p>转置卷积则可以用户来增大输入高宽</p><p>为什么叫做转置</p><p>转置卷积也是一种卷积</p><p>同反卷积的关系</p><p>数学上的反卷积是指卷积的逆运算</p><p>反卷积很少用在深度学习中</p><p>我们说的反卷积神经网络指用了转置卷积的神经网络</p><h2 id="全连接卷积神经网络">全连接卷积神经网络</h2><p>也就是FCN</p><p>是用深度神经网络来做语义分割的奠基性工作</p><p>他用转置卷积层来替换CNN最后的全连接层，从而可以实现每个像素的预测</p><h2 id="样式迁移">样式迁移</h2><p>将样式图片的样式迁移到内容图片上，得到合成图片</p><p><img src="https://zh.d2l.ai/_images/neural-style.svg" alt="基于卷积神经网络的风格迁移"></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注意力机制</title>
    <link href="/2024/08/01/attention/"/>
    <url>/2024/08/01/attention/</url>
    
    <content type="html"><![CDATA[<h2 id="注意力机制">注意力机制</h2><p>人在观察事物时会有<strong>选择性的关注较为重要的信息</strong>，称其为<strong>注意力</strong>。通过持续关注这一关键位置以获得更多的信息，而忽略其他的无用信息，这种视觉注意力机制大大提高了我们处理信息的效率和准确性。注意力机制中，可以通过query和key来有偏向性的选择输入</p><h2 id="注意力分数">注意力分数</h2><p><img src="https://zh.d2l.ai/_images/attention-output.svg" alt="计算注意力汇聚的输出为值的加权值"></p><h3 id="加性注意力">加性注意力</h3><p>一般来说，当查询和键是不同长度的矢量时，可以使用加性注意力作为评分函数。等价于将key和value合并起来后放在一个隐藏层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdditiveAttention</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(AdditiveAttention, self).__init__(**kwargs)<br>        self.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        self.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        self.w_v = nn.Linear(num_hiddens, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):</span><br>        queries, keys = self.W_q(queries), self.W_k(keys)<br>        <span class="hljs-comment"># 在维度扩展后，</span><br>        <span class="hljs-comment"># queries的形状：(batch_size，查询的个数，1，num_hidden)</span><br>        <span class="hljs-comment"># key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># 使用广播方式进行求和</span><br>        features = queries.unsqueeze(<span class="hljs-number">2</span>) + keys.unsqueeze(<span class="hljs-number">1</span>)<br>        features = torch.tanh(features)<br>        <span class="hljs-comment"># self.w_v仅有一个输出，因此从形状中移除最后那个维度。</span><br>        <span class="hljs-comment"># scores的形状：(batch_size，查询的个数，“键-值”对的个数)</span><br>        scores = self.w_v(features).squeeze(-<span class="hljs-number">1</span>)<br>        self.attention_weights = masked_softmax(scores, valid_lens)<br>        <span class="hljs-comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span><br>        <span class="hljs-keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)<br></code></pre></td></tr></table></figure><h3 id="缩放点积注意力">缩放点积注意力</h3><p>使用点积可以得到计算效率更高的评分函数， 但是点积操作要求查询和键具有相同的长度d。 假设查询和键的所有元素都是独立的随机变量， 并且都满足零均值和单位方差， 那么两个向量的点积的均值为0，方差为d。 为确保无论向量长度如何， 点积的方差在不考虑向量长度的情况下仍然是1， 我们再将点积除以 √￣d， 则<em>缩放点积注意力</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DotProductAttention</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;缩放点积注意力&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dropout, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(DotProductAttention, self).__init__(**kwargs)<br>        self.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-comment"># queries的形状：(batch_size，查询的个数，d)</span><br>    <span class="hljs-comment"># keys的形状：(batch_size，“键－值”对的个数，d)</span><br>    <span class="hljs-comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span><br>    <span class="hljs-comment"># valid_lens的形状:(batch_size，)或者(batch_size，查询的个数)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens=<span class="hljs-literal">None</span></span>):</span><br>        d = queries.shape[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 设置transpose_b=True为了交换keys的最后两个维度</span><br>        scores = torch.bmm(queries, keys.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) / math.sqrt(d)<br>        self.attention_weights = masked_softmax(scores, valid_lens)<br>        <span class="hljs-keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)<br></code></pre></td></tr></table></figure><h2 id="自注意力">自注意力</h2><p>自注意力的问题在于没有训练任何东西。于是我们自然地会想到如果向其中添加一些可训练的参数，网络应该可以学习到一些模式，从而提供更好的上下文。于是便引入了 <strong>查询(Query), 键(Key), 值(Value)</strong> 的思想。自注意力将某一时间的既作为key,value,query作为输入</p><h2 id="多头注意力">多头注意力</h2><p>用独立学习得到的h组不同的 <em>线性投影</em>（linear projections）来变换查询、键和值。 然后，这h组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这h个注意力汇聚的输出拼接在一起， 并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。 这种设计被称为<em>多头注意力</em>（multihead attention）,也就是使用h个独立的注意力池化，合并各个头输出得到最终输出</p><p><img src="https://zh.d2l.ai/_images/multi-head-attention.svg" alt="多头注意力：多个头连结然后线性变换"></p><h2 id="Transformer">Transformer</h2><p>Transformer模型完全基于注意力机制，没有任何卷积层或循环神经网络层。尽管Transformer最初是应用于在文本数据上的序列到序列学习，但现在已经推广到各种现代的深度学习中，例如语言、视觉、语音和强化学习领域。Transformer是由编码器和解码器组成的。Transformer的编码器和解码器是基于自注意力的模块叠加而成的，源（输入）序列和目标（输出）序列的<em>嵌入</em>（embedding）表示将加上<em>位置编码</em>（positional encoding），再分别输入到编码器和解码器中。</p><p><img src="https://zh.d2l.ai/_images/transformer.svg" alt="transformer架构"></p><ul><li>基于编码器-解码器来处理序列对</li><li>纯基于注意力</li></ul><h3 id="基于位置的前馈网络">基于位置的前馈网络</h3><p>基于位置的前馈网络对序列中的所有位置的表示进行变换时使用的是同一个多层感知机（MLP），这就是称前馈网络是<em>基于位置的</em>（positionwise）的原因。</p><h3 id="残差连接和层规范化">残差连接和层规范化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">ln = nn.LayerNorm(<span class="hljs-number">2</span>)<br>bn = nn.BatchNorm1d(<span class="hljs-number">2</span>)<br>X = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], dtype=torch.float32)<br><span class="hljs-comment"># 在训练模式下计算X的均值和方差</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;layer norm:&#x27;</span>, ln(X), <span class="hljs-string">&#x27;\nbatch norm:&#x27;</span>, bn(X))<br><br><span class="hljs-comment">#@save</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddNorm</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, normalized_shape, dropout, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(AddNorm, self).__init__(**kwargs)<br>        self.dropout = nn.Dropout(dropout)<br>        self.ln = nn.LayerNorm(normalized_shape)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X, Y</span>):</span><br>        <span class="hljs-keyword">return</span> self.ln(self.dropout(Y) + X)<br></code></pre></td></tr></table></figure><h3 id="编码器">编码器</h3><p>有了组成Transformer编码器的基础组件，现在可以先实现编码器中的一个层。下面的<code>EncoderBlock</code>类包含两个子层：多头自注意力和基于位置的前馈网络，这两个子层都使用了残差连接和紧随的层规范化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncoderBlock</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span></span><br><span class="hljs-params"><span class="hljs-function">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span></span><br><span class="hljs-params"><span class="hljs-function">                 dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(EncoderBlock, self).__init__(**kwargs)<br>        self.attention = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout,<br>            use_bias)<br>        self.addnorm1 = AddNorm(norm_shape, dropout)<br>        self.ffn = PositionWiseFFN(<br>            ffn_num_input, ffn_num_hiddens, num_hiddens)<br>        self.addnorm2 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X, valid_lens</span>):</span><br>        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))<br>        <span class="hljs-keyword">return</span> self.addnorm2(Y, self.ffn(Y))<br></code></pre></td></tr></table></figure><h3 id="解码器">解码器</h3><p>Transformer解码器也是由多个相同的层组成。在<code>DecoderBlock</code>类中实现的每个层包含了三个子层：解码器自注意力、“编码器-解码器”注意力和基于位置的前馈网络。这些子层也都被残差连接和紧随的层规范化围绕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoderBlock</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span></span><br><span class="hljs-params"><span class="hljs-function">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span></span><br><span class="hljs-params"><span class="hljs-function">                 dropout, i, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(DecoderBlock, self).__init__(**kwargs)<br>        self.i = i<br>        self.attention1 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        self.addnorm1 = AddNorm(norm_shape, dropout)<br>        self.attention2 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        self.addnorm2 = AddNorm(norm_shape, dropout)<br>        self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens,<br>                                   num_hiddens)<br>        self.addnorm3 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X, state</span>):</span><br>        enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 训练阶段，输出序列的所有词元都在同一时间处理，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]初始化为None。</span><br>        <span class="hljs-comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span><br>        <span class="hljs-keyword">if</span> state[<span class="hljs-number">2</span>][self.i] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            key_values = X<br>        <span class="hljs-keyword">else</span>:<br>            key_values = torch.cat((state[<span class="hljs-number">2</span>][self.i], X), axis=<span class="hljs-number">1</span>)<br>        state[<span class="hljs-number">2</span>][self.i] = key_values<br>        <span class="hljs-keyword">if</span> self.training:<br>            batch_size, num_steps, _ = X.shape<br>            <span class="hljs-comment"># dec_valid_lens的开头:(batch_size,num_steps),</span><br>            <span class="hljs-comment"># 其中每一行是[1,2,...,num_steps]</span><br>            dec_valid_lens = torch.arange(<br>                <span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            dec_valid_lens = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 自注意力</span><br>        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)<br>        Y = self.addnorm1(X, X2)<br>        <span class="hljs-comment"># 编码器－解码器注意力。</span><br>        <span class="hljs-comment"># enc_outputs的开头:(batch_size,num_steps,num_hiddens)</span><br>        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)<br>        Z = self.addnorm2(Y, Y2)<br>        <span class="hljs-keyword">return</span> self.addnorm3(Z, self.ffn(Z)), state<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代卷积神经网络模型</title>
    <link href="/2024/07/31/convolutional-modern/"/>
    <url>/2024/07/31/convolutional-modern/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">前言:依据李沐视频整理</p><h2 id="AlexNet">AlexNet</h2><p>2012年，AlexNet横空出世。它首次证明了学习到的特征可以超越手工设计的特征。它一举打破了计算机视觉研究的现状。 AlexNet使用了8层卷积神经网络，并以很大的优势赢得了2012年ImageNet图像识别挑战赛。是一个更深更大的LeNet。</p><p><img src="https://zh.d2l.ai/_images/alexnet.svg" alt="从LeNet到AlexNet"></p><p>主要改进:</p><ul><li><p>使用将sigmoid激活函数改为更简单的ReLU激活函数，ReLU激活函数的计算更简单</p></li><li><p>使用了dropout丢弃法防止过拟合</p></li><li><p>使用最大汇聚层MaxPooling替代平均汇聚层</p></li></ul><p>来看看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.Sequential(<br>    <span class="hljs-comment"># 这里使用一个11*11的更大窗口来捕捉对象。</span><br>    <span class="hljs-comment"># 同时，步幅为4，以减少输出的高度和宽度。</span><br>    <span class="hljs-comment"># 另外，输出通道的数目远大于LeNet</span><br>    nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">96</span>, kernel_size=<span class="hljs-number">11</span>, stride=<span class="hljs-number">4</span>, padding=<span class="hljs-number">1</span>), nn.ReLU(),<br>    nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>    <span class="hljs-comment"># 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数</span><br>    nn.Conv2d(<span class="hljs-number">96</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>), nn.ReLU(),<br>    nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>    <span class="hljs-comment"># 使用三个连续的卷积层和较小的卷积窗口。</span><br>    <span class="hljs-comment"># 除了最后的卷积层，输出通道的数量进一步增加。</span><br>    <span class="hljs-comment"># 在前两个卷积层之后，汇聚层不用于减少输入的高度和宽度</span><br>    nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">384</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>), nn.ReLU(),<br>    nn.Conv2d(<span class="hljs-number">384</span>, <span class="hljs-number">384</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>), nn.ReLU(),<br>    nn.Conv2d(<span class="hljs-number">384</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>), nn.ReLU(),<br>    nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>    nn.Flatten(),<br>    <span class="hljs-comment"># 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合</span><br>    nn.Linear(<span class="hljs-number">6400</span>, <span class="hljs-number">4096</span>), nn.ReLU(),<br>    nn.Dropout(p=<span class="hljs-number">0.5</span>),<br>    nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>), nn.ReLU(),<br>    nn.Dropout(p=<span class="hljs-number">0.5</span>),<br>    <span class="hljs-comment"># 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span><br>    nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805161551620.png" alt="训练完成"></p><h2 id="VGG">VGG</h2><p>与AlexNet、LeNet一样，VGG网络可以分为两部分：第一部分主要由卷积层和汇聚层组成，第二部分由全连接层组成。其中最大的特点就是VGG使用了VGG块来进行重复。</p><p><img src="https://zh.d2l.ai/_images/vgg.svg" alt="VGG结构"></p><p>一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层。在最初的VGG论文中 [Simonyan and Zisserman, 2014]，作者使用了带有3×3卷积核、填充为1（保持高度和宽度）的卷积层，和带有2×2汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层。是一个更大更深的AlexNet (重复的VGG块)。</p><p>它的思想是使用可重复使用的卷积快来构建深度卷积神经网络，不同的卷积快个数和超参数可以得到不同复杂度的变种。</p><p>来看看实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br><span class="hljs-comment"># vgg的块</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vgg_block</span>(<span class="hljs-params">num_convs, in_channels, out_channels</span>):</span><br>    layers = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layers.append(nn.Conv2d(in_channels, out_channels,<br>                                kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br>        layers.append(nn.ReLU())<br>        in_channels = out_channels<br>    layers.append(nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br><br><br>conv_arch = ((<span class="hljs-number">1</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vgg</span>(<span class="hljs-params">conv_arch</span>):</span><br>    conv_blks = []<br>    in_channels = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 卷积层部分</span><br>    <span class="hljs-keyword">for</span> (num_convs, out_channels) <span class="hljs-keyword">in</span> conv_arch:<br>        conv_blks.append(vgg_block(num_convs, in_channels, out_channels))<br>        in_channels = out_channels<br><br>    <span class="hljs-keyword">return</span> nn.Sequential(<br>        *conv_blks, nn.Flatten(),<br>        <span class="hljs-comment"># 全连接层部分</span><br>        nn.Linear(out_channels * <span class="hljs-number">7</span> * <span class="hljs-number">7</span>, <span class="hljs-number">4096</span>), nn.ReLU(), nn.Dropout(<span class="hljs-number">0.5</span>),<br>        nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>), nn.ReLU(), nn.Dropout(<span class="hljs-number">0.5</span>),<br>        nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">10</span>))<br><br>net = vgg(conv_arch)<br></code></pre></td></tr></table></figure><p>跑出来的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805155336497.png" alt="vgg"></p><h2 id="NiN">NiN</h2><p>最初的NiN网络是在AlexNet后不久提出的，显然从中得到了一些启示。 NiN使用窗口形状为11×11、5×5和3×3的卷积层，输出通道数量与AlexNet中的相同。 每个NiN块后有一个最大汇聚层，汇聚窗口形状为3×3，步幅为2。</p><p>NiN和AlexNet之间的一个显著区别是NiN完全取消了全连接层。 相反，NiN使用一个NiN块，其输出通道数等于标签类别的数量。最后放一个<em>全局平均汇聚层</em>（global average pooling layer），生成一个对数几率 （logits）。NiN设计的一个优点是，它显著减少了模型所需参数的数量。</p><p>结构示意；</p><p><img src="https://zh.d2l.ai/_images/nin.svg" alt="nin结构"></p><p>特点：</p><ul><li><p>无全连接层，使用全局平均池化层来代替VGG和AlexNet中的全连接层，最后使用全局平均池化层得到输出  其输出通道数是类别数</p></li><li><p>交替使用NiN块和步幅为2的组大池化层  逐步减少高宽和增大通道数</p></li><li><p>NiN块使用卷积层加两个1X1卷积层  后者队每个像素增加了非线性性</p></li><li><p>不容易过拟合，更少的参数</p></li></ul><p>又来看看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nin_block</span>(<span class="hljs-params">in_channels, out_channels, kernel_size, strides, padding</span>):</span><br>    <span class="hljs-keyword">return</span> nn.Sequential(<br>        nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding),<br>        nn.ReLU(),<br>        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="hljs-number">1</span>), nn.ReLU(),<br>        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="hljs-number">1</span>), nn.ReLU())<br><br>net = nn.Sequential(<br>    nin_block(<span class="hljs-number">1</span>, <span class="hljs-number">96</span>, kernel_size=<span class="hljs-number">11</span>, strides=<span class="hljs-number">4</span>, padding=<span class="hljs-number">0</span>),<br>    nn.MaxPool2d(<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>    nin_block(<span class="hljs-number">96</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">5</span>, strides=<span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>    nn.MaxPool2d(<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>    nin_block(<span class="hljs-number">256</span>, <span class="hljs-number">384</span>, kernel_size=<span class="hljs-number">3</span>, strides=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>),<br>    nn.MaxPool2d(<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>    nn.Dropout(<span class="hljs-number">0.5</span>),<br>    <span class="hljs-comment"># 标签类别数是10</span><br>    nin_block(<span class="hljs-number">384</span>, <span class="hljs-number">10</span>, kernel_size=<span class="hljs-number">3</span>, strides=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>),<br>    nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)),<br>    <span class="hljs-comment"># 将四维的输出转成二维的输出，其形状为(批量大小,10)</span><br>    nn.Flatten())<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805161420959.png" alt="训练结果"></p><p><span class = "note note-danger">不经常使用</span></p><h2 id="GoogLeNet">GoogLeNet</h2><p>首先从名字就能看出是谷歌开发的，其中名字还有玩梗，将L大写，致敬了LeNet。</p><p>其中一个独特的结构就是Inception块，这个块的特点就是，小学才做选择题，我全都要 。这个块的名字还和电影盗梦空间原本的英文名一样，取名天才。</p><p><img src="https://zh.d2l.ai/_images/inception.svg" alt="inception"></p><p>Inception块由四条并行路径组成。 前三条路径使用窗口大小为1×1、3×3和5×5的卷积层，从不同空间大小中提取信息。 中间的两条路径在输入上执行1×1卷积，以减少通道数，从而降低模型的复杂性。 第四条路径使用3×3最大汇聚层，然后使用1×1卷积层来改变通道数。 这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。在Inception块中，通常调整的超参数是每层输出通道数。四个路径从不同层面抽取信息，然后再输出通道维合并。这个块跟单3x3,5x5卷积层比，Inception块有跟梢的参数个数和计算复杂度。</p><p>GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值。Inception块之间的最大汇聚层可降低维度。 第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层避免了在最后使用全连接层。</p><p><strong>该网络的结构</strong></p><p><img src="https://zh.d2l.ai/_images/inception-full.svg" alt="GoogLeNet"></p><p>继续来看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inception</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-comment"># c1--c4是每条路径的输出通道数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>(Inception, self).__init__(**kwargs)<br>        <span class="hljs-comment"># 线路1，单1x1卷积层</span><br>        self.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 线路2，1x1卷积层后接3x3卷积层</span><br>        self.p2_1 = nn.Conv2d(in_channels, c2[<span class="hljs-number">0</span>], kernel_size=<span class="hljs-number">1</span>)<br>        self.p2_2 = nn.Conv2d(c2[<span class="hljs-number">0</span>], c2[<span class="hljs-number">1</span>], kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 线路3，1x1卷积层后接5x5卷积层</span><br>        self.p3_1 = nn.Conv2d(in_channels, c3[<span class="hljs-number">0</span>], kernel_size=<span class="hljs-number">1</span>)<br>        self.p3_2 = nn.Conv2d(c3[<span class="hljs-number">0</span>], c3[<span class="hljs-number">1</span>], kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span><br>        self.p4_1 = nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)<br>        self.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        p1 = F.relu(self.p1_1(x))<br>        p2 = F.relu(self.p2_2(F.relu(self.p2_1(x))))<br>        p3 = F.relu(self.p3_2(F.relu(self.p3_1(x))))<br>        p4 = F.relu(self.p4_2(self.p4_1(x)))<br>        <span class="hljs-comment"># 在通道维度上连结输出</span><br>        <span class="hljs-keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="hljs-number">1</span>)<br>    <br>b1 = nn.Sequential(nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">7</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">3</span>),<br>                   nn.ReLU(),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b2 = nn.Sequential(nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">1</span>),<br>                   nn.ReLU(),<br>                   nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">192</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>                   nn.ReLU(),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b3 = nn.Sequential(Inception(<span class="hljs-number">192</span>, <span class="hljs-number">64</span>, (<span class="hljs-number">96</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">16</span>, <span class="hljs-number">32</span>), <span class="hljs-number">32</span>),<br>                   Inception(<span class="hljs-number">256</span>, <span class="hljs-number">128</span>, (<span class="hljs-number">128</span>, <span class="hljs-number">192</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">96</span>), <span class="hljs-number">64</span>),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b4 = nn.Sequential(Inception(<span class="hljs-number">480</span>, <span class="hljs-number">192</span>, (<span class="hljs-number">96</span>, <span class="hljs-number">208</span>), (<span class="hljs-number">16</span>, <span class="hljs-number">48</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">512</span>, <span class="hljs-number">160</span>, (<span class="hljs-number">112</span>, <span class="hljs-number">224</span>), (<span class="hljs-number">24</span>, <span class="hljs-number">64</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">512</span>, <span class="hljs-number">128</span>, (<span class="hljs-number">128</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">24</span>, <span class="hljs-number">64</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">512</span>, <span class="hljs-number">112</span>, (<span class="hljs-number">144</span>, <span class="hljs-number">288</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">64</span>), <span class="hljs-number">64</span>),<br>                   Inception(<span class="hljs-number">528</span>, <span class="hljs-number">256</span>, (<span class="hljs-number">160</span>, <span class="hljs-number">320</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">128</span>), <span class="hljs-number">128</span>),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br><br>b5 = nn.Sequential(Inception(<span class="hljs-number">832</span>, <span class="hljs-number">256</span>, (<span class="hljs-number">160</span>, <span class="hljs-number">320</span>), (<span class="hljs-number">32</span>, <span class="hljs-number">128</span>), <span class="hljs-number">128</span>),<br>                   Inception(<span class="hljs-number">832</span>, <span class="hljs-number">384</span>, (<span class="hljs-number">192</span>, <span class="hljs-number">384</span>), (<span class="hljs-number">48</span>, <span class="hljs-number">128</span>), <span class="hljs-number">128</span>),<br>                   nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)),<br>                   nn.Flatten())<br><br>net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805161339118.png" alt="训练结果"></p><h2 id="批量归一化">批量归一化</h2><p>在每次训练迭代中，我们首先规范化输入，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。 接下来，我们应用比例系数和比例偏移。 正是由于这个基于<em>批量</em>统计的<em>标准化</em>，才有了<em>批量规范化</em>的名称。固定小批量里面的均值和方差，然后再做额外的调整。</p><p>从形式上来说，用x∈B表示一个来自小批量B的输入，批量规范化BN根据以下表达式转换x：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805163203157.png" alt="公式"></p><p>作用在全连接层和卷积层输出上，激活函数前面，全连接层和卷积层输入上，对于全连接层，作用在特征维，对于卷积层，作用在通道维。</p><p>最初论文是想用它来减少内部协变量转移，后续论文指出它可能就是通过在每个小批量里加入噪声来控制模型复杂度，因此没必要跟丢弃法混合使用</p><p>总结</p><ul><li>固定小批量中的均值和方差，然后学习出适合的偏移和缩放</li><li>批量规范化有许多有益的副作用，主要是正则化</li><li>Batch Normalization批量归一化方法可以加速神经网络的收敛，但一般不改变模型精度。仅在Batch中包含样本数量较多时有效。</li><li>对循环网络(RNN)或序列数据(Sequence)性能较差。</li><li>分布式运算时影响效率。</li></ul><p>后续又提出了：</p><ul><li>Layer Normalization:在每一个样本特征空间内的归一化。</li><li>Instance Normalization:在每一个样本特征空间内逐通道的归一化。</li></ul><h2 id="ResNet">ResNet</h2><p>学习ResNet首先要明白的就是残差块的概念：</p><ul><li>串联一个层改变函数类，我们希望能扩大函数类</li><li>残差块加入快速通道来得到<code>f(x) = x + g(x)</code> 的结构</li></ul><p><img src="https://zh.d2l.ai/_images/residual-block.svg" alt="残差块"></p><p>ResNet沿用了VGG完整的3×3卷积层设计。 残差块里首先有2个有相同输出通道数的3×3卷积层。 每个卷积层后接一个批量规范化层和ReLU激活函数。 然后我们通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前。 这样的设计要求2个卷积层的输出与输入形状一样，从而使它们可以相加。 如果想改变通道数，就需要引入一个额外的1×1卷积层来将输入变换成需要的形状后再做相加运算。</p><p><img src="https://zh.d2l.ai/_images/resnet-block.svg" alt="没有1x1卷积层，有1x1卷积层"></p><p>每个模块有4个卷积层（不包括恒等映射的1×1卷积层）。 加上第一个7×7卷积层和最后一个全连接层，共有18层。 因此，这种模型通常被称为ResNet-18。 通过配置不同的通道数和模块里的残差块数可以得到不同的ResNet模型，例如更深的含152层的ResNet-152。 虽然ResNet的主体架构跟GoogLeNet类似，但ResNet架构更简单，修改也更方便。这些因素都导致了ResNet迅速被广泛使用。</p><p><img src="https://zh.d2l.ai/_images/resnet18.svg" alt="ResNet"></p><p>来看看代码的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Residual</span>(<span class="hljs-params">nn.Module</span>):</span>  <span class="hljs-comment">#@save</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, input_channels, num_channels,</span></span><br><span class="hljs-params"><span class="hljs-function">                 use_1x1conv=<span class="hljs-literal">False</span>, strides=<span class="hljs-number">1</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(input_channels, num_channels,<br>                               kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>, stride=strides)<br>        self.conv2 = nn.Conv2d(num_channels, num_channels,<br>                               kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> use_1x1conv:<br>            self.conv3 = nn.Conv2d(input_channels, num_channels,<br>                                   kernel_size=<span class="hljs-number">1</span>, stride=strides)<br>        <span class="hljs-keyword">else</span>:<br>            self.conv3 = <span class="hljs-literal">None</span><br>        self.bn1 = nn.BatchNorm2d(num_channels)<br>        self.bn2 = nn.BatchNorm2d(num_channels)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        Y = F.relu(self.bn1(self.conv1(X)))<br>        Y = self.bn2(self.conv2(Y))<br>        <span class="hljs-keyword">if</span> self.conv3:<br>            X = self.conv3(X)<br>        Y += X<br>        <span class="hljs-keyword">return</span> F.relu(Y)<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resnet_block</span>(<span class="hljs-params">input_channels, num_channels, num_residuals,</span></span><br><span class="hljs-params"><span class="hljs-function">                 first_block=<span class="hljs-literal">False</span></span>):</span><br>    blk = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_residuals):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> first_block:<br>            blk.append(Residual(input_channels, num_channels,<br>                                use_1x1conv=<span class="hljs-literal">True</span>, strides=<span class="hljs-number">2</span>))<br>        <span class="hljs-keyword">else</span>:<br>            blk.append(Residual(num_channels, num_channels))<br>    <span class="hljs-keyword">return</span> blk<br><br><br>b1 = nn.Sequential(nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">7</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">3</span>),<br>                   nn.BatchNorm2d(<span class="hljs-number">64</span>), nn.ReLU(),<br>                   nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>))<br>b2 = nn.Sequential(*resnet_block(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">2</span>, first_block=<span class="hljs-literal">True</span>))<br>b3 = nn.Sequential(*resnet_block(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">2</span>))<br>b4 = nn.Sequential(*resnet_block(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>, <span class="hljs-number">2</span>))<br>b5 = nn.Sequential(*resnet_block(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">2</span>))<br><br>net = nn.Sequential(b1, b2, b3, b4, b5,<br>                    nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)),<br>                    nn.Flatten(), nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805164013238.png" alt="训练结果"></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络CNN</title>
    <link href="/2024/07/30/CNN/"/>
    <url>/2024/07/30/CNN/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">前言:依据李沐视频整理</p><h2 id="什么是卷积神经网络">什么是卷积神经网络</h2><p>卷积神经网络（Convolutional Neural Network，CNN）：是一种前馈神经网络，最早可追溯到1986年的BP算法。</p><p>三大网络结构：卷积层（Conv2d）、池化层（MaxPool2d）、全连接层（Linear）<br>两大特点：稀疏连接、权值共享。可以用更少的参数，获得更高的性能。</p><h2 id="全连接层">全连接层</h2><p>全连接层（Fully Connected Layers，FC）：<span class = "label label-danger">torch.nn.Linear(n_hidden, classification_num)</span></p><p>卷积层、池化层、激活函数 —— 将原始数据映射到隐层特征空间，提取特征；</p><p>全连接层 —— 将学到的 “分布式特征” 映射到样本标记空间，进行分类</p><p>全连接层FC的缺点：</p><ul><li>（1）由于忽略了空间结构，故不适用于目标检测。如：分割任务中的FCN采用卷积层替换全连接层。</li><li>（2）全连接层的参数过多，导致模型复杂度提升，容易过拟合。如：ResNet、GoogleNet采用全局平均池化替换全连接层。</li></ul><p>全连接层FC的作用：这一步卷积还有一个非常重要的作用，就是将分布式特征representation映射到样本标记空间。简单来说，就是将输入图像的所有特征整合到一起，输出一个值（猫 / 狗）。<br>效果：<span class = "label label-danger">大大减少目标位置的不同，而对分类结果带来的影响。</span></p><h2 id="从全连接到卷积">从全连接到卷积</h2><h3 id="平移不变性">平移不变性</h3><p>不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</p><h3 id="局部性">局部性</h3><p>只看附近的区域</p><p>神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</p><h2 id="卷积层">卷积层</h2><p>对全连接层使用平移不变性和局部性得到卷积层，卷积层是一个特殊的全连接层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.Conv2d(in_channels=<span class="hljs-number">3</span>, out_channels=<span class="hljs-number">16</span>, kernel_size=<span class="hljs-number">5</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p class="note note-info">卷积神经网络的核心网络层是卷积层，而卷积层的核心是卷积</p><h3 id="卷积运算">卷积运算</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240724151136946.png" alt="image-20240724151136946"></p><p>卷积运算公式</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>=</mo><mfrac><mrow><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>−</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo>+</mo><mn>2</mn><mo>∗</mo><mi>p</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">output = \frac{input - kernel + 2 * padding}{stride} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">tp</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">in</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p><strong>卷积运算的详细过程：</strong></p><p>1、取（3 x 3）输入图像中的（2 x 2）矩阵，然后与（2 x 2）卷积核进行卷积运算，得到一个计算结果（ <code>0 * 0 + 1 * 1 + 3 * 2 + 4 * 3 = 19</code>）；</p><p>2、通过滑窗，循环计算得到输出特征图（2 x 2）。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240724152527092.png" alt="image-20240724152527092"></p><p>用不同的卷积核能实现不同的效果，如边缘检测，图像锐化，高斯模糊</p><p>卷积层将输出和核矩阵进行交叉运算，加上偏移后得到输出</p><p><code>Y = wX + b</code></p><p>w(核矩阵)和b(偏移)是可学习的参数</p><h3 id="权值共享">权值共享</h3><p><img src="https://pic1.zhimg.com/v2-aaad3a67aac2b7b1412455eb331b7977_1200x500.jpg" alt="CNN中卷积层的计算细节 - 知乎"></p><p>卷积运算（多通道）</p><p>1、Kernels卷积核计算<br>每个 Kernel 的 3 个channle（R/G/B）分别与 Input 对应的 3 个channle（R/G/B）进行卷积运算，最后每个 Kernel 得到 3 个（6 * 6） feature_map_0 。</p><p>2、Feature Maps特征图计算<br>将 3 个（6 * 6）的 feature_map0 逐元素相加（即通道融合）得到 1 个 feature_map_1；<br>然后将 feature_map1 的每个元素都加上其对应的偏置 b1，得到该 Kernel 的 FeatureMap1。<br>同一个 Kernel1 对应的 3 个 channle 共享一个偏置 b1（权值共享1）<br>同一个 FeatureMap1 的所有元素共享一个卷积核 Kernel1（权值共享2）<br>同理其余Kernel，最后得到（6 * 6 * 5） 个 Feature Maps（即最终输出的 channel 数等于 Kernel 的个数）。</p><p>3、Feature Vector向量计算<br>采用全局最大池化，分别计算每一个Feature Map，最终得到一个（1 * 1 * 5）Feature Vector。</p><h3 id="边界填充Padding">边界填充Padding</h3><p>图像尺寸对齐，保持边界信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.Conv2d(in_channels=<span class="hljs-number">3</span>, out_channels=<span class="hljs-number">16</span>, kernel_size=<span class="hljs-number">5</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>padding=1：表示在输入图像的边界填充 1 圈，全 0 元素。<br>作用：</p><ul><li>（1）图像尺寸对齐：对图像进行扩展，扩展区域补零。</li><li>（2）保持边界信息：若没有padding，卷积核将对输入图像的边界像素只卷积一次，而中间像素卷积多次，导致边界信息丢失。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240724153348514.png" alt="image-20240724153348514"></p><p class = "note note-info">补0圈数的计算公式为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">Padding = \frac{kernel - 1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>如果想要 con2d 出来的图片长宽没有变化, padding=(kernel_size-1)/2 当 stride=1</p><p>stride=1  表示行/列的滑动步长，也就是步幅，是成倍缩小尺寸，而这个参数的值就是缩小的具体倍数，比如步幅为2，输出就是输入的1/2；步幅为3，输出就是输入的1/3</p><h3 id="多输入输出通道">多输入输出通道</h3><p><strong>多输入通道</strong></p><p>每个通道都有一个卷积核，结果是所有通道卷积结果的和，由于输入和卷积核都有ci个通道，我们可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和（将ci的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p><p><img src="https://zh.d2l.ai/_images/conv-multi-in.svg" alt="多通道计算"></p><p><strong>多个输出通道</strong></p><p>我们可以有多个三位卷积核，每个核生成一个输出通道。用ci和co分别表示输入和输出通道的数目，并让kh和kw为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为ci×kh×kw的卷积核张量，这样卷积核的形状是co×ci×kh×kw。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p><p><strong>1x1卷积层</strong></p><p>它不识别空间模式，只是融合通道,通常用于调整网络层的通道数量和控制模型复杂性</p><p><img src="https://zh.d2l.ai/_images/conv-1x1.svg" alt="1x1卷积层计算"></p><h2 id="池化层">池化层</h2><p>通过卷积层获得的图像特征，可以直接训练分类，但很容易导致过拟合。因此需要降采样，增大感受野，防止过拟合。</p><p>池化（Pooling）：又叫下采样、降采样。<br>作用： 降采样（减少参数），增大感受野，提高运算速度及减小噪声影响，防止过拟合。</p><p>分类：</p><ul><li>局部池化<ul><li>最大池化（Max Pooling）：取Pooling窗口内的最大值作为采样值。</li><li>均值池化（Average Pooling）：取Pooling窗口内的所有值相加取均值作为采样值。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)<br>torch.nn.AvgPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>全局池化</li><li>全局最大池化（Global Max Pooling）：取以整个特征图为单位的最大值作为采样值。</li><li>全局均值池化（Global Average Pooling）：取以整个特征图为单位的所有值相加取均值作为采样值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.AdaptiveMaxPool2d(output_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>torch.nn.AdaptiveAvgPool2d(output_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p><span class = "label label-info">全局池化相比局部池化能减少更多参数，且泛化能力比较好，但唯一的不足之处是收敛速度比较慢。</span></p><h2 id="LeNet">LeNet</h2><p>LeNet是早期成功的神经网络。年代久远，这里就只是简单介绍介绍。</p><p>架构如图所示</p><p><img src="https://zh.d2l.ai/_images/lenet.svg" alt="leNet"></p><p>总体来看，LeNet（LeNet-5）由两个部分组成：</p><ul><li>卷积编码器：由两个卷积层组成;</li><li>全连接层密集块：由三个全连接层组成。</li></ul><p>来看看使用pytorch实现的该模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br>net = nn.Sequential(<br>    nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>), nn.Sigmoid(),<br>    nn.AvgPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">2</span>),<br>    nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, kernel_size=<span class="hljs-number">5</span>), nn.Sigmoid(),<br>    nn.AvgPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">2</span>),<br>    nn.Flatten(),<br>    nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>), nn.Sigmoid(),<br>    nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>), nn.Sigmoid(),<br>    nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p><img src="https://zh.d2l.ai/_images/lenet-vert.svg" alt="结构简化版"></p><p>先使用卷积层来学习图片空间信息，然后使用全连接层来转换到类别空间，在传统的卷积神经网络中，卷积块编码得到的表征在输出之前需由一个或多个全连接层进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化算法</title>
    <link href="/2024/07/28/optimization/"/>
    <url>/2024/07/28/optimization/</url>
    
    <content type="html"><![CDATA[<p>//todo</p><p>局部最小 vs 全局最小</p><p>使用迭代算法来求解，一般只能保证找到局部最小值</p><h2 id="凸函数优化">凸函数优化</h2><p>函数两个点连的线都在该函数上面</p><p>凸优化问题，局部最小一定是全局最小</p><p>凸</p><ul><li>线性回归</li><li>softmax回归</li></ul><p>非凸</p><ul><li>MLP，CNN，RNN，attention</li></ul><h2 id="动量法">动量法</h2><p>使用平滑过的梯度对权重更新</p><h2 id="Adam">Adam</h2><p>对梯度做平滑，且对梯度各个维度值做重新调整</p><h2 id="优化器">优化器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br>optimizer = torch.optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure><p>优化器（optimizer）：通过优化策略（梯度下降）来更新可学习参数（权值W和偏置bias），使得损失函数Loss值逐步降低，输出的模型更接近真实标签。<br>影响因素：（1）梯度方向（2）学习率</p><p>常用优化器：</p><ul><li>经典的梯度下降法。</li><li>梯度下降优化算法：SGD、SGDM、NAG。缺点：缓解了参数空间的方向问题，但需要新增参数，且对学习率的控制也不太理想。</li><li>自适应优化算法：AdaGrad（累积梯度平方）、RMSProp（累积梯度平方的滑动平均）、Adam（带动量项的RMSProp）, 自适应优化算法，学习率不再是一个固定不贬值，它会根据实际情况自动调整以适应环境。</li></ul><h2 id="学习率">学习率</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br>optimizer = torch.optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure><p>学习率（learning rate，lr）：用于控制权重参数的学习速度。一般情况下，学习率随着epoch的增大而逐渐减小，可以达到更好的训练效果。</p><p class = "note note-success">动态调整学习率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.optim.lr_scheduler.LambdaLR()：通过自定义 Lambda 函数来设置每个参数组的学习率。<br>torch.optim.lr_scheduler.MultiplicativeLR()：通过指定乘法因子来调整每个参数组的学习率。<br>torch.optim.lr_scheduler.StepLR()：在每个给定的步骤上降低学习率，步骤由用户定义。<br>torch.optim.lr_scheduler.MultiStepLR()：在每个给定的步骤上降低学习率，步骤由用户定义。<br>torch.optim.lr_scheduler.ExponentialLR()：每个周期按指数衰减学习率。<br>torch.optim.lr_scheduler.CosineAnnealingLR()：每个周期按余弦函数衰减。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门</title>
    <link href="/2024/07/25/deeplearningPreliminaries/"/>
    <url>/2024/07/25/deeplearningPreliminaries/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">前言:依据李沐视频整理</p><h2 id="数据操作">数据操作</h2><h3 id="按元素操作">按元素操作</h3><p>各个矩阵的元素都是按照对应位置来操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>y = torch.tensor([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br>x + y, x - y, x * y, x / y, x ** y  <span class="hljs-comment"># **运算符是求幂运算</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pyhton">(tensor([ 3.,  4.,  6., 10.]),<br> tensor([-1.,  0.,  2.,  6.]),<br> tensor([ 2.,  4.,  8., 16.]),<br> tensor([0.5000, 1.0000, 2.0000, 4.0000]),<br> tensor([ 1.,  4., 16., 64.]))<br></code></pre></td></tr></table></figure><p>逻辑判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">X == Y<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],<br>        [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],<br>        [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>]])<br></code></pre></td></tr></table></figure><h4 id="广播机制">广播机制</h4><p>在形状不同的张量上，会调用广播机制来执行按元素操作，也就是通过适当的复制元素来扩展一个或者两个数组，以便在转换之后，可以按照对应位置的元素进行操作</p><p>在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>))<br>b = torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>a, b<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor([[<span class="hljs-number">0</span>],<br>         [<span class="hljs-number">1</span>],<br>         [<span class="hljs-number">2</span>]]),<br> tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]))<br></code></pre></td></tr></table></figure><p>由于<code>a</code>和<code>b</code>分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵<em>广播</em>为一个更大的3×2矩阵，如下所示：矩阵<code>a</code>将复制列， 矩阵<code>b</code>将复制行，然后再按元素相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a + b<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>        [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])<br></code></pre></td></tr></table></figure><h4 id="转换为其他python对象">转换为其他python对象</h4><p>将深度学习框架定义的张量转换为NumPy张量（<code>ndarray</code>）很容易，反之也同样容易。 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">A = X.numpy()<br>B = torch.tensor(A)<br><span class="hljs-built_in">type</span>(A), <span class="hljs-built_in">type</span>(B)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(numpy.ndarray, torch.Tensor)<br></code></pre></td></tr></table></figure><p>将张量转换为标量，可以调用item函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.tensor([<span class="hljs-number">3.5</span>])<br>a, a.item(), <span class="hljs-built_in">float</span>(a), <span class="hljs-built_in">int</span>(a)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor([<span class="hljs-number">3.5000</span>]), <span class="hljs-number">3.5</span>, <span class="hljs-number">3.5</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="数据预处理">数据预处理</h2><h3 id="处理缺失值">处理缺失值</h3><p>典型的方法包括插值法和删除法。先使用pandas进行读取，然后进行插值操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果没有安装pandas，只需取消对以下行的注释来安装pandas</span><br><span class="hljs-comment"># !pip install pandas</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.read_csv(data_file)<br><span class="hljs-built_in">print</span>(data)<br><span class="hljs-comment">#   NumRooms Alley   Price</span><br><span class="hljs-comment"># 0       NaN  Pave  127500</span><br><span class="hljs-comment"># 1       2.0   NaN  106000</span><br><span class="hljs-comment"># 2       4.0   NaN  178100</span><br><span class="hljs-comment"># 3       NaN   NaN  140000</span><br><br>inputs, outputs = data.iloc[:, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>], data.iloc[:, <span class="hljs-number">2</span>]<br><span class="hljs-comment"># 位置索引iloc,input选择所有行，0-2列；output是所有行，第二列</span><br>inputs = inputs.fillna(inputs.mean())<br><span class="hljs-built_in">print</span>(inputs)<br><span class="hljs-comment">#   NumRooms Alley</span><br><span class="hljs-comment"># 0       3.0  Pave</span><br><span class="hljs-comment"># 1       2.0   NaN</span><br><span class="hljs-comment"># 2       4.0   NaN</span><br><span class="hljs-comment"># 3       3.0   NaN</span><br></code></pre></td></tr></table></figure><h3 id="转换为张量">转换为张量</h3><p>将pandas里面的数值转换为张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>X = torch.tensor(inputs.to_numpy(dtype=<span class="hljs-built_in">float</span>))<br>y = torch.tensor(outputs.to_numpy(dtype=<span class="hljs-built_in">float</span>))<br>X, y<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor([[<span class="hljs-number">3.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],<br>         [<span class="hljs-number">2.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>],<br>         [<span class="hljs-number">4.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>],<br>         [<span class="hljs-number">3.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]], dtype=torch.float64),<br> tensor([<span class="hljs-number">127500.</span>, <span class="hljs-number">106000.</span>, <span class="hljs-number">178100.</span>, <span class="hljs-number">140000.</span>], dtype=torch.float64))<br></code></pre></td></tr></table></figure><h2 id="线性代数">线性代数</h2><h3 id="点积">点积</h3><p>通俗的讲就是是相同位置的按元素乘积的和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = torch.ones(<span class="hljs-number">4</span>, dtype = torch.float32)<br>x, y, torch.dot(x, y)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>]), tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]), tensor(<span class="hljs-number">6.</span>))<br></code></pre></td></tr></table></figure><p>也可以这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.<span class="hljs-built_in">sum</span>(x * y)<br><span class="hljs-comment"># 输出同样的是tensor(6.)</span><br></code></pre></td></tr></table></figure><h3 id="范数">范数</h3><p>简单讲范数即是向量的大小</p><ul><li>L1范数</li></ul><p>向量绝对值相加</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">∣</mi><mn>1</mn></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||X||_{1} = \sum_{i = 1}^{n}|x_{i}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></p><ul><li>L2范数</li></ul><p>像是以前高中学过的向量的模</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">∣</mi><mn>2</mn></msub><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>x</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">||X||_{2} = \sqrt{\sum_{i = 1}^{n}x^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1568em;vertical-align:-1.2777em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8791em;"><span class="svg-align" style="top:-5.1168em;"><span class="pstrut" style="height:5.1168em;"></span><span class="mord" style="padding-left:1.056em;"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.8391em;"><span class="pstrut" style="height:5.1168em;"></span><span class="hide-tail" style="min-width:0.742em;height:3.1968em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="3.1968em" viewBox="0 0 400000 3196" preserveAspectRatio="xMinYMin slice"><path d="M702 80H40000040H742v3062l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667219 661 l218 661zM702 80H400000v40H742z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li>F范数</li></ul><p>针对矩阵的范数</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">∣</mi><mi>F</mi></msub><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">||X||_{F} = \sqrt{\sum_{i = 1}^{m}\sum_{j = 1}^{n}x_{ij}^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2929em;vertical-align:-1.4138em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8791em;"><span class="svg-align" style="top:-5.2529em;"><span class="pstrut" style="height:5.2529em;"></span><span class="mord" style="padding-left:1.056em;"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7959em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.8391em;"><span class="pstrut" style="height:5.2529em;"></span><span class="hide-tail" style="min-width:0.742em;height:3.3329em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="3.3329em" viewBox="0 0 400000 3332" preserveAspectRatio="xMinYMin slice"><path d="M702 80H40000040H742v3198l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667219 661 l218 661zM702 80H400000v40H742z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span></span></span></span></span></p><p>调用以下函数将计算矩阵的Frobenius范数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.norm(torch.ones((<span class="hljs-number">4</span>, <span class="hljs-number">9</span>)))<br><span class="hljs-comment"># tensor(6.)</span><br></code></pre></td></tr></table></figure><h2 id="矩阵计算">矩阵计算</h2><p>通常所指的梯度就是导数，即函数的斜率。梯度指向的是值变化最大的方向</p><p>自动求导的两种模式</p><ul><li>正向累积</li><li>反向累积</li></ul><p>链式法则的公式</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240725172612742.png" alt="image-20240725172612742"></p><p>正向累积 示意</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240725172650144.png" alt="image-20240725172650144"></p><p>反向累积、又称反向传递 示意</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240725172707248.png" alt="image-20240725172707248"></p><p class = "note note-info">一个例子</p><p>对函数进行求导</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">y = 2x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>x = torch.arange(<span class="hljs-number">4.0</span>) <br><span class="hljs-comment">#tensor([0., 1., 2., 3.])</span><br><br>x.requires_grad_(<span class="hljs-literal">True</span>)  <br><span class="hljs-comment"># 等价于x=torch.arange(4.0,requires_grad=True)</span><br><br><span class="hljs-comment"># requires_grad 表达的含义是，这一参数是否保留（或者说持有，即在前向传播完成后，是否在显存中记录这一参数的梯度，而非立即释放）梯度，等待优化器执行optim.step()更新参数</span><br><br>y = <span class="hljs-number">2</span> * torch.dot(x, x)<br><br>y.backward()<br><span class="hljs-built_in">print</span>(x.grad)<br><span class="hljs-comment"># tensor([ 0.,  4.,  8., 12.])</span><br><br>x.grad == <span class="hljs-number">4</span> * x<br><span class="hljs-comment"># 函数y = 2x^x关于x的梯度应为,快速验证这个梯度是否计算正确</span><br><span class="hljs-comment"># 输出tensor([True, True, True, True])</span><br></code></pre></td></tr></table></figure><h2 id="损失函数">损失函数</h2><p><em>损失函数</em>（loss function）能够量化目标的<em>实际</em>值与<em>预测</em>值之间的差距。 通常我们会选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240729171712070.png" alt="image-20240729171712070"></p><p>回归问题中最常用的损失函数是平方误差函数。</p><p>分类问题中则多采用交叉熵损失函数</p><h3 id="交叉熵损失函数">交叉熵损失函数</h3><p>交叉熵常用来衡量两个概率的区别</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(p,q) = \sum_{i}-p_{i}\log(q_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>将他作为损失</p><p>其中，对于任何标签y}和模型预测y^，损失函数为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><msub><mi>y</mi><mi>j</mi></msub><mi>log</mi><mo>⁡</mo><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>j</mi></msub><mi mathvariant="normal">.</mi><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mover accent="true"><msub><mi mathvariant="bold">y</mi><mi>y</mi></msub><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">l(\mathbf{y}, \hat{\mathbf{y}}) = - \sum_{j=1}^q y_j \log \hat{y}_j. = -\log\hat{\mathbf{y}_{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1123em;vertical-align:-1.4138em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.994em;vertical-align:-0.2861em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p><p>其梯度是真实概率和预测概率的区别</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">∂</mi><msub><mi>o</mi><mi>j</mi></msub></msub><mi>l</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="bold">o</mi><msub><mo stretchy="false">)</mo><mi>j</mi></msub><mo>−</mo><msub><mi>y</mi><mi>j</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}})  = \mathrm{softmax}(\mathbf{o})_j - y_j.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0973em;vertical-align:-0.3473em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">softmax</span></span><span class="mopen">(</span><span class="mord mathbf">o</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p><p>损失函数：用来衡量模型预测值与真实值之间的差异。</p><ul><li>损失函数越小说明模型和参数越符合训练样本。</li><li>任何能够衡量模型预测值与真实值之间差异的函数都可以叫做损失函数。</li><li>为了避免过拟合，一般在损失函数的后面添加正则化项：<code>（F = 损失函数 + 正则化项）</code></li></ul><p class = "note note-success">常用的损失函数</p><p>1、<strong>交叉熵（Cross Entropy）</strong>，用于分类：反应两个概率分布的距离（不是欧式距离）。交叉熵又称为对数似然损失、对数损失；二分类时还可称为逻辑回归损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.CrossEntropyLoss(weight=<span class="hljs-literal">None</span>, size_average=<span class="hljs-literal">None</span>, ignore_index=-<span class="hljs-number">100</span>, reduce=<span class="hljs-literal">None</span>, reduction=<span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mo>−</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munder><mo>∑</mo><mi>x</mi></munder><mo stretchy="false">[</mo><mi>y</mi><mi>ln</mi><mo>⁡</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">C = -\frac{1}{n}\sum_{x}[y\ln a + (1 - y)\ln (1 - a)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.5714em;vertical-align:-1.25em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)]</span></span></span></span></span></p><p>其中：c表示损失值；<br>    n表示样本数量，也就是batchsize；<br>    x表示预测向量维度，主要是因为需要在输出的特征向量维度上一个个计算并求和；<br>    y表示真实值，对应x维度上的标签（1 或 0）；<br>    a表示输出的预测概率值（0~1之间，总和为1）。</p><p>2、<strong>均方误差（Mean Squared error，MSE）</strong>，用于回归：反应预测值与实际值之间的欧氏距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.MSELoss(size_average=<span class="hljs-literal">None</span>, reduce=<span class="hljs-literal">None</span>, reduction=<span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>S</mi><mi>E</mi><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mi>y</mi><mtext>预测值</mtext><mo>−</mo><mi>y</mi><mtext>实际值</mtext><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">MSE = \frac{\sum_{i = 1}^n(y\text{预测值} - y\text{实际值}) ^ 2}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">MSE</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1898em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5038em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord text"><span class="mord cjk_fallback">预测值</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord text"><span class="mord cjk_fallback">实际值</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="梯度下降">梯度下降</h2><p>那么怎么进行模型的优化呢？我们用到一种名为<em>梯度下降</em>（gradient descent）的方法， 这种方法几乎可以优化所有深度学习模型。 它通过不断地在损失函数递减的方向上更新参数来降低误差。</p><p class = "note note-success">那么，为什么需要进行梯度下降呢</p><p>有个挺不错的视频：[<a href="https://www.bilibili.com/video/BV1oY411N7Xz/">5分钟深度学习] #01 梯度下降算法_哔哩哔哩_bilibili</a></p><p>以线性的时候为例，现在需要一条直线来回归拟合这三个点</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805140005209.png" alt="拟合这三个点"></p><p>直线的方程是<code>y =wx + b</code>,而通过上述的损失函数，也就是直线到点的距离量化，作为与实际相差的值，那么得到损失函数就是一个二次函数</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805140258698.png" alt="二次函数"></p><p>这个二次函数的最小值，也就是损失函数的最小值，就是这个直线方程与实际相差最小，最拟合。这里我们使用牛顿迭代法来求出这个最小值，也就是图中所示的b的更新方程。其中ε就是学习率</p><p>梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值） 关于模型参数的导数（在这里也可以称为梯度）。 但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。 因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本， 这种变体叫做<em>小批量随机梯度下降</em>（minibatch stochastic gradient descent）。</p><p>在每次迭代中，我们首先随机抽样一个小批量样本， 它是由固定数量的训练样本组成的。 然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数，并从当前参数的值中减掉。</p><p>计算梯度和损失值：</p><ul><li>挑选一个初始值w0</li><li>重复迭代参数t = 1,2,3</li><li>沿梯度方向将增加损失函数值</li><li>学习率：步长的超参数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240729143941676.png" alt="image-20240729143941676"></p><p>选择学习率，不能太大也不能太小</p><p>太小会导致训练慢</p><p>太大则会导致震荡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer.zero_grad() <span class="hljs-comment">#梯度清零</span><br>optimizer.step() <span class="hljs-comment">#梯度更新</span><br></code></pre></td></tr></table></figure><p class = "note note-success">经典的梯度下降法</p><p>先假设一个学习率，参数沿梯度的反方向移动。</p><ul><li><strong>计算</strong>：每次迭代过程中，采用所有的训练数据的平均损失来近似目标函数。</li><li><strong>特点</strong>：（1）靠近极值点时收敛速度减慢；（2）可能会&quot; 之 &quot;字形的下降。（3）对学习率非常敏感，难以驾驭；（4）对参数空间的方向没有解决方法。</li></ul><h4 id="SGD、SGDM、NAG">SGD、SGDM、NAG</h4><p>SGD（随机梯度下降法）</p><ul><li>计算：每次只使用一个数据样本，去计算损失函数，求梯度，更新参数。</li><li>特点：（1）计算速度快，但是梯度下降慢（2）可能会在最低处两边震荡，停留在局部最优。</li></ul><p>SGDM（SGM with Momentum：动量梯度下降）</p><ul><li><p>计算：对已有的梯度进行指数加权平均，然后加上（1 - beta）。即在现有梯度信息的基础上，加入一个惯性。而梯度方向，由之前与现在的梯度方向共同决定。</p></li><li><p>优缺点：</p><ul><li><p>（1）与SGD相比，训练过程的震荡幅度会变小，速度变快。</p></li><li><p>（2）SGDM速度没Adam快，但泛化能力好。</p></li></ul></li></ul><p>NAG（Nesterov Accelerated Gradient）</p><ul><li>计算：先使用累积的动量计算一次，得到下一次的梯度方向，再把下一个点的梯度方向，与历史累积动量相结合，计算现在这个时刻的累计动量。</li></ul><h4 id="AdaGrad、RMSProp、Adam">AdaGrad、RMSProp、Adam</h4><ul><li><p>AdaGrad（Adaptive Gradient，自适应步长）：累积梯度平方</p><ul><li>计算：在现有的（梯度 * 步长）上，添加了一个系数：1 /（历史梯度的平方和，再开根号）。</li><li>优缺点：（1）适合处理稀疏数据，可以对稀疏特征进行大幅更新。（2）学习率单调递减，最终会趋于0，学习提前终止。</li></ul></li><li><p>RMSProp（root mean square prop，梯度平方根）：累积梯度平方的滑动平均</p><ul><li>计算：该方法和Adagrad的区别就是分母不一样，使得系数不会因为前几步的梯度太大而导致分母太大，从而导致系数变得太小而走不动。</li></ul></li><li><p>Adam（Adaptive Moment Estimation，自适应估计）：利用梯度的一阶、二阶矩阵估计</p><ul><li>优缺点：Adam是一种在深度学习模型中用来替代随机梯度下降的优化算法。它是SGDM和RMSProp算法的结合，训练速度快，泛化能力不太行。</li></ul></li></ul><h2 id="softmax">softmax</h2><p>与线性回归一样，softmax回归也是一个单层神经网络。 由于计算每个输出o1、o2和o3取决于 所有输入x1、x2、x3和x4， 所以softmax回归的输出层也是全连接层。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240729173000131.png" alt="image-20240729173000131"></p><p>简单的来说：</p><ul><li><p>Softmax 回归是一个多分类模型</p></li><li><p>使用softmax操作子类得到每个类的预测置信度</p></li><li><p>使用交叉熵来衡量预测和标号的区别</p></li></ul><p>在实际的应用中，可以直接使用softmax函数对模型输出的pred_logits进行处理，得到预测概率，且各个种类概率加起来等于1</p><p class = "note note-success">使用F.softmax函数计算概率分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pred_softmax = F.softmax(pred_logits, dim=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="感知机">感知机</h2><p class = "note note-success">XOR问题</p><p>当使用线性模型的时候，如果数据呈现下面的这种分布，很明显，我们无法通过一个线性模型来达到分类的目的</p><p>因此，聪明的人们想出了使用多层模型来达到分类的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240729161934894.png" alt="image-20240729161934894"></p><p>使用两个线性模型（上图的两条直线）先进行分类，然后进行异或运算，即可得到最终正确的分类,这就是多层的感知机</p><p>多层感知机在输出层和输入层之间增加一个或多个全连接隐藏层，并通过激活函数转换隐藏层的输出</p><h2 id="激活函数">激活函数</h2><p>为什么要一个<strong>非线性</strong>激活函数</p><p>如果没有—那么最后多层感知机依旧是一个线性的模型，等价于一个单层的感知机</p><h3 id="ReLU函数">ReLU函数</h3><p>最受欢迎的激活函数是<em>修正线性单元</em>（Rectified linear unit，<em>ReLU</em>）， 因为它实现简单，同时在各种预测任务中表现良好。 ReLU提供了一种非常简单的非线性变换。 给定元素x，ReLU函数被定义为该元素与0的最大值：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">ReLU(x) = max(x,0).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10903em;">LU</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>说白了就是一个和0比较的max函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.arange(-<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span>, <span class="hljs-number">0.1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>y = torch.relu(x)<br>d2l.plot(x.detach(), y.detach(), <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;relu(x)&#x27;</span>, figsize=(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>))<br></code></pre></td></tr></table></figure><h3 id="sigmoid函数">sigmoid函数</h3><p>对于一个定义域在R中的输入， <em>sigmoid函数</em>将输入变换为区间(0, 1)上的输出。 因此，sigmoid通常称为<em>挤压函数</em>（squashing function）： 它将范围（-inf, inf）中的任意输入压缩到区间（0, 1）中的某个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = torch.sigmoid(x)<br>d2l.plot(x.detach(), y.detach(), <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;sigmoid(x)&#x27;</span>, figsize=(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>))<br></code></pre></td></tr></table></figure><h3 id="tanh函数">tanh函数</h3><p>与sigmoid函数类似， tanh(双曲正切)函数也能将其输入压缩转换到区间(-1, 1)上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = torch.tanh(x)<br>d2l.plot(x.detach(), y.detach(), <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;tanh(x)&#x27;</span>, figsize=(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>))<br></code></pre></td></tr></table></figure><p>（1）用于神经网络的隐含层与输出层之间（如：卷积层+激活函数+池化层），为神经网络提供非线性建模能力。<br>（2）若没有激励函数，则模型只能处理线性可分问题。与最原始的感知机相当，拟合能力有限。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240724154035611.png" alt="image-20240724154035611"></p><p class = "note note-info">深度学习的四种激活函数：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240724154203729.png" alt="image-20240724154203729"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240724154240130.png" alt="image-20240724154240130"></p><p>如何选择激活函数：</p><p>（1）任选其一：若网络层数不多<br>（2）ReLU：若网络层数较多</p><ul><li>不宜选择sigmoid、tanh，因为它们的导数都小于1，sigmoid的导数更是在[0, 1/4]之间。</li><li>根据微积分链式法则，随着网络层数增加，导数或偏导将指数级变小。</li><li>网络层数较多的激活函数其导数不宜小于1也不能大于1，大于1将导致梯度爆炸，导数为1最好，而relu正好满足这个要</li></ul><p>（3）Softmax：用于多分类神经网络输出层。</p><h2 id="正则化">正则化</h2><p>提高模型的泛化能力，防止过拟合</p><h3 id="L1-正则化">L1 正则化</h3><ul><li><code>L1正则化（L1范数），通常表示为：||W||1</code>：指权值向量 W 中各个元素的绝对值之和。</li><li>特点：又叫特征选择，产生稀疏权值矩阵。即提取权重值最大的前N个值，并将冗余的权重值置0，直接删除。</li></ul><h3 id="L2-正则化">L2 正则化</h3><ul><li><code>L2正则化（L2范数），通常表示为：||W||2</code>：指权值向量 W 中各个元素的平方和，然后求平方根。</li><li>特点：又叫权重衰减。即抑制模型中产生过拟合的参数，使其趋近于0（而不等于0），影响变小。</li><li>特点：倾向于让所有参数的权值尽可能小。</li></ul><p>若不关心显式特征（哪些特征重要或不重要），L2正则化的性能往往优于L1正则化。</p><h3 id="Dropout-正则化">Dropout 正则化</h3><p>随机删除一定比例的神经元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.Dropout(p=<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 表示随机删除 50% 的神经元</span><br></code></pre></td></tr></table></figure><p>Dropout正则化： 在训练过程中，随机删除一定比例的神经元（比例参数可设置）。<br>一般只在训练阶段使用，测试阶段不使用。<br>一般控制在20% ~ 50%。太低没有效果，太高则会导致模型欠学习。<br>应用场景：<br>（1）在大型网络模型上效果显著<br>（2）在输入层和隐藏层都使用Dropout<br>（3）当学习率和冲量值较大时：如学习率扩大10 ~ 100倍，冲量值调高到0.9 ~ 0.99。<br>（4）用于限制网络模型的权重时：学习率越大，权重值越大。</p><p>通常将其作用在隐藏全连接层的输出上</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240730124159950.png" alt="image-20240730124159950"></p><p>丢弃法将一些输出项随机置0来控制模型复杂度</p><p>丢弃概率是控制模型复杂度的超参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.Sequential(nn.Flatten(),<br>        nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">256</span>),<br>        nn.ReLU(),<br>        <span class="hljs-comment"># 在第一个全连接层之后添加一个dropout层</span><br>        nn.Dropout(dropout1),<br>        nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>),<br>        nn.ReLU(),<br>        <span class="hljs-comment"># 在第二个全连接层之后添加一个dropout层</span><br>        nn.Dropout(dropout2),<br>        nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">10</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_weights</span>(<span class="hljs-params">m</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(m) == nn.Linear:<br>        nn.init.normal_(m.weight, std=<span class="hljs-number">0.01</span>)<br><br>net.apply(init_weights);<br></code></pre></td></tr></table></figure><h2 id="前向传播">前向传播</h2><p>实现信息的前向传导，即数据从输入层，依次经过多个隐藏层，最终到达输出层。数据每经过一个网络层，其节点输出的值所代表的信息层次就越高阶和概括</p><h2 id="反向传播">反向传播</h2><p>再贴一个视频 <a href="https://www.bilibili.com/video/BV1yG411x7Cc/">介绍反向传播</a></p><p>迭代训练，降低损失（loss，与最优化方法（如：梯度下降法）结合使用的，用来训练神经网络的常见方法。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805141611358.png" alt="计算过程"></p><p>通过损失函数，计算模型中所有权重参数的梯度，并反馈给优化算法进行梯度（权值）更新。迭代训练 N 次，获得最小损失。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240805141740674.png" alt="从后向前计算"></p><p>这种沿着黄色箭头，从后向前计算参数梯度值的方法就叫反向传播算法。</p><p>单次反向传播的过程：首先是离输出层最近的网络层E，然后是网络层D，并按照EDCBA的依次顺序进行反向传播，直到所有层都完成一次。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈</title>
    <link href="/2024/07/16/%E6%9D%82%E8%B0%88/"/>
    <url>/2024/07/16/%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1>希望</h1><p>​在大三上(2022年9月)的时候，因疫情困在家中，一次偶然的机会，我发现我的成绩居然还属于专业的前几名。并且，随着学校自己的努力，我们学院每年的保研人数也在稳步的上升，也就是说，按照各专业的人数比例来分配保研的人数，我们专业的保研人数也在逐步上升，根据我的预估，如果保持这个上升趋势不变，物联网专业(也就是我读的专业)我这一届保研的人数会达到4人左右，往年是3人。而我的平均绩点在专业的3，4名之间徘徊。换句话说，我有希望保研。</p><p>​但是由于这个名次实在是不太稳妥，我也不敢抱太大的希望。因此，我决定好好冲一把。在大三学年尽可能的把绩点多提高一些，但我也不敢放弃在大三下找实习，要是最后没保上，又没有找到实习，秋招不好找工作，那不是直接寄寄。</p><h1>压力</h1><p>​在2023年的上半年，绝对是我压力最大的一段时间之一。为了能在保研中能够多一点优势，我又去报名了算法比赛，希望能拿到国奖，给保研加分。同时我也在各个平台投实习，找工作。从寒假开始。我就开始面试了，过年之前，我就面试了百度的一个实习职位，但是由于面经没有背熟，算法题也没有做出来，毫不意外的挂了。从年后我又重新好好的背面经，在二月中旬开学后，又开始到处投简历，终于又约到了字节的和百度另外一个部门的面试。字节十分看重算法，算法题是单独的一项评分依据，虽然我前面的面经应该还算是背的不错，但是算法没做出来，挂了。百度虽然面试官感觉很讨厌，但是我一直面到了三面。最后三面问了些有的没的，还是挂了。看着身边的同学陆续找到实习，我的压力也逐渐增大。也根本没心思备考算法比赛。果不其然，算法比赛也并没有拿到国奖…</p><h1>offer</h1><p>​之后的四五月，我先是拿到了育碧成都的一个offer。抱着育碧也是知名公司的想法，我还是去上班了。上了一周发现，这压根就感觉不是技术岗，并不写代码，只是纯纯的游戏测试找bug。于是干了一周我就辞职了。然后又是漫长的面试和煎熬。前后又面试了阿里的菜鸟，美团一些公司，都挂了。双非Java狗是真的不好找，也是我自己太菜了。中间收到了一个仲量联行的offer，虽然说转正后工资还算可以，但是要从23年一直实习到24年毕业，而且实习工资极低，在上海只有不到四千一个月。这个转正我也不知道是不是铁的，毕竟也没签三方。考虑到未来的发展，最终还是没有去。经历了这些之后，我开始投了一些测试开发的岗位，这当中最有希望的就是阿里淘天的测开和京东的测开，这两个都通过了全部的技术面试。但最终阿里HR面试完挂了，不太清楚是什么原因，可能是因为学历。京东肯定是是因为学历，技术面全部结束后，久久没收到HR通知，我还电话问了技术面的面试官。结果她也有点惊讶HR还没推进流程，面试官晚上又给我说还有一个名额，问我去不去。我说去，面试官说好，并且还问了我学校的层次(重点)，之后HR会通知你的。结果等了几天，还是没有消息，我又去问了面试官，面试官说，那应该就是HR直接把我挂了。。。</p><p>​此时已经快到六月了，我还没有找到实习，压力愈发大，我只有将目光放到一些小厂，中间拿到了一家长虹那栋楼上的小厂，具体叫啥忘了。那个小厂的面试官看得出来对我非常的满意。我也确定了期末考完后入职。在二面这家小厂的时候，我接到了滴滴代驾部门的面试。滴滴这次面试走得挺快，而且没有HR面试，两次技术面试后，在期末快考完时，HR就通知我通过了，和我确定入职日期。我只能鸽了小厂，小厂HR还是有点不爽，说是已经帮我把下个月的保险都交了。对不起！小厂。</p><h1>实习</h1><p>​在23年端午后，我来到了杭州，去滴滴实习。没有算法和找实习的压力，一下子就轻松多了，我先后去了西湖，杭州博物馆，浙江博物馆，看了钱塘江，还去了千岛湖露营看英仙座流星雨。在暑假刚开始，我刚到杭州没多久时，大三的绩点出来了，还可以查到前三年的平均绩点和排名，我排到第四名。虽然我预估今年保研的名额会有四个。但这也只是我的乐观估计而已。21年，22年都是三个。为了保险起见，还是要前三名我才敢放心冲保研，去参加夏令营。看到第四名，我感觉多半是保不上了。好在找到了实习，要是能顺利转正，这个工作也还算不错。但是！这个职位(测开)果然还是没有转正，因为从七月中旬开始，我先后问了组长和leader，她们都不太清楚转正的事情。但是我还是抱有一丝希望，因为我问了HR说，大概秋招是有HC的。到了8月底，滴滴开秋招了，果然我这个部门没有HC。悬着的心终于死了，我第二周便辞了职，回到了成都。</p><h1>保研</h1><p>​回到成都一周左右，保研名额出来了，我们专业果然有四个，我预测对了。好消息是，我可以保研了。坏消息是，我啥都没有准备。我只能先去问了比较熟的一直在准备保研的朋友，还有已经保研的学长。然后海投学校，到处联系导师。最终保研名单出来时，我保研成绩居然还是第三位，因为第二名放弃保研了。但是9月下旬各个学校已经接近招好了推免生。加上双非背景，我并没有面试到多少学校。而在碰壁多家公司后我也决定，至少要92我才会去读。如果还是保双非本校，没有意义，简直是浪费时间。到了填推免志愿的那一天，我依然没有铁定可以上的92。只能填了两个还算是有点希望的学校，一个末985，还有一个还算不错的211。但这个211并不是以计算机见长的。因为填了学校后会锁定48小时，为了可能的捡漏，我留了一个志愿栏没有填写。</p><h1>录取</h1><p>​凌晨填报完志愿后，因为放中秋国庆假，我白天还要回去一趟。中午在家里饭桌上吃饭时，已经是12点后了，学校开始录取，但是我迟迟没有学校的待录取通知，我已经有点着急了。同样的，我妈和我姐也在旁边很着急。他们甚至想叫我填本校了。但是我死活不愿意。但是，可能是本科学校在当地也还算可以？那个211学校还是录取我了。原本我都想继续找工作了。</p><h1>Gap</h1><p>​之后便是愉快的Gap生活，我拿着实习还剩的工资，给自己换了台手机，还和朋友去重庆玩了几天。在寝室通关了多个3A大作。还顺利拿到了比较大额的奖学金，爽玩！但是家里也不想看着我在学校天天玩，便催促我找个班上，我随便在boss投了投简历，没想到字节还真约了我面试。但是我也完全不慌了，因为没有了之前的压力。挂了就挂了大不了躺在寝室继续玩，虽然一面我感觉挺糟糕的。但是居然这次的流程都很顺利的过了(可能是比较缺人？)。我顺利拿到了字节的实习offer。想着可以给简历增点光，还可以挣点零花钱。12月份，我去字节上班了。</p><p>​打了三个多月的工，因为字节吃饭免费，而且我住在学校宿舍。没有啥开支。我还是挣了一点小钱。在三月中旬时，马上也要毕业设计的中期检查了，我从字节离职了。有钱有闲，这确实是我最开心的一段时间之一。我给自己装了一台还算不错的电脑，通关了想玩了游戏。去了峨眉山，九寨沟，青城山。原本还打算去鱼子西和达瓦更扎，但是由于天气原因和毕业设计愈发繁重的任务，并未成行。</p><p>​最后，在上个月。顺利完成了本科的毕业设计，拿到了本科的毕业证和学位证。结束了我的本科生活。再见，油专。</p><h1>一点思考</h1><p>​最后的思考，其实我在本科的前三年一直在思考是继续读研还是找工作，在我所在的团队，大多是以找工作为主要导向的。因为大家在本科毕业时，都已经完全具备了大多数公司的部分招聘要求，大多是开发岗。而读研真的有必要吗，每个人都有自己的答案。问工作的学长说工作好，问读研的学长说读研好。当然，算法岗是最低都要一个硕士学位的。但是算法岗哪里需要那么多人，大多数人读了研究生出来也是开发岗居多。在经济下行，各大互联网公司都在裁员的背景下，网上都说读研三年不如工作三年，积累三年工作经验。在2022年底爆发了GPT大模型后，各个厂商的各种大模型层出不穷。见识到越来越聪明的大模型，越来越强的代码编写能力，说不定有一天，大模型真的会取代很多低级码农。按这个趋势，我不禁想问，干程序员真的能干到65岁退休吗？这要打一个大大的问号(当然如果没有大模型，能不能干到65岁也是一个大大的问号)。从目前短期来看，现在本科出来找一个开发工作好像确实比再读三年书研究生再出来找一个开发工作好，工资都差不多。但引入程序员多半干不到65岁退休，从长远的角度来看，三年不过弹指一挥间，花三年拿一个硕士学位，在未来AI浪潮中可能确实要好一些。当然，我这样想也可能是在找理由安慰安慰自己。最后说不定还是不如提前三年出来工作的，谁知道呢。</p><p>​现在想这些意义也不是很大了，我已经坐在实验室里，坐在 工位上了。更重要的是要抓住现在，引用一句《死亡诗社》我很喜欢的一句话–Carpe diem.</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我在育碧种土豆</title>
    <link href="/2023/04/15/InternInUbisoft/"/>
    <url>/2023/04/15/InternInUbisoft/</url>
    
    <content type="html"><![CDATA[<h1>意料之外的回复</h1><p>时间回到三月中旬，此时的我刚刚因为工资等方面的原因拒绝了某外企的QA实习，不过那个部门主管确实很负责任，甚至还帮我看了租房子那些，人也非常的和蔼可亲。好的，扯回育碧实习，那是一个周四，我在boss上海投，开始想着先找一个成都的小厂先干着，边干边找。</p><p>刷着刷着，我看到了育碧的Intern Game Tester这个职位，看了看职位描述，都没有多少跟计算机技术相关的描述，只有一个需要懂点计算机网络啥的(后面发现，根本用不上)，而且工资对比育碧这个游戏业界大厂，简直是低得发指，想着反正找个小厂先干着，于是随手一投😐</p><h1>怪怪的笔试题</h1><p>时间来到了周五,在团队摸了一天的🐟, 饭还是要吃的。 正在排队买面的时候,育碧的HR突然发来了一个笔试链接,说要我做做</p><p>回到团队打开链接,准备做题的时候,我才发现,丫的,不愧是育碧,这链接一直转圈根本进不去,于是手贱一刷新,刚刚通过邮件发过来的临时登录密码显示已经用过了,已经登不上了,只能再换个邮箱再重新搞</p><p>这一次我学聪明了,就等他一直转圈,他就这样转了好几分钟,居然真的还进去了.题目要求全英文做题, 作为一个快两年都没碰过的菜鸡来说</p><p>我看你是为难我胖虎.jpg</p><p>题目大概就是玩过哪些游戏,对于游戏的理解, 游戏bug有哪些分类啥的,最后重头戏来了—看图找bug,并且使用英语描述</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230415103223555.png" alt="image-20230415103223555"></p><p>做完好几道这种题之后。我就大概知道了进去之后大概是个什么工作了,所以最后还有一道专门考英语水平的汉译英我压根做都没做(绝对不是因为懒</p><h1>居然约面了?</h1><p>时间又过了一个周末, 对于做过的笔试题我也没放在心上,没想到在周二的时候, HR居然又给我打电话约面了,还聊了一些薪资方面的问题；加上补贴啥的,一个月的工资竟有高达三千人民币🥲</p><p>但有面试就不错了,我都先答应下来了. 面试官还专门说, 面试有个英语环节,要我好好准备一下,口语菜鸡瑟瑟发抖.</p><p>我赶紧用看看牛客上有没有育碧的面试,居然还真的有,而且好像还是同一个职位。</p><p>看面经,英语环节只是自我介绍需要,其他的环节用中文就好了, 于是用我们的 chatGPT 帮我写了一篇英语的自我介绍,不得不说写得真好, 刚开始我想把它给背下来,  发现做不到 (苦涩.jpg) ；还是多读几遍,明天照着念吧.</p><h1>面试</h1><p>面试用的teams, 有HR以及另外两人,应该是部门的人。</p><p>果不其然,一来就是英语的自我介绍. 这让我回想起了,当初大一上外教课的时候, 期末的口语考试 — 去和一个纯英国伦敦人面对面坐着,自己选一个话题说口语. 然后外教一脸微笑的听着我的辣鸡口语的窘迫感。</p><p>面试问的问题就和笔试差不多,根本就没有问计算机相关的问题,问了问对游戏的理解,玩过什么游戏,对于育碧游戏的看法,最后还问了我能不能胜任比较枯燥的重复工作(这句话给我们埋下了伏笔)</p><p>最后反问的环节,我问了以前经常问的问题, “部门的业务具体是什么” 的变化版—“这个测试平时的工作具体是什么”.谁知道居然给她问蒙了</p><p>“我不太理解你的意思,测试平时的工作就是测试啊,还能有啥”</p><p>“我的意思是平时都需要做些什么”</p><p>“??? 就是测试啊”</p><p>“???”</p><p>“我直接给你说吧,就是做的黑盒测试方面的,听了这个回答你还想来吗?”</p><p>犹豫了几秒…</p><p>“balabala”  心里: 黑盒测试是什么,面完搜一下…</p><p>面试就这样结束了,看最后的反问环节,都把她问得不耐烦了,猜想估计是寄了；</p><p>算了,反正也不是特别想去,工资也还低。</p><h1>Offer</h1><p>面试后,又过了一天. HR居然又打电话过来了；通知我过了. 虽然工资低。</p><p>毕竟是育碧. 我还是给接下来了. 先去干着吧,简历上还能多一段实习经历,</p><p>然后加了HR的微信；约了个时间入职,OC后一天收到了offer</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230415110718828.png" alt="image-20230415110718828"></p><h1>入职</h1><p>在入职前几天,我还和某夏姓男子打算一起出去短租一个房子,实习期间住; 毕竟从新都到天府三街确实是远, 没想到逛了一下午,房子也没租到满意的, 最终考虑到确实可能也做不久，于是干脆不租了。一人被坑了180块就当买个教训吧。还没毕业就遭到社会的毒打😭。只有每天去挤地铁了。</p><p>第一天我就感受到了，早上的一号线真TM的挤啊，刚去报到，没仔细看offer，跑错了写字楼，原来入职是在B3。。。</p><p>九点半，HR带我们几个今天刚入职的人又签一遍实习协议，然后还签了一个保密协议，看了看，如果泄露信息，要赔一万块，穷逼学生表示赔不起，后面的内容就尽量不泄露吧。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/9999.jpg" alt="工牌"></p><h1>苦逼的打工生活</h1><p>在入职的前几天，没有什么事情干，每天就是培训内容；</p><p>第一天参观完育碧成都工作室后，DA带我到了工位，一看工位，居然还有ps4和Xbox；心中大喜，上班玩主机这也太爽了吧！！而且还是可调节高度的桌子(原谅我这个乡巴佬没见过世面</p><p>可惜并不是，在接下来的两天培训中，我逐渐了解了解到，我被分配到了Mobile组，上班是和手机打交道，测试某手游。。。悲伤，手游我接触得其实并不算多，打的时间最长的也只有舟舟了，周五的时候，组长给我发了一个手机，下周培训完成后就要开始正式的测试了</p><p>不过，育碧居然送了我所有的育碧游戏，这实在是相当不错的福利了</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/67cd9f59e7d3e2e3.jpg" alt="游戏"></p><p>上了三天班，趁着周末回了一趟老家，跟着他们出去玩，不得不说，还是家里好，打工简直痛苦</p><p>之后的打工生活基本就是一个模子里面刻出来的了</p><p>早上7点就需要起来，收拾一会，再吃个早饭，走到地铁站差不多7点40，然后坐上三号线，油专是第二站，所以基本没多少人，还可以捡到一个座位，接着坐到省体育馆换一号线，这是每天最难受的时候，因为一号线每天的人简直是离谱，我感觉那个地铁的车门都是勉强才关的上。</p><p>走到公司差不多9点，然后开始一天的打工生活，中午一般是去乡村基吃个午饭，不过可恶的是中午只有一个小时的午餐加午休时间，所以等我吃完饭回到公司，基本上午休就没剩下多久了。下午一点继续打工生活</p><p>每天我旁边的另外一个实习生都是6点钟踩点下班，于是我每天也跟着他踩点下班。😃</p><p>在头两天下班后，还有美团的面试官约我面试，我只能匆匆忙忙吃完晚饭，然后再去赶面试，结果后来等了一周没消息，美团直接进人才池寄了😭</p><h1>离职</h1><p>在工作了一段时间后，我发现每天的任务基本上就是测试case，报告bug的工作，这实在是和我一开始想找实习，学习在学校里学不到的编程知识相违背，于是我萌生了离职的想法。但还没有做最终的决定，迷迷茫茫的又做了一段时间测试后，离职的想法也在我的脑海里愈发的强烈起来。</p><p>最终我还是决定—离职吧，在又一个周一回去学校的路上，我给我的manager发送了微信</p><p>“抱歉，我想离职了，我想做多接触一些代码和编程方面的工作”</p><p>manager并没有直接答复，只是叫我第二天去聊聊</p><p>第二天，10点钟的时候，manager给我发送了team消息，叫我去会议室开会，我来到了会议室</p><p>从左到右坐着三个人，分别是manager，DA，还有manager的manager(抱歉，忘了你的职称了🥲</p><p>他们给我聊了很多，告诉我沉住气，现在部门的领导一开始也是做测试的，而且育碧是个很好的平台之类的，最后还问我有没有回心转意，改变主意，我还是拒绝了，我给他们说</p><p>“这个主意我也考虑一段时间才做出的最终决定”</p><p>开会时，不知为什么，感觉DA小姐姐，眼眶红红的(好吧 ，可能是我的错觉</p><p>最终，我还是决定离开了，再做三天，做好一些工作交接方面的工作，周五的时候，就是我离开育碧的日子</p><p>周五终究还是到来了，工作在周四就已经完成了，上午我无所事事，下午DA给了我一个文件，是离职的清单，需要到各个部门去签字，看着清单上一个接一个签上名字，也就离我的离开越来越近了(*￣;(￣ *)</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/IMG_20230414_163409.jpg" alt="IMG_20230414_163409"></p><p>最后部门的总管也签上了它的名字，离职清单也完成了，我又坐了一会，回忆了下这段时间的实习，想了想自己的有什么收获。</p><p>走吧，去找HR吧，这是最后一步了</p><p>向HR递交了离职清单还有工牌，我就此离开，不同与每个下班，这次大概就再也不会回来了</p><p><strong>再见，育碧！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/IMG_20230414_164442.jpg" alt="走时最后拍的照片"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230415192031488.png" alt="育碧送的联名马克杯"></p>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubisoft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/12/27/OS/"/>
    <url>/2022/12/27/OS/</url>
    
    <content type="html"><![CDATA[<h1>操作系统基础</h1><h2 id="什么是操作系统">什么是操作系统</h2><ol><li>操作系统是管理计算机硬件和软件资源的程序，是计算机的基石</li><li>操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件个软件资源</li><li>操作系统的存在屏蔽了硬件层的复杂性</li><li>操作系统的内核时操作系统的核心部分，他负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</li></ol><h2 id="系统调用">系统调用</h2><p>根据进程访问的特点，我们可以把进程在系统上的运行分为两个级别</p><ol><li>用户态：用户运行的进程可以直接读取读取用户程序的数据</li><li>系统态：系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</li></ol><p>所以什么是系统调用呢？</p><p>在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p><p>比如：<strong>设备管理，文件管理，进程控制，进程通信，内存管理</strong></p><h1>进程和线程</h1><h2 id="进程和线程的区别">进程和线程的区别</h2><p>线程是进程划分的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响</p><p><strong>进程是操作系统进行资源分配的最小单元，线程是操作系统进行运算调度的最小单元</strong></p><h2 id="进程的几种状态">进程的几种状态</h2><p><strong>创建状态</strong>：进程正在被创建，尚未到就绪状态</p><p><strong>就绪状态</strong>：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦获得处理器资源即可运行</p><p><strong>运行状态</strong>：进程正在处理器上运行</p><p><strong>阻塞状态</strong>：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行</p><p><strong>结束状态</strong>：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行</p><h2 id="进程间的通信方式">进程间的通信方式</h2><p><strong>管道/匿名管道</strong>：用于具有亲缘关系的父子进程或者兄弟进程之间的通信</p><p><strong>有名管道</strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。因此提出了有名管道，有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信</p><p><strong>信号</strong>：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</p><p><strong>消息队列</strong>：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</p><p><strong>信号量</strong>：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步</p><p><strong>共享内存</strong>：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新</p><p><strong>套接字</strong>：主要用于客户端和服务器之间通过网络进行通信。、</p><h2 id="线程间的同步方式">线程间的同步方式</h2><p>线程同步就是两个或多个共享关键资源的线程并发执行，一般有下面三种线程同步的方式</p><ol><li><strong>互斥量</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公告资源的权限。</li><li><strong>信号量</strong>：它允许同一时刻多个线程访问同一资源，但是需要控制同一资源的最大资源数量</li><li><strong>事件</strong>：通过通知操作系统的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ol><h2 id="进程的调度算法">进程的调度算法</h2><ul><li><strong>先到先服务算法(FCFS)</strong>：从就绪队列中选择一个最先进入该队列的进程分配资源。</li><li><strong>短作业优先调度算法(SJF)</strong>：从就绪队列中选出一个估计运行时间最短的进程分配资源</li><li><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间段，称为它的时间片，即该进程允许运行的时间</li><li><strong>多级反馈队列调度算法</strong>：短进程有限的额调度算法仅照顾了短进程而忽视了长进程。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，是现在公认的较好的进程调度算法</li><li><strong>优先级调度</strong>：为每个线程分配优先级，首先执行的具有最高优先级的进程</li></ul><h2 id="什么是死锁">什么是死锁</h2><p>多个进程/线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期的阻塞，因此程序不可能正常终止。</p><h2 id="死锁的四个必要条件">死锁的四个必要条件</h2><ul><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放</li><li><strong>循环等待</strong>：P0等待的资源被P1占有，P1等待的资源被P2占有…，Pn等待的资源被P0占有</li></ul><p><strong>注意</strong>：这里是必要条件，不是充分条件</p><h2 id="解决死锁的办法">解决死锁的办法</h2><p><strong>预防</strong>：采取某种策略，限制并发进程对资源的请求</p><p><strong>避免</strong>：在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生</p><p><strong>检测</strong>：系统设有专门的额机构，当死锁发生的时候，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源</p><p><strong>解除</strong>：与检测相配套的一种措施，用于将进程从死锁状态下解脱出来</p><div class = "note note-success">避免死锁的经典算法</div><p>最具代表性的就是银行家算法，简单的来说就是当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就真的分配资源给该进程</p><h1>操作系统内存管理</h1><h2 id="内存管理主要是做什么的">内存管理主要是做什么的</h2><p>主要负责内存的分配与回收，地址转换(将逻辑地址转换为物理地址)也是内存管理做的事情</p><h2 id="常见的几种内存管理机制">常见的几种内存管理机制</h2><p>简单的分为<strong>连续分配管理</strong>和<strong>非连续分配管理方式</strong>，连续分配包括<strong>块式管理</strong>，非连续管理分配包括<strong>页式管理</strong>和<strong>段式管理</strong></p><ul><li><p>块式管理：将内存分为几个固定大小的块，每个块只有一个进程，当程序运行需要内存的时候，操作系统就分一块给他，这块内存剩下的空间就被浪费了</p></li><li><p>页式管理：把主存分为大小相等且固定的一页一页的形式，页比较小，相比于块的划分颗粒度更小，减少内存碎片，通过页表对应逻辑地址和物理地址</p></li><li><p>段式管理：页式管理其中的页并没有实际的意义。段式管理把主存分为一段一段的，段是具有实际意义的，每个段定义了一组逻辑信息，比如主程序段，子程序段等。通过段表对应逻辑地址和逻辑地址</p></li><li><p>段页式管理：结合了段页式管理的优点，简单的来说就是把主存分为若干段，每个段又分为若干页，也就说段页式管理中段与段以及段的内部都是离散的</p></li></ul><h2 id="分页机制和分段机制的共同点和区别">分页机制和分段机制的共同点和区别</h2><ul><li>共同点：<ul><li>分页和分段都是为了提高内存利用率，减少碎片</li><li>页和段都是离散存储的，但是页和段内部式连续的</li></ul></li><li>区别<ul><li>页的大小式固定的，但是段的大小是不固定的，取决于我们当前运行的程序</li><li>页没有信息，但是段是逻辑信息的单位，在程序中可以分为代码段，数据段等</li></ul></li></ul><h1>虚拟内存</h1><h2 id="什么是虚拟内存">什么是虚拟内存</h2><p>虚拟内存是计算机内存管理的一种技术，通过虚拟内存，可以为每一个进程提供一个一致性的，私有的地址空间。虚拟内存的重要意义就是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间</p><h2 id="局部性原理">局部性原理</h2><p>程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间页局限于某个区域</p><p>主要表现在</p><ul><li>时间局限性</li><li>空间局限性</li></ul><p>猜测一些大型游戏的加载是不是同样使用了这个原理</p><h2 id="虚拟存储器">虚拟存储器</h2><p>基于局部性原理，在程序装入的时候，可以将程序的一部分咋恍如内存，而将其他部分留在外村，就可以启动程序的执行。需要的时候再将需要的调入内存，将不需要的资源调出，这样，计算机仿佛就为用户提供了一个比实际内存大得多的储存器，这就是虚拟存储器</p><p>技术实现</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><p>和上面的类似，但是不同的是装入作业的时候不是全部装入，而是装入一部分</p><h2 id="页面置换算法">页面置换算法</h2><p>地址映射的过程中，若在页面中发现所要的页面不再内存中，则会发生缺页中断，这时如果没有空闲的页面，操作系统就需要淘汰一些页面腾出内存空间为将调入的页面做准备</p><ul><li><strong>OPT 页面置换算法(最佳页面置换算法)</strong>：选择以后以后永不使用或者未来最长时间不被使用的的页面淘汰，保证最低的缺页率，但是我们无法知道内存中哪个是未来最长不被使用的，因此这个算法是无法实现的</li><li><strong>FIFO(First In First Out)算法</strong>：看名字就知道是选择最先进入的页面淘汰</li><li><strong>LRU(Least Recently Used) 页面置换算法(最近最久未使用置换算法)</strong>：赋予每个页面一个T值记录自上次访问以来经历的时间，每次就挑这个T值最大的淘汰</li><li><strong>LFU(Least Frequently Used) 页面置换算法(最少使用页面置换算法)</strong>：选择之前使用次数最少的页面淘汰</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网</title>
    <link href="/2022/12/05/%E8%AE%A1%E7%BD%91/"/>
    <url>/2022/12/05/%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1>OSI和TCP/IP网络分层模型</h1><h2 id="OSI七层模型">OSI七层模型</h2><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221205153408890.png" alt="image-20221205153408890"></p><p>每一层都专注于自己的事情，并且每一层都需要下一层 提供的功能，OSI的七层体系结构概念清楚，理论完整，但是比较复杂而且不实用，而且有些功能在多个层中重复出现</p><p>数据链路层的三个基本问题：封装成帧，透明传输，差错检测</p><p>OSI七层模型很明显是失败了，但是还是留下了不少遗产(经典话术)</p><h2 id="TCP-IP四层模型">TCP/IP四层模型</h2><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221205154052697.png" alt="image-20221205154052697"></p><h3 id="应用层">应用层</h3><p>**位于传输层之上，主要提供两个终端设备上的应用程序之间的信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。**应用层交互的数据称为报文</p><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用协议，比如:HTTP,DHCP,FTP,DNS,SMTP,IMAP等</p><h3 id="应用层常见协议">应用层常见协议</h3><p><strong>HTTP</strong>：超文本传输协议，主要是为了Web浏览器与Web服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们的网页就是通过HTTP请求进行加载的</p><p><strong>SMTP</strong>：简单邮件传输(发送)协议，基于TCP协议，用来发送电子邮件，</p><blockquote><p>注意⚠️: 接收邮件的是POP3协议，不是SMTP协议</p></blockquote><p><strong>POP3/IMAP</strong>：邮件接收的协议，这两个协议都是负责邮件接收的协议，IMAP协议相比于POP3协议要更新一些，几乎所有现代的电子邮件都支持IMAP。大部分的网络邮件提供商都支持POP3和IMAP</p><p><strong>FTP</strong>：文件传输协议，基于TCP实现可靠的传输，使用FTP传输文件的好处就是可以屏蔽操作系统和文件存储方式</p><p><strong>Telnet</strong>：远程登录协议，建立在可靠的传输协议TCP上</p><p><strong>SSH</strong>：安全的网络传输协议，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH可以有效防止远程管理过程中的信息泄露问题。SSH建立在可靠的传输协议上。</p><p><strong>Telnet和SSH之间的主要区别在于SSH协议会对传输的数据进行加密保证数据安全性</strong></p><h3 id="传输层">传输层</h3><p>**传输层的主要任务就是负责向两台终端设备之间的通信提供通用的数据传输服务。**应用进程利用该服务传输应用层的报文</p><p>主要使用以下两种协议</p><ul><li>传输控制协议TCP : 提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务</li><li>用户数据协议UDP：提供<strong>无连接</strong>的，尽最大努力的数据传输服务(不保证可靠性)</li></ul><h3 id="网络层">网络层</h3><p>**网络层负责为交换网上的不同主机提供通信服务。**在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送，因为网络层使用IP协议，因此分组也叫IP数据报。</p><p><strong>网络层还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机</strong></p><p>互联网是由大量的异构网络通过路由器相互连接起来的。互联网使用的网络层协议是无连接的网际协议和许多路由选择协议，因此网络层也叫<strong>网际层</strong>或<strong>IP层</strong></p><div class = "note note-success">网络层常见协议</div><p><strong>IP协议</strong>: 中文名网际协议，IP协议是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议，IP协议的作用包括寻址规约，定义数据包的格式等，目前有两种IP协议:IPV4和IPV6</p><p><strong>ARP协议</strong>:全称地址解析协议，解决了网络层地址和链路层地址之间的转换问题，也就是IP地址转MAC地址的一些问题</p><p><strong>NAT协议</strong>:网络地址转换协议，应用于内部网络到外部网络的地址转换过程中。</p><p>…</p><h3 id="网络接口层">网络接口层</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体</p><ol><li>数据链路层：作用是将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息(如同步信息，地址信息，差错控制)</li><li>物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221205170103001.png" alt="image-20221205170103001"></p><h2 id="为什么要分层">为什么要分层</h2><ol><li>各层之间相互独立：各层之间不需要关心其他层是如何实现的，只需要直到自己如何调用下层提供好的功能就可以了</li><li>提高了整体灵活性：每一层都可以使用最适合的技术来实现，只需要保证接口的规则没有变就行了，对应上了<strong>高内聚，低耦合</strong></li><li>大问题化小：大化小使得复杂的计算机网络系统变得易于设计，实现和标准化，类似于将复杂的系统功能分解为更小的易于解决的问题</li></ol><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的</p></blockquote><h1>TCP和UDP</h1><h2 id="TCP和UDP的区别">TCP和UDP的区别</h2><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠传输</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20~60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table><div class ="note note-success">什么时候选择TCP，什么时候选UDP</div><ul><li><p>UDP一般用于即是通信，语音，视频，直播等，这些场景对于数据的准确性要求不是特别高的场景</p></li><li><p>TCP用于对准确性要求特别高的场景，比如文件传输，发送和接收邮件，远程登录等</p></li><li><p><strong>HTTP协议</strong>是基于TCP协议的，所以HTTP建立之前需要经历三次握手</p></li></ul><h2 id="使用TCP和UDP的协议">使用TCP和UDP的协议</h2><p><strong>TCP</strong></p><p>HTTP,HTTPS,FTP,SMTP,POP3/IMAP,Telent(远程登录协议),SSH</p><p><strong>UDP</strong></p><p>DHCP(动态主机配置协议)，DNS</p><h2 id="TCP三次握手和四次挥手-非常重要">TCP三次握手和四次挥手(非常重要!!!)</h2><h3 id="三次握手">三次握手</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221211162931677.png" alt="image-20221211162931677"></p><ul><li>一次握手：客户端发送带有SYN (SEQ=x)标志的数据包 -&gt;服务端，然后客户端进入<strong>SYN_SEND</strong>状态，等待服务器的确认</li><li>二次握手：服务器发送带有SYN+ACK(SEQ=y,ACK=x+1)标志的数据包-&gt;客户端，然后服务端进入<strong>SYN_RECV</strong>状态</li><li>三次握手：客户端发送带有ACK(ACK = y+1)标志的数据包-&gt;服务端，然后客户端和服务端都进入<strong>ESTABLISHED</strong>状态，完成TCP的三次握手</li></ul><div class = "note note-success">为什么需要三次握手?</div><p>三次握手的目的是建立可靠的通信信道，目的就是双方确认自己与对方的数据发送和接收都是正常的。</p><ul><li>第一次握手：Client什么都不能确认；Server确认了对方发送正常，自己接收正常</li><li>第二次握手：Client确认了自己发送，接收正常，对方发送接受收正常；Server确认了对方发送正常，自己接收正常</li><li>第三次握手：Client确认了自己发送，接收正常，对方发送接受收正常；Server确认了自己发送，接收正常，对方发送，接收正常</li></ul><p>因此只有三次握手才能确认双方的收发功能都正常，缺一不可</p><div class= "note note-success">为什么第二次还需要回传SYN</div><p>到第二次的时候回传SYN是为了建立并确认服务端到客户端的通信是否正常</p><h3 id="四次挥手">四次挥手</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221211164930656.png" alt="image-20221211164930656"></p><ul><li>第一次挥手：客户端发送一个FIN(SEQ=x)标志的数据包，它发送一个ACK(SEQ=X+1)标志的数据包-&gt;客户端，用来关闭客户端到服务端的数据传送。然后客户端进入<strong>FIN-WAIT-1</strong>状态</li><li>第二次挥手：服务器收到这个FIN(SEQ=x)标志的数据包，它发送一个ACK(SEQ=X+1)标志的数据包-&gt;客户端。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态</li><li>第三次挥手：服务端关闭和客户端的连接并发送一个FIN(SEQ=y)标志的数据包-&gt;客户端请求关闭，然后，服务端进入<strong>LAST-ACK</strong>状态</li><li>第四次握手：客户端发送ACK(SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到ACK(SEQ=y+1)标志的数据包后进入ClOSE状态。此时，如果客户端等待<strong>2MSL</strong>(2个报文最大生存时间)后依然没有收到回复，就证明服务端已经正常关闭，随后，客户端关闭。</li></ul><div class= "note note-success">为什么要四次挥手</div><p>TCP是全双工通信，可以双向传输数据。任何一方发出连接释放通知后，会进入半关闭状态，当另一方确认后，才会完全关闭，因此需要四次</p><div class="note note-success">为什么不把中间服务端的ACK和FIN合并变成三次挥手</div><p>因为服务器收到客户端断开请求时，可能还有一些数据</p><p>没有发完，先回复ACK表示收到了断开连接的请求，等到数据发完之后再发FIN，断开服务器到客户端的数据传送</p><div class ="note note-success">为什么需要等待2*MSL时间后才进入CLOSED状态</div><p>因为客户端发送给服务器的ACK有可能丢失，如果服务端因为某些原因没有收到ACK的话，就会不断重发FIN。因此需要客户端再次等待2MSL，防止服务端没有收到ACK而不断的重发FIN</p><h2 id="TCP传输可靠性保障">TCP传输可靠性保障</h2><h3 id="TCP如何保证传输的可靠性">TCP如何保证传输的可靠性</h3><ul><li><strong>基于数据块传输</strong>：应用数据被分割成TCP认为最适合发送的数据块</li><li>对失序数据包重新排序以及去重：TCP给每一个包一个序列号，有了序列号就能根据序列号进行排序，并且去掉重复序列号的数据</li><li><strong>校验和</strong>：TCP将保持它首部和数据的校验和，目的是检测数据在传输过程中的任何变化。如果收到的检验和有差错，TCP将丢弃这个报文段</li><li><strong>超时重传</strong>：当发送方发送数据后，会启动一个计时器。接收端成功收到后会返回一个相应的确认信息，如果在合理的往返时延内未收到确认信息，那么对应的数据包就会被假设为已丢失并进行重传</li><li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只允许发送端发送缓冲区能接收的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送</li></ul><h3 id="TCP如何让实现流量控制">TCP如何让实现流量控制</h3><p><strong>TCP利用滑动窗口进行流量控制</strong>，目的是为了控制发送方发送速率，保证发送方来得及接收。</p><p>TCP<strong>发送窗口</strong>可以划分为四个部分</p><ol><li>已经发送并且确认的TCP段</li><li>已经发送但是没有确认的TCP段</li><li>未发送但是接收方准备接收的TCP段</li><li>未发送并且接收方也未准备接受收的TCP段</li></ol><p>发送窗口如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221212160652697.png" alt="image-20221212160652697"></p><p>TCP<strong>接收窗口</strong>可以划分为三个部分</p><ol><li>已经接收并且已经确认的TCP段</li><li>等待接受且允许发送方发送TCP段</li><li>不可接收且不允许发送方发送TCP段</li></ol><p>接收窗口如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221212161038279.png" alt="image-20221212161038279"></p><p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的</strong></p><h3 id="拥塞控制的实现">拥塞控制的实现</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221212190619792.png" alt="image-20221212190619792"></p><p>TCP的拥塞控制采用了四种算法，<strong>慢开始</strong>，<strong>拥塞避免</strong>，<strong>快重传</strong>，<strong>快恢复</strong>。</p><ul><li><strong>慢开始</strong>：先试探一波，即由小到大逐渐增大拥塞窗口的数值，cwnd初始值为1，每经过一个传播轮次，cwnd<strong>加倍</strong></li><li><strong>拥塞避免</strong>：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT就增大1</li><li><strong>快重传与快恢复</strong>(FRR)：能快速恢复丢失的数据包，有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认，如果接收到三个重复确认，它会假定数据段缺失了，并立即重传这些缺失的数据段。减少重传时的暂停。</li></ul><h3 id="ARQ协议">ARQ协议</h3><p><strong>自动重传请求</strong>(Automatic Repeat-reQuest,ARQ)是OSI模型中数据链路层和传输层的错误纠正协议之一，如果发送方在发送之后一段时间之内没有收到确认信息(ACK)，它会重新发送，直到收到确认信息或者重试超过一定的次数。</p><p>ARQ包括停止等待ARQ协议和连续ARQ协议</p><p><strong>停止等待ARQ协议</strong></p><p>每发完一个分组就停止发送，等待对方确认(ACK)，若过了一段时间，还是没有收到ACK确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</p><p><strong>连续ARQ协议</strong></p><p>发送方维护一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</p><h1>HTTP</h1><h2 id="从输入URL到页面展示到底发生了什么">从输入URL到页面展示到底发生了什么</h2><p>(打开一个网页，整个过程会使用那些协议)<a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么?参考</a></p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p><strong>DNS解析</strong></p><p>DNS解析就是寻找哪台机器上有你需要资源的过程， 查询的方式是递归查询</p><p>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器会向根域名服务器发送一个请求，如果根域名也不存在，那么本地域名会向com顶级域名发送请求，依次类推</p><p><strong>TCP连接</strong></p><p>见上面的TCP连接</p><p><strong>HTTP请求</strong></p><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口(HTTPS 443 ; HTTP 80)。HTTP请求报文由三部分组成:<strong>请求行，请求报文</strong>和<strong>请求正文</strong></p><p><strong>服务器处理请求并返回HTTP报文</strong></p><p>后端从固定得到端口接收到TCP报文开始，这一部分对应变成语言里面的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。HTTP的响应报文也是由三部分组成：<strong>状态码，响应报头</strong>和<strong>响应报文</strong>。</p><p><strong>浏览器解析渲染页面</strong></p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p><h2 id="HTTP状态码">HTTP状态码</h2><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求错误</td></tr></tbody></table><h3 id="1xx（信息状态码）">1xx（信息状态码）</h3><p>大概率不会碰到，略</p><h3 id="2xx-成功状态码">2xx (成功状态码)</h3><ul><li>200 OK：请求被成功处理，服务端返回了数据</li><li>201 Created：请求被成功处理并且在服务器端创建了一个新的资源</li><li>202 Accepted：服务端已经接收到了请求，但是还没处理</li><li>204 Not Content：服务端已经成功处理了请求，但是没有返回任何内容</li></ul><p>204见得比较少，这里说一下，204状态码描述就是我们向服务端发送HTTP请求之后，只关注处理结果是否成功的场景，也就是我们需要的就是一个结果: true/false</p><h3 id="3xx-重定向状态码">3xx (重定向状态码)</h3><ul><li>301 Moved Permanently：资源被永久重定向了。</li><li>302 Found：资源被临时重定向了</li></ul><h3 id="4xx-客户端错误状态码">4xx (客户端错误状态码)</h3><ul><li>400 Bad Request：发送的HTTP请求存在问题</li><li>401 Unauthorized：未认证却请求需要认证之后才能访问的资源</li><li>403 Forbidden：直接拒绝HTTP请求，不处理，一般用来针对非法请求</li><li>404 Not Found：你请求的资源未在服务器找到</li><li>409 Conflict：表示请求的资源与服务器当前的状态存在冲突，请求无法被处理</li></ul><h3 id="5xx-（服务端错误状态码）">5xx （服务端错误状态码）</h3><ul><li>500 Internal Server Error：服务端出问题了，服务端处理请求的时候突然抛出异常，但是异常未在服务端被正确处理</li><li>502 Bad Gateway：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应</li></ul><h2 id="HTTP-和-HTTPS有什么区别">HTTP 和 HTTPS有什么区别</h2><ul><li>端口号:HTTP默认是80，HTTPS默认是443</li><li>前缀不同，显而易见一个是HTTP一个是HTTPS</li><li>安全性和资源消耗：HTTP所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，HTTPS所有传输的内容都经过加密，HTTPS拥有更高的安全性，但是会消耗更多的服务器资源</li></ul><h2 id="HTTP是不保存状态的协议，如何保存用户状态">HTTP是不保存状态的协议，如何保存用户状态</h2><p>HTTP协议自身不对请求和响应之间的通信状态进行保存。方案就是Session，服务端给特定的用户创建特定的Session，之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个session，过了时间限制，就会销毁这个session)</p><p>在服务端保存Session的方法很多，最常用的就是内存和数据库保存，我们一般通过在Cookie中附带一个Session ID来进行跟踪Session。</p><div class = "note note-success">Cookie被禁用怎么办？</div><p>最常用的就是利用URL重写把Session ID直接附加在URL路径的后面</p><h2 id="URI和URL的区别">URI和URL的区别</h2><ul><li>URI(Uniform Resource Identifier)：是统一资源标志符，可以唯一标识一个资源</li><li>URL(Uniform Resource Locator):统一资源定位符，可以提供该资源的路径。是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源</li></ul><h1>ARP</h1><h2 id="MAC地址">MAC地址</h2><p>MAC(Media Access Control Address)即媒体访问控制地址，互联网一切网络设备都由MAC地址唯一标识</p><p>MAC地址的长度为6字节，地址空间大小有280万亿之多，MAC地址由IEEE统一管理与分配，它具有可携带性，永久性，而IP地址则没有这些性质</p><p>MAC地址有一个特殊的地址:FF-FF-FF-FF-FF-FF (全1地址)，该地址表示广播地址</p><h2 id="ARP协议解决了什么问题">ARP协议解决了什么问题</h2><p>ARP全程地址解析协议(Address Resolution Protocol)，它解决的是网络层地址和链路层之间的转换问题，因为IP数据包在传输的过程中需要知道下一跳该去往哪里，但IP地址只是逻辑地址，MAC地址才是物理地址，解决了IP地址转MAC地址的一些问题</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2022/10/19/Netty/"/>
    <url>/2022/10/19/Netty/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">     <div>前言：</div>     <ul>         <div>             根据尚硅谷视频以及教学ppt整理         </div>         <div>             初版 待整理         </div>     <ul></div><h1>线程模型基本介绍</h1><p>现存线程模型：传统I/O服务模型和Reactor模式</p><p>传统阻塞I/O服务模型</p><p>特点：</p><p>采用阻塞IO模式获取输入的数据</p><p>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</p><p>缺陷</p><p>当并发数很大，就会创建大量的线程，占用很大系统资源</p><p>若线程暂时没有数据可读，该线程会阻塞在Hander对象的read操作，导致线程资源浪费</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221031152502979.png" alt="image-20221031152502979"></p><h2 id="BIO">BIO</h2><p><strong>Blocking I/O</strong>同步阻塞I/O模式，数据的读取都阻塞在一个线程内等待完成，很明显，无法应对高并发</p><h2 id="NIO">NIO</h2><p><strong>Non-blocking I/O</strong> 同步非阻塞型的I/O模型，提供了Channel,Seletor,Buffer等。支持面向缓冲的，基于通道的I/O操作方法，对于高负载，高并发的的应用，也有很好的支持</p><h2 id="AIO">AIO</h2><p><strong>Asynchronous I/O</strong> 就是NIO 2，是一种异步非阻塞的IO模型，异步IO是基于时间和回调机制实现的。也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成后，操作系统会通知相应的线程进行后续操作。目前AIO的应用还不是特别的广泛。</p><p class="note note-success">BIO,NIO,AIO的区别</p><p>当客户端发起请求</p><ul><li>BIO：阻塞等待直到处理完成</li><li>NIO：通过选择器监听多个通道，非阻塞，处理完成之后就返回</li><li>AIO：通过回调机制实现，应用操作后直接返回，不会阻塞在那里</li></ul><h1>Netty简介</h1><h2 id="Netty是什么">Netty是什么</h2><ul><li>Netty是一个基于NIO的client-server框架，使用它可以快速简单的开发网络应用程序</li><li>极大简化了TCP 和 UDP的套接字编程，并且在性能和安全性仿麦呢更优</li><li>支持多种协议比如SMTP，HTTP等</li></ul><h2 id="Netty版本说明">Netty版本说明</h2><p>Netty 5出现重大bug 已经被官网废弃，目前推荐使用Netty 4.x的稳定版本</p><p>在课程中，使用的是Netty4.1.x版本</p><h2 id="Netty的优点">Netty的优点</h2><ul><li>统一的API,支持多种传输类型，阻塞的，非阻塞的</li><li>自带编解码器解决TCP粘包/拆包问题</li><li>自带各种协议栈</li><li>安全性可靠</li><li>…</li></ul><h1>Netty的核心组件</h1><h2 id="Bytebuf-字节容器">Bytebuf 字节容器</h2><p>网络通信最终都是通过字节流进行传输的。ByteBuf就是Netty提供的一个字节容器，内部是一个字节数组，相比Java NIO提供的ByteBuf更加简单方便</p><h2 id="Bootstrap和ServerBootstrap-启动引导类">Bootstrap和ServerBootstrap 启动引导类</h2><p>Bootstrap的使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGGroup();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//创建客户端启动引导/辅助类:Bootstrap</span><br>    Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();<br>    <span class="hljs-comment">//指定线程模型</span><br>    b.group(group).<br>        .....<br>    <span class="hljs-comment">//尝试建立连接</span><br>    ChannelFuture f = b.connect(host,port).sync();<br>    f.channel().closeFuture().sync();<br>&#125; <span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//关闭线程组资源</span><br>    group.shutdownGracefully();<br>&#125;<br></code></pre></td></tr></table></figure><p>ServerBootstrap的使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.bossGroup用于接收连接，workerGroup 用于具体的额管理</span><br>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//2.创建服务端启动引导类/辅助类 ：ServerBootstrap</span><br>    ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-comment">//3.给引导类配置两大线程组，确定了线程模型</span><br>    b.group(bossGroup,workerGroup).<br>        .....<br>    <span class="hljs-comment">// 6. 绑定端口</span><br>    ChannelFuture f = b.bind(port).sync();<br>    <span class="hljs-comment">//等待连接关闭</span><br>    f.channel().closeFuture().sync();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//7.关闭线程组资源</span><br>    bossGroup.shutdownGracefully();<br>    wokerGroup.shutdownGracefully();<br>&#125;<br></code></pre></td></tr></table></figure><p>Bootstrap 是客户端的启动引导类，通常使用<code>connect()</code>方法连接到远程的主机和端口，作为一个Netty TCP协议通信中的客户端，Bootstrap也可以通过<code>bind()</code>方法绑定本地的一个端口，作为UDP协议通信的一个端口</p><p>ServerBootstrap 很明显是服务端的启动引导类，通常使用<code>bind()</code>方法绑定本地的端口，然后等待客户端的连接</p><p>Bootstrap只需要配置一个线程组 EventLoopGroup,而ServerBootstrap需要配置两个线程组，一个用于接收连接，一个用于具体的IO处理</p><h2 id="Channel-网络操作抽象类">Channel 网络操作抽象类</h2><p>Netty通过Channel进行IO操作。一旦客户端成功连接服务端，就会新建一个Channel和这个客户端进行绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">doConnect</span><span class="hljs-params">(InetSocketAddresss inetSocketAddress)</span></span>&#123;<br>    CompletableFuture&lt;Channel&gt; completableFuture = <span class="hljs-keyword">new</span> CompletableFuture&lt;&gt;();<br>    bootstrap.connect(inetSocketAddress).addListener((channelFutureListener) future -&gt;&#123;<br>        <span class="hljs-keyword">if</span>(future,isSuccess())&#123;<br>            completableFuture.complete(future.channel());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> completableFuture.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>常用的有两个实现类</p><p>NioServerSocketChannel (服务端)</p><p>NioSocketChannel (客户端)</p><h2 id="EventLoop-事件循环">EventLoop 事件循环</h2><h3 id="EventLoop介绍">EventLoop介绍</h3><p>EventLoop定义了Netty的核心抽象，用于处理来了连接的生命周期中所发生的事件，通俗的讲就是它的主要作用就是负责监听网络事件处理器进行相关 I/O操作(读写)的处理</p><h3 id="EventLoop和channel的关系">EventLoop和channel的关系</h3><p>channel为Netty网络操作抽象类，Event Loop负责处理注册到其上的Channel的I/O操作，两者配合进行I/O操作</p><h3 id="EventLoopGroup和EventLoop的关系">EventLoopGroup和EventLoop的关系</h3><p><code>EventLoopGroup</code>包含多个<code>EventLoop</code>管理着所有的<code>EventLoop</code>的生命周期</p><p><code>EventLoop</code>处理的I/O事件都将在它专有的<code>Thread</code>上被处理，即<code>Thread</code>和 <code>EventLoop</code>属于1:1的关系，从而保证线程安全</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221203162809780.png" alt="image-20221203162809780"></p><h2 id="ChannelHander-消息处理器-和-ChannelPipeline-ChannelHander-对象链表">ChannelHander (消息处理器) 和 ChannelPipeline (ChannelHander 对象链表)</h2><p><code>ChannelHandler</code>是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。</p><p>当channel被创建的时候，会自动地分配到它专属的<code>ChannelPipeline</code>。 <code>ChannelPipeline</code>是<code>ChannelHander</code>的链，一个pipeline上可以有多个<code>ChannelHandler</code></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221203164046760.png" alt="image-20221203164046760"></p><h2 id="ChannelFuture-操作执行结果">ChannelFuture 操作执行结果</h2><p>Netty中所有的I/O操作都是异步的，我们不能立刻得到操作是否执行成功，不过可以通过<code>ChannelFuture</code>接口的<code>addListener</code>方法注册一个<code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelFuture f = b.connect(host,port).addListener(future -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(future.isSuccess())&#123;<br>        System.out.println(<span class="hljs-string">&quot;连接成功!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.err.println(<span class="hljs-string">&quot;连接失败!&quot;</span>);<br>    &#125;<br>&#125;).sync();<br></code></pre></td></tr></table></figure><p>还可以通过<code>ChannelFuture</code>的<code>channel()</code>方法获取连接相关联的<code>Channel</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Channel channel = f.channel();<br></code></pre></td></tr></table></figure><p>还可以通过<code>ChannelFuture</code>接口的<code>sync()</code>方法让异步的操作变成同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelFuture f = b.bind(port).sync();<br></code></pre></td></tr></table></figure><p><strong>NioEventLoopGroup</strong>默认的构造函数实际会起的线程数为<strong>CPU核心数*2</strong></p><h1>Reactor 线程模型</h1><p>Reactor是一种经典的线程模型，它基于事件驱动，特别适合处理海量的I/O事件</p><p>别名</p><ul><li>反应器模式</li><li>分发者模式(Dispatcher)</li><li>通知者模式(notifier)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221031153540687.png" alt="image-20221031153540687"></p><p>Reactor 模式 通过一个或多个输入同时传递给服务处理器的模式</p><p>服务器端程序处理传入的多个请求，并将他们同步分派到相应的处理线程</p><p>Reator模式使用IO复用监听事件，收到事件后，分发给某个线程</p><p>原先有多个Hander阻塞，现在只用一个ServiceHandler连接</p><h2 id="Reactor模式分类">Reactor模式分类</h2><h3 id="单线程Reactor">单线程Reactor</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221101195028780.png" alt="image-20221101195028780"></p><p>单线程Reactor的优点是对系统资源的消耗特别小，但是，没办法支撑大量请求的应用场景并且处理请求的时间可能非常慢，所以一般实际项目中不会使用单线程Reactor</p><h3 id="多线程Reactor">多线程Reactor</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221101193557851.png" alt="image-20221101193557851"></p><p><strong>一个</strong>线程负责接收请求，<strong>一组</strong>NIO请求处理IO操作</p><p>大部分场景下多线程Reactor模型没有啥问题，但是在一些并发数连接比较多(百万级别)的情况下，一个线程负责接收客户端就存在性能问题了</p><h3 id="主从Reactor多线程">主从Reactor多线程</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221101193327320.png" alt="image-20221101193327320"></p><p>一组NIO线程负责接收请求，一组NIO线程处理IO操作</p><div class = "note note-success">更通俗的理解</div><p>单Reactor单线程 前台接待员和服务员是同一个人，全程为顾客服务</p><p>单Reactor多线程 一个前台接待员，多个服务员，接待员只负责接待</p><p>主从Reactor多线程，多个前台接待员，多个服务生</p><h1>Netty线程模型</h1><p>大部分的网络框架都是基于Reactor模式设计开发的，在Netty主要靠<code>NioEventLoopGroup</code>线程池来实现具体的线程模型。</p><p>实现服务端的时候，一般会初始化两个线程组</p><ul><li>bossGroup : 接收连接</li><li>workerGroup: 负责具体的处理，交由对应的Hander处理</li></ul><h2 id="单线程模型">单线程模型</h2><p>一个线程执行处理所有的accept,read,decode,process,encode,send事件，无法应对性能要求比较高的场景</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理</span><br>EventLoopGroup eventGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span><br>ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>           b.group(eventGroup,eventGroup)<br>           <span class="hljs-comment">//....</span><br></code></pre></td></tr></table></figure><h2 id="多线程模型">多线程模型</h2><p>一个Acceptor线程只负责监听客户端的连接，一个NIO线程池负责具体的处理accept,read,decode,process,encode,send事件，但是和上面说的一样，可以处理连接量不太大的情况，但是连接量巨大的时候(百万级别)就可能出现性能瓶颈</p><p>can can 代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.bossGroup 用于接收连接，workerGroup用于具体的处理</span><br>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span><br>    ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-comment">//3.给引导类配置两大线程组，确定线程模型</span><br>    b.group(bossGroup,workerGroup)<br>        <span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="主从多线程模型">主从多线程模型</h2><p>从一个主线程NIO线程池中选择一个线程作为Acceptor线程，绑定监听端口，接受客户端连接的连接，其他线程负责后续的接入认证等工作。连接完成后，SubNIO线程池负责具体处理I/O读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.bossGroup 用于接收连接，workerGroup用于具体的处理</span><br>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<span class="hljs-comment">//这里没有1</span><br>EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span><br>    ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-comment">//3.给引导类配置两大线程组，确定线程模型</span><br>    b.group(bossGroup,workerGroup)<br>        <span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>Netty服务端和客户端的启动过程</h1><h2 id="服务端">服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.bossGroup 用于接收连接，workerGroup用于具体的处理</span><br>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span><br>    ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-comment">//3.给引导类配置两大线程组，确定线程模型</span><br>    b.group(bossGroup,workerGroup)<br>        <span class="hljs-comment">// 4.指定IO模型</span><br>        .channel(NioSocketChannel.class)<br>        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                         * 自定义序列化编解码器</span><br><span class="hljs-comment">                         */</span><br>                        ChannelPipeline p = ch.pipeline();<br>                        <span class="hljs-comment">//5.可以自定义客户端消息的业务处理逻辑</span><br>                        p.addLast(<span class="hljs-keyword">new</span> HelloServerHandler());<br>                    &#125;<br>        &#125;);<br>    <span class="hljs-comment">// 6.绑定端口，调用sync方法阻塞直到绑定完成</span><br>    ChannelFuture f = b.bind(port).sync();<br>    <span class="hljs-comment">// 7.阻塞等待直到服务器Channel关闭</span><br>    f.channel().closeFuture().sync();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//8.关闭线程组资源</span><br>    bossGroup.shutdownGracefully();<br>    wokerGroup.shutdownGracefully();<br>&#125;        <br></code></pre></td></tr></table></figure><h2 id="客户端">客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个NioEventLoopGroup对象实例</span><br>EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//2.创建服务端启动引导/辅助类：Bootstrap</span><br>    Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();<br>    <span class="hljs-comment">//3.指定线程组</span><br>    b.group(bossGroup,workerGroup)<br>        <span class="hljs-comment">// 4.指定IO模型</span><br>        .channel(NioSocketChannel.class)<br>        .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                      <br>                        ChannelPipeline p = ch.pipeline();<br>                        <span class="hljs-comment">//5.可以自定义客户端消息的业务处理逻辑</span><br>                        p.addLast(<span class="hljs-keyword">new</span> HelloServerHandler(message));<br>                    &#125;<br>        &#125;);<br>    <span class="hljs-comment">// 6.尝试建立连接</span><br>    ChannelFuture f = b.connect(host,port).sync();<br>    <span class="hljs-comment">// 7.等待连接关闭</span><br>    f.channel().closeFuture().sync();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//8.关闭线程组资源</span><br>    group.shutdownGracefully();<br>&#125;        <br></code></pre></td></tr></table></figure><p>这里的connect方法返回的是一个ChannelFuture对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> </span>&#123;<br>        ObjectUtil.checkNotNull(remoteAddress, <span class="hljs-string">&quot;remoteAddress&quot;</span>);<br>        <span class="hljs-keyword">this</span>.validate();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.doResolveAndConnect(remoteAddress, <span class="hljs-keyword">this</span>.config.localAddress());<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(remoteAddress, <span class="hljs-string">&quot;remoteAddress&quot;</span>);<br>    <span class="hljs-keyword">this</span>.validate();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.doResolveAndConnect(remoteAddress, localAddress);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为他是异步的，也可以像上面ChannelFuture那儿说的，通过addListener方法增加一个监听器打印消息，看是否连接成功</p><h1>TCP 粘包/拆包</h1><p>TCP粘包/拆包就是基于TCP发送数据的时候，出现了多个字符串“粘”在一起或者一个字符串被“拆”开的情况</p><p>解决方案</p><ol><li>使用Netty自带的解码器</li></ol><ul><li><p><code>lineBasedFrameDecoder</code>：发送数据包的时候，每个数据包之间以换行符作为分隔，<code>lineBaseFrameDecoder</code>就依次遍历<code>ByteBuf</code>中的可读字节，判断是否有换行符，然后截取</p></li><li><p><code>DelimiterBasedFrameDecoder</code> :可以自定义分隔符解码器，<code>lineBasedFrameDecoder</code>实际上是一种特殊的<code>DelimiterBasedFrameDecoder</code>解码器</p></li><li><p><code>FixedLengthFrameDecoder</code>：固定长度解码器</p></li><li><p><code>LengthFieldBaseFrameDecoder</code>：基于长度字段的解码器</p></li></ul><ol start="2"><li>自定义序列化编解码器</li></ol><p>在Java中自带有<code>Serializable</code>接口来实现序列化，但是性能，安全等并不理想。</p><p>所以一般使用Protostuff,Hessian2,json,Kryo等等</p><h1>Netty长连接，心跳机制</h1><h2 id="长连接和短连接">长连接和短连接</h2><p>短连接就是server端与client端连接之后，读写完成后就关闭掉，如果下一次再要互相发送消息，就要重新连接，优点就是管理和实现都比较简单，缺点即每次读写都建立连接会带来大量的消耗</p><p>长连接就是client和server双方建立连接之后，即使client和server完成一次读写，他们之间的连接不会主动关闭，后续读写继续使用这个连接。长连接可以省去较多的TCP建立和关闭的操作，降低对网络的依赖，节约时间。</p><h2 id="心跳机制">心跳机制</h2><p>在保持长连接的过程中，可能会出现网络异常出现，那么怎么发现对方已经掉线呢，答案就是心跳机制</p><p>心跳机制就是client与server之间没有数据交互的时候，客户端或服务器就会发送一个特殊的数据包给对方，接收方收到数据后，也会发送一个特殊的数据报文回应对方，这样，就知道了对象仍然在线，确保TCP连接的有效性</p><p>Netty层面实现的话，核心类是<code>IdleStateHander</code></p><h1>Netty的零拷贝</h1><p>Zero-copy 即计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于网络传输文件时节省CPU周期和内存带宽</p><p>在OS层面上的零拷贝通常用于避免在用户态与内存态之间来回拷贝数据，在Netty层面，主要体现咋子对于数据操作的优化</p><p>Netty中</p><ul><li>使用Netty提供的<code>CompositeByteBuf</code>类，可以合并多个<code>ByteBuf</code>为一个逻辑上的<code>ByteBuf</code>,避免多个<code>ByteBuf</code>之间的拷贝</li><li><code>ByteBuf</code>支持slice操作，因此可以将<code>ByteBuf</code>分解为多个共享同一个存储区域的<code>ByteBuf</code>避免内存拷贝</li><li>通过<code>FileRegion</code>包装的<code>FileChannel.tranferTo</code>实现问文件传输，可以直接将文件缓冲区的数据传输到目标<code>Channel</code>,避免了传统的通过循环write方式导致的内存拷贝问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/2022/09/14/Java%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/09/14/Java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">    <p>前言:<p>    <ul>       <p>根据狂神说的视频以及《深入浅出Java多线程》整理出该笔记</p>    </ul></div><h1>JUC</h1><h2 id="概念">概念</h2><p>JUC并发编程就是多线程的进阶版，主要包含三个类java.util.concurrent、 java.util.concurrent.automic、 java.util.concurrent.locks</p><h2 id="回顾">回顾</h2><h3 id="进程和线程">进程和线程</h3><p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p><p>**一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。**总之，进程和线程的提出极大的提高了操作系统的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p><p>当然区别还是有的，他们本质的区别就是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>，另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p><h3 id="线程的几个状态">线程的几个状态</h3><ul><li><p>new 新建</p></li><li><p>runnable 运行</p></li><li><p>blocked 阻塞</p></li><li><p>waiting 等待</p></li><li><p>timed_waiting 超时等待</p></li><li><p>terminated终止</p></li></ul><h3 id="wait-sleep区别">wait/sleep区别</h3><ul><li><p>wait 会释放锁   sleep 不会释放锁</p></li><li><p>使用的范围不同  wait必须在同步代码块中 sleep可以任何地方使用</p></li><li><p>wait 不需要捕获异常   sleep则需要</p></li></ul><h3 id="Synchronzied-和Lock区别">Synchronzied 和Lock区别</h3><ul><li><p>Synchronized 内置的Java关键字 Lock是一个Java类</p></li><li><p>S无法判断锁的状态 Lock可以判断是否获取到了锁</p></li><li><p>S会自动释放锁 Lock必须手动释放 如果不释放就会死锁</p></li><li><p>S 线程1 （获得锁）线程2 （等待），lock锁下的线程就不一定一直等</p></li><li><p>S可重入锁 不可以中断，非公平，Lock 可重入锁</p></li><li><p>S适合锁少量的代码同步问题 Lock适合锁大量的代码同步问题</p></li></ul><h2 id="虚假唤醒问题">虚假唤醒问题</h2><p>先来看看synchronized下的生产者和消费者问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        data data = <span class="hljs-keyword">new</span> data();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    data.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    data.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">data</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//+1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span>(number!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//等待</span><br>            <span class="hljs-keyword">this</span>.wait();<br>        &#125;<br>        number++;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt;&quot;</span>+number);<br>        <span class="hljs-comment">//通知其他线程</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>    &#125;<br><br>    <span class="hljs-comment">//-1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">this</span>.wait();<br>        &#125;<br>        number--;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt;&quot;</span>+number);<br>        <span class="hljs-keyword">this</span>.notifyAll();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>若不是两个线程，而是多个线程，就会出现以下的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>A=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>C=&gt;<span class="hljs-number">1</span><br>A=&gt;<span class="hljs-number">2</span><br>C=&gt;<span class="hljs-number">3</span><br>B=&gt;<span class="hljs-number">2</span><br>B=&gt;<span class="hljs-number">1</span><br>B=&gt;<span class="hljs-number">0</span><br>C=&gt;<span class="hljs-number">1</span><br>A=&gt;<span class="hljs-number">2</span><br>C=&gt;<span class="hljs-number">3</span><br>A=&gt;<span class="hljs-number">4</span><br>C=&gt;<span class="hljs-number">5</span><br>D=&gt;<span class="hljs-number">4</span><br>D=&gt;<span class="hljs-number">3</span><br>C=&gt;<span class="hljs-number">4</span><br>D=&gt;<span class="hljs-number">3</span><br>D=&gt;<span class="hljs-number">2</span><br>D=&gt;<span class="hljs-number">1</span><br>D=&gt;<span class="hljs-number">0</span><br>C=&gt;<span class="hljs-number">1</span><br>D=&gt;<span class="hljs-number">0</span><br>C=&gt;<span class="hljs-number">1</span><br>D=&gt;<span class="hljs-number">0</span><br>C=&gt;<span class="hljs-number">1</span><br>D=&gt;<span class="hljs-number">0</span><br>C=&gt;<span class="hljs-number">1</span><br>D=&gt;<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>问题分析</p><p>结果的出现原因是资源类的if判断，可能导致两个加的方法同时进来，造成的虚假唤醒问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-comment">//这里改成while  像自旋锁</span><br>           <span class="hljs-comment">//等待</span><br>           <span class="hljs-keyword">this</span>.wait();<br>       &#125;<br>       number++;<br>       System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt;&quot;</span>+number);<br>       <span class="hljs-comment">//通知其他线程</span><br>       <span class="hljs-keyword">this</span>.notifyAll();<br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="lock锁下的生产者消费者问题">lock锁下的生产者消费者问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> PC;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: JUCDemo1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Like</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-09-30 18:59</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        data2 data = <span class="hljs-keyword">new</span> data2();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    data.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    data.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    data.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;C&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    data.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;D&quot;</span>).start();<br>    &#125;<br><br>&#125;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">data2</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//使用lock 锁</span><br>    Lock lock =  <span class="hljs-keyword">new</span> ReentrantLock();<br>    Condition condition =  lock.newCondition();<br><br><br>    <span class="hljs-comment">//+1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        lock.lock();<br>        <span class="hljs-comment">//ctrl+alt+t  快速环绕</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//等待</span><br>                condition.await();<br>            &#125;<br>            number++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt;&quot;</span>+number);<br>            condition.signalAll();<span class="hljs-comment">//通知全部线程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<span class="hljs-comment">//释放，防止死锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//-1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(number==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//等待</span><br>                condition.await();<br>            &#125;<br>            number--;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt;&quot;</span>+number);<br>            condition.signalAll();<span class="hljs-comment">//通知全部线程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<span class="hljs-comment">//释放，防止死锁</span><br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="八锁问题">八锁问题</h2><p>资源类phone可以发短信和打电话</p><p>1.创建一个Phone实例多线程调用两个方法，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone = <span class="hljs-keyword">new</span> phone();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>发短信<br>打电话<br><br></code></pre></td></tr></table></figure><p>分析：synchronized关键字是对对象上锁，谁先拿到锁，谁就先执行</p><p>2.创建一个Phone实例多线程调用两个方法，其中第一个线程调用的方法中加延迟，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone = <span class="hljs-keyword">new</span> phone();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>发短信<br>打电话<br><br></code></pre></td></tr></table></figure><p>分析：原理同上，谁先拿到锁，谁先执行</p><p>3.创建一个Phone实例多线程调用两个方法，其中一个是普通方法，而且该线程位置靠后，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone = <span class="hljs-keyword">new</span> phone();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone.watchvideo();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">watchvideo</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;看视频&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>看视频<br>发短信<br></code></pre></td></tr></table></figure><p>分析：<code>watchvideo()</code>为普通方法，当然是不受锁的影响，因为 <code>sendMessage()</code>方法体 中有延迟语句，因此会后输出，其实 抛去延迟来说，两个输出结果为不一定</p><p>4.创建两个Phone实例多线程调用两个方法，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone1 = <span class="hljs-keyword">new</span> phone();<br>        phone phone2 = <span class="hljs-keyword">new</span> phone();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone2.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>打电话<br>发短信<br></code></pre></td></tr></table></figure><p>分析：由于是两个对象，因此锁对象之间没有干扰，因为延时，所以打电话先输出，而且可以证明锁住的是实例对象，多个之间并不干扰</p><p>5.创建一个Phone实例多线程调用两个方法，两个方法都有static修饰，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone1 = <span class="hljs-keyword">new</span> phone();<br>       <span class="hljs-comment">// phone phone2 = new phone();</span><br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>发短信<br>打电话<br></code></pre></td></tr></table></figure><p>分析：发短信 在前面的原因是 synchronized 加 静态方法 锁的是 Class ，<code>Phone.Class</code>只有单个。因此第二个线程需要 等待第一个线程释放Class锁才能执行。</p><p>6.创建两个Phone实例多线程调用两个方法，两个方法都有static修饰，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone1 = <span class="hljs-keyword">new</span> phone();<br>        phone phone2 = <span class="hljs-keyword">new</span> phone();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone2.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>发短信<br>打电话<br></code></pre></td></tr></table></figure><p>分析：虽然是两个实例对象，但是锁住的是同一个phone.class，原理和5是一样的</p><p>7.创建一个Phone实例多线程调用两个方法，其中一个有static修饰，而且调用线程在前面，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone1 = <span class="hljs-keyword">new</span> phone();<br>        <span class="hljs-comment">//phone phone2 = new phone();</span><br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>打电话<br>发短信<br></code></pre></td></tr></table></figure><p>分析：打电话 先输出的原因是 Phone7 实例 和 Phone7.Class 分别被锁，两个线程之间并无影响，因为线程延迟的原因。再次 证明 synchronized 锁的是 类实例即对象 、synchronized 加 静态方法 锁的是 Class</p><p>8.创建两个Phone实例多线程调用两个方法，其中一个有static修饰，而且调用线程在前面，问哪一个先执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phone phone1 = <span class="hljs-keyword">new</span> phone();<br>        phone phone2 = <span class="hljs-keyword">new</span> phone();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone1.sendMessage();<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">//Java的延时方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            phone2.call();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>打电话<br>发短信<br></code></pre></td></tr></table></figure><p>分析：原理同7两个线程分别锁的是 Phone8.Class 和 Phone8实例，因为线程延迟，打电话 才会优先输出。</p><h2 id="集合的线程安全">集合的线程安全</h2><h3 id="概述">概述</h3><ul><li>线程安全集合：多线程并发的基础上修改一个集合，不会发生ConcurrentModificationException并发修改异常</li><li>CopyOnWriteArrayList是线程安全的集合，ArrayList是线程不安全的集合，Vector是线程安全的集合</li></ul><h3 id="ArrayList的线程安全">ArrayList的线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo1_arraylist</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));<br>                System.out.println(list);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>[<span class="hljs-keyword">null</span>, 0c293, 7509b]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b, <span class="hljs-number">50105</span>, a4b9f, cd3b1, 4d7bb, <span class="hljs-number">89969</span>, dd07a, de64e]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b, <span class="hljs-number">50105</span>, a4b9f, cd3b1, 4d7bb, <span class="hljs-number">89969</span>]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b, <span class="hljs-number">50105</span>, a4b9f, cd3b1]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b, <span class="hljs-number">50105</span>, a4b9f, cd3b1, 4d7bb]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b, <span class="hljs-number">50105</span>, a4b9f]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b, <span class="hljs-number">50105</span>]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b]<br>[<span class="hljs-keyword">null</span>, 0c293, 7509b]<br>Exception in thread <span class="hljs-string">&quot;8&quot;</span> java.util.ConcurrentModificationException<br>at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="hljs-number">911</span>)<br>at java.util.ArrayList$Itr.next(ArrayList.java:<span class="hljs-number">861</span>)<br>at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="hljs-number">461</span>)<br>at java.lang.String.valueOf(String.java:<span class="hljs-number">2994</span>)<br>at java.io.PrintStream.println(PrintStream.java:<span class="hljs-number">821</span>)<br>at listsecurity.demo1_arraylist.lambda$main$<span class="hljs-number">0</span>(demo1_arraylist.java:<span class="hljs-number">20</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><br></code></pre></td></tr></table></figure><p>如何解决呢？</p><ul><li>使用Vector：查看Vector的add()方法，发现相比于ArrayList的add()方法前面加了synchronized修饰,因此是线程安全的</li><li>使用Collectiobns.synchronizedlist(new ArrayList<String>):Collections集合工具类提供一些列线程安全的集合构造方法。</li><li>使用 JUC包下的 CopyOnWriteArrayList集合:一种线程安全的集合，CopyOnWrite的意思是写入时复制，是一种计算机程序设计优化策略，解决多线程写入覆盖问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br><span class="hljs-comment">//这几个就是线程安全的</span><br></code></pre></td></tr></table></figure><h3 id="Set-Map集合的线程安全">Set,Map集合的线程安全</h3><p>对比ArrayList，Set同样线程并不安全，可以通过上面类似的解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = Collections.synchronizedSet(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();<br></code></pre></td></tr></table></figure><p>实际上HashSet的底层是HashMap方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment">     * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br><span class="hljs-comment">//源码中的构造方法</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds the specified element to this set if it is not already present.</span><br><span class="hljs-comment">     * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="hljs-comment">     * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="hljs-comment">     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="hljs-comment">     * If this set already contains the element, the call leaves the set</span><br><span class="hljs-comment">     * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e element to be added to this set</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="hljs-comment">     * element</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>    &#125;<br><span class="hljs-comment">//add方法也是直接调用的</span><br></code></pre></td></tr></table></figure><p>因此Map也是不安全的，解决方法同样有两种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; map = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;())<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><h2 id="读写锁">读写锁</h2><p>ReadWriteLock维护一对关联的locks ，一个用于只读操作，一个用于写入。 read lock可以由多个阅读器线程同时进行，只要没有作者。 write lock是独家的。简单理解就是 可以多个线程同时读，只能有一个线程同时写。</p><p>对于最初填充数据的集合，然后经常被修改的场合时使用读写锁的立项候选，但是对于数据的大部分时间被专门锁定，并且并发型增加很少，那么不建议使用读写锁，<strong>简单理解就是 经常被修改的读取的数据，建议使用读写锁，对于不长变动而且 并发很少的情况，不建议使用读写锁。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用读写锁，实现模拟缓存</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo1_rwl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MycacheReadWriteLock cache = <span class="hljs-keyword">new</span> MycacheReadWriteLock();<br><br>        <span class="hljs-comment">//四个线程写入缓存</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>  temp = i;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                cache.save(temp + <span class="hljs-string">&quot;&quot;</span>,temp + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-comment">//四个线程写入缓存</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>  temp = i;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                cache.get(temp + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//模拟缓存 加上读写锁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MycacheReadWriteLock</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String,String&gt; cache  = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">//读写锁对象</span><br>    ReentrantReadWriteLock reentrantReadWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(String key,String value)</span></span>&#123;<br><br>         <span class="hljs-comment">//加入写锁 保证只有一个线程来写</span><br>          reentrantReadWriteLock.writeLock().lock();<br><br><br>         <span class="hljs-keyword">try</span> &#123;<br>             System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;===&gt;开始写入数据&quot;</span>);<br>             cache.put(key,value);<br>             System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;===&gt;写入成功了&quot;</span>);<br>         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>             e.printStackTrace();<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             reentrantReadWriteLock.writeLock().unlock();<br>         &#125;<br><br><br>     &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>&#123;<br>        <span class="hljs-comment">//加上读锁，保证读的时候没有其他的线程在写</span><br>        reentrantReadWriteLock.readLock().lock();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;===&gt;开始获取数据&quot;</span>);<br>            cache.get(key);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;===&gt;获取成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放读锁</span><br>            reentrantReadWriteLock.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span>===&gt;开始写入数据<br><span class="hljs-number">0</span>===&gt;写入成功了<br><span class="hljs-number">2</span>===&gt;开始写入数据<br><span class="hljs-number">2</span>===&gt;写入成功了<br><span class="hljs-number">3</span>===&gt;开始写入数据<br><span class="hljs-number">3</span>===&gt;写入成功了<br><span class="hljs-number">1</span>===&gt;开始写入数据<br><span class="hljs-number">1</span>===&gt;写入成功了<br><span class="hljs-number">1</span>===&gt;开始获取数据<br><span class="hljs-number">1</span>===&gt;获取成功<br><span class="hljs-number">0</span>===&gt;开始获取数据<br><span class="hljs-number">2</span>===&gt;开始获取数据<br><span class="hljs-number">3</span>===&gt;开始获取数据<br><span class="hljs-number">3</span>===&gt;获取成功<br><span class="hljs-number">2</span>===&gt;获取成功<br><span class="hljs-number">0</span>===&gt;获取成功<br></code></pre></td></tr></table></figure><h2 id="阻塞队列">阻塞队列</h2><p><img src="https://img-blog.csdnimg.cn/20210712171515358.png" alt=""></p><p>BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。阻塞队列简单的来说就是<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p><p>阻塞指两种状态</p><ul><li>入队：如果队列此时是满的，需要阻塞等待</li><li>取出：如果队列是空的，需要阻塞等待生产</li></ul><h3 id="阻塞队列的操作方法">阻塞队列的操作方法</h3><p>提供了四组不同的方法用于插入，移除，检查元素</p><table><thead><tr><th style="text-align:center">方法\处理方式</th><th style="text-align:center">抛出异常</th><th style="text-align:center">返回特殊值</th><th style="text-align:center">一直阻塞</th><th style="text-align:center">超时退出</th></tr></thead><tbody><tr><td style="text-align:center">插入方法</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center"><strong>put(e)</strong></td><td style="text-align:center">offer(e,time,unit)</td></tr><tr><td style="text-align:center">移除方法</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center"><strong>take()</strong></td><td style="text-align:center">poll(time,unit)</td></tr><tr><td style="text-align:center">检查方法</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><ul><li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。</li><li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li><li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。</li></ul><p><strong>注意之处</strong></p><ul><li>不能往阻塞队列中插入null,会抛出空指针异常。</li><li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo1_blockingqueue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//test1();</span><br>        <span class="hljs-comment">//test2();</span><br>        <span class="hljs-comment">//test3();</span><br>        test4();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        ArrayBlockingQueue queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);<br><br>        queue.add(<span class="hljs-string">&quot;william&quot;</span>);<br>        queue.add(<span class="hljs-string">&quot;will&quot;</span>);<br>        queue.add(<span class="hljs-string">&quot;iam&quot;</span>);<br><br>        System.out.println(queue);<br>        <span class="hljs-comment">//queue.add(&quot;队列已满，入队会抛异常&quot;); IllegalStateException</span><br><br>        System.out.println(queue.remove());<br>        <span class="hljs-comment">//获取队首元素</span><br>        System.out.println(queue.element());<br>        System.out.println(queue.remove());<br>        System.out.println(queue.remove());<br>       <span class="hljs-comment">//System.out.println(queue.element()); 队列为空的时候，获取队首元素抛异常 NoSuchElementException</span><br><br><br>        System.out.println(queue);<br><br>        <span class="hljs-comment">//System.out.println(queue.remove()); 队列已空，再次出队会抛异常 NoSuchElementException</span><br><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        ArrayBlockingQueue queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);<br><br>        queue.offer(<span class="hljs-string">&quot;william&quot;</span>);<br>        queue.offer(<span class="hljs-string">&quot;will&quot;</span>);<br>        queue.offer(<span class="hljs-string">&quot;iam&quot;</span>);<br><br>        System.out.println(queue.offer(<span class="hljs-string">&quot;队列已满，入队返回异常&quot;</span>));<br><br><br>        System.out.println(queue.poll());<br>        System.out.println(queue.poll());<br>        System.out.println(queue.poll());<br><br><br>        System.out.println(queue.poll()); <span class="hljs-comment">// 队列为空，出队返回null</span><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayBlockingQueue queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);<br><br><br>        queue.put(<span class="hljs-string">&quot;william&quot;</span>);<br>        queue.put(<span class="hljs-string">&quot;will&quot;</span>);<br>        queue.put(<span class="hljs-string">&quot;iam&quot;</span>);<br><br>        queue.put(<span class="hljs-string">&quot;队列已满，一直阻塞等待&quot;</span>);<br><br>        System.out.println(queue.take());<br>        System.out.println(queue.take());<br>        System.out.println(queue.take());<br><br>        System.out.println(queue.take());<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayBlockingQueue queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);<br><br>        queue.put(<span class="hljs-string">&quot;william&quot;</span>);<br>        queue.put(<span class="hljs-string">&quot;will&quot;</span>);<br>        queue.put(<span class="hljs-string">&quot;iam&quot;</span>);<br><br><br>        queue.offer(<span class="hljs-string">&quot;队列已满，入队会超时等待&quot;</span>,<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><br><br>        System.out.println(queue.take());<br>        System.out.println(queue.take());<br>        System.out.println(queue.take());<br><br><br>        System.out.println(queue.poll(<span class="hljs-number">1</span>, TimeUnit.SECONDS)); <span class="hljs-comment">// 队列为空，超时等待，过时间自动结束</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//test1输出</span><br>[william, will, iam]<br>william<br>will<br>will<br>iam<br>[]<br><br><span class="hljs-comment">//test2输出</span><br><span class="hljs-keyword">false</span><br>william<br>will<br>iam<br><span class="hljs-keyword">null</span><br>    <br><span class="hljs-comment">//test3一直阻塞</span><br><br>    <br><span class="hljs-comment">//test4输出</span><br>william<br>will<br>iam<br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="同步队列">同步队列</h3><p><strong>SynchronousQueue</strong>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p><p>需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。</p><p>以下方法的返回值，可以帮助理解这个队列：</p><ul><li>iterator() 永远返回空，因为里面没有东西</li><li>peek() 永远返回null</li><li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li><li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li><li>take() 取出并且remove掉queue里的element，取不到东西他会一直等。</li><li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。</li><li>isEmpty() 永远返回true</li><li>remove()&amp;removeAll() 永远返回false</li></ul><h2 id="线程池">线程池</h2><p>池化技术就是事先准备好一些资源，有人需要用 久去那里拿，用完再还回去,</p><p>线程池的好处</p><ol><li>线程复用,可以控制最大并发数,管理线程</li><li>降低资源的消耗</li><li>提高响应的速度</li><li>方便管理</li></ol><p>使用Executors创建线程池</p><p>Executors创建的线程池实例常用的三个方法</p><ul><li>newSingleThreadExecutor()创建一个使用从无界队列运行的单个工作线程的执行程序。</li><li>newFixedThreadPool(int nThreads)创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</li><li>newCachedThreadPool()创建一个根据需要创建新线程的线程池核心线程数为0，全部线程可回收，在可用时将重新使用以前构造的线程。</li><li>newScheduThreadPool()创建一个定时任务线程池</li><li>线程池关闭的方法pool.shutdown()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_ThreadPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService pool1 = Executors.newSingleThreadExecutor();<br>        ExecutorService pool2 = Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        ExecutorService pool3 = Executors.newCachedThreadPool();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                pool1.execute(()-&gt;&#123;<br>                    System.out.println(Thread.currentThread().getName());<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭线程池</span><br>            pool1.shutdown();<br>        &#125;<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                pool2.execute(()-&gt;&#123;<br>                    System.out.println(Thread.currentThread().getName());<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭线程池</span><br>            pool1.shutdown();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                pool3.execute(()-&gt;&#123;<br>                    System.out.println(Thread.currentThread().getName());<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭线程池</span><br>            pool1.shutdown();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">2</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">3</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">4</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">3</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">5</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">6</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">2</span><br>pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">4</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">3</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">2</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">1</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">4</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">5</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">6</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">7</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">8</span><br>pool-<span class="hljs-number">3</span>-thread-<span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><p>查看源码发现其实他们底层都是ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an Executor that uses a single worker thread operating</span><br><span class="hljs-comment"> * off an unbounded queue, and uses the provided ThreadFactory to</span><br><span class="hljs-comment"> * create a new thread when needed. Unlike the otherwise</span><br><span class="hljs-comment"> * equivalent &#123;<span class="hljs-doctag">@code</span> newFixedThreadPool(1, threadFactory)&#125; the</span><br><span class="hljs-comment"> * returned executor is guaranteed not to be reconfigurable to use</span><br><span class="hljs-comment"> * additional threads.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> threadFactory the factory to use when creating new</span><br><span class="hljs-comment"> * threads</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the newly created single-threaded Executor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if threadFactory is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看一下ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                             TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                             ThreadFactory threadFactory)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>            threadFactory, defaultHandler);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>七大参数</p><p>核心线程数 ：@param corePoolSize 池中要保留的线程数，即使它们处于空闲状态，除非设置了 {@code allowCoreThreadTimeOut}</p><p>最大线程数：@param maximumPoolSize 池中允许的最大线程数</p><p>空闲存活时间：@param keepAliveTime 当线程数较大时与核心相比，这是多余空闲线程在终止之前等待新任务的最长时间。</p><p>超时单位：@param unit {@code keepAliveTime} 参数的时间单位</p><p>阻塞队列： @param workQueue 用于在执行任务之前保存任务的队列。该队列将仅保存由 {@code execute} 方法提交的 {@code Runnable} 任务。</p><p>线程工厂 ：@param threadFactory 执行程序创建新线程时使用的工厂</p><p>拒接策略：@param handler 执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量 @throws IllegalArgumentException 如果以下情况之一成立：<br>{@code corePoolSize &lt; 0}<br>{@code keepAliveTime &lt; 0}<br>{@code maximumPoolSize &lt;= 0}<br>{@code maximumPoolSize &lt; corePoolSize}<br>@throws NullPointerException if {@code workQueue} 或 {@code threadFactory}或 {@code handler} 为空</p><h3 id="四种拒绝策略">四种拒绝策略</h3><p>RejectedExecutionHandler 是拒绝策略的接口，有四个实现类</p><ul><li>AbortPolicy : 默认拒绝策略，抛出异常</li><li>DiscardPolicy：不会抛出异常，会丢掉任务</li><li>DiscardOldestPolicy：不会抛出异常，会和最早的线程尝试竞争资源，竞争不一定会成功，失败就丢调任务</li><li>CallerRunsPolicy：从哪个线程来的，哪个线程处理，即main线程处理</li></ul><p>最大线程数可以通过两种方式设置</p><ul><li><p>CPU密集型  和本机核心数保持一致，可以保证CPU的效率最高</p></li><li><p>IO密集型 根据程序中大型IO耗时线程，保证大于等于</p></li></ul><h2 id="四大函数式接口">四大函数式接口</h2><p>都可以使用lamda表达式简化，函数式接口 只有一个方法的接口</p><p><code>java.util.Function</code> 包下的 有基本的四大函数式接口</p><ul><li><p>Function 函数式接口</p></li><li><p>Predicate 断定型接口</p></li><li><p>Consumer 消费型接口  只有输入没有返回值</p></li><li><p>Supplier 供给型接口 只有输出没有参数</p></li></ul><h3 id="Function接口">Function接口</h3><p>apply方法接受一个参数t，返回一个参数R</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Represents a function that accepts one argument and produces a result.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="hljs-comment"> * whose functional method is &#123;<span class="hljs-doctag">@link</span> #apply(Object)&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of the input to the function</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;R&gt; the type of the result of the function</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Applies this function to the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the function argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the function result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br>    <br><br><span class="hljs-comment">//接收T R返回的是R T</span><br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo1_function</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String, String&gt; function = <span class="hljs-keyword">new</span> Function&lt;String, String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> s;<br>            &#125;<br>        &#125;;<br><br>        Function function1 = (str)-&gt;&#123;<span class="hljs-keyword">return</span> str;&#125;;<br>        Function function2 = str-&gt;&#123;<span class="hljs-keyword">return</span> str;&#125;;<span class="hljs-comment">//当只有一个参数的时候 括号可以省略</span><br><br>        System.out.println(function.apply(<span class="hljs-string">&quot;niubi&quot;</span>));<br>        System.out.println(function1.apply(<span class="hljs-string">&quot;niubi&quot;</span>));<br>        System.out.println(function2.apply(<span class="hljs-string">&quot;niubi&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Predicate接口">Predicate接口</h3><p>断定型接口，根据传入的数据，只返回boolean值</p><p>can can 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Represents a predicate (boolean-valued function) of one argument.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="hljs-comment"> * whose functional method is &#123;<span class="hljs-doctag">@link</span> #test(Object)&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Evaluates this predicate on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if the input argument matches the predicate,</span><br><span class="hljs-comment">     * otherwise &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_predicate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Predicate&lt;String&gt; predicate = <span class="hljs-keyword">new</span> Predicate&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span>(!s.isEmpty())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;;<br><br>        Predicate&lt;String&gt; predicate1 = s -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(!s.isEmpty())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;;<br><br>        System.out.println(predicate.test(<span class="hljs-string">&quot;william&quot;</span>));<span class="hljs-comment">//true</span><br>        System.out.println(predicate1.test(<span class="hljs-string">&quot;william&quot;</span>));<span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Consumer接口">Consumer接口</h3><p>消费者型接口，只有输入参数，没有返回值</p><p>can can 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Represents an operation that accepts a single input argument and returns no</span><br><span class="hljs-comment"> * result. Unlike most other functional interfaces, &#123;<span class="hljs-doctag">@code</span> Consumer&#125; is expected</span><br><span class="hljs-comment"> * to operate via side-effects.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="hljs-comment"> * whose functional method is &#123;<span class="hljs-doctag">@link</span> #accept(Object)&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of the input to the operation</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs this operation on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Consumer&lt;String&gt; consumer = <span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;一共消费了&quot;</span> + s + <span class="hljs-string">&quot;元&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        Consumer&lt;String&gt; consumer1 = (s)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;一共消费了&quot;</span> + s + <span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;;<br><br>        consumer.accept(<span class="hljs-string">&quot;20&quot;</span>);<span class="hljs-comment">//20</span><br>        consumer.accept(<span class="hljs-string">&quot;30&quot;</span>);<span class="hljs-comment">//30</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Supplier接口">Supplier接口</h3><p>没有输入参数，只有 返回值</p><p>can can 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Represents a supplier of results.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span><br><span class="hljs-comment"> * time the supplier is invoked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="hljs-comment"> * whose functional method is &#123;<span class="hljs-doctag">@link</span> #get()&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of results supplied by this supplier</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4_supplier</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;String&gt; supplier = <span class="hljs-keyword">new</span> Supplier&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;niuBi&quot;</span>;<br>            &#125;<br>        &#125;;<br><br>        Supplier&lt;String&gt; supplier1 = ()-&gt;&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;niuBi&quot;</span>;&#125;;<br><br>        System.out.println(supplier.get());<span class="hljs-comment">//niuBi</span><br>        System.out.println(supplier1.get());<span class="hljs-comment">//niuBi</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream流式计算">Stream流式计算</h2><p>什么是Stream流式计算</p><ul><li>常用的集合是为了存储数集，而对于集合数据的一些处理（像筛选集合数据等）可以使用Stream流来处理</li><li>java.util.tream包下的Stream接口 支持顺序和并行聚合操作的一系列元素</li><li>Stream流可以结合四大函数式接口进行数据处理（方法的参数支持函数式接口）<br>使用</li></ul><p>集合.stream() 可以将集合对象 转为 流对象，调用流对象的一些方法进行数据操作<br>常用方法</p><ul><li>filter(Predicate&lt;? super T&gt; predicate) 返回由与此给定谓词匹配的此流的元素组成的流。</li><li>count() 返回此流中的元素数。</li><li>forEach(Consumer&lt;? super T&gt; action) 对此流的每个元素执行操作。</li><li>sorted(Comparator&lt;? super T&gt; comparator) 返回由该流的元素组成的流，根据提供的 Comparator进行排序。</li><li>map(Function&lt;? super T,? extends R&gt; mapper)返回由给定函数应用于此流的元素的结果组成的流。</li><li>sorted(Comparator&lt;? super T&gt; comparator)返回由该流的元素组成的流，根据提供的 Comparator进行排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_stream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user1 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;william1&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">10000</span>);<br>        User user2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;william2&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">11000</span>);<br>        User user3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;william3&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">12000</span>);<br>        User user4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;william4&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">13000</span>);<br>        User user5 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;william5&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">14000</span>);<br>        User user6 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;william6&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">15000</span>);<br><br>        List&lt;User&gt; users = Arrays.asList(user1, user2, user3, user4, user5, user6);<br><br>        <span class="hljs-comment">//1. forEach</span><br>        users.stream().forEach((user)-&gt;&#123;<br>            System.out.println(user);<br>        &#125;);<br><br>        <span class="hljs-comment">//记得关闭stream</span><br>        users.stream().close();<br><br>        System.out.println(<span class="hljs-string">&quot;---------我是分割线--------&quot;</span>);<br><br>        <span class="hljs-comment">//2.filter predicate接口</span><br>        users.stream()<br>                .filter((user) -&gt; &#123;<span class="hljs-keyword">return</span> user.getSalary() &gt; <span class="hljs-number">12000</span>;&#125;)<br>                .filter((user) -&gt; &#123;<span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">20</span>;&#125;)<br>                .forEach((user)-&gt;&#123;<br>                    System.out.println(user);<br>                &#125;);<br><br>        users.stream().close();<br><br>        <span class="hljs-comment">//3.map 和 排序</span><br>        users.stream()<br>                .filter((user)-&gt; user.getSalary() &lt; <span class="hljs-number">20000</span>)<br>                .map((user)-&gt; user.getSalary() + <span class="hljs-number">2000</span>)<br>                .sorted((u1,u2)-&gt;&#123;<span class="hljs-keyword">return</span> u1.compareTo(u2);&#125;)<br>                .forEach((user)-&gt;&#123;<br>                    System.out.println(user);<br>                &#125;);<br><br>        users.stream().close();<br>    &#125;<br><br>&#125;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>User&#123;name=<span class="hljs-string">&#x27;william1&#x27;</span>, age=<span class="hljs-number">18</span>, salary=<span class="hljs-number">10000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william2&#x27;</span>, age=<span class="hljs-number">19</span>, salary=<span class="hljs-number">11000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william3&#x27;</span>, age=<span class="hljs-number">20</span>, salary=<span class="hljs-number">12000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william4&#x27;</span>, age=<span class="hljs-number">21</span>, salary=<span class="hljs-number">13000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william5&#x27;</span>, age=<span class="hljs-number">22</span>, salary=<span class="hljs-number">14000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william6&#x27;</span>, age=<span class="hljs-number">23</span>, salary=<span class="hljs-number">15000</span>&#125;<br>---------我是分割线--------<br>User&#123;name=<span class="hljs-string">&#x27;william4&#x27;</span>, age=<span class="hljs-number">21</span>, salary=<span class="hljs-number">13000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william5&#x27;</span>, age=<span class="hljs-number">22</span>, salary=<span class="hljs-number">14000</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;william6&#x27;</span>, age=<span class="hljs-number">23</span>, salary=<span class="hljs-number">15000</span>&#125;<br><span class="hljs-number">12000</span><br><span class="hljs-number">13000</span><br><span class="hljs-number">14000</span><br><span class="hljs-number">15000</span><br><span class="hljs-number">16000</span><br><span class="hljs-number">17000</span><br><br>进程已结束，退出代码为 <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h2 id="Fork-Join分支合并">Fork/Join分支合并</h2><p>ork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p><p>与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了<strong>工作窃取算法</strong>。</p><p><strong>fork</strong>在英文里有分叉的意思，<strong>join</strong>在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221017132505169.png" alt="image-20221017132505169"></p><p>感觉就是分治算法的思想</p><p>工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p><p>工作窃取流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221017132535148.png" alt=""></p><h2 id="异步回调">异步回调</h2><ul><li><p>类似ajax技术，可以进行异步执行、成功回调、失败回调。</p></li><li><p>java.util.concurrent包下的 接口Future<V>，有</p><ul><li>实现子类：CompletableFuture ， CountedCompleter ， ForkJoinTask ， FutureTask ， RecursiveAction ， RecursiveTask ， SwingWorker</li></ul></li><li><p>CompletableFuture 有静态方法</p><p>无返回结果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210713165237808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NjU0NTAx,size_16,color_FFFFFF,t_70" alt=""></p><p>​      有返回结果</p><p><img src="https://img-blog.csdnimg.cn/20210713165403816.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br><br>        test2();<br><br>    &#125;<br><br>    <span class="hljs-comment">// 1. 无返回值的 异步</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        CompletableFuture&lt;Void&gt;  completableFuture =  CompletableFuture.runAsync(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                System.out.println(<span class="hljs-string">&quot;异步任务执行了！！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;willaim1&quot;</span>);<br>        completableFuture.get();<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 2. 有返回值的 异步</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        CompletableFuture&lt;Integer&gt;  completableFuture =  CompletableFuture.supplyAsync(()-&gt;&#123;<br>            <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br><br><br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br><br><br>        System.out.println(<span class="hljs-string">&quot;william2&quot;</span>);<br><br>        completableFuture.whenCompleteAsync((t,u)-&gt;&#123;<br>            System.out.println(t+<span class="hljs-string">&quot;=====&gt; &quot;</span> + t); <span class="hljs-comment">// 成功的时候返回值</span><br>            System.out.println(u+<span class="hljs-string">&quot;=====&gt; &quot;</span> + u); <span class="hljs-comment">// 失败的信息</span><br>            System.out.println(<span class="hljs-string">&quot;有返回值的异步执行了！&quot;</span>);<br><br>        &#125;).exceptionally((e)-&gt;&#123; <span class="hljs-comment">// 异常捕获</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;<br>        &#125;).get();<br><br><br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="JMM">JMM</h2><p>JMM：Java内存模型，是一个概念,不是实际存在的东西</p><ul><li>线程解锁前，必须把 共享变量 立刻 刷新为主存（每个线程都有自己一块内存称为 工作内存，操作的变量是自己内存块的变量，但是实际存在的位置是主存，因此每次操作完之后需要 更新 主存）</li><li>线程加锁前：必须读取主存中的最新值搭配线程工作内存中</li></ul><p>JMM的八种操作</p><ul><li>read、load</li><li>use、assign</li><li>write、store</li><li>lock、unlock</li></ul><ol><li>lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于工作内存的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ol><h2 id="volatile">volatile</h2><h3 id="保证可见性">保证可见性</h3><p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_volatile</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  Boolean flag = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(flag)&#123;<br><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;其他线程&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;主线程修改了flag,但是另外一个线程工作空间的flag仍然是true.&quot;</span>);<br>        flag = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若不加volatile 该程序会一直死循环，因为内存不可见，可以通过修改flag为<code>private static volatile Boolean flag = true;</code>  即加上volatile保证内存可见性解决问题</p><h3 id="不保证原子性">不保证原子性</h3><p>原子性即是不可分割性，通俗的讲就是线程A在执行的时候不可打扰 要么成功 要么失败</p><p>可以使用原子类来解决原子性的问题  比如原子性的integer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">1000</span>; i1++) &#123;<br>                    add();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-comment">// 确保上面的线程执行完，只剩下 main 和 gc 线程</span><br>        <span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>)&#123;<br>            Thread.yield();<span class="hljs-comment">//当前主线程 暂时停止执行</span><br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;正常结果为100，输出结果为===》&quot;</span> + num); <span class="hljs-comment">// 正常结果为10000，输出结果为===》9991</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        num++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过加上synchronzied关键字或者Lock锁来保证原子性</p><p>或者另外一种方式 使用原子类来解决</p><p>创建 可原子更新的int 值对象</p><p><code>private static volatile AtomicInteger num = new AtomicInteger(0);</code></p><p>该对象有方法+1，原理是调用Unsafe类的方法，底层使用的CAS<br><code>num.getAndIncrement();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicDemo3</span> </span>&#123;<br><br>    <span class="hljs-comment">// 创建 可原子更新的int 值对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> AtomicInteger num = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">1000</span>; i1++) &#123;<br>                    <span class="hljs-comment">// 该对象有方法+1，底层使用的CAS</span><br>                    num.getAndIncrement();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-comment">// 确保上面的线程执行完，只剩下 main 和 gc 线程</span><br>        <span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>)&#123;<br>            Thread.yield();<span class="hljs-comment">//当前主线程 暂时停止执行</span><br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;正常结果为10000，输出结果为===》&quot;</span> + num); <span class="hljs-comment">// 正常结果为10000，输出结果为===》10000</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="禁止指令重排">禁止指令重排</h3><p>指令重排 ，简单的来说就是计算机将你的指令优化了一下，以最高效的顺序执行</p><p>源代码 ==&gt; 编译器优化的重排 ==&gt; 指令并行也可能重排 ==&gt; 内存系统也会重排 执行</p><p>指令重排有个前提，他会考虑数据之间的依赖性，如果没有影响才会进行指令重排</p><p>加入volatile会避免指令重排，内存中有屏障，作用</p><ul><li>保证特定的执行顺序</li><li>可以保证某些变量的内存可见性</li></ul><h2 id="单例模式">单例模式</h2><p>单例模式是Java中最简单的设计模式之一，这种模式涉及一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p><p>注意</p><ul><li>单例类只能有一个实例</li><li>单例类必须自己创建自己的唯一实例</li><li>单例类必须给所有其他的对象提供这一实例</li></ul><h3 id="饿汉式单例">饿汉式单例</h3><p>多线程下特点</p><ul><li>这种方式比较常用，但容易产生垃圾对象。私有构造器，开始直接创建实例被加载进内存。 容易造成内存空间的浪费</li><li>优点：没有加锁，执行效率会提高。</li><li>缺点：类加载时就初始化，浪费内存。</li><li>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_hungry</span> </span>&#123;<br><br>    <span class="hljs-comment">// 因为是getInstance是静态方法，因此开始就被加载进内存，因此有可能会浪费内存空间</span><br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">byte</span>[] data1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>* <span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">byte</span>[] data2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>* <span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">byte</span>[] data3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>* <span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">byte</span>[] data4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>* <span class="hljs-number">1024</span>];<br><br>    <span class="hljs-comment">//注意 这里是私有的构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Demo1_hungry</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Demo1_hungry hungryMan = <span class="hljs-keyword">new</span> Demo1_hungry();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo1_hungry <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> hungryMan;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式单例">懒汉式单例</h3><p><strong>一般懒汉式</strong></p><p>特点</p><ul><li><p>需要使用单例时，单例才初始化占用内存。</p></li><li><p>单线程下没问题，但是线程下是不安全的，会出现多个实例。</p></li><li><p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_lazy</span> </span>&#123;<br> <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo2_lazy lazyMan;<br> <br>     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Demo2_lazy</span><span class="hljs-params">()</span></span>&#123;<br>         System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程拿到了实例！&quot;</span>);<br>     &#125;<br> <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Demo2_lazy <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-comment">//需要使用单例的情况下 且实例没有被创建 才创建单例</span><br>         <span class="hljs-keyword">if</span>(lazyMan == <span class="hljs-keyword">null</span>)&#123;<br>             <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> Demo2_lazy();<br>         &#125;<br>         <span class="hljs-keyword">return</span> lazyMan;<br>     &#125;<br> <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         <span class="hljs-comment">//模拟线程拿到实例</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>             <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                 Demo2_lazy.getInstance();<br>             &#125;,String.valueOf(i)).start();<br>         &#125;<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span>线程拿到了实例！<br><span class="hljs-number">4</span>线程拿到了实例！<br><span class="hljs-number">5</span>线程拿到了实例！<br><span class="hljs-number">3</span>线程拿到了实例！<br><span class="hljs-number">2</span>线程拿到了实例！<br><span class="hljs-number">1</span>线程拿到了实例！<br><span class="hljs-number">7</span>线程拿到了实例！<br><span class="hljs-number">6</span>线程拿到了实例！<br><span class="hljs-number">8</span>线程拿到了实例！<br><span class="hljs-number">9</span>线程拿到了实例！<br><br><span class="hljs-comment">//很明显不能保证一个单例</span><br></code></pre></td></tr></table></figure><p><strong>加锁懒汉式</strong></p><p>特点</p><ul><li>相比一般的懒汉式，在获取实例的静态方法前加synchronized关键字，可以保证多线程之间的同步问题，保证单例模式</li><li>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</li><li>优点：第一次调用才初始化，避免内存浪费。</li><li>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_sychronziedLazyMan</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo3_sychronziedLazyMan lazyMan;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Demo3_sychronziedLazyMan</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程拿到了实例！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Demo3_sychronziedLazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//需要使用单例的情况下 且实例没有被创建 才创建单例</span><br>        <span class="hljs-keyword">if</span>(lazyMan == <span class="hljs-keyword">null</span>)&#123;<br>            lazyMan = <span class="hljs-keyword">new</span> Demo3_sychronziedLazyMan();<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyMan;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//模拟线程拿到实例</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                Demo3_sychronziedLazyMan.getInstance();<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span>线程拿到了实例！<br>    <br><span class="hljs-comment">//只有一个线程拿到了实例</span><br></code></pre></td></tr></table></figure><h3 id="DCL双重校验锁">DCL双重校验锁</h3><p>特点</p><ul><li>DCL即 double-checked locking</li><li>相比一般懒汉式，又加了一层 if(实例还不存在) { synchronized (单例类) { if(实力还不存在） 初始化单例} }, volatile关键字 保证线程之间的同步问题</li><li>相比加锁的懒汉式，不是在方法前面加synchronized从而影响效率，这种方法效率更高。<br>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4_DCLLazyMan</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo4_DCLLazyMan lazyMan;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Demo4_DCLLazyMan</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 线程拿到了实例！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo4_DCLLazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//第一次判断，没有实例的时候给类加锁</span><br>        <span class="hljs-keyword">if</span>(lazyMan == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Demo4_DCLLazyMan.class)&#123;<br><br>                <span class="hljs-comment">//第二次判断，没有实例的时候 获得单例</span><br>                <span class="hljs-keyword">if</span>(lazyMan == <span class="hljs-keyword">null</span>)&#123;<br>                    lazyMan = <span class="hljs-keyword">new</span> Demo4_DCLLazyMan();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyMan;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//模拟线程拿到实例</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                Demo3_sychronziedLazyMan.getInstance();<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span>线程拿到了实例！<br></code></pre></td></tr></table></figure><p>但是上面的<code>lazyMan = new Demo4_DCLLazyMan();</code>依然有一定的缺陷，在JMM中并不是原子操作，创建实例的过程大致分为三个步骤</p><ul><li>分配内存空间</li><li>执行构造方法</li><li>将实例变量指向内存空间</li></ul><p>而在多线程执行时候，最后两步是可以变的，而这就可能导致多线程同步异常，获取单例失败，因此可以通过使用volatile关键字禁止指令重排解决常见操作非原子性的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//所以可以将上述代码改为</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Demo4_DCLLazyMan lazyMan;<br></code></pre></td></tr></table></figure><h2 id="CAS">CAS</h2><p>概念</p><ul><li>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。</li><li>CAS也是现在面试经常问的问题<br>之前学习的java.util.concurrent.automics下的AtomicsInteger等类提供简单的cas操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_CAS</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger num  = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//期望 更新</span><br>        <span class="hljs-comment">//如果期望的值达到了就跟新 否则不更新</span><br>        num.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>);<br>        System.out.println(num.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">120</span>));<span class="hljs-comment">//true</span><br>        System.out.println(num.compareAndSet(<span class="hljs-number">150</span>, <span class="hljs-number">130</span>));<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而Java实现CAS的功能使用的依然是我们熟悉的Unsafe类</p><h3 id="ABA问题">ABA问题</h3><p>ABA问题即是狸猫换太子，也就是一个线程速度过快，在正常线程1，2之间穿插了一个捣乱的线程，但是捣乱线程的操作会使 数据恢复为未执行之前的状态，故不会影响正常线程执行结果，一般情况下ABA并不会出现什么问题，但是设计引用的时候就会出现问题。</p><p><strong>通过原子引用来解决ABA问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABA</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; num = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//线程2 期望的版本号</span><br>        <span class="hljs-keyword">int</span> currentStamp = num.getStamp();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;=============正常线程1===========&quot;</span>);<br><br>            <span class="hljs-comment">//获得版本号</span><br>            System.out.println(<span class="hljs-string">&quot;正常版本号1 拿到版本号&quot;</span> + num.getStamp());<br>        &#125;,<span class="hljs-string">&quot;正常线程&quot;</span>).start();<br><br>        <span class="hljs-comment">//休眠2s</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//捣乱的线程不影响正常结果</span><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;=========I AM 捣乱线程==========&quot;</span>);<br>            System.out.println(num.compareAndSet(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,num.getStamp(), num.getStamp() + <span class="hljs-number">1</span>));<br>            System.out.println(<span class="hljs-string">&quot;捣乱线程第一次修改值后的 版本号===》&quot;</span> + num.getStamp());<br>            System.out.println(num.compareAndSet(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, num.getStamp(), num.getStamp() + <span class="hljs-number">1</span>));<br>            System.out.println(<span class="hljs-string">&quot;捣乱线程第二次修改值后的 版本号===》&quot;</span> + num.getStamp());<br>        &#125;,<span class="hljs-string">&quot;捣乱线程&quot;</span>).start();<br><br>        <span class="hljs-comment">//休眠2s</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//正常线程2</span><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;=============正常线程2===========&quot;</span>);<br><br>            <span class="hljs-comment">//获得版本号</span><br>            System.out.println(<span class="hljs-string">&quot;正常版本号2执行前 当前版本号&quot;</span> + num.getStamp());<br>            System.out.println(<span class="hljs-string">&quot;正常版本号2执行前 期望版本号&quot;</span> + currentStamp);<br>            System.out.println(num.compareAndSet(<span class="hljs-number">1000</span>, <span class="hljs-number">3000</span>, currentStamp, num.getStamp() + <span class="hljs-number">1</span>));<br>            System.out.println(<span class="hljs-string">&quot;正常线程2执行后 版本号===》&quot;</span> + num.getStamp());<br>        &#125;,<span class="hljs-string">&quot;正常线程&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>=============正常线程<span class="hljs-number">1</span>===========<br>正常版本号<span class="hljs-number">1</span> 拿到版本号<span class="hljs-number">1</span><br>=========I AM 捣乱线程==========<br><span class="hljs-keyword">true</span><br>捣乱线程第一次修改值后的 版本号===》<span class="hljs-number">2</span><br><span class="hljs-keyword">true</span><br>捣乱线程第二次修改值后的 版本号===》<span class="hljs-number">3</span><br>=============正常线程<span class="hljs-number">2</span>===========<br>正常版本号<span class="hljs-number">2</span>执行前 当前版本号<span class="hljs-number">3</span><br>正常版本号<span class="hljs-number">2</span>执行前 期望版本号<span class="hljs-number">1</span><br><span class="hljs-keyword">false</span><br>正常线程<span class="hljs-number">2</span>执行后 版本号===》<span class="hljs-number">3</span><br><br>进程已结束，退出代码为 <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h2 id="各种锁">各种锁</h2><h3 id="公平，非公平锁">公平，非公平锁</h3><p>概念</p><ul><li>公平锁：非常公平，线程之间不可以插队</li><li>非公平锁：非常不公平，线程之间可以插队(默认）</li></ul><p>这里的“公平”，其实通俗意义来说就是“先来后到”，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p><p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p><p>ReentrantLock支持非公平锁和公平锁两种。</p><h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3><p><strong>悲观锁：</strong></p><p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><p><strong>乐观锁：</strong></p><p>乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说<strong>乐观锁天生免疫死锁</strong>。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><h3 id="可重入锁">可重入锁</h3><p>所谓重入锁，顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个<strong>线程对资源重复加锁</strong>。</p><p>synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p><p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p><p><code>ReentrantLock</code>的中文意思就是可重入锁。</p><h3 id="自旋锁">自旋锁</h3><p>概述</p><ul><li>AtomicXxx类下的CAS方法底层就是 自旋锁，不断循环直到成功为止</li><li>自旋锁主要应用CAS操作，直到手动释放锁才停止</li></ul><p>主要就是while啥的，不成功就一直循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Atomically updates the current value with the results of</span><br><span class="hljs-comment">    * applying the given function, returning the previous value. The</span><br><span class="hljs-comment">    * function should be side-effect-free, since it may be re-applied</span><br><span class="hljs-comment">    * when attempted updates fail due to contention among threads.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> updateFunction a side-effect-free function</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the previous value</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> prev, next;<br>       <span class="hljs-keyword">do</span> &#123;<br>           prev = get();<br>           next = updateFunction.applyAsInt(prev);<br>       &#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<br>       <span class="hljs-keyword">return</span> prev;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h3 id="死锁">死锁</h3><p>概念</p><ul><li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</li><li>两个线程互相抢夺资源，互相争用还未释放的锁</li></ul><p>可以使用下面的方法排查死锁</p><ul><li>使用命令 <code>jps -1</code> 定位进程号</li><li>使用<code>jstack 进程号</code> 查看堆栈信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2022/06/29/leetcode/"/>
    <url>/2022/06/29/leetcode/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">前言<ul>    <div>本博客主要是刷leetcode热题所做的笔记</div></ul><ul>    <div>更新：根据以往的面试经验，给这些题尽量加上输入输出，而不仅仅是函数</div></ul></div><h2 id="输入">输入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">scan</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//输入部分</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        <span class="hljs-comment">// 输入一个元素 处理一个</span><br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(scanner.hasNextInt())&#123;<br>            <span class="hljs-keyword">int</span> input = scanner.nextInt();<br>            list.add(input);<br>            System.out.print(list.get(index++));<br>        &#125;<br>        <span class="hljs-comment">// 字符串版</span><br>        <span class="hljs-keyword">while</span>(scanner.hasNext())<br>        &#123;<br>            String string  = scanner.nextLine();<br>            <span class="hljs-keyword">char</span> [] inputs  = string.toCharArray();<br>            System.out.println(Arrays.toString(inputs));<br>        &#125;<br><br><br>        <span class="hljs-comment">// 输入一行列表的数据  需要加上结束符号</span><br>        ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        System.out.println(<span class="hljs-string">&quot;开始输入第一个列表的元素，输入&#x27;end&#x27;结束:&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (scanner.hasNextInt()) &#123;<br>                <span class="hljs-keyword">int</span> value = scanner.nextInt();<br>                list2.add(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                scanner.next(); <span class="hljs-comment">// 消耗掉非整数的输入</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;输入结束.&quot;</span>);<br>        System.out.println(Arrays.toString(list2.toArray()));<br><br><br>        <span class="hljs-comment">// 输入字符串转为数组</span><br>        ArrayList&lt;Integer&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        String input1 = scanner.nextLine();<br>        String[] elements = input1.split(<span class="hljs-string">&quot;\\s+&quot;</span>); <span class="hljs-comment">//按照空白</span><br>        <span class="hljs-keyword">for</span> (String element : elements) &#123;<br>            list3.add(Integer.parseInt(element));<br>        &#125;<br>        System.out.println(Arrays.toString(list3.toArray()));<br><br>        scanner.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="next和nextLine">next和nextLine</h3><p>next()查找并返回来自此扫描器的下一个完整标记。完整标记的前后是与分隔模式匹配的输入信息，所以next方法不能得到带空格的字符串。</p><p>nextLine()方法的结束符只是Enter键，即nextLine()方法返回的是Enter键之前的所有字符，它是可以得到带空格的字符串的。</p><p><strong>注意点（易错点）：</strong> 注意next()方法和nextLine()方法的连用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NextTest</span></span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        Scanner input = <span class="hljs-keyword">new</span> Scanner(System.in);  <br>        System.out.print(<span class="hljs-string">&quot;请输入第一个字符串：&quot;</span>);  <br>        String s1 = input.next();  <br>        System.out.print(<span class="hljs-string">&quot;请输入第二个字符串：&quot;</span>);  <br>        String s2 = input.nextLine();  <br>        System.out.println(<span class="hljs-string">&quot;输入的字符串是：&quot;</span>+ s1 + <span class="hljs-string">&quot; &quot;</span> + s2);  <br>    &#125;  <br>&#125; <br><span class="hljs-comment">//运行结果是：</span><br><span class="hljs-comment">//请输入第一个字符串：home</span><br><span class="hljs-comment">//请输入第二个字符串：输入的字符串是：home</span><br></code></pre></td></tr></table></figure><p>可以看到，nextLine()自动读取了被next()去掉的Enter作为它的结束符，所以没办法给s2从键盘输入值。经过验证，发现其他的next的方法，如nextDouble() ，nextFloat() ，nextInt() 等与nextLine()连用时都存在这个问题，解决的办法是：在每一个 next()、nextDouble() 、 nextFloat()、nextInt() 等语句之后加一个nextLine()语句，将被next()去掉的Enter等结束符过滤掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更正为</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NextTest</span></span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        Scanner input = <span class="hljs-keyword">new</span> Scanner(System.in);  <br>        System.out.print(<span class="hljs-string">&quot;请输入第一个字符串：&quot;</span>);  <br>        String s1 = input.next(); <br>        input.nextLine();  <span class="hljs-comment">//接收结束符</span><br>        System.out.print(<span class="hljs-string">&quot;请输入第二个字符串：&quot;</span>);  <br>        String s2 = input.nextLine();  <br>        System.out.println(<span class="hljs-string">&quot;输入的字符串是：&quot;</span>+ s1 + <span class="hljs-string">&quot; &quot;</span> + s2);  <br>    &#125;  <br>&#125; <br><br><span class="hljs-comment">//在Java代码String word = scanner.nextLine().trim();中，trim()的作用是去除用户输入字符串的前后空白字符</span><br>String word = scanner.nextLine().trim();<br></code></pre></td></tr></table></figure><h2 id="各种排序算法">各种排序算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hot100;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Mercury</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2025-04-02 13:31</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortingAlgorithms</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1. 冒泡排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">boolean</span> swapped = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n-i-<span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-comment">// 交换相邻元素</span><br>                    <span class="hljs-keyword">int</span> temp = arr[j];<br>                    arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                    arr[j+<span class="hljs-number">1</span>] = temp;<br>                    swapped = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有交换则提前结束</span><br>            <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 选择排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> minIndex = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将最小值交换到当前位置</span><br>            <span class="hljs-keyword">int</span> temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 插入排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> key = arr[i];<br>            <span class="hljs-keyword">int</span> j = i-<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 将大于key的元素后移</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                j--;<br>            &#125;<br>            arr[j+<span class="hljs-number">1</span>] = key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 希尔排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-comment">// 使用希尔增量序列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = n/<span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">int</span> temp = arr[i];<br>                <span class="hljs-keyword">int</span> j;<br>                <span class="hljs-keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;<br>                    arr[j] = arr[j - gap];<br>                &#125;<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 归并排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>            mergeSort(arr, left, mid);<br>            mergeSort(arr, mid+<span class="hljs-number">1</span>, right);<br>            merge(arr, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> i = left, j = mid+<span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];<br>        &#125;<br>        <span class="hljs-comment">//拷贝剩余的元素</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];<br><br>        System.arraycopy(temp, <span class="hljs-number">0</span>, arr, left, temp.length);<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 快速排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>            <span class="hljs-keyword">int</span> pi = partition(arr, low, high);<br>            quickSort(arr, low, pi-<span class="hljs-number">1</span>);<br>            quickSort(arr, pi+<span class="hljs-number">1</span>, high);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = arr[high]; <span class="hljs-comment">// 选择最后一个元素为基准</span><br>        <span class="hljs-keyword">int</span> i = low - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = low; j &lt; high; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; pivot) &#123;<br>                i++;<br>                swap(arr, i, j);<br>            &#125;<br>        &#125;<br>        swap(arr, i+<span class="hljs-number">1</span>, high);<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">// 7. 堆排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-comment">// 构建最大堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span> -<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            heapify(arr, n, i);<br>        &#125;<br>        <span class="hljs-comment">// 逐个提取元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            swap(arr, <span class="hljs-number">0</span>, i);<br>            heapify(arr, i, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> largest = i;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;<br>        <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;<br><br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            swap(arr, i, largest);<br>            heapify(arr, n, largest);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 8. 计数排序（适用于非负整数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = Arrays.stream(arr).max().getAsInt();<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) count[num]++;<br><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max; i++) &#123;<br>            <span class="hljs-keyword">while</span> (count[i]-- &gt; <span class="hljs-number">0</span>) &#123;<br>                arr[index++] = i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 9. 桶排序（假设输入在[0,1)范围内）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br><br>        <span class="hljs-comment">// 归一化数组元素到 [0, 1) 范围</span><br>        <span class="hljs-keyword">int</span> max = Arrays.stream(arr).max().getAsInt();<br>        <span class="hljs-keyword">double</span>[] normalizedArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            normalizedArr[i] = (<span class="hljs-keyword">double</span>) arr[i] / (max + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化桶</span><br>        ArrayList&lt;Double&gt;[] buckets = <span class="hljs-keyword">new</span> ArrayList[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            buckets[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-comment">// 将元素分配到桶中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> num : normalizedArr) &#123;<br>            <span class="hljs-keyword">int</span> bucketIndex = (<span class="hljs-keyword">int</span>)(num * n);<br>            buckets[bucketIndex].add(num);<br>        &#125;<br><br>        <span class="hljs-comment">// 对每个桶排序并合并回原数组</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (ArrayList&lt;Double&gt; bucket : buckets) &#123;<br>            Collections.sort(bucket);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> num : bucket) &#123;<br>                arr[index++] = (<span class="hljs-keyword">int</span>) (num * (max + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 恢复原始值</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 10. 基数排序（LSD实现）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = Arrays.stream(arr).max().getAsInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> exp = <span class="hljs-number">1</span>; max/exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) &#123;<br>            countingSortByDigit(arr, exp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countingSortByDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> exp)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-keyword">int</span>[] output = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) count[(num/exp)%<span class="hljs-number">10</span>]++;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) count[i] += count[i-<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            output[count[(arr[i]/exp)%<span class="hljs-number">10</span>]-<span class="hljs-number">1</span>] = arr[i];<br>            count[(arr[i]/exp)%<span class="hljs-number">10</span>]--;<br>        &#125;<br><br>        System.arraycopy(output, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 测试示例</span><br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;原数组: &quot;</span> + Arrays.toString(arr));<br><br>        <span class="hljs-comment">// 调用不同的排序方法测试</span><br><span class="hljs-comment">//        bubbleSort(arr);</span><br><span class="hljs-comment">//        selectionSort(arr);</span><br><span class="hljs-comment">//        insertionSort(arr);</span><br><span class="hljs-comment">//        shellSort(arr);</span><br><span class="hljs-comment">//        mergeSort(arr);</span><br><span class="hljs-comment">//        quickSort(arr);</span><br><span class="hljs-comment">//        heapSort(arr);</span><br><span class="hljs-comment">//        countingSort(arr);</span><br>        bucketSort(arr);<br><span class="hljs-comment">//        radixSort(arr);</span><br>        System.out.println(<span class="hljs-string">&quot;桶排序后: &quot;</span> + Arrays.toString(arr));<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="链表">链表</h2><h3 id="打印链表">打印链表</h3><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/">剑指 Offer 06. 从尾到头打印链表 - 力扣（Leetcode）</a></p><p>从尾巴到头部打印链表的节点</p><p>下面是自己写的垃圾代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>      <br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = list.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            res[i] = list.get(count++);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用递归,将添加进集合这一步骤放到递归的后面，这样后面返回的时候就可以逆序返回了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br>        dfs(head);<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>            res[i] = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>      <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ListNode node)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            dfs(node.next);<br>            list.add(node.val);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用辅助栈来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(head.val);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[stack.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.length; i++)&#123;<span class="hljs-comment">//这里不能使用stack.size()，因为每次循环后stack的大小都在逐渐变小</span><br>            res[i] = stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预设pre">预设pre</h3><p>使用双指针进行遍历，对于链表问题，返回结果为头结点时，<strong>通常需要先初始化一个预先指针 pre</strong>，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针(cur)移动，进而会导致头指针丢失，无法返回结果。<a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode temp1,temp2;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode cur = pre;<br>        temp1 = l1;<br>        temp2 = l2;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//这里的carry!=0的判断主要是防止后面还有进位</span><br><span class="hljs-keyword">while</span>(temp1!=<span class="hljs-keyword">null</span>||temp2!=<span class="hljs-keyword">null</span>||carry!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> x = temp1 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span>:temp1.val;<br>            <span class="hljs-keyword">int</span> y = temp2 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span>:temp2.val;<br>            <span class="hljs-keyword">int</span> resval = x + y + carry;<br>           <br>            carry = resval/<span class="hljs-number">10</span>;<span class="hljs-comment">// 刷新carry</span><br>            resval = resval % <span class="hljs-number">10</span>;<br>            <br>            ListNode body =  <span class="hljs-keyword">new</span> ListNode(resval);<br>            cur.next = body;<br>            cur = body;<span class="hljs-comment">//移动指针</span><br><br>            <span class="hljs-keyword">if</span>(temp1!=<span class="hljs-keyword">null</span>)&#123;<br>                temp1 = temp1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp2!=<span class="hljs-keyword">null</span>)&#123;<br>                temp2 = temp2.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br>--------------------------------------------------------------------------------<br><span class="hljs-comment">//have main</span><br>    <br><span class="hljs-comment">//手动扫描输入</span><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 定义链表节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">addtwonumbers</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode current = dummyHead;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位标志</span><br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span> || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> val1 = (l1 != <span class="hljs-keyword">null</span>) ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> val2 = (l2 != <span class="hljs-keyword">null</span>) ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> sum = val1 + val2 + carry;<br>            carry = sum / <span class="hljs-number">10</span>; <span class="hljs-comment">// 计算是否需要进位</span><br>            current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>); <span class="hljs-comment">// 新节点保存当前位的结果</span><br>            current = current.next;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">buildList</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经处理完所有的元素，则返回null</span><br>        <span class="hljs-keyword">if</span> (index &gt;= list.size()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 创建一个新的节点，并且递归地为下一个节点调用此方法</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(list.get(index), buildList(list, index + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        String input1 = scanner.nextLine();<br>        String[] elements1 = input1.split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String element : elements1) &#123;<br>            list1.add(Integer.parseInt(element));<br>        &#125;<br><br>        String input2 = scanner.nextLine();<br>        String[] elements2 = input2.split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String element : elements2) &#123;<br>            list2.add(Integer.parseInt(element));<br>        &#125;<br><br>        scanner.close();<br><br>        ListNode l1 = buildList(list1, <span class="hljs-number">0</span>);<br>        ListNode l2 = buildList(list2, <span class="hljs-number">0</span>);<br>        ListNode result = addTwoNumbers(l1, l2);<br><br>        <span class="hljs-comment">// 打印结果</span><br>        <span class="hljs-keyword">while</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(result.val + <span class="hljs-string">&quot; &quot;</span>);<br>            result = result.next;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//直接初始化的主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Solution solution = <span class="hljs-keyword">new</span> Solution();<br>    ListNode l1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>, <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>)));<br>    ListNode l2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">6</span>, <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>)));<br>    ListNode result = solution.addTwoNumbers(l1, l2);<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-keyword">while</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        System.out.print(result.val + <span class="hljs-string">&quot; &quot;</span>);<br>        result = result.next;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="常用的经典代码">常用的经典代码</h3><p>熟记单链表经典的删除，获取有效节点，查找倒数第几个(也可以使用快慢指针)，有时也需要考虑到特殊情况，比如删除的节点就是头节点，就找不到待删除的前一个节点，需要单独判断(预设一个pre节点的话就不需要，这就是预设节点的好处)，比如<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a>,这个题解看下面的删除节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除</span><br>cur.next = cur.next.next; <br><br><br><span class="hljs-comment">//查找倒数第几个一般是 总长减去倒数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt; size - index; i++) &#123;<br>cur = cur.next;<br>&#125;<br><br><br><span class="hljs-comment">//获取链表的有效节点数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//带头结点的空链表，不带头节点的删除就好</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br><br>  HeroNode cur = head.next;<br>  <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>) &#123;<br>    length++;<br>    cur = cur.next; <span class="hljs-comment">//遍历写一个</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> length;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="翻转链表">翻转链表</h3><p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/">剑指 Offer 24. 反转链表 - 力扣（Leetcode）</a></p><p>采用迭代的方式来实现翻转这个链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//翻转链表</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode cur = head;<br>        ListNode pre = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//存储已经翻转链表的头节点</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode temp = cur.next;<span class="hljs-comment">//先把后面的节点保存起来防止断裂</span><br>            cur.next = pre;<span class="hljs-comment">//将已经翻转的链表的头节点接上去</span><br>            pre = cur;<br>            cur = temp;<span class="hljs-comment">//后移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br></code></pre></td></tr></table></figure><p>头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">//采用头插法翻转</span><br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode temp = cur.next;<br>            cur.next = pre.next;<br>            pre.next = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II - 力扣（LeetCode）</a></p><p>反转一个指定区间里面的链表节点</p><p>使用三个链表的变量来记录在翻转的时候需要的指针变量，分别是pre,cur,next</p><p>curr：指向待反转区域的第一个节点 left；<br>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；<br>pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</p><p>第一步 图示<br><img src="https://pic.leetcode-cn.com/1615105296-bmiPxl-image.png" alt="第一步"></p><p>/第二步 图示<br><img src="https://pic.leetcode-cn.com/1615105353-PsCmzb-image.png" alt="第二步"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 设置 dummyNode 是这一类问题的一般做法</span><br>        ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        dummyNode.next = head;<br>        ListNode pre = dummyNode;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        ListNode cur = pre.next;<br>        ListNode next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>            next = cur.next;<br>            cur.next = next.next;<br>            next.next = pre.next;<br>            pre.next = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除节点">删除节点</h3><p><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/">剑指 Offer 18. 删除链表的节点 - 力扣（Leetcode）</a> 之前自己写的代码，老是报空指针异常。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        pre.next = head;<br><br>        ListNode cur = pre;<br>        <span class="hljs-comment">//找到前一个节点</span><br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.val != val)&#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//删除节点</span><br>        cur.next = cur.next.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length  = getlength(head);<br>        <span class="hljs-comment">//添加一个pre，这样删除到头节点时不会出现空指针异常</span><br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode();<br>        pre.next = head;<br>        ListNode cur = pre;<br>        <span class="hljs-comment">//寻找倒数第几个进行删除，需要找到前一个进行操作</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length - n;i++)&#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//进行删除</span><br>        cur.next = cur.next.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getlength</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            length++;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">removeNthFromEnd</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">buildList</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经处理完所有的元素，则返回null</span><br>        <span class="hljs-keyword">if</span> (index &gt;= list.size()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 创建一个新的节点，并且递归地为下一个节点调用此方法</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(list.get(index), buildList(list, index + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length  = getlength(head);<br><br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode();<br>        pre.next = head;<br>        ListNode cur = pre;<br>        <span class="hljs-comment">//寻找倒数第几个进行删除，需要找到前一个进行操作</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length - n;i++)&#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//进行删除</span><br>        cur.next = cur.next.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getlength</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            length++;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            list.add(scanner.nextInt());<br>        &#125;<br>        ListNode listNode = buildList(list,<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">//删除倒数第几个</span><br>        <span class="hljs-keyword">int</span> target = scanner.nextInt();<br>        listNode = removeNthFromEnd(listNode,target);<br>        <span class="hljs-keyword">while</span> (listNode != <span class="hljs-keyword">null</span>)&#123;<br>            System.out.print(listNode.val + <span class="hljs-string">&quot; &quot;</span>);<br>            listNode = listNode.next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快慢指针">快慢指针</h3><h4 id="判断链表是否有环，并找出环的入口">判断链表是否有环，并找出环的入口</h4><p>比如<a href="https://leetcode.cn/problems/linked-list-cycle/submissions/">141. 环形链表 - 力扣（LeetCode）</a>和<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a>就是这种题</p><p>如果链表存在环，就好像操场的跑道是一个环形一样。此时让快慢指针都从链表头开始遍历，快指针每次向前移动两个位置，慢指针每次向前移动一个位置；如果快指针到达NULL，说明链表以NULL为结尾，没有环。如果快指针追上慢指针，则表示有环。</p><p>​    如果链表存在环，如果找到环的入口点？当fast若与slow相遇时，slow肯定没有走遍历完链表或者恰好遍历一圈。于是我们从链表头与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点(证明略)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCirle</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//考虑只有一个节点的特殊情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    ListNode slow = head,fast = head;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//这里一起写上fast.next判断可以避免空指针异常</span><br>        slow = slow.next; <span class="hljs-comment">//每次前进一步</span><br>        fast = fast.next.next; <span class="hljs-comment">//每次前进两步</span><br>        <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">findLoopPort</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        ListNode slow = head,fast = head;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            fast = fast.next.next;<br>            slow = slow.next;<span class="hljs-comment">//放在if的外面，防止第一次的时候判断失误</span><br>            <span class="hljs-keyword">if</span>( slow == fast)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        slow = head;<span class="hljs-comment">//让slow返回</span><br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<span class="hljs-comment">//之后就是每次移动一步</span><br>        &#125;<br>        <span class="hljs-comment">//再次相遇的时候就是环开始的节点</span><br>        <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">//寻找环的入口，other version</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                slow = head;<br>                flag = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以再加一道题<a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数 - 力扣（Leetcode）</a></p><p>题意：在那个数组里面，只有一个数字会出现一次或者多次，其他数字只会出现一次，找出这个数</p><p>思路：这道题一看到，我就想到了哈希映射，做了一遍，思路是对的，也可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-comment">//找出这个数字的映射出现了几次</span><br>            <span class="hljs-keyword">int</span> count  = map.get(nums[i]) == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : map.get(nums[i]) + <span class="hljs-number">1</span>;<br>            map.put(nums[i],count);<br>        &#125;<br>        <span class="hljs-comment">//找出不是1的映射就是答案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(nums[i]) != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>题解一位大佬给出了另外一种快慢指针的思路，可以将这道题通过下标相互&quot;连接&quot;,将题目转换为环形链表的思路，通过找出入口的方式，就可以找出这个重复的值<a href="https://leetcode.cn/problems/find-the-duplicate-number/solutions/58841/287xun-zhao-zhong-fu-shu-by-kirsche/">287. 寻找重复数题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> fast = <span class="hljs-number">0</span>;<br>        slow = nums[slow];<br>        fast = nums[nums[fast]];<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        &#125;<br>        <span class="hljs-keyword">int</span> pre1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> pre2 = slow;<br>        <span class="hljs-keyword">while</span>(pre1 != pre2)&#123;<br>            pre1 = nums[pre1];<br>            pre2 = nums[pre2];<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在有序链表中寻找中位数">在有序链表中寻找中位数</h4><p>快指针的移动速度是慢指针的2倍，因此当快指针到达链表尾的时候，满指针到达中点。</p><p>程序还要考虑链表结点个数的奇偶数因素，当快指针移动x次后到达表尾（1+2x），说明链表有奇数个结点，直接返回慢指针指向的数据即可。</p><p>如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或（上中位数+下中位数）的一半。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; slow)&#123;<br>        <span class="hljs-keyword">if</span>(fast.next == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//奇数</span><br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//偶数 注意这个判断条件 和之前不一样 是多了一个next</span><br>            <span class="hljs-keyword">return</span> slow; <span class="hljs-comment">//这里的slow是中点的前一个</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出链表中的倒数第K个节点">输出链表中的倒数第K个节点</h4><p>快指针先向前走K下，慢指针不动，之后，快慢指针一起动，当快指针到达尾节点的时候，慢指针就是倒数第k个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode fast = pre, slow = pre;<br><span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;<br>    fast = fast.next;<br>    n--;<br>&#125;<br><span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span>) &#123;<br>    fast = fast.next;<br>    slow = slow.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/">剑指 Offer 22. 链表中倒数第k个节点 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>)&#123;<br>            fast = fast.next;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快慢指针和翻转链表一起">快慢指针和翻转链表一起</h4><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表 - 力扣（LeetCode）</a>该题就是叫你判断一个链表里面的数据是否是回文，用以前取余相乘翻转判断显然不行，因此这里可以考虑使用使用快慢指针寻找中点，并结合翻转链表，将前半段链表翻转，以此来比较，但是下面所示的该方法没有将链表翻转回来，具有一定的缺陷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode slow = head,fast = head;<br>        ListNode pre = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//用来存储已经翻转节点前驱</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//快慢指针经典语法</span><br>            fast = fast.next.next;<br>            <span class="hljs-comment">//注意！！！ </span><br>            <span class="hljs-comment">//这里需要写在最前面，不然都话，先翻转链表断裂后，fast指针无法走过去，会出现空指针异常</span><br>            ListNode temp = slow.next;<span class="hljs-comment">//用来暂时存储后续节点，防止断裂</span><br>            slow.next = pre;<span class="hljs-comment">//翻转，将前面所有已翻转节点接到slow后面</span><br>            pre = slow;<span class="hljs-comment">//记录位置</span><br>            slow = temp;<span class="hljs-comment">//相当于后移了slow指针</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//链表节点数是单数</span><br>             slow = slow.next;<span class="hljs-comment">//slow移动到中间节点的另一边去，好和前面已经翻转的节点进行比较</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(slow != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//开始比较</span><br>            <span class="hljs-keyword">if</span>(slow.val != pre.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//结果不相等</span><br>            &#125;<br>            slow = slow.next;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>第二种解法</strong></p><p>使用集合存储数据之后，使用双指针从两边开始比较，但是效率没有上面的高，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ListNode temp = head;<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>)&#123;<br>            data.add(temp.val);<br>            temp = temp.next; <span class="hljs-comment">//将数据全部遍历后加入集合</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> end = data.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>            <span class="hljs-keyword">if</span>(data.get(start) != data.get(end))&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>            &#125;<br>            start++;<br>            end--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里再贴一下回文数字的解法<a href="https://leetcode.cn/problems/palindrome-number/">9. 回文数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> temp = x;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(temp &gt; <span class="hljs-number">0</span>)&#123;<br>            cur = cur * <span class="hljs-number">10</span> + temp % <span class="hljs-number">10</span>;<br>            temp/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x==cur;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="链表中使用递归">链表中使用递归</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode）</a>或者使用下面合并升序链表题型中的常规方法新建链表排序里的那种合并也行，这是同一道题。</p><p>使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素</p><ul><li>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</li><li>返回值：每一层调用都返回排序好的链表头</li><li>本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</li><li>O(m+n)O(m+n)，mm 为 l1的长度，nn 为 l2 的长度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220707202440270.png" alt="图解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<span class="hljs-comment">//不断赋值连接</span><br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树转换为链表">二叉树转换为链表</h3><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表 - 力扣（Leetcode）</a></p><p>将一个二叉树转换为链表输出，并且为前序遍历，总的思路就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br><span class="hljs-number">3</span>   <span class="hljs-number">4</span>   <span class="hljs-number">6</span><br><br>//将 <span class="hljs-number">1</span> 的左子树插入到右子树的地方<br>    <span class="hljs-number">1</span><br>     <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>         <span class="hljs-number">5</span><br>     / <span class="hljs-string">\</span>         <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>   <span class="hljs-number">4</span>         <span class="hljs-number">6</span>        <br>//将原来的右子树接到左子树的最右边节点<br>    <span class="hljs-number">1</span><br>     <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>          <br>     / <span class="hljs-string">\</span>          <br>    <span class="hljs-number">3</span>   <span class="hljs-number">4</span>  <br>         <span class="hljs-string">\</span><br>          <span class="hljs-number">5</span><br>           <span class="hljs-string">\</span><br>            <span class="hljs-number">6</span><br>            <br> //将 <span class="hljs-number">2</span> 的左子树插入到右子树的地方<br>    <span class="hljs-number">1</span><br>     <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>          <br>       <span class="hljs-string">\</span>          <br>        <span class="hljs-number">3</span>       <span class="hljs-number">4</span>  <br>                 <span class="hljs-string">\</span><br>                  <span class="hljs-number">5</span><br>                   <span class="hljs-string">\</span><br>                    <span class="hljs-number">6</span>   <br>        <br> //将原来的右子树接到左子树的最右边节点<br>    <span class="hljs-number">1</span><br>     <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>          <br>       <span class="hljs-string">\</span>          <br>        <span class="hljs-number">3</span>      <br>         <span class="hljs-string">\</span><br>          <span class="hljs-number">4</span>  <br>           <span class="hljs-string">\</span><br>            <span class="hljs-number">5</span><br>             <span class="hljs-string">\</span><br>              <span class="hljs-number">6</span>         <br></code></pre></td></tr></table></figure><p>但是这里使用代码实现起来就是先将右子树拆接到左子树，然后再接到右子树上的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>     <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">//切记要考虑当前节点的是否为null</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)&#123;<br>            root = root.right;<span class="hljs-comment">//已经为null了，直接考虑下一个</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            TreeNode tempTail = root.left;<br>            <span class="hljs-keyword">while</span>(tempTail.right != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//当执行到最后一个节点，注意这个判断</span><br>                tempTail = tempTail.right;<span class="hljs-comment">//一直找左子树的最右边的节点</span><br>            &#125;<br>            <span class="hljs-comment">//这里先把右边接过去可以省去一个临时存储右子树的节点</span><br>            tempTail.right = root.right;<br>            root.right = root.left;<br>            root.left = <span class="hljs-keyword">null</span>;<br>            root = root.right;<span class="hljs-comment">//继续下一个节点</span><br>        &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="相交的链表">相交的链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表 - 力扣（LeetCode）</a> 寻找两条链表相交的节点，一开始首先的想到的就是上面快慢的指针方法，但是实践一下哎，发现根本不可行，看到题解的这个方法恍然大悟，主要思路就是：使用双指针，是他们按相同的速度依次走一遍这两条链表(a先走a链表，b先走b链表)，路程相同，速度也相同，最后他们必然在终点的时候是相遇的，再往前推，最后一段路程是相同的，所以他们相遇的点即是交点，看到评论区的一句骚话：走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>     &#125; <br>     ListNode pA = headA, pB = headB;<br>     <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>         pA = pA == <span class="hljs-keyword">null</span> ? headB : pA.next;<br>         pB = pB == <span class="hljs-keyword">null</span> ? headA : pB.next;<br>     &#125;<br>     <span class="hljs-keyword">return</span> pA;<br> &#125;<br><span class="hljs-comment">// 若相交，链表A： a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在公共处c起点相遇。若不相交，a+b = b+a 。因此相遇处是NULL</span><br><br><br><span class="hljs-comment">//另一种写法，也可以通过，但是逻辑没有上面的这种清晰</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode curA = headA;<br>        ListNode curB = headB;<br>        <span class="hljs-keyword">if</span>(curA == curB)&#123;<br>            <span class="hljs-keyword">return</span> curA;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-keyword">null</span> || curB!= <span class="hljs-keyword">null</span>)&#123;<br>            curA = curA == <span class="hljs-keyword">null</span> ? headB : curA.next;<br>            curB = curB == <span class="hljs-keyword">null</span> ? headA : curB.next;<br>            <span class="hljs-keyword">if</span>(curA == curB)&#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 下面这样写会导致若两条链表不相交，则会一直循环下去，导致超时</span><br>    <span class="hljs-comment">//     while(cur != cur2)&#123;</span><br>    <span class="hljs-comment">//         cur = cur.next;</span><br>    <span class="hljs-comment">//         cur2 = cur2.next;</span><br>    <span class="hljs-comment">//         if(cur == null)&#123;</span><br>    <span class="hljs-comment">//             cur = headB;</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//         if(cur2 == null)&#123;</span><br>    <span class="hljs-comment">//             cur2 = headA;</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return cur;</span><br>    <span class="hljs-comment">//    &#125;</span><br></code></pre></td></tr></table></figure><h3 id="LRU-缓存">LRU 缓存</h3><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存 - 力扣（LeetCode）</a> 做题的时候要形成条件反射，看到键值对就要想到HashMap，这里主要思路就是使用双向链表+哈希表，使用双向链表方便寻找头和尾，同时用哈希表的键和值来分别对应键和节点，每次生成键值对的时候，判断容量是否满了。每次将节点放在双向链表的最前面，如果访问了某一个节点，就把该节点移动到最前面，这样每次链表最后面的节点就是最近最久未使用的节点，当容量满了的时候，就删除替换这个节点即可。</p><p>面试官想看到的自己写双向链表和哈希表的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkedNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;<br>    &#125;<br><span class="hljs-comment">//使用双向链表+哈希表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span><br>        head = <span class="hljs-keyword">new</span> DLinkedNode();<br>        tail = <span class="hljs-keyword">new</span> DLinkedNode();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span><br>            DLinkedNode newNode = <span class="hljs-keyword">new</span> DLinkedNode(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache.put(key, newNode);<br>            <span class="hljs-comment">// 添加至双向链表的头部</span><br>            addToHead(newNode);<br>            ++size;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span><br>                DLinkedNode tail = removeTail();<br>                <span class="hljs-comment">//注意这里，看removeTail函数，这里的tail其实是倒数第二个，即我们插入的倒数第一个</span><br>                <span class="hljs-comment">// 删除哈希表中对应的项</span><br>                cache.remove(tail.key);<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        DLinkedNode res = tail.prev;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Java帮你包好数据结构版本：</p><p>这里使用了Java封装好的LinkedHashMap结构，也就是我们上面写的那个结构，主要的思路就是继承该类，然后重写最近最少使用的节点的规则，把这个规则改成size大于容量的时候就删除就行，有关这个方法更加详细的解释可以参照<a href="https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/">源于 LinkedHashMap源码 - LRU 缓存 - 力扣（LeetCode）</a>这个题解参考了部分源码，更容易理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//构造函数，0.75F指加载因子，使用默认就行，true代表按照读取的顺序，false(默认)则是按照插入顺序</span><br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getOrDefault(key, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这个可不写 因为题目要求相比父类的put方法并没有改变</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.put(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size() &gt; capacity; <span class="hljs-comment">//本题关键，删除最近最少使用的规则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表的排序">链表的排序</h3><p><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表 - 力扣（LeetCode）</a> 看到题目所要求得log型时间复杂度，我们就应该想到使用归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、递归结束条件</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//这里判断单节点的时候也是需要将head先写在前面，因为会先判断，避免空指针异常</span><br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 2、找到链表中间节点并断开链表 &amp; 递归下探</span><br>        ListNode midNode = middleNode(head);<br>        ListNode rightHead = midNode.next;<br>        midNode.next = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//斩断</span><br><br>        ListNode left = sortList(head);<br>        ListNode right = sortList(rightHead);<br><br>        <span class="hljs-comment">// 3、当前层业务操作（合并有序链表）</span><br>        <span class="hljs-keyword">return</span> mergeTwoLists(left, right);<br>    &#125;<br>    <br>    <span class="hljs-comment">//第一种方法 找到链表中间节点（876. 链表的中间结点）</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//单节点</span><br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode slow = head;<br>        ListNode fast = head.next.next;<br>        <span class="hljs-comment">//没有做单双数区分，fast这里多走了一步</span><br>        <span class="hljs-comment">//如果是单数节点会返回中间节点的前一个节点，因为主程序中该返回值返回后，还要+1，将真正的中间节点分到了后半段</span><br>        <span class="hljs-comment">//但是因为是归并排序，所以没有影响</span><br>        <span class="hljs-comment">//如果是偶数返回中间的前一个节点</span><br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-comment">//第二种写法这里区分了一下单双节点，单数节点返回中间，双数节点返回的前一个</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">midNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;     <br>        ListNode fast = head;<br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast.next == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> slow;<span class="hljs-comment">//单数节点，返回真正的中间节点，相当于将中间节点分到了前一段</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//双数节点返回中间的前一个节点</span><br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                fast = fast.next.next;<br>                slow = slow.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<span class="hljs-comment">//上面循环没进去，说明是单个节点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序链表（21. 合并两个有序链表）</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode curr = pre;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;<br>                curr.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curr.next = l2;<br>                l2 = l2.next;<br>            &#125;<br><br>            curr = curr.next;<br>        &#125;<br><br>        curr.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第二种方法：使用集合进行排序，然后重新组合成链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode();<br>        ListNode cur = head;<br>        List&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            list.add(cur);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//lambda表达式，自定义元素对集合排序      </span><br>        list.sort((node1,node2)-&gt;&#123;<br>Integer val1= node1.val;<br>Integer val2= node2.val;<br><span class="hljs-keyword">return</span>  val1.compareTo(val2);<br>    &#125;);<br>        <span class="hljs-comment">//重新封装链表</span><br>        cur = pre;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; list.size();i++)&#123;<br>            cur.next = list.get(i);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//置空，防止环的出现</span><br>        cur.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表 - 力扣（Leetcode）</a></p><p>题意：将链表重新排序为L(0) - L(n) - L(1) - L(n-1) - L(2) - L(n-2) - …的形式</p><p>思路：使用双指针分别从头尾遍历，然后重组链表,这种涉及到需要从单向链表的尾部往前遍历的，首先就应该考虑到使用集合来解决</p><p>美团一面的面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        List&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ListNode cur = head;<br>        <span class="hljs-comment">//存储到集合中</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            list.add(cur);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            list.get(i).next = list.get(j);<br>            i++;<br>            list.get(j).next = list.get(i);<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//记住末尾置空，防止环的出现</span><br>        list.get(i).next = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//other version</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        List&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            list.add(cur);<br>            cur = cur.next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            ListNode nodeHead = list.get(i);<br>            ListNode nodeTail = list.get(j); <br>            cur.next = nodeTail;<br>            cur.next.next = nodeHead;<br>            cur = cur.next.next;<br>            i++;<br>            j--;<br>        &#125;<br>        cur.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合并升序链表">合并升序链表</h3><p>先合并两个,就是和之前的归并里面的是一样的</p><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/">剑指 Offer 25. 合并两个排序的链表 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode cur = pre;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val)&#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>                cur = cur.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意这里顺序别搞错了</span><br>        cur.next = l1 == <span class="hljs-keyword">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mergeTwoLists</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">buildList</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经处理完所有的元素，则返回null</span><br>        <span class="hljs-keyword">if</span> (index &gt;= list.size()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 创建一个新的节点，并且递归地为下一个节点调用此方法</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(list.get(index), buildList(list, index + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode cur = dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur= cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-keyword">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = scanner.nextInt();<span class="hljs-comment">//链表节点个数</span><br>        ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            list1.add(scanner.nextInt());<br>        &#125;<br>        ListNode l1 = buildList(list1,<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">int</span> m = scanner.nextInt();<span class="hljs-comment">//链表节点个数</span><br>        ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            list2.add(scanner.nextInt());<br>        &#125;<br>        ListNode l2 = buildList(list2,<span class="hljs-number">0</span>);<br><br>        ListNode result = mergeTwoLists(l1,l2);<br>        <span class="hljs-keyword">while</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(result.val + <span class="hljs-string">&quot; &quot;</span>);<br>            result = result.next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表 - 力扣（LeetCode）</a>这道题刚看起来是个hard，但是一看题，感觉好像没有那么难，首先得思路就是和归并排序之前的一样合并，就是升级成K个而已，按照这个思路，写出了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        ListNode temp = <span class="hljs-keyword">new</span> ListNode();<br>        <span class="hljs-keyword">for</span>(ListNode List:lists)&#123;<br>            temp.next =  merge(List,temp.next);<span class="hljs-comment">//重复更新排序好的temp链表</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> temp.next;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode list1,ListNode list2)</span></span>&#123;<span class="hljs-comment">//常见的合并链表的方法  每次两个合并</span><br>        ListNode l1 = list1;<br>        ListNode l2 = list2;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode();<br>        ListNode cur = pre;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val&lt;l2.val)&#123;<br>                cur.next = l1;<br>                cur = cur.next;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.next = l2;<br>                cur = cur.next;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-keyword">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mergeKLists</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        ListNode res = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span>(ListNode list : lists)&#123;<br>            res = merge(list,res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode l1,ListNode l2)</span></span>&#123;<br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode cur = pre;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val)&#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-keyword">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">buildList</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经处理完所有的元素，则返回null</span><br>        <span class="hljs-keyword">if</span> (index &gt;= list.size()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 创建一个新的节点，并且递归地为下一个节点调用此方法</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(list.get(index), buildList(list, index + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">//几条链表</span><br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        ListNode[] lists = <span class="hljs-keyword">new</span> ListNode[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">int</span> m = sc.nextInt();<br>            ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                list.add(sc.nextInt());<br>            &#125;<br>            ListNode head = buildList(list, <span class="hljs-number">0</span>);<br>            lists[i] = head;<br>        &#125;<br>        mergeKLists mergeKLists = <span class="hljs-keyword">new</span> mergeKLists();<br>        ListNode result = mergeKLists.mergeKLists(lists);<br>        <span class="hljs-keyword">while</span> (result != <span class="hljs-keyword">null</span>)&#123;<br>            System.out.print(result.val + <span class="hljs-string">&quot; &quot;</span>);<br>            result = result.next;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>虽然通过了，但是这种方法很明显，并不是很好</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220915100244797.png" alt="image-20220915100244797"></p><p>分治算法(归并排序)  这里的主要思路就是把lists[] 里面的一维的链表 看成是归并排序里面的一个数字，不断的分，最后两条链表合并的时候进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-keyword">null</span> || lists.length == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//首先需要考虑的当然是是否是空</span><br>        &#125; <br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right)&#123;<span class="hljs-comment">//注意这里递归结束条件是不一样的</span><br>           <span class="hljs-keyword">return</span> lists[left];   <br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        ListNode l1 = merge(lists, left, mid);<span class="hljs-comment">//分</span><br>        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);<span class="hljs-comment">//分</span><br>        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);<span class="hljs-comment">//合</span><br>    &#125;<br><br>    <span class="hljs-comment">//这里合并采用的是上面的递归方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;  <br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;   <br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1,l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用归并后，时间明显下降</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220915104158401.png" alt="image-20220915104158401"></p><h2 id="栈和队列">栈和队列</h2><h3 id="基础结构相关">基础结构相关</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><p>使用两个栈来实现队列，这里使用了一个栈进，一个栈出，具体原理是，队列进的时候，入栈一样的push,没有什么区别，但是出队列的时候，需要判断一下，如果出栈为空，需要把入栈的元素全部转移到出栈中，再出栈，出栈不为空的话，直接出就行</p><p><img src="https://file1.kamacoder.com/i/algo/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="栈实现队列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Stack&lt;Integer&gt; StackIn;<br>    Stack&lt;Integer&gt; StackOut;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        StackIn = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        StackOut = <span class="hljs-keyword">new</span> Stack&lt;&gt;(); <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        StackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//出栈为空，进行转移</span><br>        <span class="hljs-keyword">if</span>(StackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!StackIn.isEmpty())&#123;<br>                StackOut.push(StackIn.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> StackOut.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(StackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!StackIn.isEmpty())&#123;<br>                StackOut.push(StackIn.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> StackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> StackIn.isEmpty() &amp;&amp; StackOut.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><p>用队列来实现栈就可以只使用一个队列实现了，进还是正常进，出的话就是把除了最后一个的元素重新添加进队列尾部，队列的第一个元素就是需要出栈的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;<br><br>    Deque&lt;Integer&gt; que;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;<br>        que = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        que.addLast(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//除了最后一个都移动</span><br>        <span class="hljs-keyword">int</span> size = que.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(size-- &gt; <span class="hljs-number">0</span>)&#123;<br>            que.addLast(que.removeFirst());<br>        &#125;<br>        <span class="hljs-keyword">return</span> que.removeFirst();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//直接输出最后一个</span><br>        <span class="hljs-keyword">return</span> que.peekLast();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="经典的括号匹配">经典的括号匹配</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a>括号匹配的经典思路，遇到左括号直接入栈，如果遇到右括号，若栈为空，则不符合，若栈不为空，则出栈判断是否是匹配的那个括号，最后判断，栈里是否还有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] arr = s.toCharArray();<span class="hljs-comment">//转变为数组</span><br>        Stack&lt;Character&gt; Stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:arr)&#123;<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span> ||ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span> )&#123;<br>                Stack.push(ch);<span class="hljs-comment">//遇到左括号直接入栈</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!Stack.isEmpty())&#123;<span class="hljs-comment">//栈不为空，遇到右括号，出栈对比</span><br>                <span class="hljs-keyword">char</span> chpop = Stack.pop();<br>                <span class="hljs-keyword">if</span>(chpop == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; ch!=<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(chpop == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; ch!=<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(chpop == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; ch!=<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Stack.isEmpty())&#123;<span class="hljs-comment">//栈为空 遇到右括号，不符合，直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> Stack.isEmpty();<span class="hljs-comment">//判断是否有落单的左括号</span><br>    &#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">isValid</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] arr = s.toCharArray();<span class="hljs-comment">//转变为数组</span><br>        Stack&lt;Character&gt; Stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:arr)&#123;<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span> ||ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span> )&#123;<br>                Stack.push(ch);<span class="hljs-comment">//遇到左括号直接入栈</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!Stack.isEmpty())&#123;<span class="hljs-comment">//栈不为空，遇到右括号，出栈对比</span><br>                <span class="hljs-keyword">char</span> chpop = Stack.pop();<br>                <span class="hljs-keyword">if</span>(chpop == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; ch!=<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(chpop == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; ch!=<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(chpop == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; ch!=<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Stack.isEmpty())&#123;<span class="hljs-comment">//栈为空 遇到右括号，不符合，直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> Stack.isEmpty();<span class="hljs-comment">//判断是否有落单的左括号</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine();<br>        isValid isValid = <span class="hljs-keyword">new</span> isValid();<br>        <span class="hljs-keyword">boolean</span> valid = isValid.isValid(s);<br>        System.out.println(valid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面贴一个鬼才代码，能通过，但是时间复杂度较高，本质是消消乐🤔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">int</span> l=s.length();<span class="hljs-comment">//开始前量一次长度</span><br>            s=s.replace(<span class="hljs-string">&quot;()&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>            s=s.replace(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>            s=s.replace(<span class="hljs-string">&quot;[]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-keyword">if</span>(s.length()==l)&#123;<span class="hljs-comment">//说明该消得已经消完了，本次循环没有再消</span><br>                <span class="hljs-keyword">return</span> l==<span class="hljs-number">0</span>;<span class="hljs-comment">//判断是否落单</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//代码鬼才</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a> 这一道题其实也是类似括号匹配</p><p>题意：</p><p>给出由小写字母组成的字符串 <code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。</p><p><strong>示例：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;abbaca&quot;</span><br>输出：<span class="hljs-string">&quot;ca&quot;</span><br>解释：<br>例如，在 <span class="hljs-string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="hljs-string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="hljs-string">&quot;aaca&quot;</span>，其中又只有 <span class="hljs-string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="hljs-string">&quot;ca&quot;</span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-comment">//使用双端队列来做栈</span><br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : arr)&#123;<br>            <span class="hljs-comment">//如果栈不为空且瞟了一眼栈顶是相同的</span><br>            <span class="hljs-keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peekLast() == c)&#123;<br>                stack.removeLast();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//否则入栈</span><br>                stack.addLast(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把最终返回作为字符串</span><br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            res += stack.removeFirst(); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a>简单的描述题，给你一个数组，找出当前位置后第一个比当前数字大的数字的与当前数字的距离，填在当前的位置上，先来看看暴力解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先想到的是动规，但是我点的标签是栈emmm</span><br>    <span class="hljs-comment">//发现动规好像并不可行，暴力好像可以</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br>        <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;temperatures.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j&lt;temperatures.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(temperatures[j] &gt; temperatures[i])&#123;<span class="hljs-comment">//遇见第一个大于的温度</span><br>                   array[i] = j-i;<br>                   <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure><p>暴力解题，虽然可行，显著的问题就是效率不够高<img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220918170755669.png" alt="image-20220918170755669"></p><p>单调栈的解法即维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。每次入栈的时候与栈顶元素进行比较，如果当前的数值比栈顶元素小，直接入栈，反之若当前的数值比栈顶元素比大，说明找到了比它的值，则下标相减，得到间隔，然后将栈顶元素出栈，当前的元素继续与栈顶元素比较，重复上述步骤</p><p>视频讲解：<a href="https://leetcode.cn/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">LeetCode 图解 | 739.每日温度 - 每日温度 - 力扣（LeetCode）</a></p><p><strong>note:</strong> 判别是否需要使用单调栈，如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈；单调栈的题目如矩形米面积等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;T.length;i++)&#123;<span class="hljs-comment">//只需要循环一次，时间复杂度一下子就降下来了</span><br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; T[stack.peek()]&lt;T[i])&#123;<span class="hljs-comment">//栈里面只需要存储下标就行</span><br>                <span class="hljs-keyword">int</span> pre = stack.pop();<br>                result[pre] = i - pre;<br>            &#125;<br>            stack.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)O(n)，其中 nn 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p><p>空间复杂度：O(n)O(n)，其中 nn 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="题图"></p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/">柱状图中最大的矩形 题解</a>思路：首先暴力会直接超时，因此类似的这种题可以考虑使用单调栈来进行解决</p><ol><li><strong>单调栈</strong>：维护一个单调递增的栈，栈中保存柱子的索引。当遇到一个比栈顶元素高度小的柱子时，说明栈顶元素的右边界已经找到，此时弹出栈顶元素并计算其对应的矩形面积（如果不是比栈顶小的元素，说明还可以继续往右边截取，因此还没有到矩形的最大值）。</li><li><strong>左右边界确定</strong>：对于每个弹出的栈顶元素，其左边界是新的栈顶元素（若栈为空则为-1），右边界是当前遍历到的索引。遍历结束后，处理栈中剩余元素，其右边界设为数组长度n。</li><li><strong>面积计算</strong>：根据左右边界计算每个柱子对应的矩形面积，并更新最大值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = heights.length;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//遇到比栈顶元素小的值，弹出并计算矩形的面积</span><br>            <span class="hljs-comment">//这里使用循环就是为了像index=2;3在碰到下一个小的index=4,h=2的元素时都能出栈</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;<br>                <span class="hljs-keyword">int</span> h = heights[stack.pop()];<br>                <span class="hljs-keyword">int</span> left = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                <span class="hljs-comment">//真正的长度需要再减1，比如上图的index=3的6的面积就是4-2-1=1</span><br>                <span class="hljs-keyword">int</span> width = i - left - <span class="hljs-number">1</span>;<br>                maxArea = Math.max(maxArea, h * width);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-comment">//开始处理还留在栈内的元素</span><br>        <span class="hljs-comment">//遍历结束时，剩余元素的右侧没有更小的柱子，因此它们的右边界应视为数组末尾后的位置（即 n）</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> h = heights[stack.pop()];<br>            <span class="hljs-keyword">int</span> left = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>            <span class="hljs-comment">//所以这里的宽度都是为n来减</span><br>            <span class="hljs-keyword">int</span> width = n - left - <span class="hljs-number">1</span>;<br>            maxArea = Math.max(maxArea, h * width);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接雨水也能用单调 栈的 解法，这个就后面再说了</p><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85. 最大矩形 - 力扣（LeetCode）</a>  题意:给你下图所示的一个矩形，求出内部全部都为1的矩形的面积最大值</p><p>思路：这个题换一个思路就能变成和上一道题一样的题，具体的思路请看下图</p><p><img src="https://pic.leetcode-cn.com/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png" alt="图示"></p><p>通过不断的移动坐标系，使用84题中求出柱状图最大矩形的算法，就可以求出这一行中最大面积的矩形，把所有行都遍历完成，面积最大的那个矩形就是当前这个图内部全为1的最大矩形。因此只需要遍历每一行，存储1的高度数组，传给84题的函数，最后取最大值就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = matrix.length;<br>        <span class="hljs-keyword">int</span> w = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[w];<br>        <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; h;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; w; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    heights[j]++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    heights[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            maxArea = Math.max(maxArea,largestRectangleArea(heights));<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = heights.length;<br>        <span class="hljs-keyword">int</span> maxRowArea = <span class="hljs-number">0</span>;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()])&#123;<br>                <span class="hljs-comment">//取出下标</span><br>                <span class="hljs-keyword">int</span> h = heights[stack.pop()];<br>                <span class="hljs-keyword">int</span> left = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek(); <br>                <span class="hljs-keyword">int</span> w = i - left - <span class="hljs-number">1</span>;<br>                maxRowArea = Math.max(maxRowArea, h * w) ;<br>            &#125;<br>            <span class="hljs-comment">//存储下标用于计算面积</span><br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-comment">//处理剩下的元素</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-comment">//取出下标</span><br>                <span class="hljs-keyword">int</span> h = heights[stack.pop()];<br>                <span class="hljs-keyword">int</span> left = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek(); <br>                <span class="hljs-keyword">int</span> w = n - left - <span class="hljs-number">1</span>;<br>                maxRowArea = Math.max(maxRowArea, h * w) ;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxRowArea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="辅助栈">辅助栈</h3><p>故名思意就是使用一个辅助的栈来解题，<a href="https://leetcode.cn/problems/min-stack/">155. 最小栈 - 力扣（LeetCode）</a>，该题要求查找最小值的时候需要在常数的时间内完成，因此该题的思路就是，一个栈用来存储放入的数字，一个辅助的栈用来存储当前的最小值，每次进去的时候就会比较一次是否比栈顶的小，pop的时候就一起pop出去，这样栈顶的元素就是当前的栈元素里面的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    Stack&lt;Integer&gt; stack1;<br>    Stack&lt;Integer&gt; stack2;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//构造函数初始化</span><br>       stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>       stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>       stack2.push(Integer.MAX_VALUE);<br>        <span class="hljs-comment">//需要在一开始在辅助栈里面设置一个最大值</span><br>        <span class="hljs-comment">//否则下面在比较的栈的最小值的时候会报错</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        stack1.push(val);<br>        stack2.push(Math.min(stack2.peek(),val));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stack1.pop();<br>        stack2.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack1.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack2.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>看到评论说面试官要求写一个不用辅助栈的，在这里贴一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//本质上还是辅助栈，但是把辅助栈和元素栈合并在了一起</span><br><br><br><span class="hljs-comment">//方法一  栈里插数组</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    <span class="hljs-comment">// 数组栈, [当前值, 当前最小值]</span><br>    <span class="hljs-keyword">private</span> Stack&lt;<span class="hljs-keyword">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-comment">//还是第一次见到这样的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.isEmpty())&#123;<br>            stack.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x, x&#125;);<span class="hljs-comment">//放入存储两位数字的数组，即数字和当前最小值</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            stack.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x, Math.min(x, stack.peek()[<span class="hljs-number">1</span>])&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stack.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//方法2  自定义链表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Node node;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)&#123;<br>            node = <span class="hljs-keyword">new</span> Node(x, x);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// node = new Node(x, Math.min(x, node.min), node);</span><br>            Node next = <span class="hljs-keyword">new</span> Node(x, Math.min(x, node.min));<br>            next.prev = node;<br>            node = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        node = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> node.val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> node.min;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">int</span> min;<br>        Node prev;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> min)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.min = min;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> min, Node prev)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.min = min;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//方法3  栈里面插入节点似乎也可行，这里就不细写了</span><br></code></pre></td></tr></table></figure><p>辅助栈的另外一个应用<a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码 - 力扣（Leetcode）</a></p><p>构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</p><ul><li><p>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</p></li><li><p>当 c 为字母时，在 res 尾部添加 c；</p></li><li><p>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：</p><ul><li><p>记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；</p></li><li><p>记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × […] 字符串。</p></li></ul></li><li><p>进入到新 [ 后，res 和 multi 重新记录。当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:</p><ul><li>last_res是上个 [ 到当前 [ 的字符串，例如 “3[a2[c]]” 中的 a；</li><li>cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 “3[a2[c]]” 中的 2。<br>返回字符串 res</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>   StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>   <span class="hljs-keyword">int</span> multi = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于后面乘数字</span><br>   LinkedList&lt;Integer&gt; stack_int =  <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>   LinkedList&lt;String&gt; stack_str =  <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>   <span class="hljs-keyword">for</span>(Character c : s.toCharArray())&#123;<br>       <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<span class="hljs-comment">//说明前面的数字和字母结束,可以入栈了</span><br>           stack_int.addLast(multi);<span class="hljs-comment">//数字入栈</span><br>           stack_str.addLast(res.toString());<span class="hljs-comment">//字符串入栈</span><br>           <span class="hljs-comment">//记得置空</span><br>           res = <span class="hljs-keyword">new</span> StringBuilder();<br>           multi = <span class="hljs-number">0</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>           StringBuilder tmp = <span class="hljs-keyword">new</span> StringBuilder();<br>           <span class="hljs-keyword">int</span> cur_int = stack_int.removeLast();<span class="hljs-comment">//括号外的数字</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_int; i++) &#123;<span class="hljs-comment">//乘上几倍</span><br>               tmp.append(res);<br>           &#125;<br>           res = <span class="hljs-keyword">new</span> StringBuilder(stack_str.removeLast() + tmp);<span class="hljs-comment">//和括号外的字母合并</span><br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c&lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>           multi = multi * <span class="hljs-number">10</span> + Integer.parseInt(c + <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//字符转换为数字</span><br>       &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//为字母就追加</span><br>           res.append(c);<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/">剑指 Offer 09. 用两个栈实现队列 - 力扣（Leetcode）</a></p><p>核心的思想就是使用A栈来增加元素，如果需要出队列了，就把元素倒过来又全部添加到B栈中，这样需要先出的元素就又到了栈顶，可以出队了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;<br>    LinkedList&lt;Integer&gt; A,B;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        A = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        A.addLast(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//需要注意这里的判断的先后顺序</span><br>        <span class="hljs-keyword">if</span>(!B.isEmpty()) <span class="hljs-keyword">return</span> B.removeLast();<br>        <span class="hljs-comment">//如果前面没有return，执行到后面就已经包含了一个隐含的条件B为空</span><br>        <span class="hljs-keyword">if</span>(A.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!A.isEmpty())&#123;<br>            B.addLast(A.removeLast());<br>        &#125;<br>        <span class="hljs-keyword">return</span> B.removeLast();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>Stack版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;<br>    Stack&lt;Integer&gt; A,B;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        A = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        A.push(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!B.isEmpty()) <span class="hljs-keyword">return</span> B.pop();<br>        <span class="hljs-comment">//如果前面没有return，执行到后面就已经包含了一个隐含的条件B为空</span><br>        <span class="hljs-keyword">if</span>(A.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!A.isEmpty())&#123;<br>            B.push(A.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> B.pop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="最长有效括号">最长有效括号</h3><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">32. 最长有效括号 - 力扣（Leetcode）</a>题目的要求大概就是寻找子串里符合（）且连续的最长的括号，思路好难，艹，完全想不到</p><p>栈做法</p><p>思路：首先我们需要保证栈底的元素是已经遍历的元素中<strong>最后一个未匹配的右括号</strong>，然后将左括号都入栈，每遇到右括号就出栈，然后减去当前栈顶的元素的下标就是这个右括号里面匹配了几个，具体的做法就是</p><ul><li>对于遇到的每个<code>‘(’</code>，我们将它的下标放入栈中</li><li>对于遇到的每个<code>')'</code> ，我们<strong>先弹出栈顶元素</strong>表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li></ul></li></ul><p>来看图示更好理解</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020173904777.png" alt="1"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020173944456.png" alt="2"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174011988.png" alt="3"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174031788.png" alt="4"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174109050.png" alt="5"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174138837.png" alt="6"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174200507.png" alt="7"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174218649.png" alt="8"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174250319.png" alt="9"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174323104.png" alt="10"><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221020174341684.png" alt="11"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//看到括号匹配啥的，首先想到的就是用栈</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    stack.push(-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<span class="hljs-comment">//字符串的长度函数是有括号的</span><br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            stack.push(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            stack.pop();<br>            <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>                stack.push(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum = Math.max(sum,i - stack.peek());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>动态规划做法</strong></p><p>思路和算法（说实话，没太看懂，待我再细细琢磨）</p><p>我们定义 dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。我们将 dp 数组全部初始化为 0 。显然有效的子串一定以 ‘)’结尾，因此我们可以知道以 ‘(’ 结尾的子串对应的 dp 值必定为 0，我们只需要求解 ‘)’ 在 dp 数组中对应位置的值。</p><p>我们从前往后遍历字符串求解 dp 值，我们每两个字符检查一次：</p><ol><li><p><code>s[i]=‘)’</code> 且<code> s[i−1]=‘(’</code>，也就是字符串形如<code> “……()”</code>，我们可以推出：</p><p><code>dp[i]=dp[i−2]+2</code></p></li><li><p><code>s[i]=‘)’ </code>且<code>s[i−1]=‘)’</code>，也就是字符串形如 <code>“……))”</code>，我们可以推出： 如果 <code>s[i−dp[i−1]−1]=‘(’</code>，那么</p><p><code>dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2</code></p><p>我们考虑如果倒数第二个‘)’ 是一个有效子字符串的一部分（记作sub），对于最后一个‘)’ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 ‘(’ ，且它的位置在倒数第二个‘)’ 所在的有效子字符串的前面（也就是 sub的前面）。因此，如果子字符串 sub的前面恰好是‘(’ ，那么我们就用 2 加上 sub的长度dp[i−1]去更新 dp[i]。同时，我们也会把有效子串 sub之前的有效子串的长度也加上，也就是再加上<code> dp[i−dp[i−1]−2]</code>。最后的答案即为 dp 数组中的最大值。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> maxans = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>           <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>               <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                   dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                   dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>               &#125;<br>               maxans = Math.max(maxans, dp[i]);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> maxans;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="优先队列">优先队列</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215. 数组中的第K个最大元素 - 力扣（Leetcode）</a>一道优先队列的经典题型，其实这道题使用暴力直接快排就可以直接AC，但是题目规定的是使用O(N),这里的快排很明显是O(logN),所以这里这不符合题意.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// int index = nums.length - 1;</span><br>        <span class="hljs-comment">// while(k &gt; 0)&#123;</span><br>        <span class="hljs-comment">//     k--;</span><br>        <span class="hljs-comment">//     index--;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> nums[nums.length-k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面主要来看一下优先队列的做法：</p><p>PriorityQueue是一个具有优先级的无界队列，其内部基于一个优先级堆实现的。优先级队列内部的元素之间的优先级是按照元素实现的Comparable的自然顺序排序的，或者是使用构造方法中传入的Comparator接口的实现类完成的。优先队列中不允许存放null元素，如果没有传入Comparator接口的实现类，那么内部的元素必须要实现Comparable接口，否则将抛出ClassCastException，因为元素在比较时转化为Comparable进行比较。</p><p>优先队列的思路是很朴素的。由于找第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 K 个元素的最小堆(优先队列默认就是最小堆)：</p><ul><li>如果当前堆不满，直接添加；</li><li>堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新遍历到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-comment">// 使用一个含有 k 个元素的最小堆，PriorityQueue 底层是动态数组，为了防止数组扩容产生消耗，可以先指定数组的长度</span><br>        PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k, Comparator.comparingInt(a -&gt; a));<br>        <span class="hljs-comment">// Java 里没有 heapify ，因此我们逐个将前 k 个元素添加到 minHeap 里</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            minHeap.offer(nums[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">// 看一眼，不拿出，因为有可能没有必要替换</span><br>            Integer topElement = minHeap.peek();<br>            <span class="hljs-comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; topElement) &#123;<br>                <span class="hljs-comment">// Java 没有 replace()，所以得先 poll() 出来，然后再放回去</span><br>                minHeap.poll();<br>                minHeap.offer(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minHeap.peek();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>另一种更简单的写法，同样是优先队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            heap.add(num);<br>            <span class="hljs-keyword">if</span> (heap.size() &gt; k) &#123;<br>                heap.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> heap.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重要的是理解优先队列这个结构。后面做题估计还会用到。</p><p>果然又遇到了，<a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347. 前 K 个高频元素 - 力扣（Leetcode）</a>，这个题一看就是需要使用优先队列来做</p><p>题意：找出数组中出现频率最高的前K个元素</p><p>思路：先使用老套路哈希遍历一遍将频率算出来，然后使用优先队列，以频率作为排序依据，把key存进去，使用长度为K的最小堆，一直维持这个最小堆，直到遍历结束，即是最终的答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//哈希加堆</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">int</span> freq = map.get(num) == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : map.get(num)+<span class="hljs-number">1</span>;<br>            map.put(num,freq);<br>        &#125;<br>        <span class="hljs-comment">//后面原来可以直接写lambda表达式</span><br>        <span class="hljs-comment">//使用优先队列构造出关于Value的最小堆，并把key存进去</span><br>        <span class="hljs-comment">//构建大顶堆</span><br>        <span class="hljs-comment">//相当于是降序</span><br>        <span class="hljs-comment">//k在这里是指初始容量的意思  这样就保存了前k个高频元素</span><br>        PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k,(a,b) -&gt;&#123;<span class="hljs-keyword">return</span> map.get(b) - map.get(a);&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> key:map.keySet())&#123;<br>            heap.add(key);<br>        &#125;<br>        <span class="hljs-comment">//获取最终的答案</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            res[i] = heap.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口">滑动窗口</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230222184406273.png" alt="image-20230222184406273"></p><p>滑动窗口的类题目的通用模板，主体思路和模板来自<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/">滑动窗口通用题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 滑动窗口算法框架 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">//移动right，更新窗口内的数据</span><br>            ...<br>            <br>            <span class="hljs-comment">// 判断左侧窗⼝是否要收缩</span><br>            <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>                <span class="hljs-comment">//保存答案,可能是这个位置</span><br>                ...<br>                    <br>                <span class="hljs-keyword">char</span> d = s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">//移动left，更新窗口内的数据</span><br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ...<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>其中两处 <code>...</code> 表示的更新窗口数据的地方，到时候你直接往里面填就行了</strong>。</p><p>主要的思路就是：</p><ul><li><p>滑动窗口的右边指针一直增加，直到窗口中的字符串符合要求</p></li><li><p>此时，我们停止增加right指针扩大窗口，转而不断增加left指针缩小窗口，直到窗口中的字符串不再符合要求。同时每次增加left，我们都需要更新一轮结果</p></li><li><p>重复上述步骤，直到right到达字符串s的尽头</p></li></ul><p>来看看实际的例子</p><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（Leetcode）</a></p><p>题意：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来判断窗口里面的合法字符</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-comment">//不断扩大右边的指针</span><br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br>            right++;<br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//这里需要使用equals方法，使用==的话，超过128会报错</span><br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 判断左侧窗⼝是否要收缩</span><br>            <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>                <span class="hljs-comment">// 不断缩小更新最小的覆盖子串</span><br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    start  = left;<br>                    len = right - left;<br>                &#125;<br>                <span class="hljs-keyword">char</span> d = s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">//移动left</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start,start + len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/">438. 找到字符串中所有字母异位词 - 力扣（Leetcode）</a></p><p>题意：给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。说白了就是找到母字符串里，所有子字符串的所有排列，并返回其实索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        Map&lt;Character,Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character,Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Character c : p.toCharArray())&#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//定义左右指针</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断窗口内部的合法字符有多少个</span><br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//存储结果</span><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-comment">//向右移动窗口</span><br>            Character c = s.charAt(right);<br>            right++;<br>            <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//这里需要用equals方法，不然超过128的话会报错</span><br>                <span class="hljs-keyword">if</span>(window.get(c).equals(need.get(c)))&#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//判断是否左指针移动收缩窗口</span><br>            <span class="hljs-keyword">while</span>(right - left &gt;= p.length())&#123;<br>                <span class="hljs-comment">//窗口内的合法字符等于需要的字符,保存起始索引</span><br>                <span class="hljs-keyword">if</span>(valid == need.size())&#123;<br>                    res.add(left);<br>                &#125;<br>                Character d = s.charAt(left);<br>                left++;<br>                <span class="hljs-keyword">if</span>(need.containsKey(d))&#123;<br>                    <span class="hljs-keyword">if</span>(window.get(d).equals(need.get(d)))&#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;     <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/?orderBy=most_votes">3. 无重复字符的最长子串 - 力扣（Leetcode）</a></p><p>思路：这道题使用新的思路解决，滑动窗口</p><p>思路：</p><ul><li>定义一个map数据结构，其中key为字符，value为字符位置加1，表示从字符位置后一个才开始不重复</li><li>每次都移动一次end，如果遇到和前面重复的字符就更新start的位置，也就是key的下一个位置，不断重复，直到最后</li></ul><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/7399/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/">3. 无重复字符的最长子串 - 力扣（Leetcode）画解算法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length(), ans = <span class="hljs-number">0</span>;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//每次都移动end，如果遇到重复的就跳转到key的后一个位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>,start = <span class="hljs-number">0</span>;end &lt; n;end++)&#123;<br>            <span class="hljs-keyword">char</span> alpha = s.charAt(end);<br>            <span class="hljs-keyword">if</span>(map.containsKey(alpha))&#123;<br>                start = Math.max(map.get(alpha), start);<br>            &#125;<br>            ans = Math.max(end - start + <span class="hljs-number">1</span>, ans);<br>            <span class="hljs-comment">//更新当前end的不重复的位置</span><br>            map.put(s.charAt(end), end + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用模板写一次，这里还是有一定的变化, 简化了need字符串，只要有重复的就收缩</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">//移动right，更新窗口内的数据</span><br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <br>            <span class="hljs-comment">// 判断左侧窗⼝是否要收缩 有重复了(&gt;1)就缩小左边</span><br>            <span class="hljs-keyword">while</span> (window.get(c) &gt; <span class="hljs-number">1</span>) &#123;              <br>                <span class="hljs-keyword">char</span> d = s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">//移动left，更新窗口内的数据</span><br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">//因为需要不重复，所以需要左边收缩完成后，窗口里面没有重复的数据后再更新数据</span><br>            res = Math.max(res,right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lengthOfLongestSubstring</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character,Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-comment">//扩大右边窗口</span><br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br>            right++;<br>            window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">//有重复了 缩小左边窗口</span><br>            <span class="hljs-keyword">while</span>(window.get(c) &gt; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">char</span> d = s.charAt(left);<br>                left++;<br>                window.put(d,window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>            res = Math.max(res,right -left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.next();<br>        System.out.println(s + <span class="hljs-string">&quot; : &quot;</span> + lengthOfLongestSubstring(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p>题意：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s = 7, nums = [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组</li></ul><p>思路：窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p><img src="https://file.kamacoder.com/pics/20210312160441942.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;right &lt; nums.length;right++)&#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;<br>                <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;<br>                res = Math.min(res,len);<br>                sum -= nums[left++];<span class="hljs-comment">//注意这里的位置，要先把长度计算完之后在移动</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a>一道hard题</p><p>题意：给一个滑动窗口，范围为k，找到这个窗口滑动时里面的最大值</p><p>思路：首先，暴力估计过不了，所以采用维持一个单调队列的方法，队列头的就是当前窗口的最大值，在维持的时候，需要注意</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p><img src="https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="解题思路"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-comment">//里面存储的是序号</span><br>        <span class="hljs-keyword">int</span>[] max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-comment">//窗口移动，窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="hljs-number">1</span>)&#123;<br>                deque.removeFirst();<br>            &#125;<br><br>            <span class="hljs-comment">//维持单调</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i])&#123;<br>                deque.removeLast();<br>            &#125;<br><br>            deque.addLast(i);<br><br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)&#123;<br>                max[idx++] = nums[deque.peekFirst()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树">树</h2><h3 id="遍历">遍历</h3><p>首先把三个遍历的方式都做一遍</p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a>一道简单的中序遍历的题，唯一需要值得注意的就是返回的list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        preOrder(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; list)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root.val);<br>        preOrder(root.left,list);<br>        preOrder(root.right,list);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        infixOrder(root,list);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; list)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        infixOrder(root.left,list);<br>        list.add(root.val);<span class="hljs-comment">//list集合用的是add，别记错了</span><br>        infixOrder(root.right,list);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        postOrder(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; list)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postOrder(root.left,list);<br>        postOrder(root.right,list);<br>        list.add(root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二叉树的层序遍历详见<a href="##BFS">BFS</a></p><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（Leetcode）</a></p><p>题意：判断树是不是轴对称的</p><p>思路：使用递归遍历是不是对称的</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230225191219383.png" alt="image-20230225191219383"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><span class="hljs-comment">//调用递归函数，比较左节点，右节点</span><br><span class="hljs-keyword">return</span> dfs(root.left,root.right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> </span>&#123;<br><span class="hljs-comment">//递归的终止条件是两个节点都为空</span><br><span class="hljs-comment">//或者两个节点中有一个为空</span><br><span class="hljs-comment">//或者两个节点的值不相等</span><br><span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span> &amp;&amp; right==<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span> || right==<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(left.val!=right.val) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>        <span class="hljs-comment">//只凭当前左右结点不能判断是true</span><br>        <span class="hljs-comment">// if(left.val == right.val)&#123;</span><br>        <span class="hljs-comment">//     return true;</span><br>        <span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="hljs-comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="hljs-comment">//比较内侧</span><br>        <span class="hljs-keyword">boolean</span> isinside = dfs(left.right,right.left);<br>        <span class="hljs-comment">//比较外侧</span><br>        <span class="hljs-keyword">boolean</span> isoutside = dfs(left.left,right.right);<br>        <span class="hljs-keyword">return</span> isinside &amp;&amp; isoutside;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">543. 二叉树的直径 - 力扣（Leetcode）</a></p><p>简单的来说就是求二叉树深度的变形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        depth(root);<br>        <span class="hljs-comment">//根据题意，直径需要减一</span><br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 访问到空节点了，返回0</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> L = depth(node.left); <span class="hljs-comment">// 左儿子为根的子树的深度</span><br>        <span class="hljs-keyword">int</span> R = depth(node.right); <span class="hljs-comment">// 右儿子为根的子树的深度</span><br>        ans = Math.max(ans, L+R+<span class="hljs-number">1</span>); <span class="hljs-comment">// 计算d_node即L+R+1 并更新ans</span><br>        <span class="hljs-keyword">return</span> Math.max(L, R) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回该节点为根的子树的深度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（Leetcode）</a></p><p>题意：将两个二叉树的节点合并起来，就是对应的节点的数据相加</p><p>思路：还是采用的通过同时遍历两棵树，如果有一方为空就返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span> || t2==<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> t1==<span class="hljs-keyword">null</span>? t2 : t1;<br>&#125;<br><span class="hljs-keyword">return</span> dfs(t1,t2);<br>&#125;<br><br><span class="hljs-function">TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode r1, TreeNode r2)</span> </span>&#123;<br><span class="hljs-comment">// 如果 r1和r2中，只要有一个是null，函数就直接返回</span><br><span class="hljs-keyword">if</span>(r1==<span class="hljs-keyword">null</span> || r2==<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> r1==<span class="hljs-keyword">null</span>? r2 : r1;<br>&#125;<br><span class="hljs-comment">//让r1的值 等于  r1和r2的值累加，再递归的计算两颗树的左节点、右节点</span><br>r1.val += r2.val;<br>r1.left = dfs(r1.left,r2.left);<br>r1.right = dfs(r1.right,r2.right);<br><span class="hljs-keyword">return</span> r1;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构 - 力扣（LeetCode）</a></p><p>题意：一开始给你两棵树，A和B，请你判断B是不是A的一颗子树</p><p>思路：分别遍历A的每一个节点(使用一个函数)，并且同时以当前遍历的这个节点为根结点判断是不是和B这棵树一样，<br>一样就返回true，否则返回false</p><p>实现的细节：</p><ul><li>recur函数：使用recur函数对以节点A为根结点的树是否包含B进行判断，节点内的值不一致，显而易见的是false，若B为空，而A还有，说明已经判断完毕，返回true，若A为空而B还没有为空，则说明B还比A长，返回false</li><li>遍历每一个A节点的函数，先判断以根结点为A的树是否包含，如果没有包含，则继续递归的调用左子树和右子树，类似于树的前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span></span>&#123;<br>        <span class="hljs-comment">//递归 不断</span><br>        <span class="hljs-keyword">if</span>(A != <span class="hljs-keyword">null</span> &amp;&amp; B != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(recur(A,B))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p><p>题意：在二叉树中寻找任意一条路径，使得这条路径上的节点的值之和最大，路径可以是任意节点序列，只要相邻节点之间有边，且每个节点在路径中最多出现一次。</p><p>思路：</p><p>使用递归的方法来解决这个问题。对于每个节点，我们考虑两种情况：</p><ol><li>该节点作为路径的一部分，向上延伸。此时，只能选择左子树或右子树中的一个分支。</li><li>该节点作为路径的最高点，此时可以同时包含左子树和右子树的路径。</li></ol><p>具体步骤如下：</p><ol><li>递归遍历每个节点，计算以当前节点为根的单边最大路径和（即只能选择左或右子树的一个分支）。</li><li>在递归过程中，计算当前节点作为中间节点的路径和（即左子树路径 + 当前节点值 + 右子树路径），并更新全局最大值。</li><li>递归函数返回当前节点值加上左子树或右子树的最大路径和，以便继续向上延伸路径。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSum = Integer.MIN_VALUE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归计算左右子节点的最大贡献值，</span><br>        <span class="hljs-comment">// 因为单个节点也可以作为一条路径，因此若为负则不计入，相当于舍弃负的这边</span><br>        <span class="hljs-keyword">int</span> left = Math.max(helper(node.left), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> right = Math.max(helper(node.right), <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 当前节点作为路径中间节点的总路径和</span><br>        <span class="hljs-keyword">int</span> currentPathSum = node.val + left + right;<br>        maxSum = Math.max(maxSum, currentPathSum);<br>        <br>        <span class="hljs-comment">// 返回当前节点作为左子树或者右子树的最大贡献值（单边路径）</span><br>        <span class="hljs-keyword">return</span> node.val + Math.max(left, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><p>题意：题意如题目名，就是求二叉树的最大深度，这里提供两种思路</p><p>BFS方法和上面的题，结构没有什么太大的区别，主要就是在每次的层循环之前来个计数器就是它的深度了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            depth++;<br>            <span class="hljs-comment">//每次都先处理一层，因此这里循环几次就是有多深</span><br>            <span class="hljs-comment">//注意这里的i &lt; size 不可以直接写i &lt; queue.size() 因为队列的长度在变化</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS的方法，这种方法更加的简单，更推荐这种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = maxDepth(root.left);<br>        <span class="hljs-keyword">int</span> right = maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(left,right) + <span class="hljs-number">1</span>;<span class="hljs-comment">//加上1就是加上自己本身</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a>二叉树的最小深度</p><p>和最大深度类似，但是需要注意的是</p><p><img src="https://file1.kamacoder.com/i/algo/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.png" alt="111.二叉树的最小深度"></p><p>如果这么求的话，没有左孩子的分支会算为最短深度。</p><p>所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</p><p>反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p><p>所以，根据上一题的代码进行改进，可以得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = minDepth(root.left);<br>        <span class="hljs-keyword">int</span> right = minDepth(root.right);<br>        <br>        <span class="hljs-comment">//最小深度是 1 + 右子树的深度</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//最小深度是 1 + 左子树的深度</span><br>        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(left,right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><p>简单的来说，就是求一棵树的结点数量，思路就是在遍历的时候，把左右子树的结点数量和当前结点加起来就行，和上面的求深度是很类似的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//左子树结点数量</span><br>        <span class="hljs-keyword">int</span> left  = countNodes(root.left);<br>        <span class="hljs-comment">//右子树结点数量</span><br>        <span class="hljs-keyword">int</span> right = countNodes(root.right);<br>        <span class="hljs-keyword">return</span> left + right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">110. 平衡二叉树 - 力扣（LeetCode）</a></p><p>求一棵树，是不是平衡二叉树，所谓的平衡二叉树，就是<strong>所有结点</strong>的左子树和右子树的高度都相差不超过1，因此，这道题的思路就是，写一个递归求高度的函数，然后一个递归遍历的函数，判断每一个结点是不是都相差不超过1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//递归遍历</span><br>        <span class="hljs-keyword">boolean</span> left = isBalanced(root.left);<br>        <span class="hljs-keyword">boolean</span> right = isBalanced(root.right);<br>        <br>        <span class="hljs-comment">//递归求当前结点高度</span><br>        <span class="hljs-keyword">int</span> leftDepth = depth(root.left);<br>        <span class="hljs-keyword">int</span> rightDepth = depth(root.right);<br>        <span class="hljs-comment">//判断当前结点是否平衡二叉树，而且左子树和右子树是否平衡二叉树</span><br>        <span class="hljs-keyword">return</span> Math.abs(leftDepth - rightDepth) &lt;= <span class="hljs-number">1</span> &amp;&amp; left &amp;&amp; right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = depth(node.left);<br>        <span class="hljs-keyword">int</span> right = depth(node.right);<br>        <span class="hljs-keyword">return</span> Math.max(left,right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404. 左叶子之和 - 力扣（LeetCode）</a>题意：将所有左叶子结点相加，需要注意的是，这里的是<strong>左叶子</strong>结点，也就是这个结点左孩子和有孩子都是空，且这个结点在父节点的左边，这里还是采用递归的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本情况处理：如果根节点为空，直接返回0。</span><br><span class="hljs-comment">//左子节点检查：检查当前节点的左子节点是否存在。如果存在且是叶子节点（无左右子节点），则将其值加入总和；否则，递归处理左子树。</span><br><span class="hljs-comment">//右子节点处理：递归处理右子树，确保右子树中的左叶子节点也被计入总和。</span><br><span class="hljs-comment">//返回结果：累计所有左叶子节点的值并返回。</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//防止空指针异常</span><br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//判断是否是叶子</span><br>            <span class="hljs-keyword">if</span>(root.left.left == <span class="hljs-keyword">null</span> &amp;&amp; root.left.right == <span class="hljs-keyword">null</span>)&#123;<br>                sum += root.left.val;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum += sumOfLeftLeaves(root.left);<br>            &#125;<br>        &#125;<br>        sum += sumOfLeftLeaves(root.right);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><p>题意：找到树的最大深度的左边的结点</p><p>解题步骤</p><ol><li><strong>初始化变量</strong>：定义全局变量来记录最大深度和最左节点值。</li><li><strong>递归遍历</strong>：从根节点开始递归，传递当前深度。</li><li><strong>更新最左节点</strong>：当遇到更深的节点时，更新最大深度和当前节点值。由于先遍历左子树，同一深度下最先访问的节点即为最左节点。</li><li><strong>返回结果</strong>：递归结束后，返回记录的最左节点值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxDepth = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> leftmostValue = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> leftmostValue;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果当前深度大于最大深度，更新最大深度和最左值</span><br>        <span class="hljs-keyword">if</span> (depth &gt; maxDepth) &#123;<br>            maxDepth = depth;<br>            leftmostValue = node.val;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 先递归左子树，再递归右子树</span><br>        <span class="hljs-comment">// 这样可以保证同一深度下先访问左边的节点</span><br>        dfs(node.left, depth + <span class="hljs-number">1</span>);<br>        dfs(node.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p><p>题意：这里只是一个二值的判断，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code></p><p>思路：使用递归方法遍历二叉树的每个节点，在遍历过程中不断从目标和中减去当前节点的值。当到达叶子节点时，检查剩余和是否等于0（剩下的值是否等于当前结点的值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">// 空节点情况</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 叶子节点：检查路径和是否等于目标值</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> targetSum == root.val;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 递归检查左右子树</span><br>        <span class="hljs-keyword">int</span> remainingSum = targetSum - root.val;<br>        <span class="hljs-keyword">return</span> hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></p><p>题意：按照二叉树的结构，将两棵树合并起来</p><p>思路：还是递归，如果root1为空，则返回root2，如果root2为空，则返回root1；中间则选一棵树作为主树，把他们相加即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        <span class="hljs-comment">//修改t1的数值和结构</span><br>        root1.val += root2.val;<br>        root1.left = mergeTrees(root1.left,root2.left);<br>        root1.right = mergeTrees(root1.right,root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><p>题意：返回指定val的结点和子树</p><p>思路：就是递归，然后判断是否相等就完事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val == val)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode left = searchBST(root.left,val);<br>        TreeNode right = searchBST(root.right,val);<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//代码更简洁的版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root.val == val)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode left = searchBST(root.left,val);<br>        TreeNode right = searchBST(root.right,val);<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（Leetcode）</a></p><p>题意：就是验证这棵树是不是左子树的数据都小于当前节点，右子树的数据都大于当前的节点</p><p>思路：这里面有一个很重要的点，就是二叉搜索树的数据如果用<strong>中序遍历</strong>的话，遍历出来的数据是<strong>递增</strong>的，就比如下面的这棵树，因此我们可以使用中序遍历存储上一个节点的值，看是否是大于上一个节点，否则就不是二叉搜索树</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230226143744944.png" alt="image-20230226143744944"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//先中序遍历，然后判断是否是递增的</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br>    <span class="hljs-comment">// 二叉搜索树的中序遍历都是递增的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        infixOrder(root);<br>        <span class="hljs-keyword">return</span> isIncrease(list);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        infixOrder(node.left);<br>        list.add(node.val);<br>        infixOrder(node.right);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIncrease</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> len = list.size();<br>        <span class="hljs-keyword">int</span> preVal = list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(preVal &gt;= list.get(i))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            preVal = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <br>&#125;<br><br><br><span class="hljs-comment">//other version</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Integer pre;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       <span class="hljs-comment">//访问到中点了，说明该子树是满足条件的</span><br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-comment">//访问左子树</span><br>       <span class="hljs-keyword">boolean</span> left = isValidBST(root.left);<br>       <br>       <span class="hljs-comment">//访问当前节点，若为空说明还没有初始化，还需要初始化</span><br>       <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= pre)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-comment">//存储上一个节点的值</span><br>       pre = root.val;<br>       <span class="hljs-comment">//访问右子树</span><br>       <span class="hljs-keyword">boolean</span> right = isValidBST(root.right);<br><br>       <span class="hljs-keyword">return</span>  left &amp;&amp; right;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//other version</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 二叉搜索树的中序遍历都是递增的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// integer的默认未初始化是null, int是0</span><br>        Integer[] preVal = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> infixOrder(root, preVal);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">(TreeNode node, Integer[] preVal)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历左子树</span><br>        <span class="hljs-keyword">boolean</span> left = infixOrder(node.left, preVal);<br>        <span class="hljs-keyword">if</span> (preVal[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; preVal[<span class="hljs-number">0</span>] &gt;= node.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新前一个节点的值为当前节点的值</span><br>        preVal[<span class="hljs-number">0</span>] = node.val;<br>        <span class="hljs-comment">// 遍历右子树</span><br>        <span class="hljs-keyword">boolean</span> right = infixOrder(node.right, preVal);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><p>题意：找到二叉搜索树中任意两个结点的的绝对值最小值</p><p>思路：注意这里也是二叉搜索树，因此，使用中序遍历的话，整个数列是递增的，因此只需要计算遍历后相邻的两个结点的差值最小值就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        infixOrder(root);<br>        <span class="hljs-keyword">return</span> getMin(list);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        infixOrder(node.left);<br>        list.add(node.val);<br>        infixOrder(node.right);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//计算数列相邻结点的最小差值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> len = list.size();<br>        <span class="hljs-keyword">int</span> preVal = list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(Math.abs(list.get(i) - preVal) &lt; min)&#123;<br>                min = Math.abs(list.get(i) - preVal);<br>            &#125;<br>            preVal = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a>找出这个二叉树中，频率最高的元素，并且，如果有多个众数，则一起返回，不要求顺序</p><p>思路：把整个树一起遍历一遍，然后用map统计频率，把频率排序，最后取高频元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findMode(TreeNode root) &#123;<br>        <span class="hljs-comment">// 使用哈希表统计频率</span><br>        Map&lt;Integer, Integer&gt; frequencyMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        traverse(root, frequencyMap);<br>        <br>        <span class="hljs-comment">// 找到最大频率</span><br>        <span class="hljs-keyword">int</span> maxFrequency = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> freq : frequencyMap.values()) &#123;<br>            maxFrequency = Math.max(maxFrequency, freq);<br>        &#125;<br>        <br>        <span class="hljs-comment">//重点是下面的这一段，以前没用过，记住</span><br>        <span class="hljs-comment">// 收集所有频率等于最大频率的值</span><br>        List&lt;Integer&gt; modes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : frequencyMap.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() == maxFrequency) &#123;<br>                modes.add(entry.getKey());<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 转换为数组返回</span><br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[modes.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; modes.size(); i++) &#123;<br>            result[i] = modes.get(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历二叉树并统计频率</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode node, Map&lt;Integer, Integer&gt; frequencyMap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 前序遍历：根-左-右</span><br>        frequencyMap.put(node.val, frequencyMap.getOrDefault(node.val, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        traverse(node.left, frequencyMap);<br>        traverse(node.right, frequencyMap);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a>二叉树的最近公共祖先</p><p>题意：如题所示，给你两个值，p和q，找到p和q的最近的公共祖先</p><p>题解：<a href="https://www.programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">0236.二叉树的最近公共祖先</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-comment">//包含了本身就是最近公共祖先的情况</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left ==  <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="建立树">建立树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 - 力扣（Leetcode）</a></p><p>题意：很明显，是根据前序和中序的遍历建立一个树</p><p>思路：我们知道，根据前序和中序遍历可以确定唯一一棵树</p><p>下面是使用的递归的方法创建这棵树，值得注意的是，题目说的是这棵树是没有重复的元素的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//感觉一道挺常规的题</span><br> <span class="hljs-comment">//递归</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myBuildTreeHelper(preorder,<span class="hljs-number">0</span>,preorder.length,inorder,<span class="hljs-number">0</span>,inorder.length);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">myBuildTreeHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder,<span class="hljs-keyword">int</span> p_start,<span class="hljs-keyword">int</span> p_end,<span class="hljs-keyword">int</span>[] inorder,<span class="hljs-keyword">int</span> i_start,<span class="hljs-keyword">int</span> i_end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(p_start == p_end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> val = preorder[p_start];<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(val);<br>        <span class="hljs-comment">//头节点在中序遍历中的位置</span><br>        <span class="hljs-keyword">int</span> i_index = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//注意题目说的是没有重复元素的哦</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; inorder.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == val)&#123;<br>                i_index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//左子树有几个元素</span><br>        <span class="hljs-keyword">int</span> leftnum = i_index - i_start;<br>        <span class="hljs-comment">//开始递归</span><br>        <span class="hljs-comment">//前序遍历中，左子树就是刚刚的start+1到加上刚刚的左子树元素+1，由于上面是index-start所以需要中序遍历的中间节点放在左边</span><br>        root.left  = myBuildTreeHelper(preorder,p_start+<span class="hljs-number">1</span>,p_start+leftnum+<span class="hljs-number">1</span>,inorder,i_start,i_index);<br>        root.right = myBuildTreeHelper(preorder,p_start+leftnum+<span class="hljs-number">1</span>,p_end,inorder,i_index+<span class="hljs-number">1</span>,i_end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于还需要每次遍历去找中序遍历的中间节点，所以这里可以采用hash来优化一下下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>        map.put(inorder[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buildTreeHelper(preorder, <span class="hljs-number">0</span>, preorder.length, inorder, <span class="hljs-number">0</span>, inorder.length, map);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">buildTreeHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> p_start, <span class="hljs-keyword">int</span> p_end, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> i_start, <span class="hljs-keyword">int</span> i_end,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p_start == p_end) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> root_val = preorder[p_start];<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(root_val);<br>    <span class="hljs-keyword">int</span> i_root_index = map.get(root_val);<br>    <span class="hljs-keyword">int</span> leftNum = i_root_index - i_start;<br>    root.left = buildTreeHelper(preorder, p_start + <span class="hljs-number">1</span>, p_start + leftNum + <span class="hljs-number">1</span>, inorder, i_start, i_root_index, map);<br>    root.right = buildTreeHelper(preorder, p_start + leftNum + <span class="hljs-number">1</span>, p_end, inorder, i_root_index + <span class="hljs-number">1</span>, i_end, map);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/description/">剑指 Offer 07. 重建二叉树 - 力扣（Leetcode）</a></p><p>使用递归</p><p>最核心的思想就是使用前序来确定根节点，中序来确定左子树和右子树的根节点，所以说这里的根节点是在前序遍历里的，左子节点和右子节点是在中序遍历里面的</p><table><thead><tr><th></th><th>根节点索引</th><th>中序遍历左边界</th><th>中序遍历右边界</th></tr></thead><tbody><tr><td>左子树</td><td>root + 1</td><td>left</td><td>i - 1</td></tr><tr><td>右子树</td><td>i - left + root + 1</td><td>i + 1</td><td>right</td></tr></tbody></table><p>这里的 i 就是在中序中上一个根节点的位置，而在表中右子树的(注意根节点的位置是在前序中遍历)<code>i - left + root + 1</code>指的就是左子树的长度(i-left) 加上根节点的位置在加上1</p><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solutions/100091/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/">剑指 Offer 07. 重建二叉树 - 更加详细的题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] preorder;<br>    HashMap&lt;Integer, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.preorder = preorder;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            dic.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> recur(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[root]);<br>        <span class="hljs-keyword">int</span> i = dic.get(preorder[root]);<br>        node.left  = recur(root + <span class="hljs-number">1</span>, left, i - <span class="hljs-number">1</span>);<br>        node.right = recur(i - left + root + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a></p><p>题意：</p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong>最大二叉树</strong>。</p><p>思路：每次寻找数组中最大的值，作为树的根节点，然后以这个最大值的下标，左右分成两个子数组，再次进行递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//应该时大于的时候才返回null</span><br>        <span class="hljs-comment">//如果时left == right 说明子数组中还有一个元素，应该建立结点，而不是返回null</span><br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxIndex = findMaxIndex(nums, left, right);<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[maxIndex]);<br>        root.left = buildTree(nums, left, maxIndex - <span class="hljs-number">1</span>);<br>        root.right = buildTree(nums, maxIndex + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxIndex = left;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[maxIndex]) &#123;<br>                maxIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="依靠推导公式解决">依靠推导公式解决</h3><p>这种题，面试出题总不可能现场推导吧，时间太慢，记住就行</p><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树 - 力扣（Leetcode）</a></p><p>题意：给你一个数字，问你形状不同的二叉搜索树形状有多少个</p><p>使用动态规划，这里需要推导一下递推公式</p><ul><li>假设 <code>n</code> 个节点存在二叉排序树的个数是 <code>G (n)</code>，令 <code>f(i)</code> 为以 <code>i</code> 为根的二叉搜索树的个数，则</li></ul><p>​       <strong><em>G</em>(<em>n</em>)=<em>f</em>(1)+<em>f</em>(2)+<em>f</em>(3)+<em>f</em>(4)+…+<em>f</em>(<em>n</em>)</strong></p><ul><li>当 i 为根节点时，其左子树节点个数为 i-1 个，右子树节点为 n-i，则</li></ul><p>​      **<em>f(i)</em>=<em>G(i−1)<em>∗</em>G(n−i)</em> **</p><ul><li>综合两个公式可以得到 卡特兰数 公式<br><em><strong>G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+…+G(n−1)∗G(0)</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//卡特兰数公式</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; n + <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; i + <span class="hljs-number">1</span>;j++)&#123;<br>                dp[i] += dp[j-<span class="hljs-number">1</span>] * dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者来个取巧的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>         <span class="hljs-keyword">switch</span>(n)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">132</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">429</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1430</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">4862</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">16796</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">58786</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">208012</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">742900</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">2674440</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">9694845</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">35357670</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">129644790</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">477638700</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1767263190</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀树">前缀树</h3><p>题意：实现一个前缀树，效果需要</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/717239/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">208. 实现 Trie (前缀树) 题解</a></p><p>相当于一个26叉树</p><p><strong>插入字符串</strong></p><p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li><li>子节点不存在。创建一个新的子节点，记录在 <code>children</code> 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li></ul><p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p><p><strong>查找前缀</strong></p><p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li><li>子节点不存在。说明字典树中不包含该前缀，返回空指针。<br>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = word.charAt(i);<br>            <span class="hljs-keyword">int</span> index = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie node = searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Trie <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = prefix.charAt(i);<br>            <span class="hljs-keyword">int</span> index = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie obj = new Trie();</span><br><span class="hljs-comment"> * obj.insert(word);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(word);</span><br><span class="hljs-comment"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="数组">数组</h2><h3 id="自定义排序">自定义排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//降序</span><br>Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>    <span class="hljs-comment">//重写compare方法，最好加注解，不加也没事</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a, Integer b)</span> </span>&#123;<br>        <span class="hljs-comment">//返回值&gt;0交换</span><br>        <span class="hljs-keyword">return</span> b-a;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//降序</span><br>Arrays.sort(arr, (a, b) -&gt; &#123;<span class="hljs-keyword">return</span> b-a;&#125;);<br></code></pre></td></tr></table></figure><h3 id="连续子数组">连续子数组</h3><p><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/">581. 最短无序连续子数组 - 力扣（Leetcode）</a>这道题还是比较靠思维，下面贴一张图比较好懂</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221018104918469.png" alt="image-20221018104918469"></p><p>先只考虑中段数组，设其左边界为<code>L</code>，右边界为<code>R</code>：</p><ul><li><code>nums[R]</code> 不可能是【L，R】中的最大值（否则应该将 <code>nums[R]</code> 并入右端数组）</li><li><code>nums[L]</code> 不可能是【L，R】中的最小值（否则应该将 <code>nums[L]</code> 并入左端数组）</li></ul><p>很明显:</p><ul><li>【L，R】中的最大值 <code>等于</code>【0，R】中的最大值，设其为 <code>max</code></li><li>【L，R】中的最小值 <code>等于</code> 【L， nums.length-1】中的最小值，设其为 <code>min</code></li></ul><p>那么有：</p><ul><li><code>nums[R]</code> &lt; <code>max</code> &lt; <code>nums[R+1]</code> &lt; <code>nums[R+2]</code> &lt; … 所以说，从左往右遍历，最后一个小于<code>max</code>的为右边界</li><li><code>nums[L]</code> &gt; <code>min</code> &gt; <code>nums[L-1]</code> &gt; <code>nums[L-2]</code> &gt; … 所以说，从右往左遍历，最后一个大于<code>min</code>的为左边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只能说是题解牛逼</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<span class="hljs-comment">//左边界</span><br>        <span class="hljs-keyword">int</span> end = -<span class="hljs-number">1</span>;<span class="hljs-comment">//右边界</span><br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> min = nums[len-<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-comment">//从左到右维护最大值，最后一个小于最大值的就是右边界</span><br>            <span class="hljs-keyword">if</span>(nums[i] &lt; max)&#123;<br>                end = i;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                max = nums[i];<br>            &#125;<br><br>            <span class="hljs-comment">//从右到左维护最小值，最后一个大于最小值的就是左边界</span><br>            <span class="hljs-keyword">if</span>(nums[len-i-<span class="hljs-number">1</span>] &gt; min)&#123;<br>                begin = len-i-<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                min = nums[len-i-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> end-begin+<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="接雨水">接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（Leetcode）</a>一个hard题，字节好像很喜欢考这个题，我自己做的时候感觉也出现过好多次了，之前千峰杯还是啥比赛做过，可惜现在还是不会😥</p><p>解法一，按照行求(不建议使用)</p><p>思路：一行一行的找，当遇到一个大于等于层数的墙时，开始记录，后面每当遇到一个小于层数的墙，雨水temp就加一，然后又遇到大于等于层数的墙的时候，将temp加到最终 答案ans上，否则不加，以此类推到每一层</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019111306952.png" alt="image-20221019111306952"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019111325368.png" alt="image-20221019111325368"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按照行来求</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> max = getMax(height);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; max;i++)&#123; <span class="hljs-comment">//从第一行开始</span><br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> isStart = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//是否开始记录的标志</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; height.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isStart &amp;&amp; height[j] &lt; i) &#123;<br>                temp++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (height[j] &gt;= i) &#123;<br>                ans = ans + temp;<br>                temp = <span class="hljs-number">0</span>;<br>                isStart = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;height.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(height[i] &gt; max)&#123;<br>            max = height[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么这个不建议使用呢，首先，这确实时最容易想到的方法，思路也没有错，但是会超出时间限制😥</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019110856927.png" alt="image-20221019110856927"></p><p>解法二，按列来</p><p>思路：我们单独的来看一列，，然后找出这一列左边最高的一列和右边最高的一列，而左右最高的墙中较矮的墙相对于当前的列，无非下面三种情况</p><ul><li>较矮的墙大于当前的墙</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019143911957.png" alt="image-20221019143911957"></p><p>去掉多余的列</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019143959137.png" alt="去掉多余的墙后"></p><p>可以看出这种情况的话，当前的列上面是有水的，可以计算出有(leftMax - 当前的列)单位的水</p><ul><li>较矮的墙小于当前的高度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019144301275.png" alt="去掉多余的墙后"></p><p>这种情况很明显，当前的墙上面是不会有积水的</p><ul><li>较矮的墙等于当前的高度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019144400251.png" alt="去掉多余的墙后"></p><p>这种情况同理，也不会有积水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按照列来求</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//左右两边是肯定没有水的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;height.length;i++)&#123;<br>        <span class="hljs-comment">//找出左边最高</span><br>        <span class="hljs-keyword">int</span> leftMax = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(height[j] &gt; leftMax)&#123;<br>                leftMax = height[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//找出右边最高</span><br>        <span class="hljs-keyword">int</span> rightMax = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i;k &lt; height.length; k++)&#123;<br>            <span class="hljs-keyword">if</span>(height[k] &gt; rightMax)&#123;<br>                rightMax = height[k];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> min = Math.min(leftMax,rightMax);<br>        <span class="hljs-comment">//当前的节点比左右最高中较矮的那个矮才能有水</span><br>        <span class="hljs-keyword">if</span>(min &gt; height[i])&#123;<br>            ans = ans + (min - height[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法三 动态规划</p><p>思路：主要思路和上面的一样，不同是使用动态规划来优化了寻找左右两边最高的墙的操作</p><ul><li>leftMax[i]表示左边最高的墙的高度，那么这个高度可以通过前面的值来计算，左边最高墙的值就等于前一个左边最高墙的值和左边一格墙的值中，较高的那个，那么有<code>leftMax[j] = Math.max(leftMax[j - 1],height[j - 1]);</code></li><li>同理，右边墙的最高值有<code> rightMax[k] = Math.max(rightMax[k + 1],height[k + 1]);</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按照列来求</span><br><span class="hljs-comment">//使用动归来优化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[height.length];<br>    <span class="hljs-keyword">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[height.length];<br>    <span class="hljs-comment">//找出左边最高</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; height.length - <span class="hljs-number">1</span>; j++)&#123;<br>        leftMax[j] = Math.max(leftMax[j - <span class="hljs-number">1</span>],height[j - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">//找出右边最高</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = height.length - <span class="hljs-number">2</span>;k &gt; <span class="hljs-number">0</span>; k--)&#123;<br>        rightMax[k] = Math.max(rightMax[k + <span class="hljs-number">1</span>],height[k + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">//左右两边是肯定没有水的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;height.length;i++)&#123;<br><br>        <span class="hljs-keyword">int</span> min = Math.min(leftMax[i],rightMax[i]);<br>        <span class="hljs-comment">//当前的节点比左右最高中较矮的那个矮才能有水</span><br>        <span class="hljs-keyword">if</span>(min &gt; height[i])&#123;<br>            ans = ans + (min - height[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法四 栈</p><p>思路：有点类似于括号匹配，总体的原则就是</p><ul><li>当前高度小于等于栈顶的高度，入栈，指针后移</li><li>当前高度大于栈顶高度，出栈，计算当前墙和栈顶的墙之间的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</li><li>而对于计算 current 指向墙和新的栈顶之间的水，根据图的关系，我们可以直接把这两个墙当做之前解法三的 max_left 和 max_right，然后之前弹出的栈顶当做每次遍历的 height [ i ]。水量就是 Min ( max _ left ，max _ right ) - height [ i ]，只不过这里需要乘上两个墙之间的距离</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221019191944996.png" alt="image-20221019191944996"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用栈</span><br><span class="hljs-comment">//使用栈的计算过程没有之前几个好理解</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">int</span> current = <span class="hljs-number">0</span>;<span class="hljs-comment">//从0开始遍历</span><br>    <span class="hljs-keyword">while</span>(current &lt; height.length)&#123;<br>        <span class="hljs-keyword">while</span>( !stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[current])&#123;<span class="hljs-comment">//判断empty要放前面，不然报栈空异常</span><br>            <span class="hljs-keyword">int</span> h = height[stack.peek()];<br>            stack.pop();<span class="hljs-comment">//出栈</span><br>            <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> distance = current - stack.peek() - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">//这里peek的元素已经是刚刚出栈元素的前一个元素了</span><br>            <span class="hljs-keyword">int</span> min = Math.min(height[stack.peek()],height[current]);<br>            <span class="hljs-comment">//需要乘上distance是因为不一定是挨着的</span><br>            sum += distance * (min - h); <br>        &#125;<br>        stack.push(current); <span class="hljs-comment">//当前指向的墙入栈</span><br>        current++; <span class="hljs-comment">//指针后移</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种双指针的没看太懂，就先不写了，我是菜鸡</p><h3 id="双指针">双指针</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p><p>题意：给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 原地移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">val</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span>, <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,_,_]<br>解释：你的函数函数应该返回 <span class="hljs-attr">k</span> = <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。<br></code></pre></td></tr></table></figure><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != val)&#123;<br>                nums[k++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a></p><p>题意：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>思路1：直接暴力  时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            nums[i] = nums[i] * nums[i];<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路2：双指针法，i指向起始位置，j指向终止位置。 时间复杂度为O(n)，相对于暴力排序的解法O(n + nlog n)还是提升不少的。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[left] * nums[left] &lt; nums[right] * nums[right])&#123;<br>                res[i] = nums[right] * nums[right];<br>                right--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[i] = nums[left] * nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器 - 力扣（Leetcode）</a>和接雨水好像有点像，但是又有点不像👀，一开始见到就有思路，就是暴力，虽然样例是可以过的，但是果不其然会超出时间限制，这里还是贴一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初见 暴力</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;height.length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;height.length;j++)&#123;<br>            max = Math.max(max,(j-i)*Math.min(height[i],height[j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双指针解法</strong></p><p>水的体积公式由题可知： <em>S</em>(<em>i</em>,<em>j</em>)=<em>min</em>(<em>h</em>[<em>i</em>],<em>h</em>[<em>j</em>])×(<em>j</em>−<em>i</em>)</p><p>在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1 变短：</p><p>若向内 移动短板 ，水槽的短板 min(h[i],h[j]) 可能变大，因此下个水槽的面积 可能增大 。<br>若向内 移动长板 ，水槽的短板 min(h[i],h[j]) 不变或变小，因此下个水槽的面积 一定变小 。</p><p>因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尝试动规 //失败</span><br><span class="hljs-comment">//更推荐双指针</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> waterMax = -<span class="hljs-number">1</span>,i = <span class="hljs-number">0</span>,j = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        waterMax = height[i] &lt; height[j] ? <br>            Math.max(waterMax,(j - i) * height[i++]) : <span class="hljs-comment">//短板向内收缩</span><br>            Math.max(waterMax,(j - i) * height[j--]) ;<br>    &#125;<br>    <span class="hljs-keyword">return</span> waterMax;<br>&#125;<br><br><span class="hljs-comment">//几行代码就搞定，简直是优雅</span><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">container_with_most_wate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-comment">//短板向内进行收缩</span><br>        <span class="hljs-keyword">int</span> waterMax = -<span class="hljs-number">1</span>,left = <span class="hljs-number">0</span>,right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left!=right)&#123;<br>            waterMax = height[left] &gt; height[right] ?<br>                    Math.max(waterMax,(right-left) * height[right--]):<br>                    Math.max(waterMax,(right-left) * height[left++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> waterMax;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">//输入容器长度</span><br>        <span class="hljs-keyword">int</span> len = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] height = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>            <span class="hljs-comment">//输入全部容器的高度</span><br>            height[i] = scanner.nextInt();<br>        &#125;<br>        System.out.println(maxArea(height));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（Leetcode）</a>双指针的又一个应用，题意是要你找出三个不同的数，并且相加等于0,同时不能重复</p><p>思路：首先当然能够想到的是使用暴力的方法，直接嵌套三层for循环，但是当然不太可行。</p><p>还是使用双指针的方法：排序后在当前数字的后面使用两个指针从两边(i+1，length-1)开始找,同时在找的时候还需要去重，其中有以下几种情况需要特判</p><ul><li>nums.length&lt;3 都凑不齐三个数字，当然直接返回</li><li>nums[i] &gt; 0 因为是已经排序过了，所以后面的数字都大于0 ，不可能在相加等于0，直接返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//不可重复 set?</span><br>    <span class="hljs-comment">//三个数互不相等 但是相加等于0</span><br>    <span class="hljs-comment">//双指针？</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//最终返回的结果</span><br>        <span class="hljs-comment">//特判</span><br>        <span class="hljs-keyword">if</span>(nums.length&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> lists;<br>        &#125;<br><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">//特判  这个特判不要也可以通过</span><br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> lists;<br>            <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">//双指针</span><br>            <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>,right = nums.length - <span class="hljs-number">1</span>;            <br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-keyword">int</span> sum = nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>( sum == <span class="hljs-number">0</span>)&#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    list.add(nums[i]);<span class="hljs-comment">//记住这里add的是数字不是下标，淦</span><br>                    list.add(nums[left]);<br>                    list.add(nums[right]);<br>                    lists.add(list);<br>                    <span class="hljs-comment">//去重</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>])  left++;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>])  right--;   <br>                    left++;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//和小于零移动左指针，因为右边值更大</span><br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//和大于零移动右指针，因为左边边值更小</span><br>                    right--;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">threeSum</span> </span>&#123;<br>    <span class="hljs-comment">//不可重复 set?</span><br>    <span class="hljs-comment">//三个数互不相等 但是相加等于0</span><br>    <span class="hljs-comment">//双指针？</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//最终返回的结果</span><br>        <span class="hljs-comment">//特判</span><br>        <span class="hljs-keyword">if</span>(nums.length&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> lists;<br>        &#125;<br><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">//特判</span><br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> lists;<br>            <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">//双指针</span><br>            <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>,right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-keyword">int</span> sum = nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>( sum == <span class="hljs-number">0</span>)&#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    list.add(nums[i]);<span class="hljs-comment">//记住这里add的是数字不是下标，淦</span><br>                    list.add(nums[left]);<br>                    list.add(nums[right]);<br>                    lists.add(list);<br>                    <span class="hljs-comment">//去重</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>])  left++;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>])  right--;<br>                    left++;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//和小于零移动左指针，因为右边值更大</span><br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//和大于零移动右指针，因为左边边值更小</span><br>                    right--;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> len = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; result = threeSum(nums);<br>        <span class="hljs-comment">//直接打印集合</span><br>        System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和 - 力扣（LeetCode）</a></p><p>题意：给一个数组nums，和一个目标值target。找出四个和为target，且四个值互不相同的元素</p><p>思路：和上面的三数之和一样，这里是先确定两个数字，再使用双指针找后两个数字，值得注意的是，这里 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[k] &gt; target &amp;&amp; (nums[k] &gt;=0 || target &gt;= 0)</code>就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//相当于先确定两个数字，再使用双指针找后两个数字</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-comment">//先排序</span><br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.length; k++)&#123;<br>            <span class="hljs-comment">// 剪枝 </span><br>            <span class="hljs-keyword">if</span>(nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//遇到相同的数字，继续下一个数字</span><br>            <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k + <span class="hljs-number">1</span>;i &lt; nums.length; i++)&#123;<br>                <span class="hljs-comment">//第二级剪枝</span><br>                <span class="hljs-keyword">if</span>(nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//同理，在确定第二个数字的时候遇到相同的数字</span><br>                <span class="hljs-keyword">if</span>(i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//开始双指针操作</span><br>                <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(right &gt; left)&#123;<br>                    <span class="hljs-keyword">int</span> sum = nums[k] + nums[i] + nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                        right--;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                        left++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//等于target了，进行去重</span><br>                        result.add(Arrays.asList(nums[k],nums[i],nums[left],nums[right]));<br>                        <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                        right--;<br>                        left++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-colors/description/">75. 颜色分类 - 力扣（Leetcode）</a>荷兰国旗问题</p><p>题意：把0，1，2三个数字按照大小排序，并使相同的元素相邻</p><p>思路：其实完全可以用排序解决</p><p>方法一：各种排序算法，这里不细说</p><p>方法二：单指针</p><p>使用一个指针，用来记录头部的位置，第一次循环，每次一遇到0，就交换到头部，同时指针加一。第二次循环从头部的位置开始，一遇到1就交换，把一交换到中间位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> prepointer = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录头部位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> temp = nums[prepointer];<br>            nums[prepointer]  = nums[i];<br>            nums[i] = temp;<br>            prepointer++;<span class="hljs-comment">//全部交换到了头部</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = prepointer;i &lt; nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">int</span> temp = nums[prepointer];<br>            nums[prepointer]  = nums[i];<br>            nums[i] = temp;<br>            prepointer++;<span class="hljs-comment">//把一全部交换到了中间位置</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//单指针交换0和2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//单指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>,p2 = nums.length-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//和头部交换</span><br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = temp;<br>                p0++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">//和尾部交换</span><br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[p2];<br>                nums[p2] = temp;<br>                p2--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sortColors</span> </span>&#123;<br>    <span class="hljs-comment">//也可以直接使用排序算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>,p2 = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//和头部交换</span><br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = temp;<br>                p0++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">//和尾部交换</span><br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[p2];<br>                nums[p2] = temp;<br>                p2--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        sortColors(nums);<br>        System.out.println(Arrays.toString(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：双指针</p><p>双指针法，一个在前交换0，一个在后交换2</p><ul><li><p>如果找到了0，那么与前面两种方法类似，将其与nums[p0] 进行交换，并将 p0向后移动一个位置；</p></li><li><p>如果找到了2，那么将其与 nums[p2]进行交换，并将 p2向前移动一个位置。</p></li></ul><p>可以发现，对于第二种情况，当我们将 nums[i] 与 nums[p2] 进行交换之后，新的 nums[i] 可能仍然是 2，也可能是 0。然而此时我们已经结束了交换，开始遍历下一个元素nums[i+1]，不会再考虑 nums[i] 了，这样我们就会得到错误的答案。</p><p>因此，当我们找到 2 时，我们需要不断地将其与 nums[p2] 进行交换，直到新的 nums[i] 不为 2。此时，如果nums[i]为 0，那么对应着第一种情况；如果 nums[i] 为1，那么就不需要进行任何后续的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>, p2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= p2; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[p2];<br>                nums[p2] = temp;<br>                --p2;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = temp;<br>                ++p0;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/move-zeroes/solutions/">283. 移动零 - 力扣（Leetcode）</a>一道简单题,但是我们依然可以使用双指针来简化时间，优化算法<a href="https://leetcode.cn/problems/move-zeroes/solutions/90229/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/">283. 移动零题解</a></p><p>先看看普通的解法，就是通过两次遍历，(其实也还是双指针)把非0的元素都换到前面去，记录下位置，再把后面的元素都赋为0即可，需要两次遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>                nums[j++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>            nums[j++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//自己写的丑陋的代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                list.add(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; list.size();i++)&#123;<br>            nums[i] = list.get(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过双指针优化，使用一次遍历即可完成</p><p>第二种解法的本质是一个循环不变量：<code>在每一次循环前，j 的左边全部都是不等于0的</code></p><ul><li>起始<code>j</code>为0，明显满足</li><li>此后每一次循环中，若<code>nums[i] = 0</code>，则<code>j</code>保持不变，满足；若<code>nums[i] != 0</code>，交换后<code>j</code>增一，仍然满足</li></ul><p>这就保证了最后结果的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//若发生交换，这里的nums[j]必然是0，因为j右边的0肯定已经被i先前交换到j左边去了，若不是0这里i==j</span><br>                <span class="hljs-comment">//所以是不存在将非0元素又交换到j右边的位置的情况的</span><br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j++] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（Leetcode）</a></p><p>一道简单题，使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tail = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                res[pre++] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[tail--] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心算法">贪心算法</h3><p><a href="https://leetcode.cn/problems/assign-cookies/description/">455. 分发饼干 - 力扣（LeetCode）</a></p><p>一道简单题，思路就是<strong>小饼干先喂饱小胃口</strong>，先都排序，然后遍历每一个饼干，用每一个饼干去对应胃口，满足则下一个，最后计数就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;<br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-comment">//人的胃口遍历</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length &amp;&amp; start &lt; g.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt;= g[start])&#123;<br>                count++;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列 - 力扣（LeetCode）</a></p><ol><li><strong>边界情况处理</strong>：如果数组长度小于2，直接返回数组长度，因为单个元素或空数组本身就是摆动序列。</li><li><strong>初始化变量</strong>：<ul><li><code>up</code>：表示以上升趋势结束的最长摆动子序列长度</li><li><code>down</code>：表示以下降趋势结束的最长摆动子序列长度</li><li>初始值都设为1，因为至少有一个元素的序列就是摆动序列</li></ul></li><li><strong>遍历数组</strong>：从第二个元素开始遍历数组：<ul><li>如果当前元素大于前一个元素，说明出现了上升趋势，更新<code>up = down + 1</code></li><li>如果当前元素小于前一个元素，说明出现了下降趋势，更新<code>down = up + 1</code></li><li>如果相等，不执行任何操作，保持当前值</li></ul></li><li><strong>返回结果</strong>：最终结果是<code>up</code>和<code>down</code>中的较大值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> up = <span class="hljs-number">1</span>, down = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                up = down + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                down = up + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果相等，不执行任何操作，保持当前值</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> Math.max(up, down);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏 - 力扣（Leetcode）</a></p><p>题意：一个数组里的数字代表，能够跳跃的最远距离，问能不能跳到最后</p><p>思路：注意是能够跳跃的最远距离，也就是说是可以跳到比他小的距离的，那也就是说，能够跳到某一个地方，那就能到达他左边的所有地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//奇奇怪怪，完全不知道使用什么方法</span><br>    <span class="hljs-comment">//只要不是0 就可以继续往前面跳</span><br>    <span class="hljs-comment">//动规？</span><br><br>    <span class="hljs-keyword">int</span> cover = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= cover;i++)&#123;<br>        <span class="hljs-comment">//i &lt;= cover 每次只循环到能跳到的额范围</span><br>        cover = Math.max(i + nums[i],cover);<br>        <span class="hljs-comment">//i + nums[i] 是当前下标加上跳最远距离，代表现在能覆盖的最大值</span><br>        <span class="hljs-keyword">if</span>(cover &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//能覆盖的范围大于数组最大下标，说明能覆盖完，可以跳到终点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">canJump</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cover = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= cover;i++)&#123;<br>            cover = Math.max(i+nums[i],cover);<br>            <span class="hljs-keyword">if</span>(cover &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        System.out.println(canJump.canJump(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">45. 跳跃游戏 II - 力扣（LeetCode）</a></p><p>这道题和上面的有点像，但是要难一些，主要是需要三个变量进行记录，比较难理解的是执行下一步时候的变化</p><p>其实下一步能跳的最远距离的计算，就是利用i还在当前的跳跃的次数里面的时候，挨着挨着加计算出来的，也就是利用遍历下图中的重合区域的部分时计算的</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251114171415812.png" alt="image-20251114171415812"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//当前的跳跃次数下能到达的最远距离</span><br>        <span class="hljs-keyword">int</span> currentEnd = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//经历所有跳跃后能达到的最远距离</span><br>        <span class="hljs-keyword">int</span> farthest  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> jump = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            farthest = Math.max(farthest, i + nums[i]);<br>            <br>            <span class="hljs-comment">//如果达到边界，说明需要下一次的跳跃</span><br>            <span class="hljs-keyword">if</span>(i == currentEnd)&#123;<br>                jump++;<br>                <span class="hljs-comment">//执行下一步 能跳的最远的距离</span><br>                currentEnd = farthest;<br>                <span class="hljs-keyword">if</span>(currentEnd == nums.length - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> jump;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode）</a></p><p>思路很简单，先把负数从小到大，依次变为正数，如果这时候的K还没有消耗完，就再次排序，把最小的那个数反复取反，直到K消耗完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//先排序 找负数</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; k &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= <span class="hljs-number">0</span>)&#123;<br>                nums[i] = - nums[i];<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">0</span>)&#123;<br>            Arrays.sort(nums);<br>            <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;<br>                nums[<span class="hljs-number">0</span>] = - nums[<span class="hljs-number">0</span>];<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            res += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/gas-station/description/">134. 加油站 - 力扣（LeetCode）</a></p><p>一看题就知道可以使用暴力来做，但是很明显是超出限制的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] gas, <span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> currentGas = <span class="hljs-number">0</span>; <span class="hljs-comment">// 在每个新起点重置油量</span><br>            <span class="hljs-keyword">int</span> cur = i;<br>            <span class="hljs-keyword">boolean</span> canComplete = <span class="hljs-keyword">true</span>;<br>            <br>            <span class="hljs-comment">// 行驶一圈，需要经过所有n个站点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>; step &lt; gas.length; step++)&#123;<br>                currentGas += gas[cur] - cost[cur];<br>                <br>                <span class="hljs-keyword">if</span>(currentGas &lt; <span class="hljs-number">0</span>)&#123;<br>                    canComplete = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 移动到下一站</span><br>                cur = (cur + <span class="hljs-number">1</span>) % gas.length;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 如果能完成一圈</span><br>            <span class="hljs-keyword">if</span> (canComplete) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此使用贪心</p><p>这里需要先明确</p><ol><li>如果总油量减去总消耗大于等于零那么一定可以跑完一圈</li><li>从i = 0开始累加当前剩余油量，如果当前累加的剩余油量一旦小于0，那么说明0 到 i 这个区间的点都不能当起点</li></ol><p>第二点是有点难理解的，建议看看这个题解，参考参考<a href="https://www.programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#%E6%80%9D%E8%B7%AF">134. 加油站 | 代码随想录</a>，但是简单的来说就是，如果这个0 - i这个区间和小于0了。说明这个区间里面有一个很大的负数，也就是到某一个站点的消耗的油量远大于加的油量，因此需要把这个站点放到行程后面再去加，所以重新选择起点从i+1开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] gas, <span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> totalGas = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 总剩余油量</span><br>        <span class="hljs-keyword">int</span> currentGas = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前剩余油量</span><br>        <span class="hljs-keyword">int</span> startStation = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始加油站</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> diff = gas[i] - cost[i];<br>            totalGas += diff;<br>            currentGas += diff;<br>            <br>            <span class="hljs-comment">// 如果当前油量不足，重新选择起点</span><br>            <span class="hljs-keyword">if</span> (currentGas &lt; <span class="hljs-number">0</span>) &#123;<br>                startStation = i + <span class="hljs-number">1</span>;<br>                currentGas = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果总油量足够，返回起点；否则返回-1</span><br>        <span class="hljs-keyword">return</span> totalGas &gt;= <span class="hljs-number">0</span> ? startStation : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/candy/description/">135. 分发糖果 - 力扣（LeetCode）</a></p><p>关键点是要从左到右和从右到左遍历两次，其中从右到左需要注意，需要使用max来判断取最大值，否则可能重复计算两次</p><p>例如[1, 2, 3, 1]</p><p>第一次从左到右后为 糖果为 1, 2, 3 , 1 ；接着开始从右到左遍历</p><p>如果不使用max,则会变成 1，2，2，1；下标为2的数据重复计算了，导致最终结果出错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ratings)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//每个孩子一个糖果</span><br>        <span class="hljs-keyword">int</span>[] candy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ratings.length];<br><br>        Arrays.fill(candy,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; candy.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])&#123;<br>                candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = candy.length - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i - <span class="hljs-number">1</span>] &gt; ratings[i])&#123;<br>                <span class="hljs-comment">//这里应该使用最大值判断，防止计算两次</span><br>                <span class="hljs-comment">//例如[1, 2, 3, 1]</span><br>                candy[i - <span class="hljs-number">1</span>] = Math.max(candy[i - <span class="hljs-number">1</span>], candy[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; candy.length;i++)&#123;<br>            sum += candy[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/lemonade-change/description/">860. 柠檬水找零 - 力扣（LeetCode）</a>  没什么难度，就是分类讨论，需要注意的就是把20美元的时候优先找开1张5块，一张10块的才能通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;<br>        <span class="hljs-comment">//用map来计数做</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; bills.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">5</span>)&#123;<br>                map.put(<span class="hljs-number">5</span>, map.getOrDefault(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-comment">//可以找开</span><br>                <span class="hljs-keyword">if</span>(map.getOrDefault(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">1</span>)&#123;<br>                    map.put(<span class="hljs-number">10</span>, map.getOrDefault(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    map.put(<span class="hljs-number">5</span>, map.get(<span class="hljs-number">5</span>) - <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-comment">//找开1张5块 1张10块</span><br>                <span class="hljs-keyword">if</span>(map.getOrDefault(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">1</span> &amp;&amp; map.getOrDefault(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">1</span>)&#123;<br>                    map.put(<span class="hljs-number">5</span>, map.get(<span class="hljs-number">5</span>) - <span class="hljs-number">1</span>);<br>                    map.put(<span class="hljs-number">10</span>, map.get(<span class="hljs-number">10</span>) - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//可以找开3张5块</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(map.getOrDefault(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">3</span>)&#123;<br>                    map.put(<span class="hljs-number">5</span>, map.get(<span class="hljs-number">5</span>) - <span class="hljs-number">3</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><p>需要对两个维度的数据进行排序，一个是身高，一个是k值，和上面的分发糖果类似，需要先对一个数据排序，然后再对另一个数据排序，这道题需要的就是先对身高排序，然后再对k值进行排序<a href="https://www.programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">406.根据身高重建队列 | 代码随想录</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;<br>        <span class="hljs-comment">// 按身高降序排序，身高相同按k值升序排序</span><br>        Arrays.sort(people, (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 根据k值插入到对应位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] person : people) &#123;<br>            result.add(person[<span class="hljs-number">1</span>], person);<br>        &#125;<br>        <span class="hljs-comment">// 这样写会编译错误吗？不会，但逻辑不对 </span><br>        <span class="hljs-comment">// return result.toArray(new int[result.size()][2]);</span><br>        <span class="hljs-comment">// 浪费了创建第二维数组的开销</span><br>        <br>        <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[result.size()][]);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//上面的lambda表达式如果写成匿名内部类</span><br><br>Arrays.sort(people, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。<strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。<a href="https://www.programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html#%E6%80%9D%E8%B7%AF">452. 用最少数量的箭引爆气球 | 代码随想录</a></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251120132446098.png" alt="image-20251120132446098"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;<br>        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br>        <span class="hljs-comment">// Arrays.sort(points,(a,b) -&gt; &#123;return a[0] - b[0];&#125;);</span><br>        <span class="hljs-comment">// 当 a[0] 是一个很大的正数，而 b[0] 是一个很大的负数时，a[0] - b[0] 可能会超出 int 的范围，导致排序结果不正确。</span><br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; points.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//否则，和前面的就是重叠的</span><br>                <span class="hljs-comment">//重叠区域的最靠左的end端是肯定需要一支箭的</span><br>                <span class="hljs-comment">//因此需要更新最靠左的end端的值，进行下一步point[i - 1][1]判断是否重叠</span><br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>], points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435. 无重叠区间 - 力扣（LeetCode）</a></p><p>本题其实和上面那道题<a href="https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">452.用最少数量的箭引爆气球 </a>非常像，弓箭的数量就相当于是非交叉区间的数量，只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1][1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了。</p><p>把<a href="https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">452.用最少数量的箭引爆气球 (opens new window)</a>代码稍做修改，就可以AC本题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        Arrays.sort(intervals, (a,b) -&gt; &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];&#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; intervals.length;i++)&#123;<br>            <span class="hljs-comment">//题目说了边界相交也算是不重叠</span><br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i][<span class="hljs-number">1</span>], intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.length - count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划">动态规划</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（Leetcode）</a></p><p>兜兜转转又回到最初的爬楼梯… （注意声明数组为n+1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//这里的判断可以不要，因为测试用例里面没有0的情况</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span>  <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//依据题意改的</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">climbStairs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//当台阶为0时，返回0还是1 得看具体测试用例的情况</span><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span> ans = climbStairs(n);<br>        System.out.println(ans);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/description/">剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（Leetcode）</a>题目是一样的，不同的是测试数据会大很多，需要根据题意来取模</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>            dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/description/">剑指 Offer 10- I. 斐波那契数列 - 力扣（Leetcode）</a>斐波那契数列的题，和上面的是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp =  <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n; i++)&#123;<br>            dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/counting-bits/description/">338. 比特位计数 - 力扣（Leetcode）</a></p><p>题意：给你一个十进制数字，找出这个数字的二进制数字里面有几个1</p><p>方法一：使用Java自带的<code>Integer.bitCount()</code>函数，可以直接找出有多少个1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            ans[i] = Integer.bitCount(i); <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：这个方法比较巧妙，首先需要找到规律</p><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">举例： <br>        <span class="hljs-number"> 0 </span>=<span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>= 1<br>        <span class="hljs-number"> 2 </span>=<span class="hljs-number"> 10 </span>    <span class="hljs-number"> 3 </span>= 11<br></code></pre></td></tr></table></figure><p>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">举例：<br>         <span class="hljs-number"> 2 </span>=<span class="hljs-number"> 10 </span>     <span class="hljs-number"> 4 </span>=<span class="hljs-number"> 100 </span>     <span class="hljs-number"> 8 </span>= 1000<br>         <span class="hljs-number"> 3 </span>=<span class="hljs-number"> 11 </span>     <span class="hljs-number"> 6 </span>=<span class="hljs-number"> 110 </span>     <span class="hljs-number"> 12 </span>= 1100<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                ans[i] = ans[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans[i] = ans[i / <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/hamming-distance/description/">461. 汉明距离 - 力扣（Leetcode）</a>和上面的题有类似的地方，都用到了<code>Integer.bitCount()</code>函数</p><p>题意：简单的来说，汉明距离就是这两个数字的二进制数有几位不同，遇到不同，我们就可以使用异或来解决，因为不同数字异或的结果是1，因此再搭配上<code>Integer.bitCount()</code>函数就可以得到答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.bitCount(x ^ y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类似的题</p><p><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/description/">剑指 Offer 15. 二进制中1的个数 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.bitCount(n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列 - 力扣（Leetcode）</a></p><p>题意：就是找出数字连续的最长的序列（注意这里题意不要求序列元素在原数组中连续，因此和下面的寻找最长递增子序列是不同的，下面的寻找最长递增子序列不可以用这种排序后再dp的方法）</p><p>思路：本来想使用map试试，但是map的键用keySet()取出后，set无法使用get方法取出值，因此使用排序后用dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//排序后用dp</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-comment">//考虑特殊情况</span><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-comment">//即使是一个元素，也可以是一个连续的元素</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>;cur &lt; len;cur++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[cur] == nums[cur-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)&#123;<br>                dp[cur] = dp[cur - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                res = Math.max(res,dp[cur]);<span class="hljs-comment">//有递增的就加1</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] == nums[cur-<span class="hljs-number">1</span>])&#123;<br>                dp[cur] = dp[cur - <span class="hljs-number">1</span>];<span class="hljs-comment">//相同不变</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                 dp[cur] = <span class="hljs-number">1</span>;<span class="hljs-comment">//否则重新计数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">longestConsecutive</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-comment">//考虑特殊情况</span><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-comment">//即使是一个元素，也可以是一个连续的元素</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>;cur &lt; len;cur++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[cur] == nums[cur-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)&#123;<br>                dp[cur] = dp[cur - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                res = Math.max(res,dp[cur]);<span class="hljs-comment">//有递增的就加1</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] == nums[cur-<span class="hljs-number">1</span>])&#123;<br>                dp[cur] = dp[cur - <span class="hljs-number">1</span>];<span class="hljs-comment">//相同不变</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[cur] = <span class="hljs-number">1</span>;<span class="hljs-comment">//否则重新计数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> len = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        longestConsecutive solution = <span class="hljs-keyword">new</span> longestConsecutive();<br>        <span class="hljs-keyword">int</span> result = solution.longestConsecutive(nums);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（Leetcode）</a>这道题第一次遇到是在我们团队的招新考试上，基本上算是我的动态规划的启蒙题了，我觉得很好的体现了动态规划的思想和思路，下面的这个题解我觉得比我自己写的话好很多，详细解释了动规的思想和后效性，也相当于带你入门动态规划了<a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">53. 最大子数组和题解</a>,这个题解是真的好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//一眼动规</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i-<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//注意一下这里是dp[i-1]</span><br>                dp[i] = dp[i-<span class="hljs-number">1</span>]+nums[i];<br>                max = Math.max(dp[i],max);<span class="hljs-comment">//在dp过程中就在找最大的值</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i] = nums[i];<br>                max = Math.max(dp[i],max);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//更简洁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.length;i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>] + nums[i],nums[i]);<br>            res = Math.max(dp[i],res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化空间后的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-comment">//简直是绝妙的解法</span><br>        pre = Math.max(pre + num, num);<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组 - 力扣（Leetcode）</a></p><p>题意：依旧是找连续子数组中乘积最大的</p><p>思路：乘法和加法不同，乘法中因为负负得正，所以连续子数组乘积最小的值，就有可能变成最大的。因此，我们使用两个动态规划，同时维护两个值，一个是当前子数组乘积最大值，一个是乘积最小值。当遇到负数的时候，就把维护的最大值和最小值交换，之前维护的最大值因为乘上了负数，变成了最小值，同理之前的最小值也变成了最大值。参考题解：<a href="https://leetcode.cn/problems/maximum-product-subarray/solutions/7561/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/">152. 乘积最大子数组 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//优化空间后的</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>],imax = nums[<span class="hljs-number">0</span>], imin = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> temp = imax;<br>                imax = imin;<br>                imin = temp;<br>            &#125;<br>            <span class="hljs-comment">//维护的最大值</span><br>            imax = Math.max(imax * nums[i],nums[i]);<br>            <span class="hljs-comment">//维护的最小值</span><br>            imin = Math.min(imin * nums[i],nums[i]);<br>            <span class="hljs-comment">//寻找最终的答案</span><br>            max = max &gt; imax ? max : imax;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//维护dp数组的</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">int</span>[] dpmax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>        <span class="hljs-keyword">int</span>[] dpmin = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        dpmax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dpmin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-comment">//分别维护以当前位置结尾的子数组最大乘积和最小乘积</span><br>            <span class="hljs-comment">//因为最小的可能变成最大的。所以需要三个结果里面取，用以维护最大值和最小值</span><br>            dpmax[i] = Math.max(dpmax[i - <span class="hljs-number">1</span>] * nums[i], Math.max(nums[i], dpmin[i - <span class="hljs-number">1</span>] * nums[i]));<br>            dpmin[i] = Math.min(dpmin[i - <span class="hljs-number">1</span>] * nums[i], Math.min(nums[i], dpmax[i - <span class="hljs-number">1</span>] * nums[i]));<br><br>            max = Math.max(max, dpmax[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">maxProduct</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> min = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> a = nums[i] * max;<br>            <span class="hljs-keyword">int</span> b = nums[i] * min;<br>            <span class="hljs-comment">//max和min也同时起了dp[i - 1]功能</span><br>            max = Math.max(Math.max(a, b), nums[i]);<br>            min = Math.min(Math.min(a, b), nums[i]);<br>            res = Math.max(res, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        System.out.println(maxProduct(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍 - 力扣（Leetcode）</a>一道普通的dp题</p><p>题意：你是一个小偷，要去偷东西，不能偷相邻的两家，否则会报警，问最大偷多少</p><p>思路：使用dp，当前能偷的最大值，因为不能偷相邻的，要么是当前的前面第二家加上当前值 dp[i] = dp[i-2] + num[i],要么是前面第三家加上当前值dp[i] = dp[i-3] + num[i] ，这种循环只能从第四个开始，所以数组小于三时需要特判。</p><p>下面的代码是我自己写的，不是很优雅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-comment">//特判</span><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">2</span>],nums[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-comment">//前面三个只有下面这一种情况</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">2</span>]; <br>        <span class="hljs-comment">//开始 使用递推公式推导后面的结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt; len;i++)&#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>],dp[i - <span class="hljs-number">3</span>]) + nums[i]; <br>        &#125;<br>        <span class="hljs-comment">//最后要么是最后一个最大(偷了最后一个)，或者倒数第二个最大(没有偷最后一个)</span><br>        <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>],dp[len - <span class="hljs-number">2</span>]);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/">198. 打家劫舍题解 - 力扣</a>根据题解写的优雅的代码，这个题解也相当的不错，推荐一看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 子问题：</span><br>    <span class="hljs-comment">// f(k) = 偷 [0..k) 房间中的最大金额</span><br><br>    <span class="hljs-comment">// f(0) = 0</span><br>    <span class="hljs-comment">// f(1) = nums[0]</span><br>    <span class="hljs-comment">// f(k) = max&#123; rob(k-1), nums[k-1] + rob(k-2) &#125;</span><br><br>    <span class="hljs-keyword">int</span> N = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>; k &lt;= N; k++) &#123;<br>        dp[k] = Math.max(dp[k-<span class="hljs-number">1</span>], nums[k-<span class="hljs-number">1</span>] + dp[k-<span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>改写成这样或许要好理解一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> N = nums.length;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>; k &lt; N; k++) &#123;<br>            <span class="hljs-comment">//dp = dp[k-1] 说明不偷现在的k</span><br>            <span class="hljs-comment">//dp = dp[k-2] 说明 偷了现在个节点 再加上以前第二个节点的dp</span><br>            dp[k] = Math.max(dp[k-<span class="hljs-number">1</span>], nums[k] + dp[k-<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[N-<span class="hljs-number">1</span>];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（Leetcode）</a></p><p>题意：一个m*n的棋盘，只能向下或者向右走，问你走到棋盘的右下角 一共有多少种不同的路径</p><p>思路1：排列组合</p><p>在这道题中，因为只能向下或者向右走，所以相当于走过的总路径是相同的为m+n-2,同理可以得到，向右走的步数一定是m-1,向下走的一定是n-1。因此总的路径总数就可以使用组合数来求出来，但是这里直接使用阶乘的话，数字肯定会非常大，所以这里需要化简计算，具体的化简可以看下面这个示意图</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230225111137124.png" alt="image-20230225111137124"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//只跟第几行第几列有关，从m+n-2步中抽出m-1步</span><br>        <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Math.min(m-<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>);i++)&#123;            <br>            ans*=m+n-<span class="hljs-number">2</span>-i;<br>            ans/=i+<span class="hljs-number">1</span>;           <br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路2：dp</p><p>边边上是只有一种到达方法，所以全部初始化为1，递推公式还是比较好懂的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];  <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//优化1  </span><br><span class="hljs-comment">//只保留上一行和当前行，就可以直接更新 空间复杂度降为了O(2n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(pre, <span class="hljs-number">1</span>);<br>        Arrays.fill(cur,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                cur[j] = cur[j-<span class="hljs-number">1</span>] + pre[j];<br>            &#125;<br>            pre = cur.clone();<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre[n-<span class="hljs-number">1</span>]; <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//优化2</span><br><span class="hljs-comment">//把存储上一行的数据也给优化掉了，加完cur这一行数据，在下一次加的时候里面已经存储的数据就相当于上一行的数据了</span><br><span class="hljs-comment">//空间复杂度优化为了O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(cur,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                cur[j] += cur[j-<span class="hljs-number">1</span>] ;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">uniquePaths</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]+ dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> m = sc.nextInt();<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        System.out.println(uniquePaths(m, n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-path-sum/description/">64. 最小路径和 - 力扣（Leetcode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221104140759295.png" alt="image-20221104140759295"></p><p>虽然是一道经典的动规题。但是写的时候，还是把它给想成了dfs求解，调试半天，发现做不出来。。</p><p>题意： 经典的要求你求矩形中，左上角到右下角的最短路径，而且只能向下走，或者向右走</p><p>思路：能走到某个点，说明这个点无非下面三种状态</p><ul><li>这个点在矩形中，不在边边上，说明可以由前面的节点向下或者向右走到，这时候是<code>dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1]) + grid[i][j];</code></li><li>这个点在左边边上，只能向下走到，这时候是<code>dp[i][j] = dp[i - 1][j] + grid[i][j];</code></li><li>这个点在最上面那一排，只能向右走到，这时候是<code>dp[i][j - 1] + grid[i][j];</code></li></ul><p>其实和62题是一样的思路，只不过这个需要把路径上的点加起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rows = grid.length ,columns = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][columns];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; rows;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; columns;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + grid[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + grid[i][j];<br>                <span class="hljs-keyword">else</span> dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">minPathSum</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = grid.length,n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] dp =  <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-comment">//初始化第一行</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>        <span class="hljs-comment">//初始化第一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++) dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j] + grid[i][j],dp[i][j - <span class="hljs-number">1</span>] + grid[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> m = sc.nextInt();<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[][] grid = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                grid[i][j] = sc.nextInt();<br>            &#125;<br>        &#125;<br>        System.out.println(minPathSum(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximal-square/description/">221. 最大正方形 - 力扣（Leetcode）</a>这还是一道动态规划的题(二维dp)，一开始还以为是岛屿，后来发现示例都通不过，仔细一想，好像并不是岛屿的问题。看了一下题解，发现还是使用动态规划解决</p><p>题意：在这个数组中使用一个正方形框出元素1，且使得这个正方形面积最大，简单来说就是使框出1的正方形最大</p><p>思路：<code>dp[i][j]</code>推导到<code>dp[i+1][j+1]</code>无非三种情况，左上角被0限制，上面被0限制或者左边被0限制，这里需要明白<code>dp[i][j]</code>的含义，这里指的是在以<code>dp[i-1][j-1]</code>为右下脚的正方形的最大边长，最后我们找到这个最大的边长后，返回面积即可。这里讲的思路还不是很清楚，因此给个连接，这个题解里面写得很清楚。<a href="https://leetcode.cn/problems/maximal-square/solutions/44586/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/">221. 最大正方形 题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r  = matrix.length;<br>        <span class="hljs-keyword">int</span> c = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> maxside = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//首先特判</span><br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || r &lt; <span class="hljs-number">1</span> || c &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r+<span class="hljs-number">1</span>][c+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//开始dp</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;r;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;c;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(Math.min(dp[i][j],dp[i+<span class="hljs-number">1</span>][j]),dp[i][j+<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                    maxside = Math.max(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>],maxside);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxside*maxside;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最长递增子序列<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（Leetcode）</a></p><p>题意：给你一个数组，叫你求出这个数组的子数组中，最长递增的有多长，注意不可以改变顺序</p><p>思路：使用dp，这里的dp[i]的含义就是到i这里前面的最长增长子序列有多长(不一定只有一个)，和上面的那些dp不同的是，因为子序列可以从index = 0,第二个就是index = i，中间的都可以不要，因此需要两重循环来解决，不断寻找前面当前值nums[i]小的数值，然后不断求 dp[i] 和 dp[j]+1的最大值，下面是示例图，还比较好理解</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221130153916111.png" alt="image-20221130153916111"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//学dp</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//所以递推公式是什么呢</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//全部填充为1</span><br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分 - 力扣（Leetcode）</a>单词拆分</p><p>题意：现在有一个字符串s比如是&quot;leetcode&quot;,现在有一个字典[“leet”,“code”]，问你字典里面的单词能不能够组成s,字典里面的单词可以任意使用不限次数</p><p>思路：使用dp[i]数组代表在这个位置上面能不能被字典里面的单词所表示，用一个长度为n+1的数组，第一位为true,其他 为false(因为第0位看作空，始终可以组合出来)，然后遍历每一个单词，看能不能成功的前缀匹配上，这里需要使用一个Java里面的函数<code>str.startsWith(String prefix, int toffset)</code>,<code>prefix</code>是前缀，<code>toffset</code>是开始的位置，全部匹配一遍之后，直接查看dp的最后一位就可以看到是否可以组合成功了</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230219210217286.png" alt="image-20230219210217286"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span>  <span class="hljs-keyword">boolean</span>[length + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length + <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                <span class="hljs-comment">//中间不是true的不再查询，用于延续dp中的状态信息</span><br>                <span class="hljs-comment">//不是true的说明这个长度时，字典里面的单词无法满足，从这个地方遍历没有意义</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(String word : wordDict)&#123;<br>                <span class="hljs-comment">//这里startsWith取的是i是差一位的，因此刚好对应上一个的true的后一位</span><br>                <span class="hljs-keyword">if</span>(s.startsWith(word,i))&#123;<br>                    <span class="hljs-comment">//和爬楼梯有点像，word的length就是能爬多少步 </span><br>                    dp[i + word.length()] = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[length];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//一样的思路，但是实现的方法不同</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">wordBreak</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = sc.nextLine();<br>        List&lt;String&gt; wordDict = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            wordDict.add(sc.nextLine());<br>        &#125;<br>        wordBreak wordBreak = <span class="hljs-keyword">new</span> wordBreak();<br>        System.out.println(wordBreak.wordBreak(s,wordDict));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于背包问题</strong></p><p>//todo</p><p><strong>股票系列</strong></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机 - 力扣（Leetcode）</a></p><p>一道比较简单的股票题，就是求最大利润，dp都没有用，只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-comment">//维护一个最小的</span><br>        <span class="hljs-keyword">int</span> minprices = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; prices.length;i++)&#123;<br>            <span class="hljs-comment">//更新最小值</span><br>            <span class="hljs-keyword">if</span>(prices[i] &lt; minprices)&#123;<br>                minprices = prices[i];<br>            &#125;<br>            maxProfit = Math.max(maxProfit,prices[i] - minprices);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode）</a>多状态的动态规划</p><p>题意:通过股票的买入卖出获得收益，但是同时只能持有一只股票，未卖出的情况下不能继续买，而且你卖了一只股票后，需要冷冻一天，不能继续买，具体的解析都放在代码里了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> days = prices.length;<br>        <span class="hljs-comment">// 定义动态规划状态变量，第一维记录天数，第二维记录股票的状态</span><br>        <span class="hljs-keyword">int</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[days][<span class="hljs-number">4</span>];<br><br>        <span class="hljs-comment">// 初始化状态变量</span><br>        <span class="hljs-comment">// 状态0，表示不持有股票，且没卖出，意思就是本来就不持有，没做任何买卖</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 状态1，表示不持有股票，原因是今天卖出了（这里因为是第0天，所以没买入，所以收益也是0）</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 状态2，表示持有股票，今天买入的，因为是买入，所以收入是负的，</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = -<span class="hljs-number">1</span> * prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 状态3，表示持有股票，非今天买入，从前一天继承过来的（这里因为是第0天，所以相当于是今天买入，今天卖出）</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -<span class="hljs-number">1</span> * prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; days; i++) &#123;<br>            <span class="hljs-comment">// 第i天不持有且本来也不持有，那说明前一天也不持有，即使持有也卖出了，那就是0和1两种情况</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 第i天不持有，因为今天卖出了，那收益就是今天的股票价格加上 之前累加的</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) + prices[i];<br>            <span class="hljs-comment">// 第i天持有，而且是今天买入（排除状态2、3），那么根据冷冻期 昨天一定没有卖出今天才能买入</span><br>            dp[i][<span class="hljs-number">2</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i];<br>            <span class="hljs-comment">// 第i天持有，且非今天买入, 那就是之前买入，计算之前累加的</span><br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">//因为买卖到最后，一定是不持有的（即使亏了，卖也比不卖强），所以应该是0和1两种状态，取较大值</span><br>        <span class="hljs-keyword">return</span> Math.max(dp[days-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[days-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a> 一道比较难的二维动规，难点主要在动规的定义(存储含义)和转移方程上(这不是废话，动规的难点不都在这两点上吗…)</p><p>题意：给你两个单词比如：horse和ros，经过最少多少次变化可以从单词1变为单词2。其中，这里面的变化包括：增加字母、删除字母以及直接变化字母三种。</p><p>思路：首先就是要搞清楚，用二维dp怎么进行定义，这里的定义的<code>dp[i][j]</code>代表word1的前i个字母，变换到word2的前j个字母，最短的操作次数。同时需要考虑两个单词一个字母都没有的情况，因此dp数组比单词长度都要长1个单位。</p><p>同时，状态转移方程应该是这样子搞：</p><ul><li>删除操作：<code>dp[i - 1][j]</code></li><li>增加操作：<code>dp[i][j - 1]</code></li><li>替换操作：<code>dp[i - 1][j - 1]</code></li></ul><p>具体的题解和示例图参考这篇题解<a href="https://leetcode.cn/problems/edit-distance/solutions/189676/edit-distance-by-ikaruga/">72. 编辑距离 - 题解</a>写得很好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i][j]表示word1前 i 个字母 转化到 word2 前 j 个需要的最少操作数</span><br><br>        <span class="hljs-keyword">int</span> n1 = word1.length()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n2 = word2.length()+<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1][n2];<br><br>        <span class="hljs-comment">//dp[i][0] 给第一列赋值,删除操作，从word1的字符删除到0个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n1; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <br>        <span class="hljs-comment">//dp[0][j] 给第一行赋值，增加操作，从0个字符增加到word2的字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n2; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;n2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-comment">//当字符相等，不变情况总是在最小的状态，无需与增删改情况去比较</span><br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]; <span class="hljs-comment">//no change</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 删除操作：dp[i - 1][j]</span><br>                    <span class="hljs-comment">// 增加操作：dp[i][j - 1]</span><br>                    <span class="hljs-comment">// 替换操作：dp[i - 1][j - 1]</span><br>                    dp[i][j] =Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]))+<span class="hljs-number">1</span>; <span class="hljs-comment">//add del edit</span><br>                &#125;<br>                <br>                System.out.println(dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n1-<span class="hljs-number">1</span>][n2-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">minDistance</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i][j]表示word1前 i 个字母 转化到 word2 前 j 个需要的最少操作数</span><br>        <span class="hljs-keyword">int</span> n1 = word1.length()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n2 = word2.length()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1][n2];<br>        <span class="hljs-comment">//dp[i][0] 给第一列赋值,删除操作，从word1的字符删除到0个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n1; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-comment">//dp[0][j] 给第一行赋值，增加操作，从0个字符增加到word2的字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n2; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;n2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]; <span class="hljs-comment">//no change</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] =Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]))+<span class="hljs-number">1</span>; <span class="hljs-comment">//add del edit</span><br>                &#125;<br><span class="hljs-comment">//                System.out.println(dp[i][j]);</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n1-<span class="hljs-number">1</span>][n2-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String word1 = sc.nextLine();<br>        String word2 = sc.nextLine();<br>        System.out.println(minDistance(word1,word2));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/regular-expression-matching/description/">10. 正则表达式匹配 - 力扣（LeetCode）</a>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><ul><li><code>'.'</code> 匹配任意单个字符</li><li><code>'*'</code> 匹配零个或多个前面的那一个元素</li></ul><p>为了解决这个问题，我们需要实现一个支持 ‘.’ 和 ‘<em>’ 的正则表达式匹配。其中，‘.’ 可以匹配任意单个字符，'</em>’ 可以匹配零个或多个前面的元素。关键在于处理这些特殊字符的匹配情况，并确保整个字符串被完全匹配。</p><p>思路：</p><p>我们可以使用动态规划来解决这个问题。动态规划的核心思想是构建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示字符串 <code>s</code> 的前 <code>i</code> 个字符和模式 <code>p</code> 的前 <code>j</code> 个字符是否匹配。</p><ol><li><strong>初始化</strong>：空字符串和空模式是匹配的，因此 <code>dp[0][0] = true</code>。接着处理模式 <code>p</code> 可能匹配空字符串的情况，例如模式中的每个字符后面都有一个 ‘*’，此时可以匹配零次。</li><li><strong>状态转移</strong>：<ul><li>如果当前字符是 ‘*’，我们需要考虑两种情况：<ul><li><strong>零次匹配</strong>：忽略 ‘*’ 及其前面的字符，即 <code>dp[i][j] = dp[i][j-2]</code>。</li><li><strong>一次或多次匹配</strong>：当前字符必须匹配，并且之前的字符已经匹配，即 <code>dp[i][j] = dp[i-1][j]</code>（前提是当前字符匹配）。</li></ul></li><li>如果当前字符不是 ‘*’，则直接检查当前字符是否匹配，并继承之前的匹配状态。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.length();<br>        <span class="hljs-keyword">int</span> n = p.length();<br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 初始化第一行，处理p可能匹配空字符串的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; j &gt;= <span class="hljs-number">2</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 处理 &#x27;*&#x27; 的情况</span><br>                    <span class="hljs-comment">// 零次匹配</span><br>                    <span class="hljs-keyword">boolean</span> zeroMatch = dp[i][j - <span class="hljs-number">2</span>];<br>                    <span class="hljs-comment">// 一次或多次匹配</span><br>                    <span class="hljs-keyword">boolean</span> oneOrMore = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">2</span>) || p.charAt(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                        oneOrMore = dp[i - <span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    dp[i][j] = zeroMatch || oneOrMore;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 处理非 &#x27;*&#x27; 的情况</span><br>                    <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">1</span>) || p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分">二分</h3><p>最经典的二分查找的问题<a href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（LeetCode）</a></p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//采用代码随想录的第一种写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">//二分查找</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-comment">//mid = (left + right) / 2;  这样写可能会导致溢出，下面的这种写法会好一点</span><br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123; <br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分法寻找的时候，最应该注意的就是边界问题。</p><p><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">很经典的二分，就是题目需要的返回数据不同，下面总结了一个这类二分的模版，可以套用<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123; <span class="hljs-comment">// 注意</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 注意</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target) &#123; <span class="hljs-comment">// 注意</span><br>                <span class="hljs-comment">// 相关逻辑</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 相关返回值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//下面就是套模板的代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组 - 力扣（Leetcode）</a> 就是叫你找一个数字的下标，找到就返回下标，否则返回-1，不过是旋转后的，且要求算法时间复杂度为O(log n)</p><p>先使用暴力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(target == nums[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是可以通过的</p><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/220083/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/">33. 搜索旋转排序数组 题解</a>再来看看O(log n)的,首先想到的自然就是二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//奇怪的旋转</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] num, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = num.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//使用二分法</span><br>        <span class="hljs-comment">//注意：由于有序的一边的边界值可能等于目标值，所以判断目标值是否在有序的那边时应该加个等号</span><br>        <span class="hljs-comment">//(在二分查找某个具体值得时候如果把握不好边界值，可以再每次查找前判断下边界值，也就是while循环里面的两个if注释)</span><br>       <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-comment">// if(num[left] == target) return left;</span><br>            <span class="hljs-comment">// if(num[right] == target) return right;</span><br>           <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>; <span class="hljs-comment">//这里是为了防止栈溢出才不写成(l+r)/2</span><br>           <span class="hljs-keyword">if</span>(num[mid] == target) <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">//找到了</span><br>            <span class="hljs-comment">//左边有序</span><br>            <span class="hljs-keyword">if</span>(num[left] &lt;= num[mid])&#123;<br>                <span class="hljs-comment">//在左边</span><br>                <span class="hljs-keyword">if</span>(num[left] &lt;= target &amp;&amp; num[mid] &gt; target)&#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//右边有序</span><br>                <span class="hljs-comment">//在右边</span><br>                <span class="hljs-keyword">if</span>(num[right] &gt;= target &amp;&amp; num[mid] &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//在左边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">search</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid])&#123;<br>                <span class="hljs-comment">//在左边</span><br>                <span class="hljs-keyword">if</span>(nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target)&#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(nums[right] &gt;= target &amp;&amp; nums[mid] &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//在右边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">int</span> target = scanner.nextInt();<br>        search search = <span class="hljs-keyword">new</span> search();<br>        <span class="hljs-keyword">int</span> i = search.search(nums, target);<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/description/">剑指 Offer 11. 旋转数组的最小数字 - 力扣（Leetcode）</a></p><p>这里就是要寻找旋转后的右排序数组的第一个元素，我们将他称为旋转点</p><p>当numbers[m] &gt; numbers[j] 的时候，旋转点在右边</p><p>当numbers[m] &lt; numbers[j] 的时候，旋转点在左边</p><p>当相等的时候，是有一个证明j–是正确的，但我实在不想看了</p><p>详见这个题解<a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/102826/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">剑指 Offer 11. 旋转数组的最小数字 - 力扣题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> m;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(numbers[m] &gt; numbers[j])&#123;<br>                <span class="hljs-comment">//大于边界数字了，不可能越过旋转点</span><br>                i = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[m] &lt; numbers[j])&#123;<br>                <span class="hljs-comment">//这里如果减一的话可能会越过旋转点</span><br>                j = m;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//这里有个证明，但我不想看了</span><br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（Leetcode）</a>题意就是寻找相同数字的边界</p><p>改造后的二分，即使数组中有相同的数字，仍能找到更靠左的数字target</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//二分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> l = binarySearch(nums,target);<span class="hljs-comment">//寻找左边界</span><br>        <span class="hljs-keyword">int</span> r = binarySearch(nums,target + <span class="hljs-number">1</span>);<span class="hljs-comment">//找到有边界右边一个</span><br>        <span class="hljs-comment">//使用二分找两次</span><br>        <br>        <span class="hljs-keyword">if</span>(l == nums.length || nums[l] != target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l,r - <span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//改进版 用于返回左边界</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = nums.length;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<span class="hljs-comment">//注意没有等号</span><br>            <span class="hljs-keyword">int</span> mid = l + (r - l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &lt;= nums[mid])&#123;<br>                <span class="hljs-comment">//这里有等号 即使右边找到也不返回，而是继续找，直到返回左边的</span><br>                <span class="hljs-comment">//用于防止5,7,7,8,8,10 两个数字相邻，也是返回左边界</span><br>               r = mid;<span class="hljs-comment">//这里没有加一</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               l = mid + <span class="hljs-number">1</span>;;<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">searchRange</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> l = binarySearch(nums,target);<span class="hljs-comment">//寻找左边界</span><br>        <span class="hljs-keyword">int</span> r = binarySearch(nums,target + <span class="hljs-number">1</span>);<span class="hljs-comment">//找到有边界右边一个</span><br>        <span class="hljs-comment">//使用二分找两次</span><br><br>        <span class="hljs-keyword">if</span>(l == nums.length || nums[l] != target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l,r - <span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//改进版 用于返回左边界</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = nums.length;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<span class="hljs-comment">//注意没有等号</span><br>            <span class="hljs-keyword">int</span> mid = l + (r - l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &lt;= nums[mid])&#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = mid + <span class="hljs-number">1</span>;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        searchRange searchRange = <span class="hljs-keyword">new</span> searchRange();<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">int</span> target = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] ints = searchRange.searchRange(nums, target);<br>        System.out.println(Arrays.toString(ints));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一道查询的题<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240. 搜索二维矩阵 II - 力扣（Leetcode）</a></p><p>思路：是有序的数组，很明显就会想到使用二分的方法进行查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>        <span class="hljs-comment">//这一行的第一个元素已经大于target了，但仍然没有找到，说明后面都没有了，返回false</span><br>        <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] &gt; target) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//说明这一行是没有当前target元素的，直接去下一行</span><br>        <span class="hljs-keyword">if</span>(matrix[i][matrix[i].length - <span class="hljs-number">1</span>] &lt; target)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <br>        <span class="hljs-keyword">int</span> col = binarySearch(matrix[i], target);<br>        <span class="hljs-keyword">if</span> (col != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>        <span class="hljs-comment">//这里值得注意一下，&gt;&gt;&gt;1相当于除以2</span><br>        <span class="hljs-keyword">int</span> mid = (start + end) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            start = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            end = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">4. 寻找两个正序数组的中位数 - 力扣（Leetcode）</a></p><p>先来看看暴力的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = nums1.length;<br>        <span class="hljs-keyword">int</span> n = nums2.length;<br>        <span class="hljs-keyword">int</span>[] newnums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + n];<br>        <span class="hljs-comment">//先进行特判看看是否有哪个数组是空的</span><br>        <span class="hljs-comment">//数组1为空</span><br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> (nums2[n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + nums2[n / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> nums2[n / <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//数组2为空</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(m % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> (nums1[m / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + nums1[m / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> nums1[m / <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span>(count &lt; (m + n))&#123;<br>            <span class="hljs-keyword">if</span>(i == m)&#123;<br>                <span class="hljs-keyword">while</span>(j != n)&#123;<br>                    newnums[count++] = nums2[j++];<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(j == n)&#123;<br>                <span class="hljs-keyword">while</span>(i != m)&#123;<br>                    newnums[count++] = nums1[i++];<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums1[i] &lt; nums2[j])&#123;<br>                newnums[count++] =  nums1[i++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                newnums[count++] =  nums2[j++];<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">if</span>(count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> (newnums[count / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + newnums[count / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> newnums[count / <span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>        <br><br>&#125;<br></code></pre></td></tr></table></figure><p>二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums1.length;<br>    <span class="hljs-keyword">int</span> m = nums2.length;<br>    <span class="hljs-keyword">int</span> left = (n + m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> right = (n + m + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span><br>    <span class="hljs-keyword">return</span> (getKth(nums1, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, left) + getKth(nums1, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, right)) * <span class="hljs-number">0.5</span>;  <br>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> start1, <span class="hljs-keyword">int</span> end1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> start2, <span class="hljs-keyword">int</span> end2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len1 = end1 - start1 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len2 = end2 - start2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span><br>        <span class="hljs-keyword">if</span> (len1 &gt; len2) <span class="hljs-keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);<br>        <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[start1], nums2[start2]);<br><br>        <span class="hljs-keyword">int</span> i = start1 + Math.min(len1, k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = start2 + Math.min(len2, k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;<br>            <span class="hljs-keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="hljs-number">1</span>, end2, k - (j - start2 + <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> getKth(nums1, i + <span class="hljs-number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希">哈希</h3><p><a href="https://leetcode.cn/problems/single-number/description/">136. 只出现一次的数字 - 力扣（Leetcode）</a></p><p>题意：找出数组中只出现过一次的数字</p><p>思路：一眼哈希</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据题解优化了一下我的代码，看着更加简洁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-keyword">int</span> count = map.get(i) == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : map.get(i)+<span class="hljs-number">1</span>;<br>            map.put(i,count);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Integer i : map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(i) == <span class="hljs-number">1</span>)&#123;<br>               <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用排序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length - <span class="hljs-number">1</span>;i = i + <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">//不相同的元素在中间</span><br>            <span class="hljs-keyword">if</span>(nums[i] != nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//不相同的元素在尾部</span><br>        <span class="hljs-keyword">return</span> nums[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异或解法</p><p>思路：异或解法：异或运算满足交换律，a^b^a=a^a^b=b,因此ans相当于nums[0]^nums[1]^nums[2]^nums[3]^nums[4]… 然后再根据交换律把相等的合并到一块儿进行异或（结果为0），然后再与只出现过一次的元素进行异或，这样最后的结果就是，只出现过一次的元素（0^任意值=任意值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (nums.length &gt; <span class="hljs-number">1</span>) &#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>      ans = ans ^ nums[i];<br>   &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/">剑指 Offer 03. 数组中重复的数字 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            map.put(num,map.getOrDefault(num,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(num) &gt; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用set效率会高一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(num))&#123;<br>                <span class="hljs-keyword">return</span> num;<br>            &#125;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/majority-element/description/">169. 多数元素 - 力扣（Leetcode）</a>跟上面这道题一样的 思路，甚至代码都没有怎么变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-keyword">int</span> count = map.get(i) == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : map.get(i)+<span class="hljs-number">1</span>; <br>            map.put(i,count);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Integer i: map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(i) &gt; nums.length/<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数 - 力扣（Leetcode）</a>感觉这几个题都是差不多的，连应用哈希的方法都是差不多的，不过这一道题在上面快慢指针找出口那里有另外一种思路，可以参考参考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-comment">//找出这个数字的映射出现了几次</span><br>            <span class="hljs-keyword">int</span> count  = map.get(nums[i]) == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : map.get(nums[i]) + <span class="hljs-number">1</span>;<br>            map.put(nums[i],count);<br>        &#125;<br>        <span class="hljs-comment">//找出不是1的映射就是答案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(nums[i]) != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><p>题意：给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;anagram&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;nagaram&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;rat&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;car&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>思路：使用哈希表，记录每一次的字母的次数，一次加，一次减。最后再遍历map,如果有不为0的键，说明不是字母异位词，否则是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; t.length();j++)&#123;<br>            map.put(t.charAt(j),map.getOrDefault(t.charAt(j),<span class="hljs-number">0</span>) - <span class="hljs-number">1</span>); <br>        &#125;<br>        <span class="hljs-keyword">for</span>(Character key : map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(key) != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信 - 力扣（LeetCode）</a>这道题和上面那道题方法是一样的，都是使用map记录第一个字符串中字母出现次数，减去第二个字符串中出现的字符次数，最后再遍历一遍，如果有负数，说明不可以组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> </span>&#123;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : magazine.toCharArray())&#123;<br>            map.put(c,map.getOrDefault(c,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> d : ransomNote.toCharArray())&#123;<br>            map.put(d,map.getOrDefault(d,<span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> e : map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(e) &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><p>题意：显而易见，就是求交集，注意题目说输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</p><p>思路：分别遍历nums1和nums2，并使用set存储，中间使用contains判断一下，达到求重合的交集和去重的目的，最后set转换为数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Set&lt;Integer&gt; resset = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums1)&#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums2)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(num))&#123;<br>                resset.add(num);<br>            &#125;<br>        &#125;<br><br><span class="hljs-comment">//方法1：重新来个新数组存储</span><br>        <span class="hljs-keyword">int</span>[] resarr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[resset.size()];<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : resset)&#123;<br>            resarr[j++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resarr;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//方法2：使用流将结果集合转为数组，这个不好记</span><br><span class="hljs-keyword">return</span> resset.stream().mapToInt(Integer::intValue).toArray();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将 Set&lt;Integer&gt; 转换为 int[] 数组：</span><br><span class="hljs-comment">* 1. stream() : Collection 接口的方法，将集合转换为 Stream&lt;Integer&gt;</span><br><span class="hljs-comment">* 2. mapToInt(Integer::intValue) : </span><br><span class="hljs-comment">*    - 中间操作，将 Stream&lt;Integer&gt; 转换为 IntStream</span><br><span class="hljs-comment">*    - 使用方法引用 Integer::intValue，将 Integer 对象拆箱为 int 基本类型</span><br><span class="hljs-comment">* 3. toArray() : 终端操作，将 IntStream 转换为 int[] 数组。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p><p>题意：「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><p>思路：题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p>正如：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些</a>中所说，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-comment">//如果是不为1且还没开始重复</span><br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">1</span> &amp;&amp; !set.contains(n))&#123;<br>            se t.add(n);<br>            n = getNextNumber(n);<br>        &#125;<br>        <span class="hljs-comment">//跳出循环，判断是哪个条件跳出了循环</span><br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//有点类似于回文数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> temp = n % <span class="hljs-number">10</span>;<br>            sum += Math.pow(temp,<span class="hljs-number">2</span>);<br>            n = n / <span class="hljs-number">10</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p><p>题意：四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况</p><p>思路：首先肯定能想到的是直接暴力循环，四个for，肯定是会超时的，所以这里是一个典型的hash的题目，首先使用hashmap将前面两个数组的每个的和作为键，次数作为值存储起来，后面两个数组同理，查找相加为0的键(即前面两数组的和)，把次数相加，即是有多少次数相加为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span>[] nums3, <span class="hljs-keyword">int</span>[] nums4)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j : nums2)&#123;<br>                <span class="hljs-comment">// 遍历前两个数组，统计两个数组元素之和，和出现的次数，放到map中</span><br>                map.put(i + j , map.getOrDefault(i + j , <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k : nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l : nums4)&#123;<br>                <span class="hljs-comment">//再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span><br>                count += map.getOrDefault(- k - l, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//太暴力了</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span>[] nums3, <span class="hljs-keyword">int</span>[] nums4)</span> </span>&#123;<br>        <span class="hljs-comment">//如果是四层for循环</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j : nums2)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k : nums3)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l : nums4)&#123;<br>                        <span class="hljs-keyword">if</span>(i + j + k + l == <span class="hljs-number">0</span>)&#123;<br>                            count++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="搜索">搜索</h3><p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/">剑指 Offer 04. 二维数组中的查找 - 力扣（Leetcode）</a></p><p>给定一个二维数组，从左往右不递减，从上往下不递减，给出一个搜索target最高效的方法</p><p>我自己的逐行搜素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; matrix.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; matrix[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大佬的思路：将这个图翻转一下，就可以获得一个类似二叉搜索树的结构，我们在根节点设置一个标志位，当target大于标志位的时候说明target在标志位列右侧，这时可以消去标志位所在的列。当target大于标志位的时候说明target在标志位行上侧，这时可以消去标志位所在的行。来个具体题解<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solutions/95306/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">剑指 Offer 04. 二维数组中的查找 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; matrix[<span class="hljs-number">0</span>].length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) i--;<span class="hljs-comment">//消去所在行</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) j++;<span class="hljs-comment">//消去所在列</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和">前缀和</h3><p><a href="https://kamacoder.com/problempage.php?pid=1070">58. 区间和</a>题意：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</p><p>输入描述</p><p>第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。</p><p>输出描述</p><p>输出每个指定区间内元素的总和。</p><p>思路：整个题没有什么难度，需要学习的就是可以使用前缀和这种方法来进行计算，数组里面存储的是和，而不是输入的数字；思路如下</p><p><img src="https://file.kamacoder.com/pics/20240627111319.png" alt="前缀和"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> LeetCodehot;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Mercury</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2025-05-13 16:17</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rangesum</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>            Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            <span class="hljs-keyword">int</span> n = sc.nextInt();<br>            <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//多留了一个位置0，防止后面减的时候越界</span><br>            nums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>                <span class="hljs-keyword">int</span> num = sc.nextInt();<br>                nums[i] = nums[i - <span class="hljs-number">1</span>] + num; <span class="hljs-comment">//把每一个数和前面的和加起来</span><br>            &#125;<br>            <span class="hljs-keyword">while</span>(sc.hasNextInt())&#123;<br>                <span class="hljs-keyword">int</span> start = sc.nextInt();<br>                <span class="hljs-keyword">int</span> end = sc.nextInt();<br>                <span class="hljs-keyword">int</span> res = nums[end+<span class="hljs-number">1</span>] - nums[start];<span class="hljs-comment">//减去开始区间前面的和</span><br>                System.out.println(res);<br>            &#125;<br>        &#125;<br><br>&#125;<br><br><br><span class="hljs-comment">//另一种写法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            nums[i] = sc.nextInt();<br>            sum += nums[i];<br>            sums[i] = sum;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(sc.hasNextInt())&#123;<br>            <span class="hljs-keyword">int</span> start = sc.nextInt();<br>            <span class="hljs-keyword">int</span> end = sc.nextInt();<br>            <span class="hljs-keyword">int</span> res;<br>            <span class="hljs-keyword">if</span>(start == <span class="hljs-number">0</span>)&#123;<br>                res = sums[end]; <br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res = sums[end] - sums[start - <span class="hljs-number">1</span>];<br>            &#125;<br>            System.out.println(res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://kamacoder.com/problempage.php?pid=1044">44. 开发商购买土地</a></p><p>题意：简单的说，就是一个二维数组，只能横着或者竖着切一刀，分成两个区域，问怎么切，这两个区域的里面分别的和相差最小，打印出最小相差值</p><p>思路：和上面那道题一样，也是使用前缀和，不过这里不同的是，把每一行和每一列的前缀和分别计算出。然后再计算暴力计算(循环)按行切或者按列切的最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> LeetCodehot;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Mercury</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2025-05-14 17:46</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">buyLand</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span> m = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[][] value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>                value[i][j] = sc.nextInt();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//统计每行</span><br>        <span class="hljs-keyword">int</span>[] horizon = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>                horizon[i] += value[i][j];<br>            &#125;<br>            <span class="hljs-comment">//只计算第一行后面的，防止数组越界</span><br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) horizon[i] = horizon[i] + horizon[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//统计每列</span><br>        <span class="hljs-keyword">int</span>[] vertical = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>                vertical[j] += value[i][j];<br>            &#125;<br>            <span class="hljs-comment">//只计算第一列后面的，防止数组越界</span><br>            <span class="hljs-keyword">if</span>(j != <span class="hljs-number">0</span>) vertical[j] = vertical[j] + vertical[j - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//按行切</span><br>        <span class="hljs-keyword">int</span> horizonMin = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">int</span> horizenA = horizon[i];<br>            <span class="hljs-keyword">int</span> horizenB = horizon[n - <span class="hljs-number">1</span>] - horizon[i];<br>            horizonMin = Math.min(horizonMin,Math.abs(horizenA - horizenB));<br>        &#125;<br><br>        <span class="hljs-comment">//按列切</span><br>        <span class="hljs-keyword">int</span> verticalMin = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>            <span class="hljs-keyword">int</span> verticalA = vertical[j];<br>            <span class="hljs-keyword">int</span> verticalB = vertical[m - <span class="hljs-number">1</span>] - vertical[j];<br>            verticalMin = Math.min(verticalMin,Math.abs(verticalA - verticalB));<br>        &#125;<br>        System.out.println(Math.min(horizonMin,verticalMin));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="不成系列的方法">不成系列的方法</h3><p><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a>力扣第一题，找到相加等于target的目标值，直接暴力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">twosum</span> </span>&#123;<br><span class="hljs-comment">//    输入：nums = [2,7,11,15], target = 9</span><br><span class="hljs-comment">//    输出：[0,1]</span><br><span class="hljs-comment">//    解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; nums.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)&#123;<br>                    result[<span class="hljs-number">0</span>] = i;<br>                    result[<span class="hljs-number">1</span>] = j;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//输入部分</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// 读取数组长度</span><br>        <span class="hljs-keyword">int</span> length = scanner.nextInt();<br><br>        <span class="hljs-comment">// 读取数组元素</span><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">// 读取目标值</span><br>        <span class="hljs-keyword">int</span> target = scanner.nextInt();<br>        System.out.println(Arrays.toString(twoSum(nums,target)));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/next-permutation/description/">31. 下一个排列 - 力扣（Leetcode）</a></p><p>我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。</p><p>思路：</p><ul><li>首先从后向前查找第一个顺序对(i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为a[i]。此时 [i+1,n) 必然是下降序列。</li><li>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素j 满足 a[i]&lt;a[j]。这样「较大数」即为 a[j]。</li><li>交换a[i] 与 a[j]，此时可以证明区间[i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</li></ul><p>直接的思路有点抽象，还是看图比较直观<a href="https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">包含题解的图</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//i ：小数  k ：大数</span><br>    <span class="hljs-keyword">int</span> n = nums.length, i = n - <span class="hljs-number">1</span>, j = i, k = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//从后向前找到第一个相邻升序的元素对</span><br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>        i--;<br>    &#125;<br>    <span class="hljs-comment">//没进if说明已经是最大排列了，直接整个倒过来</span><br>    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//找到i-1后续中第一个大于nums[i-1]的数</span><br>        <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; nums[j] &lt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//交换</span><br>        <span class="hljs-keyword">int</span> temp = nums[i - <span class="hljs-number">1</span>];<br>        nums[i - <span class="hljs-number">1</span>] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">//将i后面的数变为升序</span><br>    <span class="hljs-keyword">while</span>(i &lt; k)&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        nums[i++] = nums[k];<br>        nums[k--] = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">nextPermutation</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length, i = n - <span class="hljs-number">1</span>, j = i, k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; nums[j] &lt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">int</span> temp = nums[i - <span class="hljs-number">1</span>];<br>            nums[i - <span class="hljs-number">1</span>] = nums[j];<br>            nums[j] = temp;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &lt; k)&#123;<br>            <span class="hljs-keyword">int</span> temp = nums[i];<br>            nums[i++] = nums[k];<br>            nums[k--] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        nextPermutation(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            System.out.print(nums[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/rotate-image/description/">48. 旋转图像 - 力扣（Leetcode）</a>旋转图像</p><p>思路：虽然题目要求需要原地旋转，但是是可以使用辅助数组的</p><p>参考题解：<a href="https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/">48. 旋转图像 题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//辅助矩阵</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] newMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length][matrix[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; matrix.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; matrix[<span class="hljs-number">0</span>].length;j++)&#123;<br>                newMatrix[j][matrix[<span class="hljs-number">0</span>].length - i -<span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; matrix.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; matrix[<span class="hljs-number">0</span>].length;j++)&#123;<br>                 matrix[i][j] = newMatrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//原地修改</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-comment">//奇偶有所不同</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;j++)&#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-j][i];<br>                matrix[n-<span class="hljs-number">1</span>-j][i] = matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j];<br>                matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j] = matrix[j][n-<span class="hljs-number">1</span>-i];<br>                matrix[j][n-<span class="hljs-number">1</span>-i] = temp;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rotate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-comment">//奇偶有所不同</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;j++)&#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-j][i];<br>                matrix[n-<span class="hljs-number">1</span>-j][i] = matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j];<br>                matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j] = matrix[j][n-<span class="hljs-number">1</span>-i];<br>                matrix[j][n-<span class="hljs-number">1</span>-i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                matrix[i][j] = sc.nextInt();<br>            &#125;<br>        &#125;<br><br>        rotate r = <span class="hljs-keyword">new</span> rotate();<br>        r.rotate(matrix);<br>        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            System.out.print(Arrays.toString(matrix[i]) + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/group-anagrams/description/">49. 字母异位词分组 - 力扣（Leetcode）</a></p><p>题意：找出字母一样但是顺序不一样的单词</p><p>思路：每个单词的字母都是一样的，那么使用排序后，字母的顺序也一定是一样的，将其作为key，然后在map里面使用ArrayList存上所有这个单词的异型单词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//寻找字母一样的单词？</span><br><br>    <span class="hljs-comment">//一样的字母，排序后是一样的，就可以作为哈希表的键</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map =  <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String s:strs)&#123;<br>            <span class="hljs-keyword">char</span>[] array = s.toCharArray();<span class="hljs-comment">//先转换为数组</span><br>            Arrays.sort(array);<span class="hljs-comment">//没有返回值</span><br>            String key = <span class="hljs-keyword">new</span> String(array);<span class="hljs-comment">//排序后再转换为字符串</span><br>            <span class="hljs-comment">//类似拉链法</span><br>            List&lt;String&gt; list = map.getOrDefault(key,<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>            <span class="hljs-comment">//这个函数是返回key，或是返回一个默认值，这里不能直接使用get，否则后面可能会空指针异常</span><br>            list.add(s);<br>            map.put(key,list);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">groupAnagrams</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String str:strs)&#123;<br>            <span class="hljs-keyword">char</span>[] array =  str.toCharArray();<br>            Arrays.sort(array);<span class="hljs-comment">//没有返回值</span><br>            String key = Arrays.toString(array);<br>            List&lt;String&gt; list = map.getOrDefault(key,<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>            list.add(str);<br>            map.put(key,list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//eat tea tan ate nat bat</span><br>        <span class="hljs-comment">//[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一组字符串，用空格分隔:&quot;</span>);<br>        String input = scanner.nextLine();<br>        String[] strs = input.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        System.out.println(groupAnagrams.groupAnagrams(strs));<br><br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221101110128794.png" alt="image-20221101110128794"></p><p><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间 - 力扣（Leetcode）</a></p><p>思路：按照左端点排序后，依次遍历比较结果集合中最右边的的端点值</p><ul><li>当前这个数组左端点比集合中最右边的右端点大，直接加入集合，在最右边</li><li>否则，重合，需要将其合并，合并的方法就是比较右端点的值，把较大的右端点值作为新的右端点值更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals)&#123;<br>        <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//数组为空则返回一个新的数组回去</span><br>        &#125;<br>        Arrays.sort(intervals,<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1,<span class="hljs-keyword">int</span>[] interval2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">0</span>] - interval2[<span class="hljs-number">0</span>]; <span class="hljs-comment">//按照左端端点的升序排序</span><br>                <span class="hljs-comment">//这里可以使用lamba简化，为了方便理解，没有简化</span><br>            &#125;<br>        &#125;);<br><br><br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; intervals.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> l = intervals[i][<span class="hljs-number">0</span>],r = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//如果为空，或者当前数组左端点大于集合最右边集合的右端点，直接加入最右边</span><br>            <span class="hljs-keyword">if</span>(merged.isEmpty() || merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; l)&#123;<br>                merged.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l,r&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//更新最右边的节点</span><br>                merged.get(merged.size() -<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], r);<br>            &#125;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[merged.size()][]);<br>        <span class="hljs-comment">//集合转换为数组，并将其填充在new的新数组中</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">merge</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">//lamba表达式 左端点的升序排序</span><br>        Arrays.sort(intervals,(o1, o2)-&gt;&#123;<span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];&#125;);<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; intervals.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> l = intervals[i][<span class="hljs-number">0</span>],r = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(merged.size() == <span class="hljs-number">0</span> || l &gt; merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//加入最右端</span><br>                merged.add(intervals[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//更新最右端</span><br>                merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>],r);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//传入0也可以,toArray()会自动设置merged集合的长度</span><br>        <span class="hljs-comment">//当T泛型的长度没有list的size大时，会以size长度返回T；否则，使用传入的T。所以使用时不管写0还是其它数字，都没关系，习惯写0。</span><br>        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">//传入数组的数量</span><br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[][] intervals = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-comment">//传入数组的元素</span><br>            <span class="hljs-keyword">int</span> l = sc.nextInt();<br>            <span class="hljs-keyword">int</span> r = sc.nextInt();<br>            intervals[i][<span class="hljs-number">0</span>] = l;<br>            intervals[i][<span class="hljs-number">1</span>] = r;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[][] res = merge(intervals);<br>        <span class="hljs-comment">//可以直接将二维数组转换为字符串</span><br>        System.out.println(Arrays.deepToString(res));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积 - 力扣（Leetcode）</a>像是dp，但是好像又不是dp</p><p>题意：由题目的名字很容易就可以看出，是求除了这个数字外的数组乘积，值得注意的是，这里题目规定了不能使用除法，并且需要使用时间复杂度为O(n)的算法,这个题解也很好，值得一看<a href="https://leetcode.cn/problems/product-of-array-except-self/solutions/272369/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/">238. 除自身以外数组的乘积-题解</a></p><p>思路：将该数字前的数字乘积相乘，后面的数字相乘，最终再乘一次，得出最终答案。这样求左边数字乘积的时候遍历一遍，右边的时候遍历一遍，最终再遍历一遍，一共遍历三遍，成功在O(n)的复杂度下求出了结果</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221121113055118.png" alt="求左边的前缀乘积"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span>[] L = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span>[] R = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <br>        <span class="hljs-comment">//求左边的前缀乘积</span><br>        L[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//左边没有元素，初始化为1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ;i&lt;nums.length;i++)&#123;<br>            L[i] = L[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<span class="hljs-comment">//将前一个位置的左边乘积，和前一个数字相乘就是现在位置左边的乘积</span><br>        &#125;<br>        <span class="hljs-comment">//求右边的后缀乘积</span><br>        <span class="hljs-comment">//原理同上，需要注意的就是这里的i不要忘记还有一个=0</span><br>        R[nums.length-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            R[i] = R[i+<span class="hljs-number">1</span>] * nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//求出最终答案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            ans[i] = L[i] * R[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化空间复杂度：</p><p>只使用一个ans数组，先将之前的前缀乘积直接就存储到ans中，后面的后缀乘积使用变量R不断更新，同时也乘进ans数组中，这样就只使用一个数组且减少了一次循环完成了题目，因为题目说输出数组不算进空间复杂度中，因此这里的空间复杂度是O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <br>        <span class="hljs-comment">//求左边的前缀乘积</span><br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ;i&lt;nums.length;i++)&#123;<br>            ans[i] = ans[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//求右边的后缀乘积并同时合并到之前的前缀乘积中求出最终答案</span><br>        <span class="hljs-keyword">int</span> R = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            R = R * nums[i+<span class="hljs-number">1</span>];<br>            ans[i] = ans[i] * R;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（Leetcode）</a></p><p><strong>注意</strong>：如果遇到这种数对，还涉及到排序的，根据第一个降序，第二个升序或者第一个升序，第二个降序，往往能简化结题过程。</p><p>这道题的核心的思想就是  <strong>高的是看不见低的</strong>，因此我们可以先排列好高的，后面再插入低的时候，低元素的插入不会对高元素的第二个值(也就是前面有几个人身高大等于我)造成影响，因此，我们先按照身高(第一个值)进行降序排序，然后挨个插入，而因为题目要求的是第二值代表的前面有几个人身高大等于我，因此这里的第二值我们需要按照升序排序，这样挨个插入的时候，才不会对前面已经插入的值造成影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;<br>        Arrays.sort(people,(x,y)-&gt;&#123;<br>            <span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>] != y[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-comment">//第一个元素降序</span><br>                <span class="hljs-keyword">return</span> y[<span class="hljs-number">0</span>] - x[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//第二个元素升序</span><br>                <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] - y[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; people.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(list.size() &gt; people[i][<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//插入到第people[i][1]个位置上</span><br>                list.add(people[i][<span class="hljs-number">1</span>],people[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//加到队尾</span><br>                list.add(people[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//转化为二维数组</span><br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">448. 找到所有数组中消失的数字 - 力扣（Leetcode）</a>一道简单题</p><p>思路：就是普通的使用哈希，没有啥特别的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span>  HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> count = map.get(nums[i]) == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : map.get(nums[i]) + <span class="hljs-number">1</span>;<br>            map.put(nums[i],count);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(i) == <span class="hljs-keyword">null</span>)&#123;<br>                list.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/description/">剑指 Offer 14- I. 剪绳子 - 力扣（Leetcode）</a></p><p>题意简单的来说就是将一个数字分成m段，然后将这m段的长度相乘，问最大的值是多少。</p><p>这里可以采用数学求导的方法来做，经过一系列的数学求导计算，将每段分成3是最大的，如果有余数，余数是1的时候，将前一段3和1转变为2和2乘积会更大。如果最后一段是2，最后就乘以2.</p><p>详细的证明可以参考这里<a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/solutions/">剑指 Offer 14- I. 剪绳子 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-comment">//b == 2</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/description/">剑指 Offer 14- II. 剪绳子 II - 力扣（Leetcode）</a></p><p>升级版，将n值扩大了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写的时候总是会溢出，需要换成long并且在最后的答案中还是需要再取余然后再转换</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)((remainder(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>, <span class="hljs-number">1000000007</span>) * <span class="hljs-number">3</span>) % p);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)((remainder(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>, <span class="hljs-number">1000000007</span>) * <span class="hljs-number">4</span>) % p);<br>        <span class="hljs-comment">//b == 2</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)((remainder(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>, <span class="hljs-number">1000000007</span>) * <span class="hljs-number">6</span>) % p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">remainder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a; i++)&#123;<br>            res = (res * num) % p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优雅一点的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">long</span> ret = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lineNums=n/<span class="hljs-number">3</span>;           <span class="hljs-comment">//线段被我们分成以3为大小的小线段个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;lineNums;i++) <span class="hljs-comment">//从第一段线段开始验算，3的ret次方是否越界。注意是验算lineNums-1次。</span><br>            ret = <span class="hljs-number">3</span>*ret % p;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(ret * <span class="hljs-number">3</span> % p);   <span class="hljs-comment">//刚好被3整数的，要算上前一段</span><br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(ret * <span class="hljs-number">4</span> % p);   <span class="hljs-comment">//被3整数余1的，要算上前一段</span><br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(ret * <span class="hljs-number">6</span> % p);       <span class="hljs-comment">//被3整数余2的，要算上前一段</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/description/">剑指 Offer 17. 打印从1到最大的n位数 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-comment">//先生成末尾的数字</span><br>        <span class="hljs-keyword">int</span> end = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; end; i++)<br>            res[i] = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>阿里笔试第二题</p><p>题目：输入一个数组，比如[9, 9, 9, 1] ,每次只能改变各个数字的二进制数的一位，求把数组里面的数字全部变成一样最少需要多少次操作。</p><p>思路：统计数组里面的数字在二进制数的各个位上的情况，因为是二进制，所以只有两种情况0和1，如果这个位上1多，就把剩下的0改成1，这就是这一位上的最少操作数，反之，就把1改成0，后面的位亦然。总结就是把每一位上0和1中较少的次数相加，就是最终最少的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Mercury</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2023-04-12 16:54</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">alino2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">int</span> x = sc.nextInt();<br>            add(x, b);<br>        &#125;<br>        <br>        <span class="hljs-comment">//找到1和0中位数比较少的那一位，相加起来</span><br>        <span class="hljs-comment">//因为只有0和1两种情况，所以只要1的数量大于了一半就把剩下的0改成1，这需要n - b[i]次操作次数</span><br>        <span class="hljs-comment">//反之，就把1改成0，这需要b[i]次操作次数</span><br>        <span class="hljs-keyword">double</span> mid = n / <span class="hljs-number">2.0</span>;<br>       <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (b[i] &gt; mid) &#123;<br>                sum += n - b[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += b[i];<br>            &#125;<br>        &#125;<br><br>        System.out.println(sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;<br>        <span class="hljs-comment">//计算数组中用二进制表示的数字在各位上的分布情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> j = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//右移i位然后再与1 取出二进制位</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>) &#123;<br>                b[i]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//in  4    9 9 9 9</span><br><span class="hljs-comment">//out 0</span><br><br><span class="hljs-comment">//in  4    9 9 9 8</span><br><span class="hljs-comment">//out 1</span><br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a>题意简单的来说是按照螺旋的线对数组进行填充</p><p>这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20250509173746577.png" alt="image-20250509173746577"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">int</span> startX = <span class="hljs-number">0</span>,startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> loop = <span class="hljs-number">0</span>; <span class="hljs-comment">//第几圈，为了和offset搭配使用</span><br>        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">//距离边边的距离</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//要填充的数字</span><br>        <span class="hljs-keyword">int</span> i,j; <span class="hljs-comment">// j 代表列, i 代表行;</span><br>        <span class="hljs-keyword">while</span>(loop &lt; n / <span class="hljs-number">2</span>)&#123;<br>            i = startY;<br>            j = startX;<br>            <span class="hljs-comment">//顶部</span><br>            <span class="hljs-keyword">for</span>(; j &lt; n - offset; j++)&#123;<br>                nums[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">//右边</span><br>            <span class="hljs-keyword">for</span>(; i &lt; n - offset; i++)&#123;<br>                nums[i][j]  = count++;<br>            &#125;<br>            <span class="hljs-comment">//底边</span><br>            <span class="hljs-keyword">for</span>(;j &gt; startX; j--)&#123;<br>                nums[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">//左边</span><br>            <span class="hljs-keyword">for</span>(;i &gt; startY; i--)&#123;<br>                nums[i][j] = count++;<br>            &#125;<br>            startX++;<br>            startY++;<br>            loop++;<br>            offset++;<br>        &#125;<br>        <span class="hljs-comment">//对奇数矩阵的最里面的一个数字进行单独处理</span><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                nums[startY][startX] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS">DFS</h2><h3 id="DFS回溯">DFS回溯</h3><p>注意回溯的模板</p><p>① 画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※<br>② 根据题意，确立结束条件<br>③ 找准选择列表(与函数参数相关),与第一步紧密关联※<br>④ 判断是否需要剪枝<br>⑤ 作出选择，递归调用，进入下一层<br>⑥ 撤销选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">main&#123;<br>    dfs(...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(...)</span></span>&#123;<br>    <span class="hljs-comment">//满足条件返回</span><br>    <span class="hljs-keyword">if</span>(..)&#123;<br>        res.add(path)<span class="hljs-comment">//添加到最终答案中</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        path.add()<span class="hljs-comment">//添加元素</span><br>        dfs()<br>        path.remove()<span class="hljs-comment">//回溯</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><p>很经典的回溯的样本题</p><p>这里再贴一个挺好的讲解：<a href="https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88.html">代码随想录-77组合</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>       backtracking(n,k,<span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//通过加入startIndex来避免重复</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == k)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = startIndex; i &lt;= n;i++)&#123;<br>            path.add(i);<br>            backtracking(n,k,i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III - 力扣（LeetCode）</a></p><p>模板都是类似的，这里不再详细写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n) &#123;<br>        backtracking(k,n,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; n)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = startIndex;i &lt;= <span class="hljs-number">9</span>;i++)&#123;<br>            path.add(i);<br>            backtracking(k,n,sum+i,i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和 - 力扣（Leetcode）</a>感觉蛮经典的一个DFS，题意是可以无限次的使用规定的数组，使他们加起来和等于target，问一共有几种组合</p><p>思路：使用DFS不断回溯，每次减去一个数组里面的数，直到最后等于0或者小于0，其中等于0走过的路径就是我们需要的组合。就如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221029113113621.png" alt="image-20221029113113621"></p><p>但是有一个问题就是，这中间走过的路径是会重复的比如 [2,2,3] 和 [3,2,2]，为了解决这个问题，可以想到set事后去重，但是好像有点难搞，我们可以在遍历的时候就去重，如下图所示，后面每次的走的时候就不去走前面的数组就行，这里可以使用一个begin来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221029113138250.png" alt="image-20221029113138250"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//找出和为target的所有组合</span><br>    <span class="hljs-comment">//搜索回溯 dfs</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> len = candidates.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">//特值判断</span><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">//双端队列 用来存储经过的路径</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        dfs(candidates,<span class="hljs-number">0</span>,len,target,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> len,<span class="hljs-keyword">int</span> target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//说明不是刚好等于target，舍弃</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//注意这里的begin是为了去重</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin;i&lt;len;i++)&#123;<br>            <span class="hljs-comment">//往下走一步</span><br>            path.add(candidates[i]);<br><br>            dfs(candidates,i,len,target - candidates[i],path,res);<br>            <span class="hljs-comment">//回溯</span><br>            path.removeLast();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//使用相加</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(); <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        backtracking(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> sum,<span class="hljs-keyword">int</span> idx)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = idx;i&lt;candidates.length;i++)&#123;<br>            path.add(candidates[i]);<br>            backtracking(candidates,target,candidates[i]+sum,i);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">combinationSum</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-comment">//特值判断</span><br>        <span class="hljs-keyword">if</span>(candidates.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>,candidates,target,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;<br>        <span class="hljs-comment">//出口</span><br>        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//可以直接添加进去</span><br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin;i &lt; candidates.length;i++)&#123;<br>            path.add(candidates[i]);<br>            dfs(i,candidates,target-candidates[i],path,res);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> len = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] candidates = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            candidates[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">int</span> target = scanner.nextInt();<br>        List&lt;List&lt;Integer&gt;&gt; res = combinationSum(candidates,target);<br>        System.out.println(res);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>、</p><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p><p>题意：这道题和上面那道题类似，但是<strong>每种</strong>数字只能使用一次，给的数组里面可能会有重复的数字</p><p>因此，需要对最后的结果进行去重，这里采用的方法是，使用一个标记的数组used，</p><p>“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。注意是同一层上！！！</p><p>这里需要细细的去理解一下：<a href="https://www.programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">组合总和2</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(); <br>    <span class="hljs-keyword">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[candidates.length];<br>        <span class="hljs-comment">// 加标志数组，用来辅助判断同层节点是否已经遍历</span><br>        Arrays.fill(used, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 为了将重复的数字都放到一起，所以先进行排序</span><br>        Arrays.sort(candidates);<br>        backtracking(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> sum,<span class="hljs-keyword">int</span> idx)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = idx;i&lt;candidates.length;i++)&#123;<br>            <span class="hljs-comment">// 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过</span><br>            <span class="hljs-comment">//candidatest[=candidates[i-1]说明有两个相同的元素，而used[i-1]为1，说明同一树枝上有两个重复的元素candidates[1]和candidates[O]，可以重复选取</span><br>            <span class="hljs-comment">//candidatest[=candidates[i-1]说明有两个相同的元素，而used[i-1]为0，说明同一层上有两个重复的元素candidates[1]和candidates[O]，不可以重复选取</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-keyword">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-keyword">true</span>;<br>            path.add(candidates[i]);<br>            <span class="hljs-comment">// 每个节点仅能选择一次，所以从下一位开始</span><br>            backtracking(candidates,target,candidates[i]+sum,i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>            used[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><p><strong>切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251027151405641.png" alt="image-20251027151405641"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;<br>        List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(), result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> start, List&lt;String&gt; current, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经处理完整个字符串，将当前分割方案加入结果</span><br>        <span class="hljs-keyword">if</span> (start == s.length()) &#123;<br>            result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(current));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 尝试所有可能的分割点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = start; end &lt; s.length(); end++) &#123;<br>            <span class="hljs-comment">// 检查从start到end的子串是否是回文</span><br>            <span class="hljs-keyword">if</span> (isPalindrome(s, start, end)) &#123;<br>                <span class="hljs-comment">// 如果是回文，加入当前路径</span><br>                current.add(s.substring(start, end + <span class="hljs-number">1</span>));<br>                <span class="hljs-comment">// 递归处理剩余部分</span><br>                backtrack(s, end + <span class="hljs-number">1</span>, current, result);<br>                <span class="hljs-comment">// 回溯，移除当前选择</span><br>                current.remove(current.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针法判断是否是回文</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br>  <br><br><span class="hljs-comment">//other version</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;<br>        List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;String&gt; current = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        backtracking(s, <span class="hljs-number">0</span>, current, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> start, Deque&lt;String&gt; current , List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(start == s.length())&#123;<br>            result.add(<span class="hljs-keyword">new</span> ArrayList(current));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i &lt; s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(isPalindrome(s,start,i))&#123;<br>                current.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>                backtracking(s, i + <span class="hljs-number">1</span>, current, result);<br>                current.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br>  <br><br></code></pre></td></tr></table></figure><p><strong>全排列</strong></p><p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（Leetcode）</a></p><p>题意：找出数组里面数字的全部排列组合，一眼丁真鉴定为dfs</p><p>思路：因为全排列的数字顺序不同也可以看作一个答案，所以这里采用的是used数组来判定是否使用过该元素，且原数组没有重复元素，所以不需要剪枝</p><p>需要想清楚和组合问题的区别，排列问题，for循环里不用startIndex因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//dfs</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录现在排列了几个了</span><br>        <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<span class="hljs-comment">//记录现在那几个元素是使用了的</span><br>        dfs(nums,res,path,<span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; res,Deque&lt;Integer&gt; path,<span class="hljs-keyword">int</span> length,<span class="hljs-keyword">int</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(length &gt;= nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<span class="hljs-comment">//已经全部排列好了，返回结果</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] != <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果不用这个会导致多出例如[1,1,1] [1,1,2]这样的重复数字结果</span><br>                path.add(nums[i]);<br>                used[i]++;<br>                dfs(nums,res,path,length+<span class="hljs-number">1</span>,used);<span class="hljs-comment">//继续dfs</span><br>                used[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span><br>                path.removeLast();<span class="hljs-comment">//回溯</span><br>            &#125;    <br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br> <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt;  res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;Integer&gt; path =  <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        dfs(res,path,nums,nums.length,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res,Deque&lt;Integer&gt; path,<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> length,<span class="hljs-keyword">int</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] != <span class="hljs-number">1</span>)&#123;<br>                path.add(nums[i]);<br>                used[i] = <span class="hljs-number">1</span>;<br>                dfs(res,path,nums,length,used);<br>                used[i] = <span class="hljs-number">0</span>;<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        permute p = <span class="hljs-keyword">new</span> permute();<br>        List&lt;List&lt;Integer&gt;&gt; lists = p.permute(nums);<br><br>        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; lists.size();i++)&#123;<br>            System.out.print(Arrays.toString(lists.get(i).toArray()) + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;]&quot;</span>);<br><br>    &#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        Arrays.fill(used,<span class="hljs-number">0</span>);<br>        backtrack(res, path, nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-number">1</span>;<br>            path.add(nums[i]);<br>            backtrack(res,path,nums,used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a></p><p>题意：和前面的全排列是类似的，只不过里面有了重复数，至于去重的原理和前面的组合问题的去重也是一样的，先排序，然后使用uesd数组进行判断</p><p>具体的判断逻辑和之前的也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>       List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        Arrays.fill(used,<span class="hljs-number">0</span>);<br>        Arrays.sort(nums);<br>        backtrack(res, path, nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-number">1</span>;<br>            path.add(nums[i]);<br>            backtrack(res,path,nums,used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子集<a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（Leetcode）</a></p><p>鉴定为回溯，这里再贴一个很好的题解<a href="https://leetcode.cn/problems/subsets/solutions/229569/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">78. 子集 - 力扣题解</a></p><p>题意：找出一个数组里的所有子集</p><p>思路：这里依然使用的是start,因为题中说数组里没有重复的元素，所以没有剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res  = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<span class="hljs-comment">//不能重合的时候需要start来保证每次不遍历之前已经遍历过的数</span><br>        dfs(res,path,nums,start);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res,Deque&lt;Integer&gt; path,<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() &gt; nums.length)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i &lt; nums.length;i++)&#123;<br>            path.add(nums[i]);<br>            dfs(res,path,nums,i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subsets</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(nums, <span class="hljs-number">0</span>, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() &gt;= nums.length)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;<br>            path.addLast(nums[i]);<br>            dfs(nums, i + <span class="hljs-number">1</span>, path, res);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> len = sc.nextInt();<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            nums[i] = sc.nextInt();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; result = subsets(nums);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II - 力扣（LeetCode）</a></p><p>题意：和上面的组合总数类似，因为给定的数组里面有重复的元素，也是需要在同一层的树上进行去重，去重的原理就是使用used数组进行判断，具体可以参考题解：<a href="https://www.programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#%E6%80%9D%E8%B7%AF">代码随想录-子集II</a></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251103140117237.png" alt="image-20251103140117237"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        Arrays.fill(used, <span class="hljs-number">0</span>);<br>        Arrays.sort(nums);<br>        backtacking(res,path,<span class="hljs-number">0</span>,nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtacking</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="hljs-keyword">int</span> startindex, <span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() &gt; nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> ArrayList(path));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = startindex; i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-number">1</span>;<br>            path.add(nums[i]);<br>            backtacking(res,path,i + <span class="hljs-number">1</span>, nums, used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/word-search/description/">79. 单词搜索 - 力扣（Leetcode）</a>这道题和普通的回溯有一点点的差别，这里的有四个方向，而且不用加入数组啥的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//回溯</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] check = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[board.length][board[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">int</span> pathLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//记住这里还需要遍历一遍</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">boolean</span> flag = dfs(board, pathLength, word,i, j, check);<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board,<span class="hljs-keyword">int</span> pathLength ,String word,<span class="hljs-keyword">int</span> rows,<span class="hljs-keyword">int</span> column,<span class="hljs-keyword">int</span>[][] check)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(board[rows][column] != word.charAt(pathLength))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pathLength == word.length()-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        check[rows][column] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记为已经走过</span><br>        <span class="hljs-comment">//这里是写在dfs外面的，写在里面的话，会导致第一个,也就是board[0][0]未被标记，导致答案错误</span><br>        <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++)&#123;        <br>            rows += direction[i][<span class="hljs-number">0</span>];<br>            column += direction[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(rows&gt;=<span class="hljs-number">0</span> &amp;&amp; rows&lt;=board.length - <span class="hljs-number">1</span> &amp;&amp; column &gt;= <span class="hljs-number">0</span> &amp;&amp; column &lt;= board[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> &amp;&amp; check[rows][column] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//没被遍历过,且没在边界</span><br>                flag = dfs(board,pathLength + <span class="hljs-number">1</span>,word,rows,column,check);<br>                <span class="hljs-keyword">if</span>(flag)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>              <br>            &#125;<br>            <span class="hljs-comment">//回溯</span><br>            rows -= direction[i][<span class="hljs-number">0</span>];<br>            column -= direction[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//回溯</span><br>        check[rows][column] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>剑指offer上一样的题<a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/solutions/">剑指 Offer 12. 矩阵中的路径 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = board.length;<br>        <span class="hljs-keyword">int</span> n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n]; <span class="hljs-comment">// 标记是否访问</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(recur(board, word, i, j, <span class="hljs-number">0</span>, visited))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[][] visited)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(visited[i][j] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 如果之前已经访问过，则直接返回，防止递归到已经访问过的节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(board[i][j] != word.charAt(k))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k == word.length()-<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 表示字符串已经遍历完毕，返回true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        visited[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 做选择</span><br>        <span class="hljs-comment">// 当if(board[i][j] == word.charAt(k))满足时，开始回溯递归：</span><br>        <span class="hljs-keyword">boolean</span> up = recur(board, word, i-<span class="hljs-number">1</span>, j, k+<span class="hljs-number">1</span>, visited);<br>        <span class="hljs-keyword">boolean</span> down = recur(board, word, i+<span class="hljs-number">1</span>, j, k+<span class="hljs-number">1</span>, visited);<br>        <span class="hljs-keyword">boolean</span> left = recur(board, word, i, j-<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>, visited);<br>        <span class="hljs-keyword">boolean</span> right = recur(board, word, i, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>, visited);<br><br>        visited[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 撤销选择</span><br><br>        <span class="hljs-keyword">return</span> up || down || left || right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（Leetcode）</a>硬币的兑换</p><p>题意：给你一个数值，使用限定的硬币拼出来，问最少多少个</p><p>思路：一开始感觉像是回溯，试着写了以下，超出内存限制。。。</p><p>超出内存限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//特值判断</span><br>        <span class="hljs-keyword">if</span>(coins.length == <span class="hljs-number">0</span> || amount == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//双端队列 用来存储经过的路径</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        dfs(amount,coins,path,res);<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(Integer size:res)&#123;<br>            min = Math.min(min,size);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min == Integer.MAX_VALUE)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span>[] coins,Deque&lt;Integer&gt; path,List&lt;Integer&gt; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            res.add(path.size());<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;coins.length;i++)&#123;<br>            path.add(coins[i]);<br>            dfs(target-coins[i],coins,path,res);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了看题解，使用的记忆化搜索，也是使用的dfs,不过会使用一个数组每次会把已经计算过的存储起来，避免超出时间限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> coinChange(coins, amount, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> rem, <span class="hljs-keyword">int</span>[] count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (rem &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rem == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果已经计算过，直接返回，节约时间</span><br>        <span class="hljs-keyword">if</span> (count[rem - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> count[rem - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;<br>            <span class="hljs-keyword">int</span> res = coinChange(coins, rem - coin, count);<br>            <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span> &amp;&amp; res &lt; min) &#123;<br>                min = <span class="hljs-number">1</span> + res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将最少需要的硬币数量存储起来</span><br>        count[rem - <span class="hljs-number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="hljs-number">1</span> : min;<br>        <span class="hljs-keyword">return</span> count[rem - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>使用动规解决</p><p>dp[i] 表示总值i需要最少几个硬币，dp[0] = 0, dp[负数]忽略，若硬币为1,2,5那么就有</p><p>dp[1] = Min(dp[1 - 1],dp[1 - 2],dp[1 - 5]) + 1 = 1</p><p>dp[2] = Min(dp[2 - 1],dp[2 - 2],dp[2 - 5])  + 1= 1</p><p>dp[3] = Min(dp[3 - 1],dp[3 - 2],dp[3 - 5]) + 1 = 2</p><p>…</p><p>所以递推公式就已经很明显了,看代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br><br>        <span class="hljs-comment">//amount可能是0，所以这里加1</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//这里使用amout+1的原因就是硬币数量可能等于amout，但是肯定不会大于，因为没有面额为负的硬币!</span><br>        Arrays.fill(dp,amount+<span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=amount;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;coins.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i-coins[j]&gt;=<span class="hljs-number">0</span>)&#123;<br>                    dp[i] = Math.min(dp[i],dp[i-coins[j]] + <span class="hljs-number">1</span>);<br>                &#125;  <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//前面的amount+1就是为了便于这里判断</span><br>        <span class="hljs-keyword">return</span> dp[amount] &gt; amount? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（Leetcode）</a>目标和</p><p>题意：给你一组数字，让你添加 + 或者是 - 号，让最终的结果等于target，问有几种方式</p><p>思路：比较笨的办法，将每一种穷尽出来，这里采用的是回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>            backTrack(nums,s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> sum)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>                <span class="hljs-keyword">if</span>(sum == s)&#123;<br>                    count++;<span class="hljs-comment">//记录下来</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                backTrack(nums,s,index + <span class="hljs-number">1</span>,sum+nums[index]);<span class="hljs-comment">//加的方法</span><br>                backTrack(nums,s,index + <span class="hljs-number">1</span>,sum-nums[index]);<span class="hljs-comment">//减的方法</span><br>            &#125;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：使用动态规划</p><p>写在动规那里了</p><p><a href="https://leetcode.cn/problems/generate-parentheses/description/">22. 括号生成 - 力扣（Leetcode）</a>括号生成</p><p>思路：回溯+剪枝  一开始看另外一个题解，使用动态规划，看了半天没有看懂，还是用dfs吧，这样好理解一些，这里就不同于上面那些题了，这里是需要剪枝的，因为如果左括号剩余的数量大于了右括号的数量，这就说明一定会有一个或多个左括号没有闭合(因为这里我们是从左往右挨个挨个加上去的)，因此需要把枝叶提前剪掉。</p><p>下面的高级方法没有带回溯，为了通俗易懂还是带点回溯的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();<br>        dfs(path, n, n, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  从根结点到任意结点的路径，全程只使用一份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左括号还有几个可以使用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右括号还有几个可以使用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> res</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(StringBuilder path, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, List&lt;String&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// path.toString() 生成了一个新的字符串，相当于做了一次拷贝，这里的做法等同于「力扣」第 46 题、第 39 题</span><br>            res.add(path.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span><br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            path.append(<span class="hljs-string">&quot;(&quot;</span>);<br>            dfs(path, left - <span class="hljs-number">1</span>, right, res);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span>) &#123;<br>            path.append(<span class="hljs-string">&quot;)&quot;</span>);<br>            dfs(path, left, right - <span class="hljs-number">1</span>, res);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">generateParenthesis</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();<br>        dfs(path, n, n, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(StringBuilder path, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, List&lt;String&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// path.toString() 生成了一个新的字符串，相当于做了一次拷贝</span><br>            res.add(path.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span><br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            path.append(<span class="hljs-string">&quot;(&quot;</span>);<br>            dfs(path, left - <span class="hljs-number">1</span>, right, res);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span>) &#123;<br>            path.append(<span class="hljs-string">&quot;)&quot;</span>);<br>            dfs(path, left, right - <span class="hljs-number">1</span>, res);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>        generateParenthesis gp = <span class="hljs-keyword">new</span> generateParenthesis();<br>        List&lt;String&gt; res = gp.generateParenthesis(n);<br>        <span class="hljs-keyword">for</span> (String s : res) &#123;<br>            System.out.print(s + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法一：做减法</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230220141042788.png" alt="image-20230220141042788"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//做减法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        dfs(<span class="hljs-string">&quot;&quot;</span>,n, n, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String curStr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, List&lt;String&gt; res)</span></span>&#123;<br>        <span class="hljs-comment">//括号用完了，递归结束</span><br>        <span class="hljs-comment">//每次回退后，可以使用新的字符串变量，因此可以不用回溯</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.add(curStr);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//剪枝，减去不合理的枝叶，因为这里遍历出来的结果是不合题意或者是重复的</span><br>        <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span>)&#123;<br>            dfs(curStr + <span class="hljs-string">&quot;(&quot;</span>, left - <span class="hljs-number">1</span>, right, res);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(right &gt; <span class="hljs-number">0</span>)&#123;<br>            dfs(curStr + <span class="hljs-string">&quot;)&quot;</span>, left, right - <span class="hljs-number">1</span>, res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：做加法</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230220142930821.png" alt="image-20230220142930821"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">// 做加法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 特判</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> curStr 当前递归得到的结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left   左括号已经用了几个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right  右括号已经用了几个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n      左括号、右括号一共得用几个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> res    结果集</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String curStr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> n, List&lt;String&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == n &amp;&amp; right == n) &#123;<br>            res.add(curStr);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            dfs(curStr + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right, n, res);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; n) &#123;<br>            dfs(curStr + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>, n, res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p>题意：现在有一个9键的电话按键，每个数字对应了几个字母，现在随便输入几个数字，问你一共有几种组合方式</p><p>思路：看到组合这个关键字，首先想到的就是dfs进行解题，下面就是使用通用的dfs模板写的解题方法, 除此之外，还有一个bfs的题解，一道排列的组合的题，利用类似广度优先搜索的方法，将将要入队的字母和已经在队列里面的字母组合后，然后入队，直到将数字遍历完毕</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">//设置全局列表存储最后的结果</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-keyword">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串&quot;&quot;</span><br>        String[] numString = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>        <span class="hljs-comment">//迭代处理</span><br>        backTracking(digits, numString, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br><br>    &#125;<br><br>    <span class="hljs-comment">//每次迭代获取一个字符串，所以会涉及大量的字符串拼接，所以这里选择更为高效的 StringBuilder</span><br>    StringBuilder temp = <span class="hljs-keyword">new</span> StringBuilder();<br><br>    <span class="hljs-comment">//比如digits如果为&quot;23&quot;,num 为0，则str表示2对应的 abc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(String digits, String[] numString, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">//遍历全部一次记录一次得到的字符串</span><br>        <span class="hljs-keyword">if</span> (num == digits.length()) &#123;<br>            list.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//str 表示当前num对应的字符串</span><br>        String str = numString[digits.charAt(num) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            temp.append(str.charAt(i));<br>            <span class="hljs-comment">//递归，处理下一层</span><br>            backTracking(digits, numString, num + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//剔除末尾的继续尝试</span><br>            temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(digits.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;Character,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;()&#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br>        <span class="hljs-comment">//定义一个存储路径的可变字符的变量</span><br>        Deque&lt;Character&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        dfs(path,map,digits,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Deque&lt;Character&gt; path,Map&lt;Character,String&gt; map, String digits,<span class="hljs-keyword">int</span> dept,List&lt;String&gt; res)</span></span>&#123;<br>        <span class="hljs-comment">//当递归到底层的时候，将路径上的参数加入结果集中 出口</span><br>        <span class="hljs-keyword">if</span>(dept == digits.length())&#123;<br>            <span class="hljs-comment">//转换成字符串存储，并把中括号，逗号那些去除</span><br>            res.add(path.toString().replace(<span class="hljs-string">&quot;[&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    <br>        <span class="hljs-keyword">char</span> digit = digits.charAt(dept);<br>        String str = map.get(digit);<br><br>        <span class="hljs-keyword">int</span> len = str.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; len; i++)&#123;<br>            <span class="hljs-comment">//将字符添加进路径结果中</span><br>            path.add(str.charAt(i));<br>            <span class="hljs-comment">//递归</span><br>            dfs(path, map,digits,dept+<span class="hljs-number">1</span>,res);<br>            <span class="hljs-comment">//回溯</span><br>            path.removeLast();<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-comment">//totest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LetterCombinations</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">//输入字符串</span><br>        String digits = scanner.nextLine();<br><br>        List&lt;String&gt; combinations = <span class="hljs-keyword">new</span> LetterCombinations().letterCombinations(digits);<br><br>        System.out.println(<span class="hljs-string">&quot;Letter combinations:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String combination : combinations) &#123;<br>            System.out.print(combination + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br><br>        scanner.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;Character, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br>        Deque&lt;Character&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        dfs(path, map, digits, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">dfs</span><span class="hljs-params">(Deque&lt;Character&gt; path, Map&lt;Character, String&gt; map, String digits, <span class="hljs-keyword">int</span> dept, List&lt;String&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dept == digits.length()) &#123;<br>            <span class="hljs-comment">//这个正则表达式可以匹配字符串中的[ , ]和空格这些字符。</span><br>            res.add(path.toString().replaceAll(<span class="hljs-string">&quot;[\\[\\], ]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">char</span> digit = digits.charAt(dept);<br>        String letters = map.get(digit);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.length(); i++) &#123;<br>            path.add(letters.charAt(i));<br>            dfs(path, map, digits, dept + <span class="hljs-number">1</span>, res);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//bfs</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        <span class="hljs-comment">//存储最终结果</span><br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Character,String[]&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>&#125;);<br><br>        <span class="hljs-comment">//存储组合结果</span><br>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; digits.length(); i++)&#123;<br>            queue_letterCombinaions(queue,map.get(digits.charAt(i)));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(String s: queue)&#123;<br>            ans.add(s);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Queue&lt;String&gt; <span class="hljs-title">queue_letterCombinaions</span><span class="hljs-params">(Queue&lt;String&gt; queue, String[] letters)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(queue.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(String letter: letters)&#123;<br>                queue.add(letter);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//这里需要将现在队列的长度保存下来，不然会一直循环</span><br>            <span class="hljs-keyword">int</span> queueLen = queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; queueLen; i++)&#123;<br>                <span class="hljs-comment">//出队队头</span><br>                String s = queue.poll();<br>                <span class="hljs-comment">//和还没有进入队列的元素组合然后入队</span><br>                <span class="hljs-keyword">for</span>(String letter: letters)&#123;<br>                    queue.add(s + letter);<br>                &#125;<br>            &#125;         <br>        &#125;<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">332. 重新安排行程 - 力扣（LeetCode）</a></p><p>这里使用Hierholzer算法来寻找欧拉路径</p><p>欧拉路径和欧拉回路</p><ul><li><strong>欧拉路径</strong>：经过图中每条边恰好一次的路径</li><li><strong>欧拉回路</strong>：起点和终点相同的欧拉路径（闭合的欧拉路径）</li></ul><p>欧拉路径存在的条件</p><ul><li><strong>无向图</strong>：<ul><li>欧拉回路：所有顶点度数为偶数</li><li>欧拉路径：恰好有0个或2个顶点度数为奇数</li></ul></li><li><strong>有向图</strong>：<ul><li>欧拉回路：所有顶点入度等于出度</li><li>欧拉路径：恰好有一个顶点出度比入度大1（起点），一个顶点入度比出度大1（终点），其余顶点入度等于出度</li></ul></li></ul><p>Hierholzer 算法步骤<br>算法流程</p><ol><li><strong>检查欧拉路径/回路存在性</strong>（可选，但推荐）</li><li><strong>选择起点</strong>：<ul><li>欧拉回路：任意顶点</li><li>欧拉路径：出度比入度大1的顶点</li></ul></li><li><strong>深度优先遍历</strong>：<ul><li>从起点开始DFS</li><li>每次选择一条未访问的边</li><li>当无路可走时，将当前顶点加入路径</li></ul></li><li><strong>构建路径</strong>：最终路径是逆序的，需要反转</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个还是有点难的</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;<br>        <span class="hljs-comment">// 构建图，使用优先队列按字典序存储到达机场</span><br>        Map&lt;String, PriorityQueue&lt;String&gt;&gt; graph = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;<br>            String from = ticket.get(<span class="hljs-number">0</span>);<br>            String to = ticket.get(<span class="hljs-number">1</span>);<br>            <br>            <span class="hljs-keyword">if</span> (!graph.containsKey(from)) &#123;<br>                graph.put(from, <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;());<br>            &#125;<br>            graph.get(from).offer(to);<br>        &#125;<br>        <br>        LinkedList&lt;String&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//题目要求都是从JFK出发，从起点开始DFS</span><br>        dfs(<span class="hljs-string">&quot;JFK&quot;</span>, graph, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String airport, Map&lt;String, PriorityQueue&lt;String&gt;&gt; graph, LinkedList&lt;String&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取当前机场的所有到达机场（按字典序排列）</span><br>        <span class="hljs-comment">//每次选择一条未访问的边，这里选择的就是按照字典顺序选择的边</span><br>        PriorityQueue&lt;String&gt; destinations = graph.get(airport);<br>        <br>        <span class="hljs-comment">// 递归访问所有可到达的机场  使用的是poll 相当于把这条边删除</span><br>        <span class="hljs-keyword">while</span> (destinations != <span class="hljs-keyword">null</span> &amp;&amp; !destinations.isEmpty()) &#123;<br>            String nextAirport = destinations.poll();<br>            dfs(nextAirport, graph, result);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 跳出了循环，说明已经无路可走，当无路可走时，将当前顶点加入路径</span><br>        <span class="hljs-comment">// 将当前机场添加到结果列表的头部</span><br>        <span class="hljs-comment">//同时，由于是加在</span><br>        result.addFirst(airport);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/n-queens/description/">51. N 皇后 - 力扣（LeetCode）</a></p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>总的来说，还是一个回溯的问题</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20251110133647430.png" alt="image-20251110133647430"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>[] c : chessboard)&#123;<br>            Arrays.fill(c,<span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        backtrack(n, <span class="hljs-number">0</span>, chessboard, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] chessboard, List&lt;List&lt;String&gt;&gt; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n)&#123;<br>            res.add(array2list(chessboard));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; n; col++)&#123;<br>            <span class="hljs-keyword">if</span>(isValid(row, col, n, chessboard))&#123;<br>                <span class="hljs-comment">//放置皇后</span><br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                backtrack(n,row + <span class="hljs-number">1</span>,chessboard,res);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">array2list</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chessboard)</span></span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>[] c : chessboard)&#123;<br>            list.add(String.copyValueOf(c));<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[][] chessboard)</span></span>&#123;<br>        <span class="hljs-comment">//检查同一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; row;i++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//不用检查同一行</span><br>        <span class="hljs-comment">//因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</span><br>        <br>        <span class="hljs-comment">//检查45°</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;=<span class="hljs-number">0</span>; i--,j--)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//检查135°</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--,j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><p>这题是有点难，简单的看看就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-comment">// 预处理行、列、块的掩码以及空格的位置</span><br>        <span class="hljs-keyword">int</span>[] rowMask = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">int</span>[] colMask = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">int</span>[] blockMask = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; (num - <span class="hljs-number">1</span>);<br>                    rowMask[i] |= mask;<br>                    colMask[j] |= mask;<br>                    <span class="hljs-keyword">int</span> blockIndex = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + (j / <span class="hljs-number">3</span>);<br>                    blockMask[blockIndex] |= mask;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        backtrack(board, spaces, <span class="hljs-number">0</span>, rowMask, colMask, blockMask);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces, <span class="hljs-keyword">int</span> pos, </span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">int</span>[] rowMask, <span class="hljs-keyword">int</span>[] colMask, <span class="hljs-keyword">int</span>[] blockMask)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == spaces.size()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 所有空格处理完成</span><br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] space = spaces.get(pos);<br>        <span class="hljs-keyword">int</span> i = space[<span class="hljs-number">0</span>], j = space[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> blockIndex = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + (j / <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">9</span>; num++) &#123;<br>            <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; (num - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 检查当前数字是否有效</span><br>            <span class="hljs-keyword">if</span> ((rowMask[i] &amp; mask) == <span class="hljs-number">0</span> &amp;&amp; <br>                (colMask[j] &amp; mask) == <span class="hljs-number">0</span> &amp;&amp; <br>                (blockMask[blockIndex] &amp; mask) == <span class="hljs-number">0</span>) &#123;<br><br>                <span class="hljs-comment">// 填充数字并更新掩码</span><br>                board[i][j] = (<span class="hljs-keyword">char</span>)(num + <span class="hljs-string">&#x27;0&#x27;</span>);<br>                rowMask[i] |= mask;<br>                colMask[j] |= mask;<br>                blockMask[blockIndex] |= mask;<br><br>                <span class="hljs-comment">// 递归处理下一个空格</span><br>                <span class="hljs-keyword">if</span> (backtrack(board, spaces, pos + <span class="hljs-number">1</span>, rowMask, colMask, blockMask)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 回溯：恢复状态</span><br>                rowMask[i] &amp;= ~mask;<br>                colMask[j] &amp;= ~mask;<br>                blockMask[blockIndex] &amp;= ~mask;<br>                board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="岛屿问题">岛屿问题</h3><p>岛屿的问题在力扣上面是一个系列，都有一个通用的模板，可以看作是dfs的另一种题型，一般来说我们都需要遍历这些岛，而遍历这些岛无非下面这些步骤</p><ul><li>查询是否走到了边界</li><li>查询是否是岛屿(这里使用的1是岛屿的一部分，0是海洋)</li><li>把这里设为已经走过</li><li>接着继续向四个方向走</li></ul><p>代码示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!inArea(grid,r,c))&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//这个格子不是岛屿或者已经走过</span><br>    <span class="hljs-keyword">if</span>(grid[r][c] != <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">//标记为已经走过</span><br>    grid[r][c] = <span class="hljs-string">&#x27;2&#x27;</span>;<br><br>    <span class="hljs-comment">//向四个方向走</span><br>    dfs(grid,r-<span class="hljs-number">1</span>,c);<br>    dfs(grid,r+<span class="hljs-number">1</span>,c);<br>    dfs(grid,r,c-<span class="hljs-number">1</span>);<br>    dfs(grid,r,c+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 判断坐标 (r, c) 是否在网格中</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].length;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量 - 力扣（Leetcode）</a>岛屿的数量</p><p>题意：找出海洋上一共有几个岛屿，相连的1且周围都是0看作一个岛屿，可以把边界都看作是0</p><p>思路：先使用dfs对每一个是1的节点遍历，如果它走出了dfs说明这个岛屿已经遍历完毕，将岛屿上面的1都标记为了2，视为已经走过，然后将结果+1即可。按这个方法，直至遍历完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//岛屿数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-comment">//遍历每一个1节点</span><br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    dfs(grid,i,j);<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!inArea(grid,r,c))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//这个格子不是岛屿或者已经走过</span><br>        <span class="hljs-keyword">if</span>(grid[r][c] != <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//标记为已经走过</span><br>        grid[r][c] = <span class="hljs-string">&#x27;2&#x27;</span>;<br><br>        dfs(grid,r-<span class="hljs-number">1</span>,c);<br>        dfs(grid,r+<span class="hljs-number">1</span>,c);<br>        dfs(grid,r,c-<span class="hljs-number">1</span>);<br>        dfs(grid,r,c+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断坐标 (r, c) 是否在网格中</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].length;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/">剑指 Offer 13. 机器人的运动范围 - 力扣（Leetcode）</a></p><p>题意：简单的来说就是向四个方向走，求能到达多少个地方，不过增加了一条不能进入行坐标和列坐标的数位之和大于k的格子,在判断的边界的时候，一起判断一下就好</p><p>DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(visited, m ,n ,k , <span class="hljs-number">0</span> , <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[][] visited, <span class="hljs-keyword">int</span> m ,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> i , <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || visited[i][j] || bitSum(i) + bitSum(j) &gt; k)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        visited[i][j] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//这里加的1相当于当前节点</span><br>        <span class="hljs-comment">//从0 开始也只有向下和向右开始了</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span> + dfs(visited, m, n, k, i + <span class="hljs-number">1</span>, j) + dfs(visited, m, n, k, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//计算数位之和</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bitSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>            sum += num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        Deque&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> bfs(visited, queue, m, n, k, res);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[][] visited, Deque&lt;<span class="hljs-keyword">int</span>[]&gt; queue, <span class="hljs-keyword">int</span> m ,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> res)</span></span>&#123;<br>        <span class="hljs-comment">//记得初始化queue;</span><br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span>[] index = queue.poll();<br>            <span class="hljs-keyword">int</span> i  = index[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> j  = index[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || visited[i][j] || bitSum(i) + bitSum(j) &gt; k) <span class="hljs-keyword">continue</span>;<br>            visited[i][j] = <span class="hljs-keyword">true</span>;<br>            res++;<br>            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i + <span class="hljs-number">1</span>,j&#125;);<br>            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j + <span class="hljs-number">1</span>&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bitSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>            sum += num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS">BFS</h2><p>先看一遍树的DFS遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(root.left);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看看树的层序遍历，这里是使用BFS实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        TreeNode node = queue.poll(); <span class="hljs-comment">// Java 的 pop 写作 poll()</span><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>            queue.add(node.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>            queue.add(node.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独的一层拎出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二叉树的层序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> n = queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <br>            <span class="hljs-comment">// 变量 i 无实际意义，只是为了循环 n 次</span><br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a></p><p>题意：这道题的层序遍历和上面并没有什么本质的区别，值得注意的就是这里返回的时候需要将每一层的数据隔一下，因此这里我们需要每次进入下一层之前，数一下队列有多长，然后进行一下循环，将每一层隔离开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br><br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-comment">//这里需要判断一下</span><br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-comment">//把每一层的单独拎出来</span><br>            <span class="hljs-keyword">int</span> n = queue.size();<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br>                TreeNode node = queue.poll();<br>                level.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><p>题意：题意如题目名，就是求二叉树的最大深度，这里提供两种思路</p><p>BFS方法和上面的题，结构没有什么太大的区别，主要就是在每次的层循环之前来个计数器就是它的深度了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            depth++;<br>            <span class="hljs-comment">//每次都先处理一层，因此这里循环几次就是有多深</span><br>            <span class="hljs-comment">//注意这里的i &lt; size 不可以直接写i &lt; queue.size() 因为队列的长度在变化</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS的方法，这种方法更加的简单，更推荐这种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = maxDepth(root.left);<br>        <span class="hljs-keyword">int</span> right = maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(left,right) + <span class="hljs-number">1</span>;<span class="hljs-comment">//加上1就是加上自己本身</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（Leetcode）</a></p><p>题意：把二叉树的左右对调，这里也是提供两种实现的方法</p><p>BFS，依然是通过在遍历的时候交换左右子树来实现这个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-comment">//交换左右子树</span><br>            TreeNode temp = node.left;<br>            node.left = node.right;<br>            node.right = temp;<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS，就是在普通的dfs的遍历中加入交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这样写更加的规范一点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        invertTree(root.left);<br>        invertTree(root.right);<br>        swapTree(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapTree</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        TreeNode temp = <span class="hljs-keyword">new</span> TreeNode();<br>        temp = node.left;<br>        node.left = node.right;<br>        node.right = temp;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//交换左右子树</span><br>        TreeNode temp = root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>        dfs(root.left);<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像 - 力扣（LeetCode）</a> 跟前面的那道题是一样的，这里采用dfs的方法来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">//交换</span><br>        TreeNode temp = <span class="hljs-keyword">new</span> TreeNode();<br>        temp.left = root.left;<br>        root.left = root.right;<br>        root.right = temp.left;<br>        mirrorTree(root.left);<br>        mirrorTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/course-schedule/description/">207. 课程表 - 力扣（Leetcode）</a></p><p>拓扑排序，将每个节点的入度结合起来，只有入度是0的时候才能继续向后走，具体的解析可以参考下面的题解</p><p><a href="https://leetcode.cn/problems/course-schedule/solutions/250377/bao-mu-shi-ti-jie-shou-ba-shou-da-tong-tuo-bu-pai-/">207. 课程表 思路</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 节点的入度: 使用数组保存每个节点的入度,</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.课号和对应的入度</span><br>        Map&lt;Integer, Integer&gt; inDegree = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// 将所有的课程先放入</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            inDegree.put(i, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.依赖关系, 依赖当前课程的后序课程</span><br>        Map&lt;Integer, List&lt;Integer&gt;&gt; adj = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br><br><br>        <span class="hljs-comment">// 初始化入度和依赖关系</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] relate : prerequisites) &#123;<br>            <span class="hljs-comment">// (3,0), 想学3号课程要先完成0号课程, 更新3号课程的入度和0号课程的依赖(邻接表)</span><br>            <span class="hljs-keyword">int</span> cur = relate[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> next = relate[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 1.更新入度</span><br>            inDegree.put(next, inDegree.get(next) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 2.当前节点的邻接表</span><br>            <span class="hljs-keyword">if</span> (!adj.containsKey(cur)) &#123;<br>                adj.put(cur, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>            &#125;<br>            adj.get(cur).add(next);<br>        &#125;<br><br>        <span class="hljs-comment">// 3.BFS, 将入度为0的课程放入队列, 队列中的课程就是没有先修, 可以学的课程</span><br>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : inDegree.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (inDegree.get(key) == <span class="hljs-number">0</span>) &#123;<br>                q.offer(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 取出一个节点, 对应学习这门课程.</span><br>        <span class="hljs-comment">// 遍历当前邻接表, 更新其入度; 更新之后查看入度, 如果为0, 加入到队列</span><br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> cur = q.poll();<br>            <span class="hljs-comment">// 遍历当前课程的邻接表, 更新后继节点的入度</span><br>            <span class="hljs-comment">//遍历到最后一个节点，这个节点是没有后续依赖的节点的，所以直接跳过，不然会空指针异常</span><br>            <span class="hljs-keyword">if</span> (!adj.containsKey(cur)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            List&lt;Integer&gt; successorList = adj.get(cur);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k : successorList) &#123;<br>                inDegree.put(k, inDegree.get(k) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegree.get(k) == <span class="hljs-number">0</span>) &#123;<br>                    q.offer(k);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.遍历入队, 如果还有课程的入度不为0, 返回fasle</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : inDegree.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (inDegree.get(key) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//这里可以不要</span><br>    <span class="hljs-comment">// public static void main(String[] args) &#123;</span><br>    <span class="hljs-comment">//     int[][] course = new int[][]&#123;</span><br>    <span class="hljs-comment">//             &#123;3,0&#125;, &#123;3,1&#125;, &#123;4,1&#125;, &#123;4,2&#125;, &#123;5,3&#125;, &#123;5,4&#125;</span><br>    <span class="hljs-comment">//     &#125;;</span><br>    <span class="hljs-comment">//     boolean res = new Solution().canFinish(6, course);</span><br>    <span class="hljs-comment">//     System.out.println(res);</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><p><a href="https://blog.csdn.net/the_ZED/article/details/105126583">【算法与数据结构】—— 并查集_酱懵静的博客-CSDN博客_并查集</a>这是一篇关于并查集的文章，我觉得写得很好，推荐阅读</p><p><a href="https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">399. 除法求值题解力扣（Leetcode</a>再来看看这道题，这道题，是使用并查集解决的，将每个数字与根节点的倍数表达出来，然后需要求两者之间的倍数(就是除法)d额时候，就通过这个根节点的倍数除就行，这就是基本的思想。具体的实现就需要用到并查集的一些知识了，比如路径压缩,具体的代码还是挺复杂的 <a href="https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">//并查集的parent[i]指的是在位置i的元素的父节点位置在perent[i]</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries)&#123;<br>        <span class="hljs-keyword">int</span> equationsSize = equations.size();<br><br>        UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(<span class="hljs-number">2</span> * equationsSize);<br><br>        Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;equations.size();i++)&#123;<br>            String var1 = equations.get(i).get(<span class="hljs-number">0</span>);<br>            String var2 = equations.get(i).get(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//这里是反过来将map中的key作为值，把value作为键来使用的</span><br>            <span class="hljs-keyword">if</span>(!map.containsKey(var1))&#123;<br>                map.put(var1,id++);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(!map.containsKey(var2))&#123;<br>                map.put(var2,id++);<br>            &#125;<br>            <span class="hljs-comment">//生成并查集</span><br>            unionFind.join(map.get(var1),map.get(var2),values[i]);<br>    &#125;<br><br>     <span class="hljs-comment">// 第 2 步：做查询</span><br>        <span class="hljs-keyword">int</span> queriesSize = queries.size();<br>        <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queriesSize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queriesSize; i++) &#123;<br>            String var1 = queries.get(i).get(<span class="hljs-number">0</span>);<br>            String var2 = queries.get(i).get(<span class="hljs-number">1</span>);<br><br>            Integer id1 = map.get(var1);<br>            Integer id2 = map.get(var2);<br><br>            <span class="hljs-keyword">if</span> (id1 == <span class="hljs-keyword">null</span> || id2 == <span class="hljs-keyword">null</span>) &#123;<br>                res[i] = -<span class="hljs-number">1.0d</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = unionFind.isConnected(id1, id2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>        <span class="hljs-comment">//权值</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] weight;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.weight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>                parent[i] = i;<br>                weight[i] = <span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">double</span> value)</span></span>&#123;<br>            <span class="hljs-keyword">int</span> rootx = find(x);<br>            <span class="hljs-keyword">int</span> rooty = find(y);<br>            <span class="hljs-keyword">if</span>(rootx != rooty)&#123;<br>                <span class="hljs-comment">//合并起来</span><br>                parent[rootx] = rooty;<br>            &#125;<br>            <span class="hljs-comment">//关系式的推导见下面的示意图</span><br>            weight[rootx] = weight[y] * value / weight[x];<br>        &#125;<br><br>        <span class="hljs-comment">//路径压缩</span><br>        <span class="hljs-comment">//这里采用的是优化find函数，使用递归，一边查找一边改变并查集的结构</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(x != parent[x])&#123;<br>                <span class="hljs-keyword">int</span> origin = parent[x];<br>                parent[x] = find(parent[x]);<br>                <span class="hljs-comment">//赋值权重</span><br>                weight[x] *= weight[origin];<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>            <span class="hljs-keyword">int</span> rootx = find(x);<br>            <span class="hljs-keyword">int</span> rooty = find(y);<br>            <span class="hljs-keyword">if</span>(rootx == rooty)&#123;<br>                <span class="hljs-keyword">return</span> weight[x]/weight[y];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20221213163711026.png" alt="image-20221213163711026"></p><h2 id="字符串">字符串</h2><h3 id="翻转字符串">翻转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p><p>题意：没什么好说的，就是给你一个字符数组，把这个数组从头到尾进行翻转</p><p>思路：使用双指针进行交换翻转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tail = s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(tail &gt; head)&#123;<br>            <span class="hljs-keyword">char</span> temp;<br>            temp = s[head];<br>            s[head] = s[tail];<br>            s[tail] = temp;<br>            head++;<br>            tail--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II - 力扣（LeetCode）</a></p><p>题意：给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>这个需要特别注意一下翻转尾部的位置，其他的翻转操作和上面的那道题一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i = i + <span class="hljs-number">2</span> * k)&#123;<br>            <span class="hljs-keyword">int</span> head = i;<br>            <span class="hljs-comment">//判断末尾的够不够k.从而确定反转区间的尾部位置</span><br>            <span class="hljs-keyword">int</span> tail = i + k - <span class="hljs-number">1</span> &gt; str.length - <span class="hljs-number">1</span> ? str.length - <span class="hljs-number">1</span> : i + k - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(tail &gt; head)&#123;<br>                <span class="hljs-keyword">char</span> temp = str[head];<br>                str[head] = str[tail];<br>                str[tail] = temp;<br>                head++;<br>                tail--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><p>题意：如题所示，将字符串里面的每一个单词进行翻转</p><p>思路：使用分割函数，分割每一个单词，然后从后向前重新排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 去除字符串首尾空格</span><br>        s = s.trim();<br>        <span class="hljs-comment">// 如果字符串为空，直接返回空字符串</span><br>        <span class="hljs-keyword">if</span> (s.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 使用正则表达式分割字符串（匹配一个或多个空格）</span><br>        String[] words = s.split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <br>        <span class="hljs-comment">// 从后向前遍历单词数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = words.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            sb.append(words[i]);<br>            <span class="hljs-comment">// 在单词之间添加空格（最后一个单词后不添加）</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正则表达式中\s匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</p><ul><li>\f -&gt; 匹配一个换页</li><li>\n -&gt; 匹配一个换行符</li><li>\r -&gt; 匹配一个回车符</li><li>\t -&gt; 匹配一个制表符</li><li>\v -&gt; 匹配一个垂直制表符</li></ul><p>而<code>\s+</code>则表示匹配任意多个上面的字符。另因为反斜杠在Java里是转义字符，所以在Java里，我们要这么用<code>\\s+</code></p><p><a href="https://kamacoder.com/problempage.php?pid=1065">55. 右旋字符串（第八期模拟笔试）</a></p><p>题意：这个是翻转部分字符串，给定一个数字k，只翻转倒数k个字符到前面去</p><p>思路：使用StringBuilder依旧很好解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> k = sc.nextInt();<br>        <span class="hljs-comment">//这里需要注意，如果使用nextLine() ，nextLine()会读取回车</span><br>        String s = sc.next();<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-comment">//将后面的翻转到前面去</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s.length() - k;i &lt; s.length();i++)&#123;<br>            <span class="hljs-keyword">char</span> cur = s.charAt(i);<br>            res.append(cur);<br>        &#125;<br>        <span class="hljs-comment">//接上没有翻转的</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length() - k;i++)&#123;<br>            <span class="hljs-keyword">char</span> cur = s.charAt(i);<br>            res.append(cur);<br>        &#125;<br>        System.out.println(res.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用StringBuilder">使用StringBuilder</h3><p><a href="https://kamacoder.com/problempage.php?pid=1064">54. 替换数字（第八期模拟笔试）</a></p><p>题意：给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p><p>思路：Java中的String是不可以更改的，因此使用StringBuilder来更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine().trim();<br>        System.out.println(replaceDigits(s));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">replaceDigits</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-comment">//主要是要记住这个方法</span><br>            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>                result.append(<span class="hljs-string">&quot;number&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个字符串，比如“dddafffffbbb” 根据字母出现的次数，从到小输出字母。如果相同就按字母acs码从大到小输出</p><p>预期结果：fdba</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charsort</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 定义一个字符串</span><br>        String s = <span class="hljs-string">&quot;dddafffffbbb&quot;</span>;<br>        <span class="hljs-comment">// 3. 创建一个Map集合,用于存储字符与出现次数的关系</span><br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>            map.put(c, map.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Set&lt;Character&gt; set= map.keySet();<span class="hljs-comment">// 获取到map集合中的所有key值</span><br><br>        System.out.println(set);<br><br>        <span class="hljs-keyword">while</span>(!map.isEmpty()) &#123;<br>            <span class="hljs-comment">// 7. 通过遍历每一个key的值,获取到对应的value值</span><br>            <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">0</span>;<br>            Character maxZiFu = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span>(Character cha : set) &#123;<br>                <span class="hljs-keyword">int</span> value= map.get(cha);<br>                <span class="hljs-keyword">if</span>(value &gt; maxValue) &#123;<span class="hljs-comment">// 为了将当前map集合中的最大值获取到</span><br>                    maxValue = value;<br>                    maxZiFu = cha;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value == maxValue) &#123;<span class="hljs-comment">//如果相等按照asc码进行排序</span><br>                    maxValue = value;<br>                    maxZiFu = cha &gt; maxZiFu ? cha : maxZiFu;<br>                &#125;<br><br><br>            &#125;<br><br>            System.out.println(maxZiFu + <span class="hljs-string">&quot;==&quot;</span> + maxValue);<br>            <span class="hljs-comment">// 8. 将最大的键值对输出之后,从map集合中删除</span><br>            map.remove(maxZiFu);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="KMP字符串匹配">KMP字符串匹配</h3><p>先贴一个视频<a href="https://www.bilibili.com/video/BV1M5411j7Xx/">https://www.bilibili.com/video/BV1M5411j7Xx/</a></p><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><p>一道简单题，给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p>首先是暴力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String haystack, String needle)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理 needle 为空的情况</span><br>        <span class="hljs-keyword">if</span> (needle.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> n = haystack.length();<br>        <span class="hljs-keyword">int</span> m = needle.length();<br>        <span class="hljs-comment">// 如果 needle 比 haystack 长，不可能匹配</span><br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历所有可能的起始位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n - m; i++)&#123;<br>            <span class="hljs-keyword">int</span> j = i,k = <span class="hljs-number">0</span>; <br>            <span class="hljs-keyword">while</span>(k &lt; m &amp;&amp; haystack.charAt(j) == needle.charAt(k)) &#123;<br>                j++;<br>                k++;<br>            &#125;<br>            <span class="hljs-comment">//如果最后相等，说明已经完全匹配</span><br>            <span class="hljs-keyword">if</span>(k == m) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用KMP</p><p>更详细的next数组的使用和计算可以参考下一道题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String haystack, String needle)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果模式串为空，则返回0</span><br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 创建next数组，用于存储模式串的最长相同前后缀长度</span><br>        <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[needle.length()];<br>        <span class="hljs-comment">// 计算next数组</span><br>        getNext(next, needle);<br><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// j表示模式串当前匹配位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.length(); i++) &#123;<br>            <span class="hljs-comment">// 当字符不匹配时，根据next数组回退j</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) <br>                j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 回退到最长公共前后缀的末尾位置</span><br>            <br>            <span class="hljs-comment">// 当前字符匹配，模式串指针j后移</span><br>            <span class="hljs-keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) <br>                j++;<br>            <br>            <span class="hljs-comment">// 完全匹配成功，返回起始下标</span><br>            <span class="hljs-keyword">if</span> (j == needle.length()) <br>                <span class="hljs-keyword">return</span> i - needle.length() + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算起始位置</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>    &#125;<br>    <br>    <span class="hljs-comment">// 构建KMP算法的next数组（部分匹配表）</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] next, String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前缀末尾指针（也代表i之前子串的最长相等前后缀长度）</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 第一个字符无前后缀，长度为0</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123; <span class="hljs-comment">// i为后缀末尾指针</span><br>            <span class="hljs-comment">// 前后缀不相同：回退j到前一个位置对应的next值</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) <br>                j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 核心回退操作</span><br>            <br>            <span class="hljs-comment">// 前后缀相同：共同长度+1</span><br>            <span class="hljs-keyword">if</span> (s.charAt(j) == s.charAt(i)) <br>                j++;<br>            <br>            <span class="hljs-comment">// 记录当前位置的最长相等前后缀长度</span><br>            next[i] = j; <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><p>题意：给一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abab&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">&quot;ab&quot;</span> 重复两次构成。<br></code></pre></td></tr></table></figure><p>思路1：使用KMP进行字符串匹配</p><p>next 数组（前缀函数）解释</p><p>在 KMP 算法中，<strong>next 数组</strong>（也称为前缀函数）存储了字符串的最长公共前后缀长度信息：</p><ul><li><code>next[i]</code> 表示子串 <code>s[0..i]</code> 的<strong>最长相等真前缀和真后缀</strong>的长度（不包括整个字符串本身）</li><li>真前缀/真后缀：指不包含字符串本身的前缀/后缀</li></ul><p>例如：</p><ul><li><code>s = &quot;abab&quot;</code> → next = <code>[0, 0, 1, 2]</code><ul><li><code>i=0</code>：<code>&quot;a&quot;</code> → 0（无真前缀/后缀）</li><li><code>i=1</code>：<code>&quot;ab&quot;</code> → 0</li><li><code>i=2</code>：<code>&quot;aba&quot;</code> → 1（前缀 <code>&quot;a&quot;</code> = 后缀 <code>&quot;a&quot;</code>）</li><li><code>i=3</code>：<code>&quot;abab&quot;</code> → 2（前缀 <code>&quot;ab&quot;</code> = 后缀 <code>&quot;ab&quot;</code>）</li></ul></li></ul><p>为什么通过整除可以判断重复</p><p><strong>核心原理</strong>：如果字符串 <code>s</code> 由重复子串构成，那么它的最小重复单元长度 <code>L</code> 满足：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">L = <span class="hljs-built_in">n</span> - next[<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>且字符串总长度 <code>n</code> 必须能被 <code>L</code> 整除。</p><p>验证过程</p><ol><li><p><strong>设最小重复单元为 <code>t</code></strong>，则 <code>s = t + t + ... + t</code>（共 <code>k</code> 次）</p></li><li><p><strong>最长相等前后缀</strong>：</p><ul><li>前缀：前 <code>(k-1)</code> 个 <code>t</code>（长度 = <code>(k-1)*L</code>）</li><li>后缀：后 <code>(k-1)</code> 个 <code>t</code>（长度 = <code>(k-1)*L</code>）</li></ul></li><li><p><strong><code>next[n-1]</code> 的值</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">next</span>[n-<span class="hljs-number">1</span>] = (k-<span class="hljs-number">1</span>)*L<br></code></pre></td></tr></table></figure></li><li><p><strong>推导最小重复单元长度</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">L</span> = n - next[n-<span class="hljs-number">1</span>] = k*L - (k-<span class="hljs-number">1</span>)*L<br></code></pre></td></tr></table></figure></li><li><p><strong>判断条件</strong>：</p><ul><li><code>n</code> 必须能被 <code>L</code> 整除：<code>n % L == 0</code></li><li>等价于 <code>n % (n - next[n-1]) == 0</code></li></ul></li></ol><p>简单的来说就是，最长公共前缀是不包含最后一个字母的，因此，最长的公共前后缀之间正好相差一个最小重复单元的长度，所以总长度和最长公共前后缀之间相差的长度就是最小重复单元的长度。如果能被整除，说明就是重复的，如果不行，那就不是</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/03d2e31866735cd5aa430750da3bd44f.jpeg" alt="img"></p><p>示例分析</p><ol><li><p><strong><code>s = &quot;abab&quot;</code>（n=4）</strong></p><ul><li>next = <code>[0,0,1,2]</code> → <code>next[n-1]=2</code></li><li><code>L = 4-2 = 2</code></li><li><code>4 % 2 = 0</code> → <code>true</code>（由 <code>&quot;ab&quot;</code> 重复 2 次）</li></ul></li><li><p><strong><code>s = &quot;aba&quot;</code>（n=3）</strong></p><ul><li>next = <code>[0,0,1]</code> → <code>next[n-1]=1</code></li><li><code>L = 3-1 = 2</code></li><li><code>3 % 2 ≠ 0</code> → <code>false</code></li></ul></li><li><p><strong><code>s = &quot;abcabcabcabc&quot;</code>（n=12）</strong></p><ul><li>next = <code>[0,0,0,1,2,3,4,5,6,7,8,9]</code> → <code>next[n-1]=9</code></li><li><code>L = 12-9 = 3</code></li><li><code>12 % 3 = 0</code> → <code>true</code>（由 <code>&quot;abc&quot;</code> 重复 4 次）</li></ul></li></ol><p>边界条件处理</p><ul><li><strong>单字符字符串</strong>：直接返回 <code>false</code>（无法由更小的子串重复构成）</li><li><strong>next[n-1]=0</strong>：说明无公共前后缀，直接返回 <code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <br>        <span class="hljs-comment">// 构建 next 数组</span><br>        <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前匹配的前缀长度</span><br>        <span class="hljs-comment">//i指向后缀末尾位置</span><br>        <span class="hljs-comment">//j指向前  缀末尾位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 字符不匹配时，回溯到前一个匹配位置</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 字符匹配时，扩展前缀长度</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> last = next[n - <span class="hljs-number">1</span>];      <span class="hljs-comment">// 最后一个字符的 next 值</span><br>        <span class="hljs-keyword">int</span> unitLen = n - last;      <span class="hljs-comment">// 最小重复单元长度</span><br>        <br>        <span class="hljs-comment">// 验证：需满足 last≠0 且 n 能被单元长度整除</span><br>        <span class="hljs-keyword">return</span> last != <span class="hljs-number">0</span> &amp;&amp; n % unitLen == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路2：如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。</p><p>例如：abcabc</p><p>移位一次：cabcab<br>移位两次：bcabca<br>移位三次：abcabc</p><p>现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。</p><p>基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。</p><p>为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。</p><p>比如字符串：S = acd，那么 str = S + S = acdacd</p><p>acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口</p><p>一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束</p><p>所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串</p><p>这个思路可以直接使用两行代码解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        String str = s + s;<br>        <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">1</span>, str.length() - <span class="hljs-number">1</span>).contains(s);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中心扩展法求回文子串">中心扩展法求回文子串</h3><p>求回文子串这种题的思想就是找中心点然后向两边进行扩展，直到找到全部的回文子串，下面根据题来具体的看看</p><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（Leetcode）</a></p><p>题意就是要求你找出字符串里面有多少个回文子串，单独一个字符也算是回文子串，针对找回文子串，我们首先需要的就是找到中心点，而作为偶数或者是奇数为中心点的话是有区别的，如一个单独字符串(一个字母的)无法通过向两边扩展的方式得到形如abba的字符串，因此，最终的中心点需选用一个字符和有两个字符的作为中心点，如果再多就可以通过1个或者2个扩展得到，所以中心点有2 * len -1 个</p><ul><li>为什么有 2 * len - 1 个中心点？<br>aba 有5个中心点，分别是 a、b、a、ab、ba<br>abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</li><li>什么是中心点？<br>中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</li><li>为什么不可能是三个或者更多？<br>因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到</li></ul><p>具体的中心点的顺序(如 <code>abba</code> 作为母字符串 ) 可以由下图看出，而左右的指针满足下面的规律</p><ul><li>left = center / 2</li><li>right = left + center % 2;</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230225175353817.png" alt="image-20230225175353817"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 中心扩展法</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> center = <span class="hljs-number">0</span>; center &lt; <span class="hljs-number">2</span> * s.length() - <span class="hljs-number">1</span>; center++) &#123;<br>            <br>            <span class="hljs-keyword">int</span> left = center / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> right = left + center % <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;<br>                ans++;<br>                left--;<br>                right++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（Leetcode）</a>最长回文子串</p><p>题意：</p><p>思路：中心扩散的方法</p><p>不断寻找可能是中心节点的子串，这里包含两种可能，子串是偶数或者是奇数，如果是偶数，就需要先向一边进行扩散，再向两边扩散</p><p>这里的left和right都是字符串两边+1的位置，并没有包含在字符串中，所以需要注意一下</p><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/solutions/63641/zhong-xin-kuo-san-fa-he-dong-tai-gui-hua-by-reedfa/">5. 最长回文子串 - 力扣（Leetcode）题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> strLen = s.length();<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> maxStart = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strLen; i++)&#123;<br>            left = i - <span class="hljs-number">1</span>;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//当是偶数的回文串的时候</span><br>            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(left) == s.charAt(i))&#123;<br>                len++;<br>                left--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(right &lt; strLen &amp;&amp; s.charAt(right) == s.charAt(i))&#123;<br>                len++;<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; strLen &amp;&amp; s.charAt(left) == s.charAt(right))&#123;<br>                len = len + <span class="hljs-number">2</span>;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">//保存最大值</span><br>            <span class="hljs-keyword">if</span>(len &gt; maxLen)&#123;<br>                maxLen = len;<br>                maxStart = left;<br>            &#125;<br>            len = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxStart + <span class="hljs-number">1</span>, maxStart + <span class="hljs-number">1</span> + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果根据上面一道题的写法写的话是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> strLen = s.length();<br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strLen * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">int</span> left = i / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> right = left + i % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; strLen &amp;&amp; s.charAt(left) == s.charAt(right))&#123;<br>                String temp = s.substring(left,right + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//保存最大值</span><br>                <span class="hljs-keyword">if</span>(temp.length() &gt; res.length())&#123;<br>                    res = temp;<br>                &#125;<br>                left--;<br>                right++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//have main</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">longestPalindrome</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 特例判断</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 中心拓展</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> center = <span class="hljs-number">0</span>; center &lt; <span class="hljs-number">2</span> * len - <span class="hljs-number">1</span>; center++) &#123;<br>            <span class="hljs-keyword">int</span> left = center / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> right = left + center % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                <span class="hljs-comment">// 保存最长的子串  substring是左闭右开[</span><br>                String substring = s.substring(left, right + <span class="hljs-number">1</span>);<br>                res = res.length() &gt; substring.length() ? res : substring;<br>                left--;<br>                right++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入一个字符串: &quot;</span>);<br>        String input = scanner.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;最长回文字串为：&quot;</span> + longestPalindrome(input));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看看dp的解法</p><p>dp解法的思想是，首先<code>dp[l][r]</code>为true代表字符串从下标 l - r的子串是回文的，那么可以容易知道如果下标 l 对应的字符和下标r对应的字符相等，且前一个dp数组，也就是去除了两边字符的<code>dp[l][r]</code>为true，那么<code>dp[l][r]</code>也为true，值得注意的是，这里因为需要赋初值，所以还需要增加一个条件<code>r - l &lt;= 2</code>且两边的字符相等，那么也为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">int</span> strLen = s.length();<br>        <span class="hljs-keyword">int</span> maxStart = <span class="hljs-number">0</span>;  <span class="hljs-comment">//最长回文串的起点</span><br>        <span class="hljs-keyword">int</span> maxEnd = <span class="hljs-number">0</span>;    <span class="hljs-comment">//最长回文串的终点</span><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;  <span class="hljs-comment">//最长回文串的长度</span><br><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[strLen][strLen];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>; r &lt; strLen; r++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; r; l++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="hljs-number">2</span> || dp[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>])) &#123;<br>                    dp[l][r] = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                        maxLen = r - l + <span class="hljs-number">1</span>;<br>                        maxStart = l;<br>                        maxEnd = r;<br><br>                    &#125;<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxStart, maxEnd + <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><p><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/">剑指 Offer 16. 数值的整数次方 - 力扣（Leetcode）</a></p><p>题意就是简单的求幂运算，直接使用Math.pow()就行，但是很明显不会这么简单，这里采用高级一点的做法，可以将时间复杂度降低到<code>O(logn)</code> 级别(二分)</p><p>简单的来说就是将x的n次方，转换为x的平方的n/2方。这里的n需要判断一下奇偶数，如果是奇数，就把多出来的那个x乘进去res, 偶数就不用管</p><p>具体的题解推荐<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solutions/112529/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">剑指 Offer 16. 数值的整数次方 - 力扣题解</a></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230314140542221.png" alt="image-20230314140542221"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>            n = -n;<br>            x = <span class="hljs-number">1</span>/x;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                res *= x;<br>            &#125;<br>            x *= x;<br>            n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">//就是向下取整</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码最后一个样例是通不过的，int 会超出限制，因此我们采用一个long 类型来暂存就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">long</span> b = n;<br>        <span class="hljs-keyword">if</span>(b &lt; <span class="hljs-number">0</span>)&#123;<br>            b = -b;<br>            x = <span class="hljs-number">1</span>/x;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                res *= x;<br>            &#125;<br>            x *= x;<br>            b &gt;&gt;= <span class="hljs-number">1</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有限状态自动机">有限状态自动机</h2><p>有限状态自动机，就是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件，简单来说，就是把他具体抽象为有限个状态，在状态之间进行转化</p><p><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/">剑指 Offer 20. 表示数值的字符串 - 力扣（Leetcode）</a></p><p>题意： 给定一个字符串，判断这个字符串是不是代表一个数字，这个数字可能有e ,±,还有小数点等</p><p>思路：使用上述所说的有限状态自动机，具体定义了九种状态，画出状态转移图，这是最难的部分</p><p>参考题解：<a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solutions/278913/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/">剑指 Offer 20. 表示数值的字符串题解</a></p><p>状态的定义：</p><p>按照字符串从左到右的顺序，定义以下 9 种状态。</p><ul><li>开始的空格</li><li>幂符号前的正负号</li><li>小数点前的数字</li><li>小数点、小数点后的数字</li><li>当小数点前为空格时，小数点、小数点后的数字</li><li>幂符号</li><li>幂符号后的正负号</li><li>幂符号后的数字</li><li>结尾的空格</li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20230416152141087.png" alt="状态转移图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//有限状态机解题</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map[] states = &#123;<br>            <span class="hljs-comment">//在new的时候初始化数据，这里需要两层括号</span><br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;()&#123;&#123; put(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>);put(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">1</span>);put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>);put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">4</span>); &#125;&#125;,<br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;()&#123;&#123; put(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">2</span>);put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">4</span>); &#125;&#125;,<br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;()&#123;&#123; put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>);put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">3</span>);put(<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">5</span>);put(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>); &#125;&#125;,<br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>); &#125;&#125;,              <br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">3</span>); &#125;&#125;,                                        <br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">6</span>); put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>); &#125;&#125;,                        <br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>); &#125;&#125;,                                        <br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>); put(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>); &#125;&#125;,                           <br>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>); &#125;&#125;  <br>        &#125;;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span> t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) t = <span class="hljs-string">&#x27;d&#x27;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>) t = <span class="hljs-string">&#x27;s&#x27;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span>) t = <span class="hljs-string">&#x27;e&#x27;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;.&#x27;</span> || c == <span class="hljs-string">&#x27; &#x27;</span>) t = c;<span class="hljs-comment">//直接使用符号充当状态机转移的命令</span><br>            <span class="hljs-keyword">else</span> t = <span class="hljs-string">&#x27;?&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!states[p].containsKey(t))  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//没有下一个状态</span><br>            p = (<span class="hljs-keyword">int</span>)states[p].get(t);<span class="hljs-comment">//到达下一个状态</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> p == <span class="hljs-number">2</span> || p == <span class="hljs-number">3</span> || p == <span class="hljs-number">7</span> || p == <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的方法不容易想出来，还是来看看if-else吧</p><p>if-else大法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>,y = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= y;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                x = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = y;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                y = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        s = s.substring(x,y+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;-&#x27;</span> || s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                s = s.substring(<span class="hljs-number">1</span>,s.length());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> note = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span> &lt; <span class="hljs-number">0</span> || s.charAt(i) &gt; <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;e&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;E&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span> || i == s.length() - <span class="hljs-number">1</span> <br>                    || i == <span class="hljs-number">0</span>)&#123;<br>                        flag = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                        num = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> || i==s.length()-<span class="hljs-number">1</span>||(s.charAt(i-<span class="hljs-number">1</span>)!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;s.charAt(i-<span class="hljs-number">1</span>)!=<span class="hljs-string">&#x27;E&#x27;</span>))&#123;<br>                        System.out.println(i);<br>                        flag = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(note == -<span class="hljs-number">1</span>)&#123;<br>                        flag = -<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num!= <span class="hljs-number">1</span>)&#123;<br>                        note = -<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        flag = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>((i &lt; s.length() -<span class="hljs-number">1</span> &amp;&amp; (s.charAt(i+<span class="hljs-number">1</span>)!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;s.charAt(i+<span class="hljs-number">1</span>)!=<span class="hljs-string">&#x27;E&#x27;</span>)) || (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;s.charAt(i-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;E&#x27;</span>)))&#123;<br>                       <br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                         flag = -<span class="hljs-number">1</span>;<br>                    &#125;<br><br>                        <span class="hljs-keyword">if</span>(i == s.length() -<span class="hljs-number">1</span>&amp;&amp;i == <span class="hljs-number">0</span>)&#123;<br>                            flag = -<span class="hljs-number">1</span>;<br>                        &#125;<br>                    <br>                &#125;<span class="hljs-keyword">else</span> flag = -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据结构与算法</title>
    <link href="/2022/06/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2022/06/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">前言<ul>    <div>本博客主要是学习《大话数据结构》以及<a herf = "https://www.bilibili.com/video/BV1E4411H73v" target = "_blank">尚硅谷的Java数据结构及算法所作的笔记</a></div></ul></div><h1>1. 稀疏数组和队列</h1><h2 id="1-1-稀疏数组">1.1 稀疏数组</h2><h3 id="使用的场景">使用的场景</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><h3 id="处理方法">处理方法:</h3><ol><li><p>记录数组<strong>一共有几行几列，有多少个不同</strong>的值</p></li><li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模队列</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220622183934608.png" alt="image-20220622183934608"></p><h3 id="转换思路">转换思路</h3><p><strong>二维-&gt;稀疏数组</strong></p><ol><li>遍历原始的二维数组，得到有效数据的个数sum</li><li>根据sum就可以创建稀疏数组sparseArr int[sum + 1] [3];</li><li>将二维数组的有效数据存入到稀疏数组</li></ol><p><strong>稀疏数组-&gt;二维数组</strong></p><ol><li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</li><li>再读取稀疏数组后几行的数据，并赋给原始的二维数组</li></ol><h3 id="代码实现">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SparseArray</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//原始的二维数组</span><br>      <span class="hljs-keyword">int</span> chessArr1[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>      chessArr1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>      chessArr1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>      chessArr1[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">2</span>;<span class="hljs-comment">//棋子在数组里面的位置</span><br><br>      System.out.println(<span class="hljs-string">&quot;原始的二维数组~~&quot;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : chessArr1) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> data : row) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, data);<br>         &#125;<br>         System.out.println();<br>      &#125;<br><br>       <span class="hljs-comment">//先遍历一遍，得到意义的数据有哪些</span><br>      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">11</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (chessArr1[i][j] != <span class="hljs-number">0</span>) &#123;<br>               sum++;<br>            &#125;<br>         &#125;<br>      &#125;<br><br>      <span class="hljs-comment">//根据sum来创建稀疏数组</span><br>      <span class="hljs-keyword">int</span> sparseArr[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>      <span class="hljs-comment">//赋初值</span><br>      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">11</span>;<span class="hljs-comment">//11行</span><br>      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<span class="hljs-comment">//11列</span><br>      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;<span class="hljs-comment">//sum个有意义的数据</span><br>      <br>      <span class="hljs-comment">// 遍历二维数组，将数据存储到稀疏数组中</span><br>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//count用来表示在稀疏数组的第几行</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">11</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (chessArr1[i][j] != <span class="hljs-number">0</span>) &#123;<br>               count++;<br>               sparseArr[count][<span class="hljs-number">0</span>] = i;<br>               sparseArr[count][<span class="hljs-number">1</span>] = j;<br>               sparseArr[count][<span class="hljs-number">2</span>] = chessArr1[i][j];<br>            &#125;<br>         &#125;<br>      &#125;<br>      <br>      <span class="hljs-comment">//输出稀疏数组</span><br>      System.out.println();<br>      System.out.println(<span class="hljs-string">&quot;稀疏数组~~~~&quot;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sparseArr.length; i++) &#123;<br>         System.out.printf(<span class="hljs-string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="hljs-number">0</span>], sparseArr[i][<span class="hljs-number">1</span>], sparseArr[i][<span class="hljs-number">2</span>]);<br>      &#125;<br>      System.out.println();<br>      <br><br><br>      <span class="hljs-comment">// 将稀疏数组恢复为原始的二维数组</span><br><br>      <span class="hljs-keyword">int</span> chessArr2[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];<span class="hljs-comment">//根据第一行的数据创建二维数组</span><br>      <br><br>      <span class="hljs-comment">//遍历稀疏数组循环赋值</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; sparseArr.length; i++) &#123;<br>         chessArr2[sparseArr[i][<span class="hljs-number">0</span>]][sparseArr[i][<span class="hljs-number">1</span>]] = sparseArr[i][<span class="hljs-number">2</span>];<br>      &#125;<br>      <br>      <span class="hljs-comment">//输出恢复后的二维数组为</span><br>      System.out.println();<br>      System.out.println(<span class="hljs-string">&quot;恢复后的二维数组为：&quot;</span>);<br>      <br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : chessArr2) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> data : row) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, data);<br>         &#125;<br>         System.out.println();<br>      &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-队列">1.2 队列</h2><h3 id="队列概念">队列概念</h3><ol><li><p>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</p></li><li><p>遵循<strong>先入先出</strong>的原则。即：<strong>先存入队列的数据，要先取出。后存入的要后取</strong>出</p></li><li><p>示意图：(使用数组模拟队列示意图)</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220622190958986.png" alt="示意图"></p></li></ol><h3 id="数组模拟队列思路">数组模拟队列思路</h3><ol><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。</p></li><li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear 则是随着数据输入而改变</p></li><li><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：</p></li></ol><ul><li><p>将尾指针往后移：rear+1 , 当 front == rear （空） (这里的front是有数据的前一个位置)</p></li><li><p>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。rear == maxSize - 1(队列满)</p></li></ul><h3 id="代码实现-2">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用数组来模拟队列</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize; <span class="hljs-comment">//队列的最大容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front; <span class="hljs-comment">// 头指针，这里代表的是有数据的前一个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear; <span class="hljs-comment">// 尾指针</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr; <span class="hljs-comment">// 存放数据</span><br><br><span class="hljs-comment">//初始化队列</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arrMaxSize)</span> </span>&#123;<br>maxSize = arrMaxSize;<br>arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxSize];<br>front = -<span class="hljs-number">1</span>; <span class="hljs-comment">// ָ赋初值为空</span><br>rear = -<span class="hljs-number">1</span>; <span class="hljs-comment">// ָ赋初值为空</span><br>&#125;<br><br><span class="hljs-comment">// 判断是否已满</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> rear == maxSize - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> rear == front;<br>&#125;<br><br><span class="hljs-comment">// 增加数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">// 先判断还有没有空间可以加</span><br><span class="hljs-keyword">if</span> (isFull()) &#123;<br>System.out.println(<span class="hljs-string">&quot;队列已满~&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>rear++; <span class="hljs-comment">// 将尾指针往后移</span><br>arr[rear] = n; <span class="hljs-comment">// 从后面入队</span><br>&#125;<br><br><span class="hljs-comment">// 获取队首的数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQueue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 还是要判断是否是空的</span><br><span class="hljs-keyword">if</span> (isEmpty()) &#123;<br><span class="hljs-comment">// 手写一个异常抛出</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;队列为空，没有数据&quot;</span>);<br>&#125;<br>front++; <span class="hljs-comment">// 移动头指针</span><br><span class="hljs-keyword">return</span> arr[front];<br><br>&#125;<br><br><span class="hljs-comment">// 打印队列里面的全部数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQueue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 经典判断</span><br><span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>System.out.println(<span class="hljs-string">&quot;队列为空没有数据~~&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>System.out.printf(<span class="hljs-string">&quot;arr[%d]=%d\n&quot;</span>, i, arr[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 只是查看数据，没有取出，就是没有移动头指针</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">headQueue</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;队列为空没有数据~~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> arr[front + <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数组模拟环形队列">数组模拟环形队列</h3><ul><li>front变量指向<strong>队首元素</strong>，初值为0</li><li>rear变量指向队尾元素的<strong>下一个元素</strong>，初值为0。规定空出一个位置</li><li>队列为空的判定条件：front == rear</li><li>队列为满的判定条件：(rear + 1) % maxSize == front</li><li>队列中有效元素的个数：(rear - front + maxSize) % maxSize</li><li>入队和出队时，都需要让标记<strong>对maxSize取模</strong></li></ul><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleArray</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize; <span class="hljs-comment">//队列的最大容量</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front; <span class="hljs-comment">// 头指针</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear; <span class="hljs-comment">// 尾指针 这里代表的是有数据的后一个位置</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr; <span class="hljs-comment">// 存放数据</span><br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircleArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arrMaxSize)</span> </span>&#123;<br>      maxSize = arrMaxSize;<br>      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxSize];<br>   &#125;<br>   <br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> (rear  + <span class="hljs-number">1</span>) % maxSize == front;<br>   &#125;<br>   <br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> rear == front;<br>   &#125;<br><br>   <span class="hljs-comment">// 添加元素</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-comment">// 判断是否已满</span><br>      <span class="hljs-keyword">if</span> (isFull()) &#123;<br>         System.out.println(<span class="hljs-string">&quot;队列已满，没有数据~&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//ֱ 赋值</span><br>      arr[rear] = n;<br>      <span class="hljs-comment">// 向后移动指针</span><br>      rear = (rear + <span class="hljs-number">1</span>) % maxSize;<br>   &#125;<br>   <br>   <span class="hljs-comment">// 出队</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQueue</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;队列为空，没有数据&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">int</span> value = arr[front];<br>      front = (front + <span class="hljs-number">1</span>) % maxSize;<br>      <span class="hljs-keyword">return</span> value;<br><br>   &#125;<br>   <br>   <span class="hljs-comment">// 打印队列里面的全部数据</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQueue</span><span class="hljs-params">()</span> </span>&#123;<br><br>      <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>         System.out.println(<span class="hljs-string">&quot;队列为空~~&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//因为可能大于maxsize，因此也需要取余</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = front; i &lt; front + size() ; i++) &#123;<br>         System.out.printf(<span class="hljs-string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);<br>      &#125;<br>   &#125;<br>   <br>   <span class="hljs-comment">// 获取队列中的有效数据有多少个</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// rear = 2</span><br>      <span class="hljs-comment">// front = 1</span><br>      <span class="hljs-comment">// maxSize = 3 </span><br>      <span class="hljs-keyword">return</span> (rear + maxSize - front) % maxSize;   <br>   &#125;<br>   <br>   <span class="hljs-comment">// 只是查看数据，没有取出，就是没有移动头指针</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">headQueue</span><span class="hljs-params">()</span> </span>&#123;<br><br>      <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;队列为空~~&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> arr[front];<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>2. 链表</h1><h2 id="2-1-单链表">2.1 单链表</h2><h3 id="简单的介绍">简单的介绍</h3><ul><li><p>链表是以节点的方式来存储,<strong>是链式存储</strong></p></li><li><p>每个节点包含 data 域， next 域：指向下一个节点.</p></li><li><p>链表的各个节点<strong>不一定</strong>是连续存储.</p></li><li><p>链表分<strong>带头节点的链表</strong>和<strong>没有头节点的链表</strong>，根据实际的需求来确定</p></li></ul><p>链表的逻辑结构示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220627184325255.png" alt="示意图"></p><h3 id="实现思路">实现思路</h3><p><strong>增加</strong></p><p>直接添加到尾部，把上一个节点的指针指向新的节点</p><p><strong>根据排名添加节点(插入)</strong></p><p>先遍历到需要插入夫人地方，将新的节点先连接到下一个节点上，然后再把上一个节点指向这个节点，</p><p>heroNode.next = temp.next;  //先连接<br>temp.next = heroNode;          //再断开</p><p><strong>修改节点</strong></p><p>遍历找到需要修改的节点，修改信息即可</p><p><strong>删除节点</strong></p><p>找到需要删除的节点的上一个节点，把当前节点(要删除节点的上一个节点)指向需要删除节点的一个节点的上一个节点</p><p>temp.next = temp.next.next;</p><p><strong>逆序打印链表</strong></p><p>使用栈的先进后出的特性来实现</p><p><strong>查找链表的倒数第几个节点</strong></p><p>倒数第几个节点就是顺数第(size-index)个节点，先遍历一遍求得长度，然后求第(size-index)个节点就行</p><p><strong>翻转链表</strong></p><p>感觉和前面的插入没有什么不同，就是需要一个next 来暂存下一个节点，防止断开后找不到下一个节点的位置</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220627193150020.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220627194129143.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220627194520787.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220627194557963.png" alt=""></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Mercury.linkedlist;<br><br><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkedListDemo</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//测试增加</span><br>HeroNode hero1 = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;宋江&quot;</span>, <span class="hljs-string">&quot;及时雨&quot;</span>);<br>HeroNode hero2 = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;卢俊义&quot;</span>, <span class="hljs-string">&quot;玉麒麟&quot;</span>);<br>HeroNode hero3 = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;吴用&quot;</span>, <span class="hljs-string">&quot;智多星&quot;</span>);<br>HeroNode hero4 = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;林冲&quot;</span>, <span class="hljs-string">&quot;豹子头&quot;</span>);<br><br><span class="hljs-comment">//创建一个新的链表</span><br>SingleLinkedList singleLinkedList = <span class="hljs-keyword">new</span> SingleLinkedList();<br><br><br><span class="hljs-comment">//添加几个节点</span><br>singleLinkedList.add(hero1);<br>singleLinkedList.add(hero4);<br>singleLinkedList.add(hero2);<br>singleLinkedList.add(hero3);<br><br><span class="hljs-comment">//输出链表</span><br>System.out.println(<span class="hljs-string">&quot;链表数据如下~~&quot;</span>);<br>singleLinkedList.list();<br><br><br>System.out.println(<span class="hljs-string">&quot;逆序打印链表, 没有打印链表的结构~~&quot;</span>);<br>reversePrint(singleLinkedList.getHead());<br><br><span class="hljs-comment">//翻转链表，改变了结构</span><br>System.out.println(<span class="hljs-string">&quot;翻转后的链表为&quot;</span>);<br>reversetList(singleLinkedList.getHead());<br>singleLinkedList.list();<br><br><br>        <span class="hljs-comment">//创建一个新的链表</span><br>SingleLinkedList singleLinkedList2 = <span class="hljs-keyword">new</span> SingleLinkedList();<br><span class="hljs-comment">//按照排名添加</span><br>singleLinkedList2.addByOrder(hero1);<br>singleLinkedList2.addByOrder(hero4);<br>singleLinkedList2.addByOrder(hero2);<br>singleLinkedList2.addByOrder(hero3);<br><br><span class="hljs-comment">//修改节点的值</span><br>HeroNode newHeroNode = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小卢&quot;</span>, <span class="hljs-string">&quot;玉麒麟~~&quot;</span>);<br>singleLinkedList2.update(newHeroNode);<br><br>System.out.println(<span class="hljs-string">&quot;修改后的~~&quot;</span>);<br>singleLinkedList2.list();<br><br><br>singleLinkedList2.del(<span class="hljs-number">1</span>);<br>singleLinkedList2.del(<span class="hljs-number">4</span>);<br>System.out.println(<span class="hljs-string">&quot;删除后的节点为~~&quot;</span>);<br>singleLinkedList2.list();<br><br><span class="hljs-comment">//求有效节点数</span><br>System.out.println(<span class="hljs-string">&quot;有效节点数=&quot;</span> + getLength(singleLinkedList2.getHead()));<br><br><br>HeroNode res = findLastIndexNode(singleLinkedList2.getHead(), <span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;res=&quot;</span> + res);<br><br><br>&#125;<br><br><br><br><span class="hljs-comment">//使用栈来逆序打印</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reversePrint</span><span class="hljs-params">(HeroNode head)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>Stack&lt;HeroNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;HeroNode&gt;();<br>HeroNode cur = head.next;<br><span class="hljs-comment">// 如果不为空就入栈</span><br><span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>) &#123;<br>stack.push(cur);<br>cur = cur.next;<br>&#125;<br>        <span class="hljs-comment">//栈不为空就出栈</span><br><span class="hljs-keyword">while</span> (stack.size() &gt; <span class="hljs-number">0</span>) &#123;<br>System.out.println(stack.pop());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//翻转链表</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reversetList</span><span class="hljs-params">(HeroNode head)</span> </span>&#123;<br><span class="hljs-comment">//链表是空的，或者只有一个节点，那还翻转个什么</span><br><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-comment">//一样的用来遍历节点的临时节点</span><br>HeroNode cur = head.next;<br>HeroNode next = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// ָ用来保存当前节点的下一个节点</span><br>HeroNode reverseHead = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">//不断的在头部插入遍历的节点以达到翻转的效果</span><br><span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>) &#123; <br>next = cur.next;<span class="hljs-comment">//暂时保存当前节点的下一个节点</span><br>cur.next = reverseHead.next;<span class="hljs-comment">//先连接cur和revers的下一个节点</span><br>reverseHead.next = cur; <span class="hljs-comment">//将头节点指向当前的节点</span><br>cur = next;<span class="hljs-comment">//cur移到下一位</span><br>&#125;<br><br>head.next = reverseHead.next;<span class="hljs-comment">//改变头部</span><br>&#125;<br><br><span class="hljs-comment">//查找单链表中的倒数第 k 个结点</span><br><span class="hljs-comment">//思路</span><br><span class="hljs-comment">//1. 编写一个方法，接收 head 节点，同时接收一个 index</span><br><span class="hljs-comment">//2. index 表示是倒数第 index 个节点</span><br><span class="hljs-comment">//3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="hljs-comment">//4. 得到 size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到//5. 如果找到了，则返回该节点，否则返回 null</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HeroNode <span class="hljs-title">findLastIndexNode</span><span class="hljs-params">(HeroNode head, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> size = getLength(head);<br><br><br><span class="hljs-keyword">if</span>(index &lt;=<span class="hljs-number">0</span> || index &gt; size) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>&#125;<br><br>HeroNode cur = head.next; <span class="hljs-comment">//3 // 3 - 1 = 2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt; size - index; i++) &#123;<br>cur = cur.next;<br>&#125;<br><span class="hljs-keyword">return</span> cur;<br><br>&#125;<br><br><span class="hljs-comment">//获取链表的有效节点数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(HeroNode head)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//带头结点的空链表</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br><br>HeroNode cur = head.next;<br><span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>) &#123;<br>length++;<br>cur = cur.next; <span class="hljs-comment">//遍历写一个</span><br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-comment">//SingleLinkedList</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkedList</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> HeroNode head = <span class="hljs-keyword">new</span> HeroNode(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><br><span class="hljs-comment">//获取头部</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(HeroNode heroNode)</span> </span>&#123;<br><br><span class="hljs-comment">//需要用一个temp来遍历</span><br>HeroNode temp = head;<br><span class="hljs-comment">//找尾部</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">//找到了尾部</span><br><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//没有找到，继续向下一个遍历</span><br>temp = temp.next;<br>&#125;<br><span class="hljs-comment">//将新节点赋给尾部</span><br>temp.next = heroNode;<span class="hljs-comment">//Java对象是引用传递</span><br>&#125;<br><br><span class="hljs-comment">//根据排名将英雄添加到指定位置，如果有这个排名，则添加失败，并且给出提示</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addByOrder</span><span class="hljs-params">(HeroNode heroNode)</span> </span>&#123;<br><br><span class="hljs-comment">//单链表需要找添加位置的前一个节点</span><br>HeroNode temp = head;<br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// flag标志添加的编号是否存在，默认为false</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//遍历到了尾部了</span><br><span class="hljs-keyword">break</span>;<br>&#125; <br><span class="hljs-keyword">if</span>(temp.next.no &gt; heroNode.no) &#123; <span class="hljs-comment">//找到了该添加的位置</span><br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="hljs-comment">//编号已经存在，不能再添加</span><br><br>flag = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//设置不能再添加的标志</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>temp = temp.next; <span class="hljs-comment">//都不是以上情况，继续遍历下一个</span><br>&#125;<br><span class="hljs-comment">//判断flag的值，看看有没有出现上面的那种情况</span><br><span class="hljs-keyword">if</span>(flag) &#123;<br>System.out.printf(<span class="hljs-string">&quot;准备插入英雄编号 %d 已经存在, 不能再加入\n&quot;</span>, heroNode.no);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//进行插入操作</span><br>heroNode.next = temp.next;<span class="hljs-comment">//先连接</span><br>temp.next = heroNode;<span class="hljs-comment">//再断开</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//根据no来修改</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(HeroNode newHeroNode)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;链表为空~&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//根据no找到需要修改的节点</span><br>HeroNode temp = head.next;<br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//表示是否找到该节点</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(temp.no == newHeroNode.no) &#123;<br><span class="hljs-comment">//找到该节点</span><br>flag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>temp = temp.next;<span class="hljs-comment">//没找到，继续找</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(flag) &#123;<br>temp.name = newHeroNode.name;<br>temp.nickname = newHeroNode.nickname;<span class="hljs-comment">//找到了该节点，进行修改</span><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//没有找到节点</span><br>System.out.printf(<span class="hljs-string">&quot;没有找到编号为 %d 的节点\n&quot;</span>, newHeroNode.no);<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br>HeroNode temp = head;<br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 设置有没有找到的标志</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(temp.next.no == no) &#123;<br><span class="hljs-comment">//找到待删除的前一个节点temp</span><br>flag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>temp = temp.next; <span class="hljs-comment">//temp继续遍历下一个</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(flag) &#123;<br><span class="hljs-comment">//找到了待删除的前一个节点，进行删除</span><br>temp.next = temp.next.next;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.printf(<span class="hljs-string">&quot;没有找到编号为 %d 的节点\n&quot;</span>, no);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//输出数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 从头部的下一个开始</span><br>HeroNode temp = head.next;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><br><span class="hljs-keyword">if</span>(temp == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 一个个接着打印</span><br>System.out.println(temp);<br><span class="hljs-comment">// 打印完以后移位</span><br>temp = temp.next;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//HeroNode</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroNode</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> no;<br><span class="hljs-keyword">public</span> String name;<br><span class="hljs-keyword">public</span> String nickname;<br><span class="hljs-keyword">public</span> HeroNode next; <span class="hljs-comment">//ָ指向下一个节点</span><br><span class="hljs-comment">//构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HeroNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no, String name, String nickname)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.no = no;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.nickname = nickname;<br>&#125;<br><span class="hljs-comment">//重写toString</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode [no=&quot;</span> + no + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, nickname=&quot;</span> + nickname + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出的数据如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">链表数据如下~~<br>HeroNode [no=<span class="hljs-number">1</span>, name=宋江, nickname=及时雨]<br>HeroNode [no=<span class="hljs-number">4</span>, name=林冲, nickname=豹子头]<br>HeroNode [no=<span class="hljs-number">2</span>, name=卢俊义, nickname=玉麒麟]<br>HeroNode [no=<span class="hljs-number">3</span>, name=吴用, nickname=智多星]<br>逆序打印链表, 没有打印链表的结构~~<br>HeroNode [no=<span class="hljs-number">3</span>, name=吴用, nickname=智多星]<br>HeroNode [no=<span class="hljs-number">2</span>, name=卢俊义, nickname=玉麒麟]<br>HeroNode [no=<span class="hljs-number">4</span>, name=林冲, nickname=豹子头]<br>HeroNode [no=<span class="hljs-number">1</span>, name=宋江, nickname=及时雨]<br>翻转后的链表为<br>HeroNode [no=<span class="hljs-number">3</span>, name=吴用, nickname=智多星]<br>HeroNode [no=<span class="hljs-number">2</span>, name=卢俊义, nickname=玉麒麟]<br>HeroNode [no=<span class="hljs-number">4</span>, name=林冲, nickname=豹子头]<br>HeroNode [no=<span class="hljs-number">1</span>, name=宋江, nickname=及时雨]<br>修改后的~~<br>HeroNode [no=<span class="hljs-number">1</span>, name=宋江, nickname=及时雨]<br>HeroNode [no=<span class="hljs-number">2</span>, name=小卢, nickname=玉麒麟~~]<br>HeroNode [no=<span class="hljs-number">3</span>, name=吴用, nickname=智多星]<br>HeroNode [no=<span class="hljs-number">4</span>, name=林冲, nickname=豹子头]<br>删除后的节点为~~<br>HeroNode [no=<span class="hljs-number">2</span>, name=小卢, nickname=玉麒麟~~]<br>HeroNode [no=<span class="hljs-number">3</span>, name=吴用, nickname=智多星]<br>有效节点数=<span class="hljs-number">2</span><br>res=HeroNode [no=<span class="hljs-number">2</span>, name=小卢, nickname=玉麒麟~~]<br></code></pre></td></tr></table></figure><h2 id="2-2-双向链表">2.2 双向链表</h2><h3 id="简单的介绍-2">简单的介绍</h3><p>管理单向链表的缺点分析:</p><ol><li><p>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p></li><li><p>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会).</p></li></ol><h3 id="思路实现">思路实现</h3><ol><li><p><strong>遍历</strong> 方和 单链表一样，只是可以向前，也可以向后查找</p></li><li><p><strong>添加</strong> (默认添加到双向链表的最后)</p></li></ol><p>​        先找到双向链表的最后这个节点</p><p>​         temp.next = newHeroNode</p><p>​         newHeroNode.pre = temp;</p><ol start="3"><li><p><strong>修改</strong> 思路和 原来的单向链表一样.</p></li><li><p><strong>删除</strong></p></li></ol><ul><li><p>因为是双向链表，因此，我们可以实现自我删除某个节点直接找到要删除的这个节点，比如 temp</p></li><li><p>temp.pre.next = temp.next</p></li><li><p>temp.next.pre = temp.pre;</p><ul><li>如果这里是最后一个节点的话需要额外判断一下，否则会出现空指针异常</li></ul></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Mercury.linkedlist;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleLinkedListDemo</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>HeroNode2 hero1 = <span class="hljs-keyword">new</span> HeroNode2(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;宋江&quot;</span>, <span class="hljs-string">&quot;及时雨&quot;</span>);<br>HeroNode2 hero2 = <span class="hljs-keyword">new</span> HeroNode2(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;卢俊义&quot;</span>, <span class="hljs-string">&quot;玉麒麟&quot;</span>);<br>HeroNode2 hero3 = <span class="hljs-keyword">new</span> HeroNode2(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;吴用&quot;</span>, <span class="hljs-string">&quot;智多星&quot;</span>);<br>HeroNode2 hero4 = <span class="hljs-keyword">new</span> HeroNode2(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;林冲&quot;</span>, <span class="hljs-string">&quot;豹子头&quot;</span>);<br><span class="hljs-comment">// 添加节点</span><br>DoubleLinkedList doubleLinkedList = <span class="hljs-keyword">new</span> DoubleLinkedList();<br>doubleLinkedList.add(hero1);<br>doubleLinkedList.add(hero2);<br>doubleLinkedList.add(hero3);<br>doubleLinkedList.add(hero4);<br><br>doubleLinkedList.list();<br><br>        <span class="hljs-comment">//修改节点</span><br>HeroNode2 newHeroNode = <span class="hljs-keyword">new</span> HeroNode2(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;公孙胜&quot;</span>, <span class="hljs-string">&quot;入云龙&quot;</span>);<br>doubleLinkedList.update(newHeroNode);<br>System.out.println(<span class="hljs-string">&quot;修改后的链表情况&quot;</span>);<br>doubleLinkedList.list();<br><br><span class="hljs-comment">// 删除</span><br>doubleLinkedList.del(<span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-string">&quot;删除后的链表情况~~&quot;</span>);<br>doubleLinkedList.list();<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// 双向链表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleLinkedList</span> </span>&#123;<br><br><br><span class="hljs-keyword">private</span> HeroNode2 head = <span class="hljs-keyword">new</span> HeroNode2(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode2 <span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br>    <span class="hljs-comment">//链表遍历没有什么变化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;双向链表为空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>HeroNode2 temp = head.next;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br><span class="hljs-keyword">if</span> (temp == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>System.out.println(temp);<br>temp = temp.next;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 添加方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(HeroNode2 heroNode)</span> </span>&#123;<br><br><br>HeroNode2 temp = head;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br><span class="hljs-keyword">if</span> (temp.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>temp = temp.next;<br>&#125;<br><span class="hljs-comment">//就多了一句话</span><br>temp.next = heroNode;<br>heroNode.pre = temp;<br>&#125;<br><br><br><span class="hljs-comment">// 没有什么变化就只是类型变为了 HeroNode2</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(HeroNode2 newHeroNode)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;链表为空~&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>HeroNode2 temp = head.next;<br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (temp.no == newHeroNode.no) &#123;<br>flag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>temp = temp.next;<br>&#125;<br><span class="hljs-keyword">if</span> (flag) &#123;<br>temp.name = newHeroNode.name;<br>temp.nickname = newHeroNode.nickname;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.printf(<span class="hljs-string">&quot;没有找到编号为 %d 的节点\n&quot;</span>, newHeroNode.no);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 双向链表的删除这里有着较大的区别</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br><br><span class="hljs-comment">// 熟悉的判断是否为空</span><br><span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;双向链表为空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>HeroNode2 temp = head.next; <span class="hljs-comment">// 熟悉的temp指针</span><br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 熟悉的判断有没有找到</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 因为双向的链表的删除不需要找节点的前一个节点了，所以这里直接判断temp是否为空就行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (temp.no == no) &#123;<br><span class="hljs-comment">// 同样的道理，这里也是直接判断temp的编号</span><br>flag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>temp = temp.next; <span class="hljs-comment">// temp后移</span><br>&#125;<br><span class="hljs-comment">// 判断flag</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-comment">//以前单链表的删除操作</span><br><span class="hljs-comment">// temp.next = temp.next.next;</span><br>temp.pre.next = temp.next;<br><span class="hljs-comment">// 这里有一个问题，如果要删除的temp是链表的最后一个元素的话，下面的这一句话就会出现空指针异常</span><br><span class="hljs-comment">// 所以这里需要再判断一下，如果是最后一个元素就不需要执行下面一句话</span><br><span class="hljs-keyword">if</span> (temp.next != <span class="hljs-keyword">null</span>) &#123;<br>temp.next.pre = temp.pre;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.printf(<span class="hljs-string">&quot;没有找到编号为 %d 的节点\n&quot;</span>, no);<br>&#125;<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroNode2</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> no;<br><span class="hljs-keyword">public</span> String name;<br><span class="hljs-keyword">public</span> String nickname;<br><span class="hljs-keyword">public</span> HeroNode2 next; <span class="hljs-comment">// 指向下一个节点null</span><br><span class="hljs-keyword">public</span> HeroNode2 pre; <span class="hljs-comment">// ָ指向上一个节点null</span><br><br>    <span class="hljs-comment">//构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HeroNode2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no, String name, String nickname)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.no = no;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.nickname = nickname;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode [no=&quot;</span> + no + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, nickname=&quot;</span> + nickname + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-约瑟夫环">2.3 约瑟夫环</h2><h3 id="问题介绍">问题介绍</h3><p>Josephu  问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><h3 id="思路实现-2">思路实现</h3><p>使用单向环形链表实现，每报到一个数的时候就让这个节点打印出来，然后删除节点，直到只有最后一个节点</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220627200346925.png" alt="出去的顺序"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Mercury.linkedlist;<br><br><br><span class="hljs-comment">//约瑟夫环问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Josepfu</span> </span>&#123;<br><br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>      CircleSingleLinkedList circleSingleLinkedList = <span class="hljs-keyword">new</span> CircleSingleLinkedList();<br>      circleSingleLinkedList.addBoy(<span class="hljs-number">5</span>);<span class="hljs-comment">// 添加小孩</span><br>      <span class="hljs-comment">//circleSingleLinkedList.showBoy();</span><br>      <br>      <span class="hljs-comment">//测试</span><br>      circleSingleLinkedList.countBoy(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span><br>   &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleSingleLinkedList</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> Boy first = <span class="hljs-keyword">null</span>;<br><br>   <span class="hljs-comment">// 添加小孩，构造环形链表</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBoy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nums)</span> </span>&#123;<br>      <span class="hljs-comment">// nums &lt; 1那还添加个啥，总不能添加半个小孩吧</span><br>      <span class="hljs-keyword">if</span> (nums &lt; <span class="hljs-number">1</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;nums 输入有误，请重新输入&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br>      Boy curBoy = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// curboy用来指向当前的节点</span><br>      <span class="hljs-comment">// 以循环添加</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums; i++) &#123;<br>         <span class="hljs-comment">// 构造新小孩</span><br>         Boy boy = <span class="hljs-keyword">new</span> Boy(i);<br>         <span class="hljs-comment">//如果是第一个小孩</span><br>         <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>            first = boy;<br>            first.setNext(first); <span class="hljs-comment">// 构成环状</span><br>            curBoy = first; <span class="hljs-comment">//cur 当前也在第一个的位置</span><br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            curBoy.setNext(boy);<span class="hljs-comment">// 添加到尾部</span><br>            boy.setNext(first);<span class="hljs-comment">// 指向头部，形成环状</span><br>            curBoy = boy;<span class="hljs-comment">// 移动到新添加的位置</span><br>         &#125;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">// 一个展示的函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBoy</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// 链表为空</span><br>      <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;当前链表为空~~&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      Boy curBoy = first;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>         System.out.printf(<span class="hljs-string">&quot;当前小孩的编号为 %d \n&quot;</span>, curBoy.getNo());<br>         <span class="hljs-keyword">if</span> (curBoy.getNext() == first) &#123;<span class="hljs-comment">// 说明已经遍历完了一遍</span><br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>         curBoy = curBoy.getNext(); <span class="hljs-comment">// curBoy后移</span><br>      &#125;<br>   &#125;<br><br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> startNo  表示从第几个小孩开始数数</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> countNum  表示数几下</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> nums   表示最初有几个小孩在圈中</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countBoy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startNo, <span class="hljs-keyword">int</span> countNum, <span class="hljs-keyword">int</span> nums)</span> </span>&#123;<br><br>      <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span> || startNo &lt; <span class="hljs-number">1</span> || startNo &gt; nums) &#123;<br>         System.out.println(<span class="hljs-string">&quot;链表为空或输入的编号有误&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 定义一个辅助的变量用来删除出去的节点</span><br>      Boy helper = first;<br>      <span class="hljs-comment">// helper</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>         <span class="hljs-keyword">if</span> (helper.getNext() == first) &#123; <span class="hljs-comment">// 移动helper到第一个节点</span><br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>         helper = helper.getNext();<br>      &#125;<br>      <span class="hljs-comment">// 移动到开始报数的位置</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; startNo - <span class="hljs-number">1</span>; j++) &#123;<br>         first = first.getNext();<br>         helper = helper.getNext();<br>      &#125;<br><br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>         <span class="hljs-keyword">if</span>(helper == first) &#123; <span class="hljs-comment">// 说明只剩下了一个节点，结束循环</span><br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-comment">// 要报数几个节点就是 first 和 helper 移动 countNum - 1 位</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; countNum - <span class="hljs-number">1</span>; j++) &#123;<br>            first = first.getNext();<br>            helper = helper.getNext();<br>         &#125;<br><br>         System.out.printf(<span class="hljs-string">&quot;出环的孩子编号为 %d \n&quot;</span>, first.getNo());<br>         <span class="hljs-comment">// first移动到下一位，以便删除</span><br>         first = first.getNext();<br>         helper.setNext(first); <span class="hljs-comment">//helper指向现在的位置，之前first指向的元素即被舍弃，会被GC回收</span><br>         <br>      &#125;<br>      System.out.printf(<span class="hljs-string">&quot;最后出环的孩子编号为 %d \n&quot;</span>, first.getNo());<br>      <br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// boy实体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> no;<span class="hljs-comment">// 数据域</span><br>   <span class="hljs-keyword">private</span> Boy next; <span class="hljs-comment">// 指针域</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Boy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.no = no;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNo</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> no;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.no = no;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Boy <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> next;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Boy next)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.next = next;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>3. 栈</h1><h2 id="3-1-初识栈">3.1 初识栈</h2><h3 id="什么是栈">什么是栈</h3><p>栈是一种先进后出的有序列表，限制删除和增加的操作只能在同一端的特殊线性表，变化的一端就是栈顶，另一端被我们称为栈底。</p><p><strong>栈的应用场景</strong></p><ul><li>子程序的调用</li><li>处理递归调用</li><li>表达式的求值</li><li>二叉树的遍历</li><li>图的深度优先搜索</li></ul><h3 id="实现思路-2">实现思路</h3><ul><li>使用数组来模拟栈</li><li>栈顶定义为top，初始值设为-1</li><li>入栈 top++ ; stack[top] = data;</li><li>出栈 int value = stack[top]; top–;</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用数组来模拟栈</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] stack;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//栈顶</span><br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span></span>&#123;<br><span class="hljs-keyword">this</span>.maxSize  = maxSize;<br>stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];<br>&#125;<br><br><span class="hljs-comment">//判断栈满</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> top == maxSize - <span class="hljs-number">1</span>;<span class="hljs-comment">//wc 简直机智</span><br>&#125;<br><br><span class="hljs-comment">//判断栈空</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//入栈</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br><span class="hljs-keyword">if</span>(isFull()) &#123;<br>System.out.println(<span class="hljs-string">&quot;栈已经满了&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>top++;<br>stack[top] = value;<br>&#125;<br><br><span class="hljs-comment">//出栈</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>  <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(isEmpty())&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span>  RuntimeException(<span class="hljs-string">&quot;栈已经空了&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> value = stack[top];<br>top--;<br><span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">//遍历栈</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(isEmpty())&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈为空&quot;</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = top; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>   System.out.printf(<span class="hljs-string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStackDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ArrayStack arrayStack = <span class="hljs-keyword">new</span> ArrayStack(<span class="hljs-number">4</span>);<br>arrayStack.push(<span class="hljs-number">10</span>);<br>arrayStack.push(<span class="hljs-number">9</span>);<br>arrayStack.push(<span class="hljs-number">4</span>);<br>System.out.println(arrayStack.pop());<br>System.out.println(arrayStack.pop());<br>System.out.println(arrayStack.pop());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="3-2-表达式求值">3.2 表达式求值</h2><p>表达式求值是栈的经典的应用之一,简单的来说，就是把一长串的数学表达式，通过程序计算出来，实现一个计算机的功能</p><h3 id="实现的思路">实现的思路</h3><ul><li>建立两个栈来分别存储数字和运算符号，并使用一个索引遍历表达式</li><li>遇到数字直接就进入数栈</li><li>遇到符号<ul><li>如果符号栈是空的，直接入符号栈</li><li>如果不是空的，当前的符号的优先级小于或等于栈顶的元素，符号栈弹出一个符号，数字栈弹出两个数字计算，运算结果进入数字栈，然后当前的符号入符号栈</li><li>如果不是空的，当前的符号的优先级大于栈顶的元素，当前的元素直接入符号栈</li></ul></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Mercury.stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>String expression = <span class="hljs-string">&quot;7*2*2-5+1-5+3-4&quot;</span>; <span class="hljs-comment">// 18</span><br><br>ArrayStack2 numStack = <span class="hljs-keyword">new</span> ArrayStack2(<span class="hljs-number">10</span>);<br>ArrayStack2 operStack = <span class="hljs-keyword">new</span> ArrayStack2(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">int</span> num2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> oper = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27; &#x27;</span>;<br>String keepNum = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>ch = expression.substring(index, index+<span class="hljs-number">1</span>).charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//取出表达式里面的字符</span><br><span class="hljs-keyword">if</span>(operStack.isOper(ch)) &#123;<span class="hljs-comment">//判断是否是符号</span><br><span class="hljs-keyword">if</span>(!operStack.isEmpty()) &#123;<span class="hljs-comment">//如果栈没有空</span><br><span class="hljs-keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;<span class="hljs-comment">//新的符号没有栈顶的符号优先级高</span><br>num1 = numStack.pop();<br>num2 = numStack.pop();<span class="hljs-comment">//弹两个数字出来</span><br>oper = operStack.pop();<span class="hljs-comment">//弹一个符号出来</span><br>res = numStack.cal(num1, num2, oper);<span class="hljs-comment">//计算结果</span><br>numStack.push(res);<span class="hljs-comment">//结果入栈</span><br>operStack.push(ch);<span class="hljs-comment">//新的符号入栈</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//新的符号比栈顶的符号优先级高，直接入栈</span><br>operStack.push(ch);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>operStack.push(ch); <span class="hljs-comment">//符号栈是空的，直接入栈</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//是数字</span><br>keepNum += ch;<span class="hljs-comment">//拼接成字符串</span><br><span class="hljs-keyword">if</span> (index == expression.length() - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果是在字符串的尾巴，说明后面不会再有数字，直接转换为数字入栈</span><br>numStack.push(Integer.parseInt(keepNum));<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span> (operStack.isOper(expression.substring(index+<span class="hljs-number">1</span>,index+<span class="hljs-number">2</span>).charAt(<span class="hljs-number">0</span>))) &#123;<span class="hljs-comment">//后面一位是符号，也是转换为数字后入栈</span><br>numStack.push(Integer.parseInt(keepNum));<br>keepNum = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//入栈后，清空原来的字符串</span><br>&#125;<br><span class="hljs-comment">//如果没有进上面那个if分支，keepNum就会一直加，直到后面一位是符号后才入栈</span><br>&#125;<br>&#125;<br>index++;<br><span class="hljs-keyword">if</span> (index &gt;= expression.length()) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//全部入栈后</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(operStack.isEmpty()) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>num1 = numStack.pop();<br>num2 = numStack.pop();<br>oper = operStack.pop();<br>res = numStack.cal(num1, num2, oper);<span class="hljs-comment">//依次弹出栈，进行运算</span><br>numStack.push(res);<br>&#125;<br><span class="hljs-keyword">int</span> res2 = numStack.pop();<span class="hljs-comment">//得到最后的结果</span><br>System.out.printf(<span class="hljs-string">&quot; %s = %d&quot;</span>, expression, res2);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack2</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] stack;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top = -<span class="hljs-number">1</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.maxSize = maxSize;<br>stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> stack[top];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> top == maxSize - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(isFull()) &#123;<br>System.out.println(<span class="hljs-string">&quot;栈是满的&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>top++;<br>stack[top] = value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(isEmpty()) &#123;<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈是空的~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> value = stack[top];<br>top--;<br><span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>System.out.println(<span class="hljs-string">&quot;栈是空的~~&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = top; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>System.out.printf(<span class="hljs-string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oper)</span> </span>&#123;<span class="hljs-comment">//判断优先级的额函数</span><br><span class="hljs-keyword">if</span>(oper == <span class="hljs-string">&#x27;*&#x27;</span> || oper == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&#x27;+&#x27;</span> || oper == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOper</span><span class="hljs-params">(<span class="hljs-keyword">char</span> val)</span> </span>&#123;<br><span class="hljs-keyword">return</span> val == <span class="hljs-string">&#x27;+&#x27;</span> || val == <span class="hljs-string">&#x27;-&#x27;</span> || val == <span class="hljs-string">&#x27;*&#x27;</span> || val == <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2, <span class="hljs-keyword">int</span> oper)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">switch</span> (oper) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>res = num1 + num2;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>res = num2 - num1; <span class="hljs-comment">//后弹出栈的减先弹出栈的数字</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>res = num1 * num2;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>res = num2 / num1;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-3-中缀转后缀">3.3 中缀转后缀</h2><p><strong>后缀表达式(逆波兰表达式)的计算</strong></p><p>从左到右扫描后缀表达式，遇到数字入栈，遇到符号，弹出两个数字计算，将结果入栈，最后得出最后结果，</p><h3 id="实现思路-3">实现思路</h3><ul><li>初始化一个符号栈s1，一个存储中间结果的栈s2，从左到右扫描表达式</li><li>遇到数字，直接压入s2</li><li>遇到运算符<ul><li>s1为空，s1栈顶为左括号’ ( ',当前符号比栈顶运算符优先级高，直接入栈s1</li><li>否则(s1栈顶的元素优先级小于或等于当前的元素的优先级)将s1栈顶的运算符弹出并压入s2中，再次与s1中的栈顶元素比较</li></ul></li><li>遇到括号<ul><li>遇到左括号’(’ 直接压入s1</li><li>遇到右括号 ‘)’  依次弹出s1栈顶的运算符并压入s2,直到遇到左括号为止，然后将这一对括号丢弃</li></ul></li><li>将s1中剩余的运算符依次弹出并压入s2</li><li>依次弹出s2中的元素并输出，结果的逆序就是结果</li></ul><p><strong>1+( ( 2 + 3 ) * 4 ) - 5 的转换过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220707165627801.png" alt=""></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolandNotation</span> </span>&#123;<br><br><br><span class="hljs-comment">//中缀表达式转后缀表达式</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><br><br>String expression = <span class="hljs-string">&quot;1+((2+3)*4)-5&quot;</span>;<br>List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);<br>System.out.println(<span class="hljs-string">&quot;中缀表达式 List=&quot;</span> + infixExpressionList); <span class="hljs-comment">// ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br>List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);<br>System.out.println(<span class="hljs-string">&quot;后缀表达式 List&quot;</span> + suffixExpreesionList); <span class="hljs-comment">//ArrayList [1,2,3,+,4,*,+,5,-]</span><br>System.out.printf(<span class="hljs-string">&quot;expression=%d&quot;</span>, calculate(suffixExpreesionList)); <span class="hljs-comment">// 最后的计算结果</span><br><br>&#125;<br><br><span class="hljs-comment">// 将表达式装入集合</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">toInfixExpressionList</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>List&lt;String&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>String str;<br><span class="hljs-keyword">char</span> c;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//如果是数字</span><br><span class="hljs-keyword">if</span>((c=s.charAt(i)) &lt; <span class="hljs-number">48</span> ||  (c=s.charAt(i)) &gt; <span class="hljs-number">57</span>) &#123;<br>ls.add(<span class="hljs-string">&quot;&quot;</span> + c);<br>i++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= <span class="hljs-number">48</span> &amp;&amp; (c=s.charAt(i)) &lt;= <span class="hljs-number">57</span>) &#123;<br>str += c;<br>i++;<br>&#125;<br>ls.add(str);<br>&#125;<br>&#125;<span class="hljs-keyword">while</span>(i &lt; s.length());<br><span class="hljs-keyword">return</span> ls;<br>&#125;<br><br><span class="hljs-comment">//中缀转换为后缀的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">parseSuffixExpreesionList</span><span class="hljs-params">(List&lt;String&gt; ls)</span> </span>&#123;<br><br>Stack&lt;String&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;String&gt;();<br>List&lt;String&gt; s2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br><span class="hljs-keyword">for</span>(String item: ls) &#123;<br><span class="hljs-keyword">if</span>(item.matches(<span class="hljs-string">&quot;\\d+&quot;</span>)) &#123;<br>s2.add(item);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>s1.push(item);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br><span class="hljs-keyword">while</span>(!s1.peek().equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>s2.add(s1.pop());<br>&#125;<br>s1.pop();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span>(s1.size() != <span class="hljs-number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123;<br>s2.add(s1.pop());<br>&#125;<br>s1.push(item);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span>(s1.size() != <span class="hljs-number">0</span>) &#123;<br>s2.add(s1.pop());<br>&#125;<br><span class="hljs-keyword">return</span> s2;<br><br>&#125;<br><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getListString</span><span class="hljs-params">(String suffixExpression)</span> </span>&#123;<br><span class="hljs-comment">// suffixExpression</span><br>String[] split = suffixExpression.split(<span class="hljs-string">&quot; &quot;</span>);<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-keyword">for</span>(String ele: split) &#123;<br>list.add(ele);<br>&#125;<br><span class="hljs-keyword">return</span> list;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(List&lt;String&gt; ls)</span> </span>&#123;<br><br>Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;String&gt;();<br><br><span class="hljs-keyword">for</span> (String item : ls) &#123;<br><br><span class="hljs-keyword">if</span> (item.matches(<span class="hljs-string">&quot;\\d+&quot;</span>)) &#123; <span class="hljs-comment">// 使用正则表达式判断是不是数字</span><br>stack.push(item);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> num2 = Integer.parseInt(stack.pop());<br><span class="hljs-keyword">int</span> num1 = Integer.parseInt(stack.pop());<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>res = num1 + num2;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>res = num1 - num2;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>res = num1 * num2;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>res = num1 / num2;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;符号非法&quot;</span>);<br>&#125;<br>stack.push(<span class="hljs-string">&quot;&quot;</span> + res);<span class="hljs-comment">//计算结果入栈</span><br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> Integer.parseInt(stack.pop());<span class="hljs-comment">//最后留在栈中的，就是最后的结果</span><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Operation</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ADD = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SUB = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MUL = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> DIV = <span class="hljs-number">2</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(String operation)</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">switch</span> (operation) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>result = ADD;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>result = SUB;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>result = MUL;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>result = DIV;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">中缀表达式 List=[<span class="hljs-number">1</span>, +, (, (, <span class="hljs-number">2</span>, +, <span class="hljs-number">3</span>, ), *, <span class="hljs-number">4</span>, ), -, <span class="hljs-number">5</span>]<br>后缀表达式 List[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, +, <span class="hljs-number">4</span>, *, +, <span class="hljs-number">5</span>, -]<br>expression=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h1>4. 递归</h1><h2 id="4-1-初识递归">4.1 初识递归</h2><p><strong>递归的简单介绍</strong></p><p>简单的来说就是自己调用自己，每次调用的时候都传入不同的变量，递归有助于解决，复杂的问题，虽然他自己空间复杂度太高有时会导致算法的效率不高</p><h3 id="递归需要遵守的规则">递归需要遵守的规则</h3><ul><li>执行一个方法的时候，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的</li><li>如果方法中使用的是引用类型的变量(比如数组)，就会共享该类型的的数据</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError</li><li>当一个方法执行完毕，或者遇到return的时候，就会返回，遵守谁调用就返回给谁的原则</li></ul><h2 id="4-2-迷宫问题">4.2 迷宫问题</h2><p>从迷宫的左上角走到右下角，问你路径(这里还不是最短路径)</p><h3 id="实现思路-4">实现思路</h3><ul><li>使用1标记墙，0代表没有走过的路，2代表走过可行的路，3代表走不通的路</li><li>使用递归依次遍历下，右，上，左四个方向，如果走不通则标记当前为3，返回上一级，重新走</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiGong</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[][] map =  <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)&#123;<br>map[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>map[<span class="hljs-number">7</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>map[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>map[i][<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><br>map[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>map[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><br>setway(map,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">7</span>; j++) &#123;<br>System.out.print(map[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setway</span><span class="hljs-params">(<span class="hljs-keyword">int</span> map[][], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br><span class="hljs-keyword">if</span>(map[<span class="hljs-number">6</span>][<span class="hljs-number">5</span>] == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//递归出口</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(map[i][j] == <span class="hljs-number">0</span>)&#123;<br>map[i][j] = <span class="hljs-number">2</span>;<span class="hljs-comment">//先假设走得通，做个标记，表示已经走过</span><br><span class="hljs-keyword">if</span>(setway(map,i+<span class="hljs-number">1</span>,j))&#123;<span class="hljs-comment">//向下</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(setway(map,i,j+<span class="hljs-number">1</span>))&#123;<span class="hljs-comment">//向右</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(setway(map,i-<span class="hljs-number">1</span>,j))&#123;<span class="hljs-comment">//向上</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(setway(map,i,j-<span class="hljs-number">1</span>))&#123;<span class="hljs-comment">//向左</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>map[i][j] = <span class="hljs-number">3</span>;<span class="hljs-comment">//这个点走不通</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// map[i][j] == 1,2,3</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><h2 id="4-3-八皇后问题">4.3 八皇后问题</h2><h3 id="问题描述">问题描述</h3><p>这个问题是一个经典的问题，回溯算法的经典案例，即在一个8*8的棋盘上面，摆放8个皇后棋子，这8个棋子不能在同一行，不能再同一列，也不能在同一条斜线上，问一共有几种摆放的方法</p><h3 id="实现思路-5">实现思路</h3><ul><li>第一个棋子先放在第一行第一列</li><li>第二个棋子放在第二行第一列，判断是不是可行，不可行就放在第二行第二列，继续判断</li><li>继续上述步骤，直到摆放完8个棋子，得到一个可行的结果，如果都不可行，就返回上一个步骤，放在下一个位置</li><li>一直回溯，直到找到全部的解</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue8</span> </span>&#123;<br><span class="hljs-keyword">int</span> max = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max];<span class="hljs-comment">//数组是引用类型</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>  count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Queue8 queue = <span class="hljs-keyword">new</span> Queue8();<br>queue.cheak(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;总数为 ：&quot;</span>+count);<br>&#125;<br><br><br><span class="hljs-comment">//摆放棋子的函数</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x   在第几行摆放，也就是横坐标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">cheak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-comment">//递归的出口</span><br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">8</span>)&#123;<br>print(array);<br>count++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//i 代表在第几列摆放棋子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++) &#123;<br>array[x] = i;<br><span class="hljs-keyword">if</span>(judge(x))&#123;<span class="hljs-comment">//如果在这一列成功摆放</span><br>cheak(x+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-comment">//如果在同一列或者同一条斜线上，则不成立,后面斜线的判断其实就是类似 斜率的判断</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>System.out.print(<span class="hljs-string">&quot; &quot;</span>+ array[i]);<br>&#125;<br>System.out.println();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span><br> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span><br> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span><br> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span><br> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span><br> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span><br> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span><br> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span><br> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span><br> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span><br> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span><br> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span><br> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span><br> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span><br> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span><br> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span><br> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span><br> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><br> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span><br> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span><br> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br>总数为 ：<span class="hljs-number">92</span><br></code></pre></td></tr></table></figure><h1>5. 排序算法</h1><h2 id="5-1-算法的时间复杂度">5.1 算法的时间复杂度</h2><p>我们一般使用O()来表示算法的时间复杂度</p><p>推导时间复杂度</p><ol><li>用1取代所有的加法常数</li><li>只保留最高阶项</li><li>去掉最高阶项的常数(非常数的时候)</li></ol><p><strong>常数阶</strong></p><p>比如一般的分支结构都是O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>System.out.println(sum);<br></code></pre></td></tr></table></figure><p><strong>线性阶</strong></p><p>循环结构就是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对数阶</strong></p><p>下面的这写代码，每次循环count就变为两倍，则运行的次数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^x=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">x=log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>,时间复杂度就是O(log n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(count&lt;n)&#123;<br>    count = count*<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>平方阶</strong></p><p>简单来说就是双重循环就是平方阶了，当然还是得按照推导方法来推导</p><p><strong>常见的时间度</strong></p><p>O(1) &lt; O(logn)&lt; O(n)&lt; O(nlogn)&lt; O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)&lt; O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)&lt; O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)&lt; O(n!)&lt; O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</p><p><strong>算法的空间复杂度</strong></p><p>衡量算法性能的另一个指示标准，算法的空间复杂度的计算公式记作<strong>S(n) = O(f(n))</strong>;  n为问题的规模，f(n)为语句关于n所占存储空间的函数</p><div class = "note note-success">各个算法的动画演示</div><p>由于这个博客系统的原因，动图显示不出来，因此在这里贴一个动图连接<a href="https://zhuanlan.zhihu.com/p/60152722">数据结构与算法系列–十大排序（附动态图解） - 知乎 (zhihu.com)</a></p><h2 id="5-2-冒泡排序">5.2 冒泡排序</h2><h3 id="冒泡简介">冒泡简介</h3><p>冒泡排序应该说是程序员的入门排序算法了，他的基本的思想就是，从数组的较小的元素开始，依次比较相邻的两个元素的值，如果是逆序，则把两个值交换，</p><p>因为需要比较很多次，因此效率很低。</p><div class = "note note-success">优化</div><p>如果一趟比较下来没有进行过交换，就说明序列有序，因此可以通过设置一个flag来判断，用来减少不必要的交换</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span></span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>&#125;;<br>      bubblesort(arr);<br>      System.out.println(Arrays.toString(arr));<br><br>      <span class="hljs-comment">//测试性能</span><br>      <span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>;i++) &#123;<br>         testArr[i] = (<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">8000000</span>);<br>      &#125;<span class="hljs-comment">//生成80000万个数据</span><br>      <span class="hljs-keyword">long</span> startTime=System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>      bubblesort(testArr);<br><br>      <span class="hljs-keyword">long</span> endTime=System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>      System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br><br>   &#125;<br><br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubblesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//加flag优化</span><br>      <br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&lt;arr[j])&#123;<br>               flag = <span class="hljs-keyword">true</span>;<br>               temp = arr[i];<br>               arr[i] = arr[j];<br>               arr[j] = temp;<br>            &#125;<br>         &#125;<br>          <br>         <span class="hljs-keyword">if</span>(!flag)&#123;<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            flag = <span class="hljs-keyword">false</span>;<br>         &#125;<br>      &#125;<br><br><br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>]<br>八万个随机数据程序运行时间： 7760ms<br></code></pre></td></tr></table></figure><h2 id="5-3-选择排序">5.3 选择排序</h2><h3 id="选择排序简介">选择排序简介</h3><p>选择排序也属于内部排序法，按指定的规则选出一个元素，再依次按规定交换位置，达到排序的目的，他的基本的思想就是从要开始的排序的下标开始，把当前的数据看作是最小的数据，然后遍历后面的数据，并且不断刷新最小值，遍历完成后，与刚刚位置上面的值相比，如果没有变，就不做处理，否则交换。第二个位置则不断刷新后面未排序的里面的最小值，重复上述操作，直到排序完成。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectSort</span></span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">101</span>, <span class="hljs-number">34</span>, <span class="hljs-number">119</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">90</span>, <span class="hljs-number">123</span>&#125;;<br>selectsort(arr);<br>System.out.println(Arrays.toString(arr));<br><br><span class="hljs-comment">//测试性能</span><br><span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>;i++) &#123;<br>testArr[i] = (<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">8000000</span>);<br>&#125;<span class="hljs-comment">//生成80000个数据</span><br><span class="hljs-keyword">long</span> startTime=System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>selectsort(testArr);<br><br><span class="hljs-keyword">long</span> endTime=System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;<br><br><span class="hljs-keyword">int</span> min;<span class="hljs-comment">//熟悉的交换排序</span><br><span class="hljs-keyword">int</span> minIndex;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) &#123;<br>min = arr[i];<br>minIndex = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<span class="hljs-comment">//寻找后面位置没有进行排序的最小的数字</span><br><span class="hljs-keyword">if</span>(min &gt; arr[j])&#123;<br>min = arr[j];<br>minIndex = j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(min != arr[i])&#123;<span class="hljs-comment">//发现了有更小的数字就交换</span><br>arr[minIndex] = arr[i];<br>arr[i] = min;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">90</span>, <span class="hljs-number">101</span>, <span class="hljs-number">119</span>, <span class="hljs-number">123</span>]<br>八万个随机数据程序运行时间：  1999ms<br></code></pre></td></tr></table></figure><h2 id="5-4-插入排序">5.4 插入排序</h2><h3 id="插入排序简介">插入排序简介</h3><p>插入排序也属于内部排序，基本思想就是把已经排好的数据看作一组，把未排序的数据一个一个在里面找到属于自己的合适位置，并在这个过程中，把已经排好顺序的数据后移，直到那个数据找到合适的位置插入进去。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//插入排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">101</span>, <span class="hljs-number">34</span>, <span class="hljs-number">119</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">89</span>&#125;;<br>        insertsort(arr);<br>        System.out.println(Arrays.toString(arr));<br><br>        <span class="hljs-comment">//测试性能</span><br>        <span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>; i++) &#123;<br>            testArr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">8000000</span>);<br>        &#125;<span class="hljs-comment">//生成80000个数据</span><br>        <span class="hljs-keyword">long</span> startTime=System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>        insertsort(testArr);<br><br>        <span class="hljs-keyword">long</span> endTime=System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> insertVal;<br>        <span class="hljs-keyword">int</span> insertIndex;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            insertVal = arr[i];<br>            insertIndex = i - <span class="hljs-number">1</span>;<span class="hljs-comment">//此时指向前面待插入的最后一位</span><br>            <span class="hljs-keyword">while</span> (insertIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;<br>                arr[insertIndex + <span class="hljs-number">1</span>] = arr[insertIndex];<br>                insertIndex--;<br>            &#125;<br>            <span class="hljs-comment">//这时候就找到了应该插入的位置</span><br><br>            <span class="hljs-keyword">if</span> (insertIndex + <span class="hljs-number">1</span> != i) &#123;<span class="hljs-comment">//优化</span><br>                arr[insertIndex + <span class="hljs-number">1</span>] = insertVal;<span class="hljs-comment">//这里的索引是多移动了一位的  所以需要加上一个 1</span><br>            &#125;<br><br>        &#125;<br><br><span class="hljs-comment">//        //另一种写法</span><br><span class="hljs-comment">//        for (int i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="hljs-comment">//            int insertVal = arr[i];</span><br><span class="hljs-comment">//            int insertIndex = i ;</span><br><span class="hljs-comment">//            if(arr[insertIndex]&lt;arr[insertIndex-gap]) &#123;</span><br><span class="hljs-comment">//                while (insertIndex- gap &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex-gap]) &#123;</span><br><span class="hljs-comment">//                    arr[insertIndex ] = arr[insertIndex- gap];</span><br><span class="hljs-comment">//                    insertIndex -= gap;//不断的向前移动找寻待插入的位置</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            arr[insertIndex] = insertVal;</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">89</span>, <span class="hljs-number">101</span>, <span class="hljs-number">119</span>]<br>八万个随机数据程序运行时间： 437ms<br></code></pre></td></tr></table></figure><h2 id="5-5-希尔排序">5.5 希尔排序</h2><h3 id="希尔排序简介">希尔排序简介</h3><p>很明显，希尔排序是由希尔这个人提出来的，他是简单插入排序的经过改进后的一个更高效的版本，也被称为<strong>缩小增量排序</strong>。他的基本思想就是，把数组数据按照下标的一些分组，不断进行插入排序，分组逐渐减少，当减少到1的时候，算法便终止。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//shell排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShellSort</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>        shellsortSwap(arr);<br>        System.out.println(Arrays.toString(arr));<br><br>        <span class="hljs-keyword">int</span>[] arr2 = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>        shellsortInsert(arr2);<br>        System.out.println(Arrays.toString(arr2));<br><br>        <span class="hljs-comment">//测试性能</span><br>        <span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>; i++) &#123;<br>            testArr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">8000000</span>);<br>        &#125;<span class="hljs-comment">//生成80000个数据</span><br>        <span class="hljs-keyword">long</span> startTime=System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>        shellsortInsert(testArr);<br><br>        <span class="hljs-keyword">long</span> endTime=System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//希尔排序交换法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellsortSwap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">//交换法的希尔排序其实这里面的这一层就是加了步长的冒泡</span><br>            <span class="hljs-comment">//所以效率低下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - gap; j &gt;= <span class="hljs-number">0</span>; j -= gap) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;<br>                        temp = arr[j + gap];<br>                        arr[j + gap] = arr[j];<br>                        arr[j] = temp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//这里才是正宗的shell排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellsortInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//步长逐渐减少</span><br>            <span class="hljs-comment">//里面使用直接插入排序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;<br>                <span class="hljs-keyword">int</span> insertVal = arr[i];<br>                <span class="hljs-keyword">int</span> insertIndex = i;<br>                <span class="hljs-keyword">if</span> (arr[insertIndex] &lt; arr[insertIndex - gap]) &#123;<br>                    <span class="hljs-keyword">while</span> (insertIndex - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex - gap]) &#123;<br>                        arr[insertIndex] = arr[insertIndex - gap];<br>                        insertIndex -= gap;<span class="hljs-comment">//不断的向前移动找寻待插入的位置</span><br>                    &#125;<br>                &#125;<br>                arr[insertIndex] = insertVal;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>程序运行时间： 17ms<br></code></pre></td></tr></table></figure><h2 id="5-6-快速排序">5.6 快速排序</h2><h3 id="快速排序简介">快速排序简介</h3><p>快速排序是对冒泡排序的一种改进，基本思想就是把将要排序的数据分为两组，其中一部分的数据比另外的一部分都要小，然后把这两组数据分别再次进行相同的操作，直到排序完成，整个过程通过递归实现。快排是一种不稳定排序</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//快速排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">9</span>, <span class="hljs-number">78</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23</span>, -<span class="hljs-number">567</span>, <span class="hljs-number">70</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">900</span>, <span class="hljs-number">4561</span>&#125;;<br>        quicksort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(arr));<br><br>        <span class="hljs-comment">//测试性能</span><br>        <span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>; i++) &#123;<br>            testArr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">8000000</span>);<br>        &#125;<span class="hljs-comment">//生成80000个数据</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>        quicksort(testArr, <span class="hljs-number">0</span>, testArr.length - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot;ms&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot;<br>        <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>            pivot = Partition(arr, low, high);<br>            quicksort(arr, low, pivot - <span class="hljs-number">1</span>);<span class="hljs-comment">//对左边快排</span><br>            quicksort(arr, pivot + <span class="hljs-number">1</span>, high);<span class="hljs-comment">//对右边快排</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivotkey;<br>        pivotkey = arr[low];<span class="hljs-comment">//把低位的数当作中轴</span><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivotkey) &#123;<br>                high--;<br>            &#125;<br>            Swap(arr, low, high);<span class="hljs-comment">//不断寻找比中轴大的数，交换到右边</span><br>            <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivotkey) &#123;<br>                low++;<br>            &#125;<br>            Swap(arr, low, high);<span class="hljs-comment">//不断寻找比中轴小的数，交换到左边</span><br>        &#125;<span class="hljs-comment">//low==high了，退出循环，中轴数已经被环岛路中间</span><br>        <span class="hljs-keyword">return</span> low;<span class="hljs-comment">//返回下标</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = temp;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[-<span class="hljs-number">567</span>, -<span class="hljs-number">9</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23</span>, <span class="hljs-number">70</span>, <span class="hljs-number">78</span>, <span class="hljs-number">900</span>, <span class="hljs-number">4561</span>]<br>程序运行时间： 11ms<br></code></pre></td></tr></table></figure><h2 id="5-7-归并排序">5.7 归并排序</h2><h3 id="归并排序简介">归并排序简介</h3><p>这是一种利用归并思想实现的排序算法，该算法采用经典的分治思想，(分)先把数据分成很小的部分，(治)然后分别排序，即分而治之。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//归并排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergetSort</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">int</span> temp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<span class="hljs-comment">//需要额外的空间</span><br><br>mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>,temp);<br>System.out.println(Arrays.toString(arr));<br><br><br><span class="hljs-comment">//测试性能</span><br><span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>; i++) &#123;<br>testArr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">8000000</span>);<br>&#125;<span class="hljs-comment">//生成80000个数据</span><br><span class="hljs-keyword">int</span> testTemp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[testArr.length];<span class="hljs-comment">//需要额外的空间</span><br><br><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>mergeSort(testArr, <span class="hljs-number">0</span>, testArr.length - <span class="hljs-number">1</span>,testTemp);<br><br><span class="hljs-keyword">long</span> endTime = System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot;ms&quot;</span>);<br><br><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(left &lt; right) &#123;<br><span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>mergeSort(arr, left, mid, temp);<span class="hljs-comment">//分</span><br>mergeSort(arr, mid + <span class="hljs-number">1</span>, right, temp);<span class="hljs-comment">//分</span><br>merge(arr, left, mid, right, temp);<span class="hljs-comment">//治</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//将小的部分合成有序的大部分的函数，即治</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> i = left;<br><span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br><span class="hljs-keyword">if</span>(arr[i] &lt;= arr[j]) &#123;<br>temp[t] = arr[i];<br>t += <span class="hljs-number">1</span>;<br>i += <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>temp[t] = arr[j];<br>t += <span class="hljs-number">1</span>;<br>j += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<span class="hljs-comment">//分别在临时数组中放入两个之中较小的数</span><br><br><span class="hljs-keyword">while</span>( i &lt;= mid) &#123;<br>temp[t] = arr[i];<br>t += <span class="hljs-number">1</span>;<br>i += <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//将前面剩余的数放入数组</span><br><br><span class="hljs-keyword">while</span>( j &lt;= right) &#123;<br>temp[t] = arr[j];<br>t += <span class="hljs-number">1</span>;<br>j += <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//将后面剩余的数放入数组</span><br><br>t = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> tempLeft = left;<br><span class="hljs-keyword">while</span>(tempLeft &lt;= right) &#123;<br>arr[tempLeft] = temp[t];<br>t += <span class="hljs-number">1</span>;<br>tempLeft += <span class="hljs-number">1</span>;<span class="hljs-comment">//将数据倒腾回去</span><br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>程序运行时间： 12ms<br></code></pre></td></tr></table></figure><h2 id="5-8-基数排序">5.8 基数排序</h2><h3 id="基数排序简介">基数排序简介</h3><p>基数排序是稳定的排序算法，是桶排序的拓展。基本的思想就是把每个数字切割出来，然后将他们按照个位大小放入桶中，排完之后，取出放入数组，然后比较十位大小，直到排序完。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基数排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">53</span>, <span class="hljs-number">3</span>, <span class="hljs-number">542</span>, <span class="hljs-number">748</span>, <span class="hljs-number">14</span>, <span class="hljs-number">214</span>&#125;;<br>radixSort(arr);<br>System.out.println(Arrays.toString(arr));<br><br><span class="hljs-comment">//测试性能</span><br><span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>; i++) &#123;<br>testArr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">8000000</span>);<br>&#125;<span class="hljs-comment">//生成80000个数据</span><br><span class="hljs-keyword">int</span> testTemp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[testArr.length];<span class="hljs-comment">//需要额外的空间</span><br><br><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>radixSort(testArr);<br><br><span class="hljs-keyword">long</span> endTime = System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot;ms&quot;</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>max = arr[i];<span class="hljs-comment">//找出最大的数</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> maxLength = (max + <span class="hljs-string">&quot;&quot;</span>).length();<span class="hljs-comment">//秀，找出有多少位</span><br><br><span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][arr.length];<span class="hljs-comment">//桶</span><br><span class="hljs-keyword">int</span>[] bucketElementCounts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> , n = <span class="hljs-number">1</span>; i &lt; maxLength; i++, n *= <span class="hljs-number">10</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br><span class="hljs-keyword">int</span> digitOfElement = arr[j] / n % <span class="hljs-number">10</span>;<br>bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];<span class="hljs-comment">//在对应桶的第几位上面放上数字</span><br>bucketElementCounts[digitOfElement]++;<span class="hljs-comment">//该桶放的数字数量加一</span><br>&#125;<br><br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;<span class="hljs-comment">//遍历每个桶</span><br><span class="hljs-keyword">if</span>(bucketElementCounts[k] != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;<br>arr[index++] = bucket[k][l];<span class="hljs-comment">//将桶内的数据拿出来放在数组里面</span><br>&#125;<br>&#125;<br>bucketElementCounts[k] = <span class="hljs-number">0</span>;<br><br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">3</span>, <span class="hljs-number">14</span>, <span class="hljs-number">53</span>, <span class="hljs-number">214</span>, <span class="hljs-number">542</span>, <span class="hljs-number">748</span>]<br>程序运行时间： 16ms<br></code></pre></td></tr></table></figure><h2 id="5-9-排序算法总结">5.9 排序算法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220715205437105.png" alt="排序算法"></p><p>相关属术语解释：</p><ul><li>稳定：如果 a 原本在 b 前面，而 a == b ，排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面，而 a == b ，排序之后 a 可能会出现在 b 的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度：一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n :数据规模</li><li>k :“桶”的个数</li><li>In - place :  不占用额外内存</li><li>Out - place ：占用额外内存</li></ul><h1>6. 查找</h1><h2 id="6-1-二分查找">6.1 二分查找</h2><h3 id="实现思路-6">实现思路</h3><ul><li><p>首先通过左右两个索引确定数组的下标，即mid</p><ul><li>$ mid = low + F(k - 1) -1 $</li></ul></li><li><p>让target与中间值对比，如果target大于该值，则继续往前二分查找，否则，就往后继续二分查找</p></li><li><p>如果中间值==target说明目标找到，结束递归，或者左边的索引已经大于了右边的索引，说明没有找到，结束递归</p></li><li><p>特别注意：二分查找的前提是这一系列的数据都已经排序好，后续的几个查找，都需要<strong>排序好</strong></p></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearch</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>&#125;;<br>        <span class="hljs-keyword">int</span> resIndex = binarySearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, <span class="hljs-number">17</span>);<br>        System.out.println(<span class="hljs-string">&quot;resIndex=&quot;</span> + resIndex);<br><br>        <span class="hljs-keyword">int</span> arr2[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>&#125;;<br>        List&lt;Integer&gt; resIndexList = binarySearch2(arr2, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;resIndex=&quot;</span> + resIndexList);<br><br><br>    &#125;<br><br>    <br>    <span class="hljs-comment">//查找单一的值，找到就返回下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt; high || target &gt; arr[arr.length - <span class="hljs-number">1</span>] || target &lt; arr[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; target) &#123;<br>            <span class="hljs-keyword">return</span> binarySearch(arr, low, mid - <span class="hljs-number">1</span>, target);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;<br>            <span class="hljs-keyword">return</span> binarySearch(arr, mid + <span class="hljs-number">1</span>, high, target);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//找寻等于该值的所有下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">binarySearch2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt; high || target &gt; arr[arr.length - <span class="hljs-number">1</span>] || target &lt; arr[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; target) &#123;<br>            <span class="hljs-keyword">return</span> binarySearch2(arr, low, mid - <span class="hljs-number">1</span>, target);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;<br>            <span class="hljs-keyword">return</span> binarySearch2(arr, mid + <span class="hljs-number">1</span>, high, target);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//找到下标之后，向两边遍历</span><br>            ArrayList&lt;Integer&gt; resIndexlist = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> temp = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> || arr[temp] != target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                resIndexlist.add(temp);<br>                temp -= <span class="hljs-number">1</span>;<br>            &#125;<br>            resIndexlist.add(mid);<br><br>            temp = mid +<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (temp &gt;= arr.length || arr[temp] != target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                resIndexlist.add(temp);<br>                temp += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> resIndexlist;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">resIndex=<span class="hljs-number">16</span><br>resIndex=[<span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure><h2 id="6-2-插值查找">6.2 插值查找</h2><h3 id="实现思路-7">实现思路</h3><p>简单的来说，就是把上述二分查找的mid索引，换成了一个新的公式算出来的新索引，其他的都一样</p><p>$ mid = low + \frac{target - arr[low]}{arr[high] - arr[low]} * (high - low) $</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertValueSearch</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">89</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1234</span>&#125;;<br>        <span class="hljs-keyword">int</span> resIndex = insertvalueSearch(arr,<span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>,<span class="hljs-number">1234</span>);<br>        System.out.println(resIndex);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertvalueSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target &lt; arr[<span class="hljs-number">0</span>] || target &gt; arr[arr.length - <span class="hljs-number">1</span>] || low &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> mid = low + (high - low) * (target - arr[low]) / (arr[high] - arr[low]);<span class="hljs-comment">//精髓在于这个公式</span><br>        <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;<br>            <span class="hljs-keyword">return</span> insertvalueSearch(arr, mid + <span class="hljs-number">1</span>, high, target);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; arr[mid]) &#123;<br>            <span class="hljs-keyword">return</span> insertvalueSearch(arr, low, mid - <span class="hljs-number">1</span>, target);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">该数据下标是<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="6-3-斐波那契查找">6.3 斐波那契查找</h2><h3 id="实现思路-8">实现思路</h3><p>斐波那契查找与前面两种查找类似，仅仅只是改变了中间索引mid的位置，这个索引现在位于黄金分割点附近，即</p><p>$ mid = low + F(k - 1) -1 $</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220715204056396.png" alt="斐波那契查找"></p><p>感觉花里胡哨，并没有提高多少查找效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciSearch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> massize = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">89</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1234</span>&#125;;<br>        <span class="hljs-keyword">int</span> resIndex = fibonaccisearch(arr, <span class="hljs-number">1000</span>);<br>        System.out.println(resIndex);<br>    &#125;<br><br>    <span class="hljs-comment">//先构造一个斐波那契数列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] creatfibnacci() &#123;<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[massize];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; massize; i++) &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonaccisearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> f[] = creatfibnacci();<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> high = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (high &gt; f[k] - <span class="hljs-number">1</span>) &#123;<br>            k++;<br>        &#125;<span class="hljs-comment">//找到大于数组最大小标的最小fibonacci数</span><br><br>        <span class="hljs-keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);<br>        <span class="hljs-comment">//创造一个长度为f[k]的包含arr数组的临时数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = high + <span class="hljs-number">1</span>; i &lt; f[k]; i++) &#123;<br>            temp[i] = arr[high];<br>        &#125;<span class="hljs-comment">//将数组后面空出的部分用最大值填满</span><br><br><br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            mid = low + f[k - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (temp[mid] &gt; target) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>                k -= <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//前一段是f[k-1]，f[k-1]再分一次 ，就是 f[k-2]+f[k-3] 所以这里减1</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[mid] &lt; target) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>                k -= <span class="hljs-number">2</span>;<span class="hljs-comment">//后一段是f[k-2]，f[k-2]再分一次，就是 f[k-3]+f[k-4] 所以这里减2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">//因为数组是补充后的，可能查到后面重复的数字，所以这里返回两者中较小的数字</span><br>                <span class="hljs-keyword">if</span> (mid &lt; high) &#123;<br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> high;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//没有找到</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>7. 哈希表</h1><h2 id="7-1-哈希表的简单介绍">7.1 哈希表的简单介绍</h2><p>散列表，也叫哈希表，是根据关键码值二进行访问的数据结构，也就是说，它通过关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220724153014882.png" alt="简单的图示"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTabDemo</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><span class="hljs-comment">//创建新的哈希表</span><br>HashTab hashTab = <span class="hljs-keyword">new</span> HashTab(<span class="hljs-number">7</span>);<br><br><br>String key = <span class="hljs-string">&quot;&quot;</span>;<br>Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;add:  添加数据&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;list: 展示&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;find: 查找&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;exit: 退出&quot;</span>);<br><br>key = scanner.next();<br><span class="hljs-keyword">switch</span> (key) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add&quot;</span>:<br>System.out.println(<span class="hljs-string">&quot;输入id&quot;</span>);<br><span class="hljs-keyword">int</span> id = scanner.nextInt();<br>System.out.println(<span class="hljs-string">&quot;输入姓名&quot;</span>);<br>String name = scanner.next();<br><br>Emp emp = <span class="hljs-keyword">new</span> Emp(id, name);<br>hashTab.add(emp);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;list&quot;</span>:<br>hashTab.list();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;find&quot;</span>:<br>System.out.println(<span class="hljs-string">&quot;输入查找id&quot;</span>);<br>id = scanner.nextInt();<br>hashTab.findEmpById(id);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;exit&quot;</span>:<br>scanner.close();<br>System.exit(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTab</span> </span>&#123;<br><span class="hljs-keyword">private</span> EmpLinkedList[] empLinkedListArray;<span class="hljs-comment">//散列表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashTab</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.size = size;<br><span class="hljs-comment">//初始化empLinkedListArray</span><br>empLinkedListArray = <span class="hljs-keyword">new</span> EmpLinkedList[size];<br><span class="hljs-comment">//在每个后面初始化一个链表</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>empLinkedListArray[i] = <span class="hljs-keyword">new</span> EmpLinkedList();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//添加函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Emp emp)</span> </span>&#123;<br><span class="hljs-keyword">int</span> empLinkedListNO = hashFun(emp.id);<br>empLinkedListArray[empLinkedListNO].add(emp);<br><br>&#125;<br><span class="hljs-comment">//展示hashtab</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>empLinkedListArray[i].list(i);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//根据id来寻找节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findEmpById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">int</span> empLinkedListNO = hashFun(id);<br>Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);<br><span class="hljs-keyword">if</span>(emp != <span class="hljs-keyword">null</span>) &#123;<br>System.out.printf(<span class="hljs-string">&quot;在第%d条链表找到id = %d\n&quot;</span>, (empLinkedListNO + <span class="hljs-number">1</span>), id);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;没有找到该雇员&quot;</span>);<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashFun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">return</span> id % size;<br>&#125;<br><br><br>&#125;<br><br><span class="hljs-comment">//雇员节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">public</span> String name;<br><span class="hljs-keyword">public</span> Emp next; <span class="hljs-comment">//next 初始null</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Emp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//EmpLinkedList</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmpLinkedList</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> Emp head; <span class="hljs-comment">//null</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Emp emp)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;<br>head = emp;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>Emp curEmp = head;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(curEmp.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>curEmp = curEmp.next;<br>&#125;<br><br>curEmp.next = emp;<br>&#125;<br><br><span class="hljs-comment">//展示的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123; <br>System.out.println(<span class="hljs-string">&quot;第&quot;</span>+(no+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;链表为空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.print(<span class="hljs-string">&quot;第&quot;</span>+(no+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;条链表 信息为&quot;</span>);<br>Emp curEmp = head;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>System.out.printf(<span class="hljs-string">&quot; =&gt; id=%d name=%s\t&quot;</span>, curEmp.id, curEmp.name);<br><span class="hljs-keyword">if</span>(curEmp.next == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>curEmp = curEmp.next;<br>&#125;<br>System.out.println();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Emp <span class="hljs-title">findEmpById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;空表&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>Emp curEmp = head;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(curEmp.id == id) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(curEmp.next == <span class="hljs-keyword">null</span>) &#123;<br>curEmp = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>curEmp = curEmp.next;<br>&#125;<br><br><span class="hljs-keyword">return</span> curEmp;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>8. 树</h1><h2 id="8-1-树的基本介绍">8.1 树的基本介绍</h2><p>树的基本介绍，在另一篇博客中有详细的介绍，这里不在详述</p><h2 id="8-2-二叉树的前中后序遍历">8.2 二叉树的前中后序遍历</h2><p>简单的来说，就是根节点的输出的顺序不同导致的，比如前序遍历就是  <strong>根-左-右</strong> ，中序遍历就是 <strong>左-右-根</strong> ，后序遍历就是 <strong>左-右-根</strong> ，在代码的实现过程中，主要体现在写递归的时候，输出函数的位置不同</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BinaryTree </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;<br><span class="hljs-keyword">private</span> HeroNode root;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(HeroNode root)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.root = root;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.root != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.root.preOrder();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;该树为空&quot;</span>);<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.root != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.root.infixOrder();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;该树为空&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.root != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.root.postOrder();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;该树为空&quot;</span>);<br>&#125;<br>&#125;<br><br><br>&#125;<br><br><span class="hljs-comment">//HeroNode</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroNode</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> no;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> HeroNode left; <span class="hljs-comment">//null</span><br><span class="hljs-keyword">private</span> HeroNode right; <span class="hljs-comment">//null</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HeroNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.no = no;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNo</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> no;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.no = no;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(HeroNode left)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.left = left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(HeroNode right)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.right = right;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode [no=&quot;</span> + no + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><br><span class="hljs-comment">//前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left.preOrder();<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right.preOrder();<br>&#125;<br>&#125;<br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left.infixOrder();<br>&#125;<br><br>System.out.println(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right.infixOrder();<br>&#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left.postOrder();<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right.postOrder();<br>&#125;<br>System.out.println(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-二叉树的查找指定的节点">8.3 二叉树的查找指定的节点</h2><h3 id="实现思路-9">实现思路</h3><p>我自我感觉就是和前面的相比，就是把前面前中后序遍历中的输出变成了寻找到相应节点的递归出口，其他并么有多大的变化</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title">preOrderSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br><span class="hljs-comment">//一遇到的就是，直接返回</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.no == no) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>HeroNode resNode = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>resNode = <span class="hljs-keyword">this</span>.left.preOrderSearch(no);<span class="hljs-comment">//向左继续前序遍历</span><br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//左子树找到</span><br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><span class="hljs-comment">//前面没有返回，继续执行到了这一步，说明左边没有找到</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>resNode = <span class="hljs-keyword">this</span>.right.preOrderSearch(no);<span class="hljs-comment">//向右继续遍历</span><br>&#125;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><br><span class="hljs-comment">//中序搜索</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br>HeroNode resNode = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>resNode = <span class="hljs-keyword">this</span>.left.infixOrderSearch(no);<span class="hljs-comment">//向左继续中序遍历</span><br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> resNode;<span class="hljs-comment">//找到了就返回</span><br>&#125;<br><span class="hljs-comment">//对比号码找到了就返回</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.no == no) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//否则继续向右边搜索</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>resNode = <span class="hljs-keyword">this</span>.right.infixOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">return</span> resNode;<br><br>&#125;<br><br><span class="hljs-comment">//后序搜索</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title">postOrderSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;<br><span class="hljs-comment">//流程都差不多</span><br>HeroNode resNode = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>resNode = <span class="hljs-keyword">this</span>.left.postOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>resNode = <span class="hljs-keyword">this</span>.right.postOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.no == no) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8-4-二叉树删除相应的节点">8.4 二叉树删除相应的节点</h2><h3 id="实现思路-10">实现思路</h3><ul><li>如果是空树root，如果只有一个root节点，则等价于将二叉树置空</li><li>因为是单项的树，所以删除的时候需要寻找待删除节点的上一个节点</li><li>在每个节点里写好删除的方法，如果下一个节点不为空并且数字符合，那么就置空，然后返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">binaryTree</span>中：</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">delNode</span>(<span class="hljs-title">int</span> <span class="hljs-title">no</span>) </span>&#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span>(root.getNo() == no) &#123;<br>root = <span class="hljs-keyword">null</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>root.delNode(no);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;空树，不能删除&quot;</span>);<br>&#125;<br>&#125;<br><br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span>中：</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">delNode</span>(<span class="hljs-title">int</span> <span class="hljs-title">no</span>) </span>&#123;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.left.no == no) &#123;<br><span class="hljs-keyword">this</span>.left = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.right.no == no) &#123;<br><span class="hljs-keyword">this</span>.right = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left.delNode(no);<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right.delNode(no);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-5-堆排序">8.5 堆排序</h2><p>堆排序实际上也是一种选择排序，它也是不稳定排序。堆是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆，每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。</p><h3 id="实现思路-11">实现思路</h3><ul><li>将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点</li><li>将堆顶的元素与末尾元素进行交换，此时末尾就为最大值</li><li>将除去最后一个已排序的节点的其他元素继续构造为一个大顶堆，再与堆的最后一个元素交换</li><li>持续上述操作，直至成为有序序列</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>&#125;;<br>heapSort(arr);<br>System.out.println(Arrays.toString(arr));<br><span class="hljs-comment">//测试性能</span><br><span class="hljs-keyword">int</span>[] testArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>;i++) &#123;<br>testArr[i] = (<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">8000000</span>);<br>&#125;<span class="hljs-comment">//生成80000万个数据</span><br><span class="hljs-keyword">long</span> startTime=System.currentTimeMillis(); <span class="hljs-comment">//获取开始时间</span><br><br>heapSort(testArr);<br><br><span class="hljs-keyword">long</span> endTime=System.currentTimeMillis(); <span class="hljs-comment">//获取结束时间</span><br>System.out.println(<span class="hljs-string">&quot;八万个随机数据程序运行时间： &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span> </span>&#123;<br><span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-comment">//调整为大顶堆</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = arr.length / <span class="hljs-number">2</span> -<span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i--) &#123;<br>adjustHeap(arr, i, arr.length);<br>&#125;<br><br><span class="hljs-comment">//将最后一个交换后继续调整为大顶堆</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = arr.length-<span class="hljs-number">1</span>;j &gt;<span class="hljs-number">0</span>; j--) &#123;<br><br>temp = arr[j];<br>arr[j] = arr[<span class="hljs-number">0</span>];<br>arr[<span class="hljs-number">0</span>] = temp;<br>adjustHeap(arr, <span class="hljs-number">0</span>, j); <br>&#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">//调整为大顶堆的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> lenght)</span> </span>&#123;<br><br><span class="hljs-comment">//保存当前的变量</span><br><span class="hljs-keyword">int</span> temp = arr[i];<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; lenght; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k+<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//说明左子节点小于右子节点</span><br>k++;<span class="hljs-comment">//指向右子节点(较大的节点</span><br>&#125;<br><span class="hljs-keyword">if</span>(arr[k] &gt; temp) &#123;<span class="hljs-comment">//如果子节点大于父节点</span><br>arr[i] = arr[k];<span class="hljs-comment">//将较大的值赋给当前节点</span><br>i = k;<span class="hljs-comment">//继续循环比较</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//将小的那位置赋为小的值，完成交换</span><br>arr[i] = temp;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-6-赫夫曼树">8.6 赫夫曼树</h2><h3 id="基本介绍">基本介绍</h3><p>给定n个权值作为n个叶子节点，构造一棵二叉树，<strong>若该树的带权路径长度达到最小</strong>，称这样的树为最优二叉树，也称赫夫曼树</p><h3 id="实现思路-12">实现思路</h3><p>将每个数据看作是一棵最简单的二叉树，不断取出根节点权值最小的两颗二叉树，组成一棵新的二叉树，该颗二叉树根节点的权值是前面两颗二叉树根节点权值的和，然后再将这颗新的二叉树放回去，再次排序，不断选出最小的两棵二叉树组合。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTree</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">13</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">29</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span> &#125;;<br>Node root = createHuffmanTree(arr);<br>preOrder(root); <br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;<br>root.preOrder();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;kono空树da~~&quot;</span>);<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br><br>List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;<br>nodes.add(<span class="hljs-keyword">new</span> Node(value));<br>&#125;<br><br><br><br><span class="hljs-keyword">while</span>(nodes.size() &gt; <span class="hljs-number">1</span>) &#123;<br><br>Collections.sort(nodes);<br>System.out.println(<span class="hljs-string">&quot;nodes =&quot;</span> + nodes);<br>Node leftNode = nodes.get(<span class="hljs-number">0</span>);<br>Node rightNode = nodes.get(<span class="hljs-number">1</span>);<br><br>Node parent = <span class="hljs-keyword">new</span> Node(leftNode.value + rightNode.value);<br>parent.left = leftNode;<br>parent.right = rightNode;<br><br>nodes.remove(leftNode);<br>nodes.remove(rightNode);<br>nodes.add(parent);<br>&#125;<br><br><span class="hljs-comment">//���ع���������root���</span><br><span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//为了实现排序，需要实现这个排序的接口，里面重写这个compareTo的方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt; </span>&#123;<br><span class="hljs-keyword">int</span> value;<br><span class="hljs-keyword">char</span> c; <br>Node left; <br>Node right; <br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left.preOrder();<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right.preOrder();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.value = value;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node [value=&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value - o.value;<span class="hljs-comment">//从小到大排序</span><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8-7-二叉排序树">8.7 二叉排序树</h2><h3 id="二叉排序树介绍">二叉排序树介绍</h3><p>二叉排序数(BST : Binary Sort Tree) 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值要大</p><h3 id="二叉排序树的实现思路">二叉排序树的实现思路</h3><ul><li><p>创建</p><ul><li>在创建的时候不断比较，比节点小的就不断去左边，直到找到合适的位置，右边同理</li></ul></li><li><p>删除</p><ul><li><p>需要找到待删除节点的父节点</p></li><li><p>删除叶子节点</p></li><li><p>删除只有一棵子树的节点（四种情况：target左右 * child左右）</p></li><li><p>删除有两棵子树的节点（就是从targetNode里面找到最小的节点赋值给target节点，然后删除那个最小的节点的位置）</p></li></ul></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTreeDemo</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;;<br>BinarySortTree binarySortTree = <span class="hljs-keyword">new</span> BinarySortTree();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; arr.length; i++) &#123;<br>binarySortTree.add(<span class="hljs-keyword">new</span> Node(arr[i]));<br>&#125;<br><br><br>System.out.println(<span class="hljs-string">&quot;中序遍历~&quot;</span>);<br>binarySortTree.infixOrder(); <span class="hljs-comment">// 1, 3, 5, 7, 9, 10, 12</span><br><br>    <br>   <br>    binarySortTree.delNode(<span class="hljs-number">12</span>);<br>   <br> <br>    binarySortTree.delNode(<span class="hljs-number">5</span>);<br>    binarySortTree.delNode(<span class="hljs-number">10</span>);<br>    binarySortTree.delNode(<span class="hljs-number">2</span>);<br>    binarySortTree.delNode(<span class="hljs-number">3</span>);<br>   <br>    binarySortTree.delNode(<span class="hljs-number">9</span>);<br>    binarySortTree.delNode(<span class="hljs-number">1</span>);<br>    binarySortTree.delNode(<span class="hljs-number">7</span>);<br>    <br><br>System.out.println(<span class="hljs-string">&quot;root=&quot;</span> + binarySortTree.getRoot());<br><br><br>System.out.println(<span class="hljs-string">&quot;中序遍历&quot;</span>);<br>binarySortTree.infixOrder();<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span> </span>&#123;<br><span class="hljs-keyword">private</span> Node root;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getRoot</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> root.search(value);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> root.searchParent(value);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node  传入的根节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回最小的额node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delRightTreeMin</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>Node target = node;<br><span class="hljs-keyword">while</span>(target.left != <span class="hljs-keyword">null</span>) &#123;<br>target = target.left;<br><span class="hljs-comment">//循环的查找左节点，就会找到最小值，因为小的放在左边</span><br>&#125;<br>delNode(target.value);<span class="hljs-comment">//删除最小的节点</span><br><span class="hljs-keyword">return</span> target.value;<span class="hljs-comment">//返回最小的值</span><br>&#125;<br><br><br><span class="hljs-comment">//删除节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//targetNode</span><br>Node targetNode = search(value);<br><span class="hljs-comment">//没有找到target</span><br><span class="hljs-keyword">if</span>(targetNode == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//该科书只有一个节点</span><br><span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>root = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><br>Node parent = searchParent(value);<br><span class="hljs-comment">//删除叶子节点</span><br><span class="hljs-keyword">if</span>(targetNode.left == <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//说明这个节点是叶子节点</span><br><span class="hljs-keyword">if</span>(parent.left != <span class="hljs-keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<br>parent.left = <span class="hljs-keyword">null</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<br>parent.right = <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//说明target有两个节点</span><br><span class="hljs-keyword">int</span> minVal = delRightTreeMin(targetNode.right);<br>targetNode.value = minVal;<span class="hljs-comment">//返回右子树的最小值</span><br><br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 剩下的情况就是只有一个子树的节点</span><br><span class="hljs-keyword">if</span>(targetNode.left != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//说明这个待删除节点有左子节点</span><br><span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//target是parent的左节点</span><br><span class="hljs-keyword">if</span>(parent.left.value == value) &#123;<br>parent.left = targetNode.left;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//  target是parent的右节点</span><br>parent.right = targetNode.left;<br>&#125; <br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//待删除的节点没有父节点</span><br>root = targetNode.left;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//说明target有右子节点</span><br><span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//target是parent的左节点</span><br><span class="hljs-keyword">if</span>(parent.left.value == value) &#123;<br>parent.left = targetNode.right;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//target是parent的右节点</span><br>parent.right = targetNode.right;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//待删除的节点没有父节点</span><br>root = targetNode.right;<br>&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br>root = node;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>root.add(node);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;<br>root.infixOrder();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;kono空树da~&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Node</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><span class="hljs-keyword">int</span> value;<br>Node left;<br>Node right;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br><span class="hljs-keyword">this</span>.value = value;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(value == <span class="hljs-keyword">this</span>.value) &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left  == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.search(value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.search(value);<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.left.value == value) || <br>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.right.value == value)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(value &lt; <span class="hljs-keyword">this</span>.value &amp;&amp; <span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.searchParent(value); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-keyword">this</span>.value &amp;&amp; <span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.searchParent(value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node [value=&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(node.value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left = node;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br><span class="hljs-keyword">this</span>.left.add(node);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right = node;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br><span class="hljs-keyword">this</span>.right.add(node);<br>&#125;<br><br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.left.infixOrder();<br>&#125;<br>System.out.println(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.right.infixOrder();<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8-8-平衡二叉树">8.8 平衡二叉树</h2><h3 id="简单的介绍-3">简单的介绍</h3><p>平衡二叉树(AVL树)也叫二叉搜索树，可以保证查询的效率高，平衡二叉树具有以下特点：他是一棵空树或者他的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树，平衡二叉树的实现方法有 红黑树，AVL,替罪羊树，Treap，伸展树等。</p><h3 id="实现思路-13">实现思路</h3><p>平衡二叉树可以通过上面的二叉排序树旋转而来，通常有左旋转，右旋转，双旋转。</p><p><strong>左旋转</strong></p><p>当则右子树的高度大于左子树的高度的时候，我们就需要左旋转来换个根节点，将右子树的高度压下去。</p><p><strong>右旋转</strong></p><p>当左子树的高度大于右子树的高度的时候，这个时候就需要进行右旋转，用来把左子树的高度压下去</p><p><strong>双旋转</strong></p><p>有时候，你进行上述两个操作之后，发现仍然没有达到平衡二叉树的要求，这个时候就需要双旋转的出场了，出现这个问题就是因为它的左子树的右子树的高度大于了它左子树左子树的高度，或者相反，都会导致这种情况的发生。解决的思路就是先对当前这个节点进行左旋转(或者右旋转)，再对当前节点进行右旋转(或者相反)</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>        AVLTree avlTree = <span class="hljs-keyword">new</span> AVLTree();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            avlTree.add(<span class="hljs-keyword">new</span> Node(arr[i]));<br>        &#125;<br><br><br>        System.out.println(<span class="hljs-string">&quot;中序遍历&quot;</span>);<br>        avlTree.infixOrder();<br><br>        System.out.println(<span class="hljs-string">&quot;在平衡处理后：&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;树的高度=&quot;</span> + avlTree.getRoot().height()); <span class="hljs-comment">//3</span><br>        System.out.println(<span class="hljs-string">&quot;左子树的高度=&quot;</span> + avlTree.getRoot().leftHeight()); <span class="hljs-comment">// 2</span><br>        System.out.println(<span class="hljs-string">&quot;右子树的高度=&quot;</span> + avlTree.getRoot().rightHeight()); <span class="hljs-comment">// 2</span><br>        System.out.println(<span class="hljs-string">&quot;当前的根节点=&quot;</span> + avlTree.getRoot());<span class="hljs-comment">//8</span><br><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// AVLTree</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span> </span>&#123;<br><br>    <span class="hljs-comment">//下面这一些部分都是跟前面的二叉搜索树是差不多的</span><br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root.search(value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root.searchParent(value);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delRightTreeMin</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        Node target = node;<br><br>        <span class="hljs-keyword">while</span> (target.left != <span class="hljs-keyword">null</span>) &#123;<br>            target = target.left;<br>        &#125;<br><br>        delNode(target.value);<br>        <span class="hljs-keyword">return</span> target.value;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            Node targetNode = search(value);<br><br>            <span class="hljs-keyword">if</span> (targetNode == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>                root = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br><br>            Node parent = searchParent(value);<br><br>            <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right == <span class="hljs-keyword">null</span>) &#123;<br><br>                <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<br>                    parent.left = <span class="hljs-keyword">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<br>                    parent.right = <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> minVal = delRightTreeMin(targetNode.right);<br>                targetNode.value = minVal;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br><br>                        <span class="hljs-keyword">if</span> (parent.left.value == value) &#123;<br>                            parent.left = targetNode.left;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            parent.right = targetNode.left;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        root = targetNode.left;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br><br>                        <span class="hljs-keyword">if</span> (parent.left.value == value) &#123;<br>                            parent.left = targetNode.right;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            parent.right = targetNode.right;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        root = targetNode.right;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            root = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root.add(node);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>            root.infixOrder();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;这怕是个空树&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Node</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> value;<br>    Node left;<br>    Node right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-comment">//左子树的高度</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftHeight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left.height();<br>    &#125;<br><br>    <span class="hljs-comment">//右子树的高度</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightHeight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right.height();<br>    &#125;<br><br>    <span class="hljs-comment">//返回以该节点为根节点的树的高度</span><br>    <span class="hljs-comment">//简直是牛逼</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.max(left == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : left.height(), right == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : right.height()) + <span class="hljs-number">1</span>;<span class="hljs-comment">//最后还需要加上当前这个节点</span><br>    &#125;<span class="hljs-comment">//递归的去寻找左右子树的高度最大值，就是这棵树的高度</span><br><br>    <span class="hljs-comment">//左旋转的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//六步走的方法</span><br><br>        <span class="hljs-comment">//以当前节点的值，创建新节点</span><br>        Node newNode = <span class="hljs-keyword">new</span> Node(value);<br>        <span class="hljs-comment">//把新节点的左子树设置为当前节点的左子树</span><br>        newNode.left = left;<br>        <span class="hljs-comment">//把新节点的右子树设置为当前节点右子树的左子树</span><br>        newNode.right = right.left;<br>        <span class="hljs-comment">//把当前节点的值替换成右子点的值</span><br>        value = right.value;<br>        <span class="hljs-comment">//把当前的右子树设置成右子树的右子树</span><br>        right = right.right;<br>        <span class="hljs-comment">//把当前节点的左子树(左子节点)设置成新的节点</span><br>        left = newNode;<br>        <span class="hljs-comment">//剩余的没有指向的节点会被Java的垃圾回收机制给回收掉</span><br><br>    &#125;<br><br>    <span class="hljs-comment">//右旋转</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">()</span> </span>&#123;<br>        Node newNode = <span class="hljs-keyword">new</span> Node(value);<br>        newNode.right = right;<br>        newNode.left = left.right;<br>        value = left.value;<br>        left = left.left;<br>        right = newNode;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.value) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.search(value);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.search(value);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.left.value == value) || (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.right.value == value)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-keyword">this</span>.value &amp;&amp; <span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.searchParent(value);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-keyword">this</span>.value &amp;&amp; <span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.searchParent(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node [value=&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span> (node.value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.left = node;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-keyword">this</span>.left.add(node);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.right = node;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-keyword">this</span>.right.add(node);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//当添加稳一个节点后，右子树的高度大于左子树的高度  左旋转</span><br>        <span class="hljs-keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="hljs-number">1</span>) &#123;<br><br>            <span class="hljs-comment">//如果右子树的左子树高度大于右子树的右子树高度 就先要对右子树进行右旋转 然后再对当前节点进行左旋转</span><br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;<br>                right.rightRotate();<br>                leftRotate();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                leftRotate();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//当添加稳一个节点后，左子树的高度大于右子树的高度  右旋转</span><br>        <span class="hljs-keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//如果左子树的右子树高度大于左子树的左子树高度 就先要对左子树进行左旋转 然后再对当前节点进行右旋转</span><br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;<br>                left.leftRotate();<br>                rightRotate();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                rightRotate();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infixOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.left.infixOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.right.infixOrder();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8-9-多路查找树">8.9 多路查找树</h2><h3 id="B树">B树</h3><p>B树通过重新组织节点，降低了树的高度，文件系统及数据库系统设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)这样每个节点只需要一次I/O就可以完全载入，将树得度M设置1024，在600亿个元素最多只需要4次I/O操作就可以读取到想要得元素，B树(B+)广泛应用于文件存储系统以及数据库系统中，B树得阶就是节点最多子节点个数</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220725212038044.png" alt="image-20220725212038044"></p><h3 id="B-树">B+树</h3><p>B+树是B树得变种，也是一种多路查找树。B+树得搜索与b树基本相同，区别是B+树只有达到叶子节点才命中，所有关键字都出现在叶子节点得链表中(也叫做稠密索引)，且链表中的关键字恰好是有序的，非叶子节点相当于是叶子节点的索引(稀疏索引)，叶子节点相当于是存储数据的数据层，更适合文件索引系统</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220725212139781.png" alt="image-20220725212139781"></p><h3 id="B-树-2">B *树</h3><p>B *树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针，B *树定义了非叶子节点关键字至少为(2/3) * M,即块的最低使用率为2/3，而B+树的块的最低使用率为1/2</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220725212609444.png" alt="image-20220725212609444"></p><h1>9. 图</h1><h2 id="简单的介绍-4">简单的介绍</h2><p>图是一种数据结构，其中节点可以具有零个或多个相邻的元素。两个节点之间的连接称为边</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220725213128120.png" alt="image-20220725213128120"></p><p>图的其他术语不再详细介绍，在这里，我们采用邻接矩阵的方式来表示图，其中1表示连接，0表示没有连接</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220725213242391.png" alt="image-20220725213242391"></p><h2 id="图的深度优先遍历-DFS">图的深度优先遍历(DFS)</h2><p>主要是可以递归(栈)实现，从初识节点初识访问节点开始，接着访问它的第一个邻接节点，接着再以这个被访问的节点为初始节点，接着访问下一个邻接节点，如果这个邻接节点不存在(不相连)，就退回上一个节点，访问和它相连的第二个邻接节点</p><h2 id="图的广度优先遍历-BFS">图的广度优先遍历(BFS)</h2><p>主要通过队列实现，类似于一个分层搜索的过程，将第一个节点(root)入队，然后将和它相连所有节点入队，一个接着一个访问，并且把所有未访问的并且和该节点相连的节点都入队，进行访问，直到访问完毕。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="hljs-comment">//存储顶点的集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges; <span class="hljs-comment">// 存储邻接矩阵</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges; <span class="hljs-comment">// 表示边的数目</span><br><span class="hljs-comment">//记录某个节点是否被访问过</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isVisited;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> n = <span class="hljs-number">8</span>;  <span class="hljs-comment">// 节点的个数</span><br><span class="hljs-comment">//String Vertexs[] = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;;</span><br>String Vertexs[] = &#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>&#125;;<br><br><span class="hljs-comment">//创建图对象</span><br>Graph graph = <span class="hljs-keyword">new</span> Graph(n);<br><span class="hljs-comment">// 循环添加顶点</span><br><span class="hljs-keyword">for</span>(String vertex: Vertexs) &#123;<br>graph.insertVertex(vertex);<br>&#125;<br><br><br><span class="hljs-comment">//添加边</span><br>graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>);<br>graph.insertEdge(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>);<br><br><br><br><br>graph.showGraph();<br><br><span class="hljs-comment">//dfs</span><br>System.out.println(<span class="hljs-string">&quot;dfs&quot;</span>);<br>graph.dfs(); <span class="hljs-comment">// A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7]</span><br>System.out.println();<br>System.out.println(<span class="hljs-string">&quot;bfs&quot;</span>);<br>graph.bfs(); <span class="hljs-comment">// A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8]</span><br><br>&#125;<br><br><span class="hljs-comment">// 构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">// 初始化vertexList</span><br>edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(n);<br>numOfEdges = <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-comment">//得到第一个邻接节点的下标</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果存在返回对应的下标，否则返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFirstNeighbor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexList.size(); j++) &#123;<br><span class="hljs-keyword">if</span>(edges[index][j] &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//根据前一个邻接节点的下标来获取下一个节点的下标</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNeighbor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = v2 + <span class="hljs-number">1</span>; j &lt; vertexList.size(); j++) &#123;<br><span class="hljs-keyword">if</span>(edges[v1][j] &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><span class="hljs-comment">//访问节点 输出</span><br>System.out.print(getValueByIndex(i) + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br><span class="hljs-comment">//标记为已经访问</span><br>isVisited[i] = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">//查找i的第一个节点</span><br><span class="hljs-keyword">int</span> w = getFirstNeighbor(i);<br><span class="hljs-keyword">while</span>(w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//说明有临接节点</span><br><span class="hljs-keyword">if</span>(!isVisited[w]) &#123;<span class="hljs-comment">//判断是否访问过</span><br>dfs(isVisited, w);<br>&#125;<br><span class="hljs-comment">//</span><br>w = getNextNeighbor(i, w);<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//对dfs重载 解决非连通图</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br>isVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[vertexList.size()];<br><span class="hljs-comment">//遍历所有的节点 进行回溯</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;<br><span class="hljs-keyword">if</span>(!isVisited[i]) &#123;<br>dfs(isVisited, i);<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><span class="hljs-keyword">int</span> u ; <span class="hljs-comment">// 队列头节点对应的下标</span><br><span class="hljs-keyword">int</span> w ; <span class="hljs-comment">// 邻接节点w</span><br><span class="hljs-comment">// 队列记录节点的访问顺序</span><br>LinkedList queue = <span class="hljs-keyword">new</span> LinkedList();<br><span class="hljs-comment">// 输出这个节点的信息</span><br>System.out.print(getValueByIndex(i) + <span class="hljs-string">&quot;=&gt;&quot;</span>);<br><span class="hljs-comment">// 标记为已访问</span><br>isVisited[i] = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 把这个节点加入队列</span><br>queue.addLast(i);<br><br><span class="hljs-keyword">while</span>( !queue.isEmpty()) &#123;<br><span class="hljs-comment">// 取出队列头节点</span><br>u = (Integer)queue.removeFirst();<br><span class="hljs-comment">// 取出下一个下标</span><br>w = getFirstNeighbor(u);<br><span class="hljs-keyword">while</span>(w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//可以连</span><br><span class="hljs-comment">//没有访问过</span><br><span class="hljs-keyword">if</span>(!isVisited[w]) &#123;<br>System.out.print(getValueByIndex(w) + <span class="hljs-string">&quot;=&gt;&quot;</span>);<br><span class="hljs-comment">// 标记为已经访问</span><br>isVisited[w] = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">//入队列</span><br>queue.addLast(w);<br>&#125;<br><span class="hljs-comment">//</span><br>w = getNextNeighbor(u, w); <span class="hljs-comment">//以这个为前驱，继续找下一个</span><br>&#125;<br>&#125;<br><br>&#125; <br><br><span class="hljs-comment">// 解决非连通图</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>isVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[vertexList.size()];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;<br><span class="hljs-keyword">if</span>(!isVisited[i]) &#123;<br>bfs(isVisited, i);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 返回节点的个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfVertex</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> vertexList.size();<br>&#125;<br><span class="hljs-comment">// 显示图对应的矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] link : edges) &#123;<br>System.err.println(Arrays.toString(link));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 得到边的个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfEdges</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> numOfEdges;<br>&#125;<br><span class="hljs-comment">// 返回节点的值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValueByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><span class="hljs-keyword">return</span> vertexList.get(i);<br>&#125;<br><span class="hljs-comment">//返回v1 v2的权值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> edges[v1][v2];<br>&#125;<br><br><br><span class="hljs-comment">//插入节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;<br>vertexList.add(vertex);<br>&#125;<br><br><span class="hljs-comment">// 添加边</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v1 点的下标  &quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;0 &quot;B&quot;-&gt;1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v2 表示第二个顶点对应的下标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> weight 表示权重</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>edges[v1][v2] = weight;<br>edges[v2][v1] = weight;<br>numOfEdges++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>10. 常用(大概吧)算法</h1><p>这里写的算法以及示例都是相对比较浅的，就看一遍的话，是不可能掌握的，要想真正的掌握，成竹在胸，必须要多刷题！！！</p><h2 id="二分查找非递归">二分查找非递归</h2><p>相比较之前的递归，这里采用的是使用循环实现二分查找，原理都是一样的，关键是mid值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left &lt;= right) &#123; <span class="hljs-comment">//说明继续查找</span><br><span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(arr[mid] == target) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( arr[mid] &gt; target) &#123;<br>right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//需要向左边查找</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//需要向右边查找</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分治算法">分治算法</h2><p>分治算法的核心就是<strong>分</strong>和<strong>治</strong>两个部分，即先把问题分解成一个一个小的问题，然后通过解决一个一个的小的问题，合成大的解，最后解决整个问题，这里使用汉诺塔问题作为示例</p><p>汉诺塔问题，经典问题，简单的来说就是，有A，B，C三根柱子，其中A柱子上面有n个圆盘，每次移动一个圆盘并且不能把大圆盘放在小圆盘的上面，问一共需要多少步能把圆盘全部移动到C柱子上。</p><h3 id="实现思路-14">实现思路</h3><p>首先我们一步一步的逆着思考，要想把n个圆盘移动到C上，把上面的n-1个圆盘看作一个整体，我们就需要把n-1个圆盘移动到B上面，然后把第n个圆盘移动到C柱上，再将n-1移动到C柱上面，完成最后一步移动，再往前想，要移动n-1个圆盘到B柱上，就需要把n-2个圆盘先移动到C柱上，然后把第n-1个圆盘移动到B柱上，然后把第n-2个圆盘移动到B柱上，完成移动，再往前推，我们可以发现他们的实现过程都是类似的，直到n最后是1的时候就可以移动了,完全可以使用递归实现</p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hanoitower</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>hanoiTower(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//汉诺塔的移动的方法</span><br><span class="hljs-comment">//使用分治算法</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoiTower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b, <span class="hljs-keyword">char</span> c)</span> </span>&#123;<br><span class="hljs-comment">//如果只有一个盘</span><br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;第1个盘从 &quot;</span> + a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘</span><br><span class="hljs-comment">//1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c</span><br>hanoiTower(num - <span class="hljs-number">1</span>, a, c, b);<br><span class="hljs-comment">//2. 把最下边的盘 A-&gt;C</span><br>System.out.println(<span class="hljs-string">&quot;第&quot;</span> + num + <span class="hljs-string">&quot;个盘从 &quot;</span> + a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);<br><span class="hljs-comment">//3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  </span><br>hanoiTower(num - <span class="hljs-number">1</span>, b, a, c);<br><br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><p>动态规划算法是我们的老朋友了，动态规划的算法的核心就是需要将以前的状态存储起来，然后再根据之前的状态推导出之后的状态，最后得到我们的最终答案，其中核心便是动态规划的动态转移方程。下面以背包问题举例说明</p><p>背包问题：</p><p>有一个背包，容量为4磅，现在有如下物品，要求使装入背包的总价值最大，并且重量不超出背包的最大容量，要求装入的物品不重复<img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220809181739427.png" alt="image-20220809181739427">这里的背包问题是01背包问题(01背包，每个物品最多放一个，完全背包问题则是每种物品都有无限件可以使用)</p><h3 id="实现思路-15">实现思路</h3><p>利用动态规划，每次遍历到第i个物品，根据w[i] 和G[i] 来确定是否需要放入该物品，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnapsackProblem</span> </span>&#123;<br><br><span class="hljs-comment">//需要特别注意每个数组的含义</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//物品的重量</span><br><span class="hljs-keyword">int</span>[] val = &#123;<span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>&#125;; <span class="hljs-comment">//物品的价值 这里val[i] 就是前面讲的v[i]</span><br><span class="hljs-keyword">int</span> m = <span class="hljs-number">4</span>; <span class="hljs-comment">//背包的容量</span><br><span class="hljs-keyword">int</span> n = val.length; <span class="hljs-comment">//物品的个数</span><br><br><br><br><span class="hljs-comment">//创建二维数组，</span><br><span class="hljs-comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span><br><span class="hljs-keyword">int</span>[][] v = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//为了记录放入商品的情况，我们定一个二维数组</span><br><span class="hljs-keyword">int</span>[][] path = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.length; i++) &#123;<br>v[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将第一列设置为0</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; v[<span class="hljs-number">0</span>].length; i++) &#123;<br>v[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将第一行设置0</span><br>&#125;<br><br><span class="hljs-comment">//动规的思想是最重要的</span><br><span class="hljs-comment">//根据前面得到公式来动态规划处理</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; v.length; i++) &#123; <span class="hljs-comment">//不处理第一行 i是从1开始的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j &lt; v[<span class="hljs-number">0</span>].length; j++) &#123;<span class="hljs-comment">//不处理第一列, j是从1开始的</span><br><span class="hljs-comment">//当物品的所需的容量大于背包容量的时候</span><br><span class="hljs-keyword">if</span>(w[i-<span class="hljs-number">1</span>]&gt; j) &#123; <span class="hljs-comment">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span><br>v[i][j]=v[i-<span class="hljs-number">1</span>][j];<span class="hljs-comment">//当前空间能装的最大价值就和不能装这个东西的同等容量的背包一致</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//因为我们的i 从1开始的， 因此公式里面的w[i]调整成w[i-1]</span><br><span class="hljs-comment">//v[i-1][j-w[i]] 就是没装当前这个东西前剩余空间的价值最大值  求Max相当于就是在决定要不要装这个东西</span><br><span class="hljs-comment">//v[i][j]=Math.max(v[i-1][j], val[i]+v[i-1][j-w[i]]) =&gt; v[i][j] = Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span><br><span class="hljs-comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span><br><span class="hljs-keyword">if</span>(v[i - <span class="hljs-number">1</span>][j] &lt; val[i - <span class="hljs-number">1</span>] + v[i - <span class="hljs-number">1</span>][j - w[i - <span class="hljs-number">1</span>]]) &#123;<br>v[i][j] = val[i - <span class="hljs-number">1</span>] + v[i - <span class="hljs-number">1</span>][j - w[i - <span class="hljs-number">1</span>]];<br><span class="hljs-comment">//把当前的情况记录到path</span><br>path[i][j] = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>v[i][j] = v[i - <span class="hljs-number">1</span>][j];<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//输出一下v 看看目前的情况</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; v.length;i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; v[i].length;j++) &#123;<br>System.out.print(v[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br><br><span class="hljs-comment">//动脑筋</span><br><span class="hljs-keyword">int</span> i = path.length - <span class="hljs-number">1</span>; <span class="hljs-comment">//行的最大下标</span><br><span class="hljs-keyword">int</span> j = path[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;  <span class="hljs-comment">//列的最大下标</span><br><span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">//从path的最后开始找</span><br><span class="hljs-keyword">if</span>(path[i][j] == <span class="hljs-number">1</span>) &#123;<br>System.out.printf(<span class="hljs-string">&quot;第%d个商品放入到背包\n&quot;</span>, i);<br>j -= w[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//把当前物品的重量减掉 就能求出所剩空间放入的价值最大的商品</span><br>&#125;<br>i--;<br>&#125;<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="KMP算法">KMP算法</h2><p>字符串匹配问题,这个算法常用于在一个文本串S内查找一个模式串P的位置，字符串的匹配问题就是:有一个字符串str1 = “BBC ABCDAB ABCDABCDABDE”和一个子串 str2 = “ABCDABD” 现在要判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有，就返回-1，KMP算法的核心就在于部分匹配值的应用</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220809213116344.png" alt="image-20220809213116344"></p><p>这个部分匹配值指的就是以这个节点前面的字符串为一个全新的字符串，他的前缀和后缀的重复长度，而KMP需要回溯移动的位数指的就是已匹配的字符数-对应的部分匹配值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KMPAlgorithm</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>String str1 = <span class="hljs-string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;<span class="hljs-comment">//需要匹配匹配的串</span><br>String str2 = <span class="hljs-string">&quot;ABCDABD&quot;</span>;<span class="hljs-comment">//子串</span><br><span class="hljs-comment">//String str2 = &quot;BBC&quot;;</span><br><br><span class="hljs-keyword">int</span>[] next = kmpNext(<span class="hljs-string">&quot;ABCDABD&quot;</span>); <span class="hljs-comment">//[0，0，0，0, 1, 2, 0]</span><br>System.out.println(<span class="hljs-string">&quot;next=&quot;</span> + Arrays.toString(next));<br><br><span class="hljs-keyword">int</span> index = kmpSearch(str1, str2, next);<br>System.out.println(<span class="hljs-string">&quot;index=&quot;</span> + index); <span class="hljs-comment">// 15了</span><br><br><br>&#125;<br><br><span class="hljs-comment">//写出我们的kmp搜索算法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str1 源字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str2 子串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kmpSearch</span><span class="hljs-params">(String str1, String str2, <span class="hljs-keyword">int</span>[] next)</span> </span>&#123;<br><br><span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;<br><br><span class="hljs-comment">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span><br><span class="hljs-comment">//KMP算法核心点, 可以验证...</span><br><span class="hljs-keyword">while</span>( j &gt; <span class="hljs-number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;<br>j = next[j-<span class="hljs-number">1</span>]; <br>&#125;<br><br><span class="hljs-keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;<br>j++;<br>&#125;<br><span class="hljs-keyword">if</span>(j == str2.length()) &#123;<span class="hljs-comment">//找到了 // j = 3 i </span><br><span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>  -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//获取到一个字符串(子串) 的部分匹配值表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span>[] kmpNext(String dest) &#123;<br><span class="hljs-comment">//创建一个next 数组保存部分匹配值</span><br><span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[dest.length()];<br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//如果字符串是长度为1 部分匹配值就是0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; dest.length(); i++) &#123;<br><span class="hljs-comment">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span><br><span class="hljs-comment">//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出</span><br><span class="hljs-comment">//这时kmp算法的核心点</span><br><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;<br>j = next[j-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1</span><br><span class="hljs-keyword">if</span>(dest.charAt(i) == dest.charAt(j)) &#123;<br>j++;<br>&#125;<br>next[i] = j;<br>&#125;<br><span class="hljs-keyword">return</span> next;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心算法">贪心算法</h2><p>贪心算法即在当前情况下寻找最优的那个解，因此最终得到的结果<strong>不一定是最优解</strong>，下面以集合覆盖问题为例，假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区，如何选择最少的广播台，让所有的地区都可以接收到信号</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220809214343947.png" alt="image-20220809214343947"></p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreedyAlgorithm</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建广播电台,放入到Map</span><br>HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="hljs-keyword">new</span> HashMap&lt;String, HashSet&lt;String&gt;&gt;();<br><span class="hljs-comment">//将各个电台放入到broadcasts</span><br>HashSet&lt;String&gt; hashSet1 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>hashSet1.add(<span class="hljs-string">&quot;北京&quot;</span>);<br>hashSet1.add(<span class="hljs-string">&quot;上海&quot;</span>);<br>hashSet1.add(<span class="hljs-string">&quot;天津&quot;</span>);<br><br>HashSet&lt;String&gt; hashSet2 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>hashSet2.add(<span class="hljs-string">&quot;广州&quot;</span>);<br>hashSet2.add(<span class="hljs-string">&quot;北京&quot;</span>);<br>hashSet2.add(<span class="hljs-string">&quot;深圳&quot;</span>);<br><br>HashSet&lt;String&gt; hashSet3 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>hashSet3.add(<span class="hljs-string">&quot;成都&quot;</span>);<br>hashSet3.add(<span class="hljs-string">&quot;上海&quot;</span>);<br>hashSet3.add(<span class="hljs-string">&quot;杭州&quot;</span>);<br><br><br>HashSet&lt;String&gt; hashSet4 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>hashSet4.add(<span class="hljs-string">&quot;上海&quot;</span>);<br>hashSet4.add(<span class="hljs-string">&quot;天津&quot;</span>);<br><br>HashSet&lt;String&gt; hashSet5 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>hashSet5.add(<span class="hljs-string">&quot;杭州&quot;</span>);<br>hashSet5.add(<span class="hljs-string">&quot;大连&quot;</span>);<br><br><span class="hljs-comment">//加入到map</span><br>broadcasts.put(<span class="hljs-string">&quot;K1&quot;</span>, hashSet1);<br>broadcasts.put(<span class="hljs-string">&quot;K2&quot;</span>, hashSet2);<br>broadcasts.put(<span class="hljs-string">&quot;K3&quot;</span>, hashSet3);<br>broadcasts.put(<span class="hljs-string">&quot;K4&quot;</span>, hashSet4);<br>broadcasts.put(<span class="hljs-string">&quot;K5&quot;</span>, hashSet5);<br><br><span class="hljs-comment">//allAreas 存放所有的地区</span><br>HashSet&lt;String&gt; allAreas = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>allAreas.add(<span class="hljs-string">&quot;北京&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;上海&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;天津&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;广州&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;深圳&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;成都&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;杭州&quot;</span>);<br>allAreas.add(<span class="hljs-string">&quot;大连&quot;</span>);<br><br><span class="hljs-comment">//创建ArrayList, 存放选择的电台集合</span><br>ArrayList&lt;String&gt; selects = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br><span class="hljs-comment">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span><br>HashSet&lt;String&gt; tempSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br><br><span class="hljs-comment">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span><br><span class="hljs-comment">//如果maxKey 不为null , 则会加入到 selects</span><br>String maxKey = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">while</span>(allAreas.size() != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span><br><span class="hljs-comment">//每进行一次while,需要</span><br>maxKey = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">//遍历 broadcasts, 取出对应key</span><br><span class="hljs-keyword">for</span>(String key : broadcasts.keySet()) &#123;<br><span class="hljs-comment">//每进行一次for</span><br>tempSet.clear();<br><span class="hljs-comment">//当前这个key能够覆盖的地区</span><br>HashSet&lt;String&gt; areas = broadcasts.get(key);<br>tempSet.addAll(areas);<br><span class="hljs-comment">//求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet</span><br>tempSet.retainAll(allAreas);<br><span class="hljs-comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span><br><span class="hljs-comment">//就需要重置maxKey</span><br><span class="hljs-comment">// tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span><br><span class="hljs-comment">//就是选出最大的</span><br><span class="hljs-keyword">if</span>(tempSet.size() &gt; <span class="hljs-number">0</span> &amp;&amp; <br>(maxKey == <span class="hljs-keyword">null</span> || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;<br>maxKey = key;<br>&#125;<br>&#125;<br><span class="hljs-comment">//maxKey != null, 就应该将maxKey 加入selects</span><br><span class="hljs-keyword">if</span>(maxKey != <span class="hljs-keyword">null</span>) &#123;<br>selects.add(maxKey);<br><span class="hljs-comment">//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉</span><br>allAreas.removeAll(broadcasts.get(maxKey));<br>&#125;<br><br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;得到的选择结果是&quot;</span> + selects);<span class="hljs-comment">//[K1,K2,K3,K5]</span><br><br><br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="最小生成树算法">最小生成树算法</h2><p>先例举一个问题，有下图所示的7个村庄，现在需要修路把7个村庄联通，问如何修路保证各个村庄都能联通，并且总的修建公路的总里程最短<img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220809214857788.png" alt="image-20220809214857788"></p><p>这个问题的实质就是怎么生成最小生成树的问题，而解决这个问题的算法主要 有两个，分别从两个不同的方向对怎么生成最小生成树做出了解释</p><h3 id="普里姆算法">普里姆算法</h3><p>普里姆算法主要看的是点，依次寻找该点到另一个点的最短路径是哪条，不断重复，最终找到最小生成树</p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimAlgorithm</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//测试看看图是否创建ok</span><br><span class="hljs-keyword">char</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>&#125;;<br><span class="hljs-keyword">int</span> verxs = data.length;<br><span class="hljs-comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span><br><span class="hljs-keyword">int</span> [][]weight=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">10000</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">2</span>&#125;,<br>            &#123;<span class="hljs-number">5</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">3</span>&#125;,<br>            &#123;<span class="hljs-number">7</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>&#125;,<br>            &#123;<span class="hljs-number">10000</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">4</span>,<span class="hljs-number">10000</span>&#125;,<br>            &#123;<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;,<br>            &#123;<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">6</span>&#125;,<br>            &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10000</span>&#125;,&#125;;<br>            <br>        <span class="hljs-comment">//创建MGraph对象</span><br>        MGraph graph = <span class="hljs-keyword">new</span> MGraph(verxs);<br>        <span class="hljs-comment">//创建一个MinTree对象</span><br>        MinTree minTree = <span class="hljs-keyword">new</span> MinTree();<br>        minTree.createGraph(graph, verxs, data, weight);<br>        <span class="hljs-comment">//输出</span><br>        minTree.showGraph(graph);<br>        <span class="hljs-comment">//测试普利姆算法 生成最小生成树</span><br>        minTree.prim(graph, <span class="hljs-number">1</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//创建最小生成树-&gt;村庄的图</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinTree</span> </span>&#123;<br><span class="hljs-comment">//创建图的邻接矩阵</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> graph 图对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> verxs 图对应的顶点个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data 图的各个顶点的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> weight 图的邻接矩阵</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createGraph</span><span class="hljs-params">(MGraph graph, <span class="hljs-keyword">int</span> verxs, <span class="hljs-keyword">char</span> data[], <span class="hljs-keyword">int</span>[][] weight)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; verxs; i++) &#123;<span class="hljs-comment">//顶点</span><br>graph.data[i] = data[i];<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; verxs; j++) &#123;<br>graph.weight[i][j] = weight[i][j];<span class="hljs-comment">//初始化邻接矩阵</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//显示图的邻接矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">(MGraph graph)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] link: graph.weight) &#123;<br>System.out.println(Arrays.toString(link));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//编写prim算法，得到最小生成树</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> graph 图</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v 表示从图的第几个顶点开始生成&#x27;A&#x27;-&gt;0 &#x27;B&#x27;-&gt;1...</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(MGraph graph, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-comment">//visited[] 标记结点(顶点)是否被访问过</span><br><span class="hljs-keyword">int</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[graph.verxs];<br><span class="hljs-comment">//visited[] 默认元素的值都是0, 表示没有访问过</span><br><br><span class="hljs-comment">//把当前这个结点标记为已访问</span><br>visited[v] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//h1 和 h2 记录两个顶点的下标</span><br><span class="hljs-keyword">int</span> h1 = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> h2 = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> minWeight = <span class="hljs-number">10000</span>; <span class="hljs-comment">//将 minWeight 初始成一个大数，后面在遍历过程中，会被替换</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; graph.verxs; k++) &#123;<span class="hljs-comment">//因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边</span><br><br><span class="hljs-comment">//这个是确定每一次生成的子图 ，和哪个结点的距离最近</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.verxs; i++) &#123;<span class="hljs-comment">// i结点表示被访问过的结点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt; graph.verxs;j++) &#123;<span class="hljs-comment">//j结点表示还没有访问过的结点</span><br><span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">1</span> &amp;&amp; visited[j] == <span class="hljs-number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;<br><span class="hljs-comment">//替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span><br>minWeight = graph.weight[i][j];<br>h1 = i;<br>h2 = j;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//找到一条边是最小</span><br>System.out.println(<span class="hljs-string">&quot;边&lt;&quot;</span> + graph.data[h1] + <span class="hljs-string">&quot;,&quot;</span> + graph.data[h2] + <span class="hljs-string">&quot;&gt; 权值:&quot;</span> + minWeight);<br><span class="hljs-comment">//将当前这个结点标记为已经访问</span><br>visited[h2] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//minWeight 重新设置为最大值 10000</span><br>minWeight = <span class="hljs-number">10000</span>;<br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MGraph</span> </span>&#123;<br><span class="hljs-keyword">int</span> verxs; <span class="hljs-comment">//表示图的节点个数</span><br><span class="hljs-keyword">char</span>[] data;<span class="hljs-comment">//存放结点数据 A B C D ....</span><br><span class="hljs-keyword">int</span>[][] weight; <span class="hljs-comment">//存放边权重，就是我们的邻接矩阵</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> verxs)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.verxs = verxs;<br>data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[verxs];<br>weight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[verxs][verxs];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="克鲁斯卡尔算法">克鲁斯卡尔算法</h3><p>这个算法相比于上一个普里姆算法，主要突出的特点就是，克鲁斯卡尔算法是先将边排序，不断寻找最短的边，并一直判断这些边是否是联通的联通的就不行(判断的方法使用了并查集的思想)，直到这些点全部都联通</p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KruskalCase</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> edgeNum; <span class="hljs-comment">//边的个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] vertexs; <span class="hljs-comment">//顶点数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] matrix; <span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-comment">//使用 INF 表示两个顶点不能连通</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">char</span>[] vertexs = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>&#125;;<br><span class="hljs-comment">//克鲁斯卡尔算法的邻接矩阵  </span><br>      <span class="hljs-keyword">int</span> matrix[][] = &#123;<br>      <span class="hljs-comment">/*A*/</span><span class="hljs-comment">/*B*/</span><span class="hljs-comment">/*C*/</span><span class="hljs-comment">/*D*/</span><span class="hljs-comment">/*E*/</span><span class="hljs-comment">/*F*/</span><span class="hljs-comment">/*G*/</span><br><span class="hljs-comment">/*A*/</span> &#123;   <span class="hljs-number">0</span>,  <span class="hljs-number">12</span>, INF, INF, INF,  <span class="hljs-number">16</span>,  <span class="hljs-number">14</span>&#125;,<br><span class="hljs-comment">/*B*/</span> &#123;  <span class="hljs-number">12</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">10</span>, INF, INF,   <span class="hljs-number">7</span>, INF&#125;,<br><span class="hljs-comment">/*C*/</span> &#123; INF,  <span class="hljs-number">10</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>, INF&#125;,<br><span class="hljs-comment">/*D*/</span> &#123; INF, INF,   <span class="hljs-number">3</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">4</span>, INF, INF&#125;,<br><span class="hljs-comment">/*E*/</span> &#123; INF, INF,   <span class="hljs-number">5</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">8</span>&#125;,<br><span class="hljs-comment">/*F*/</span> &#123;  <span class="hljs-number">16</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">6</span>, INF,   <span class="hljs-number">2</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">9</span>&#125;,<br><span class="hljs-comment">/*G*/</span> &#123;  <span class="hljs-number">14</span>, INF, INF, INF,   <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,   <span class="hljs-number">0</span>&#125;&#125;; <br>      <span class="hljs-comment">//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span><br>      <br>      <span class="hljs-comment">//创建KruskalCase 对象实例</span><br>      KruskalCase kruskalCase = <span class="hljs-keyword">new</span> KruskalCase(vertexs, matrix);<br>      <span class="hljs-comment">//输出构建的</span><br>      kruskalCase.print();<br>      kruskalCase.kruskal();<br>      <br>&#125;<br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KruskalCase</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vertexs, <span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br><span class="hljs-comment">//初始化顶点数和边的个数</span><br><span class="hljs-keyword">int</span> vlen = vertexs.length;<br><br><span class="hljs-comment">//初始化顶点, 复制拷贝的方式</span><br><span class="hljs-keyword">this</span>.vertexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexs.length; i++) &#123;<br><span class="hljs-keyword">this</span>.vertexs[i] = vertexs[i];<br>&#125;<br><br><span class="hljs-comment">//初始化边, 使用的是复制拷贝的方式</span><br><span class="hljs-keyword">this</span>.matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vlen; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j= <span class="hljs-number">0</span>; j &lt; vlen; j++) &#123;<br><span class="hljs-keyword">this</span>.matrix[i][j] = matrix[i][j];<br>&#125;<br>&#125;<br><span class="hljs-comment">//统计边的条数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; vlen; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; vlen; j++) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.matrix[i][j] != INF) &#123;<br>edgeNum++;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示最后结果数组的索引</span><br><span class="hljs-keyword">int</span>[] ends = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[edgeNum]; <span class="hljs-comment">//用于保存&quot;已有最小生成树&quot; 中的每个顶点在最小生成树中的终点</span><br><span class="hljs-comment">//创建结果数组, 保存最后的最小生成树</span><br>EData[] rets = <span class="hljs-keyword">new</span> EData[edgeNum];<br><br><span class="hljs-comment">//获取图中 所有的边的集合 ， 一共有12边</span><br>EData[] edges = getEdges();<br>System.out.println(<span class="hljs-string">&quot;图的边的集合=&quot;</span> + Arrays.toString(edges) + <span class="hljs-string">&quot; 共&quot;</span>+ edges.length); <span class="hljs-comment">//12</span><br><br><span class="hljs-comment">//按照边的权值大小进行排序(从小到大)</span><br>sortEdges(edges);<br><br><span class="hljs-comment">//遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; edgeNum; i++) &#123;<br><span class="hljs-comment">//获取到第i条边的第一个顶点(起点)</span><br><span class="hljs-keyword">int</span> p1 = getPosition(edges[i].start); <span class="hljs-comment">//p1=4</span><br><span class="hljs-comment">//获取到第i条边的第2个顶点</span><br><span class="hljs-keyword">int</span> p2 = getPosition(edges[i].end); <span class="hljs-comment">//p2 = 5</span><br><br><span class="hljs-comment">//获取p1这个顶点在已有最小生成树中的终点</span><br><span class="hljs-keyword">int</span> m = getEnd(ends, p1); <span class="hljs-comment">//m = 4</span><br><span class="hljs-comment">//获取p2这个顶点在已有最小生成树中的终点</span><br><span class="hljs-keyword">int</span> n = getEnd(ends, p2); <span class="hljs-comment">// n = 5</span><br><span class="hljs-comment">//是否构成回路 类似于并查集</span><br><span class="hljs-keyword">if</span>(m != n) &#123; <span class="hljs-comment">//没有构成回路</span><br>ends[m] = n; <span class="hljs-comment">// 设置m 在&quot;已有最小生成树&quot;中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0]</span><br>rets[index++] = edges[i]; <span class="hljs-comment">//有一条边加入到rets数组</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span><br><span class="hljs-comment">//统计并打印 &quot;最小生成树&quot;, 输出  rets</span><br>System.out.println(<span class="hljs-string">&quot;最小生成树为&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>System.out.println(rets[i]);<br>&#125;<br><br><br>&#125;<br><br><span class="hljs-comment">//打印邻接矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;邻接矩阵为: \n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexs.length; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j &lt; vertexs.length; j++) &#123;<br>System.out.printf(<span class="hljs-string">&quot;%12d&quot;</span>, matrix[i][j]);<br>&#125;<br>System.out.println();<span class="hljs-comment">//换行</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能：对边进行排序处理, 冒泡排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> edges 边的集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortEdges</span><span class="hljs-params">(EData[] edges)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; edges.length - <span class="hljs-number">1</span> - i; j++) &#123;<br><span class="hljs-keyword">if</span>(edges[j].weight &gt; edges[j+<span class="hljs-number">1</span>].weight) &#123;<span class="hljs-comment">//交换</span><br>EData tmp = edges[j];<br>edges[j] = edges[j+<span class="hljs-number">1</span>];<br>edges[j+<span class="hljs-number">1</span>] = tmp;<br>&#125;<br>&#125;<br> &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ch 顶点的值，比如&#x27;A&#x27;,&#x27;B&#x27;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回ch顶点对应的下标，如果找不到，返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPosition</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexs.length; i++) &#123;<br><span class="hljs-keyword">if</span>(vertexs[i] == ch) &#123;<span class="hljs-comment">//找到</span><br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-comment">//找不到,返回-1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span><br><span class="hljs-comment"> * 是通过matrix 邻接矩阵来获取</span><br><span class="hljs-comment"> * EData[] 形式 [[&#x27;A&#x27;,&#x27;B&#x27;, 12], [&#x27;B&#x27;,&#x27;F&#x27;,7], .....]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> EData[] getEdges() &#123;<br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>EData[] edges = <span class="hljs-keyword">new</span> EData[edgeNum];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexs.length; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j &lt;vertexs.length; j++) &#123;<br><span class="hljs-keyword">if</span>(matrix[i][j] != INF) &#123;<br>edges[index++] = <span class="hljs-keyword">new</span> EData(vertexs[i], vertexs[j], matrix[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> edges;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i : 表示传入的顶点对应的下标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//类似于并查集</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ends, <span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">// i = 4 [0,0,0,0,5,0,0]</span><br><span class="hljs-keyword">while</span>(ends[i] != <span class="hljs-number">0</span>) &#123;<br>i = ends[i];<br>&#125;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br> <br>&#125;<br><br><span class="hljs-comment">//创建一个类EData ，它的对象实例就表示一条边</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EData</span> </span>&#123;<br><span class="hljs-keyword">char</span> start; <span class="hljs-comment">//边的一个点</span><br><span class="hljs-keyword">char</span> end; <span class="hljs-comment">//边的另外一个点</span><br><span class="hljs-keyword">int</span> weight; <span class="hljs-comment">//边的权值</span><br><span class="hljs-comment">//构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> start, <span class="hljs-keyword">char</span> end, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.start = start;<br><span class="hljs-keyword">this</span>.end = end;<br><span class="hljs-keyword">this</span>.weight = weight;<br>&#125;<br><span class="hljs-comment">//重写toString, 便于输出边信息</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;EData [&lt;&quot;</span> + start + <span class="hljs-string">&quot;, &quot;</span> + end + <span class="hljs-string">&quot;&gt;= &quot;</span> + weight + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="最短路径算法">最短路径算法</h2><p>最短路径，故名思意，就是寻找从起点到终点的最短的路径，解决这个问题的，同样有两种算法，<img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220809214857788.png" alt=""></p><h3 id="迪杰斯特拉算法">迪杰斯特拉算法</h3><p>这个算法的主要特点就是以起始点为中心向外层层扩展（就是广度优先搜索的思想），直到扩展到终点为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DijkstraAlgorithm</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">char</span>[] vertex = &#123; <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span> &#125;;<span class="hljs-comment">//顶点数组</span><br><span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vertex.length][vertex.length];<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">65535</span>;<span class="hljs-comment">// 表示不可以连接</span><br>matrix[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;N,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,N,N,N,<span class="hljs-number">2</span>&#125;;  <br>        matrix[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">5</span>,N,N,<span class="hljs-number">9</span>,N,N,<span class="hljs-number">3</span>&#125;;  <br>        matrix[<span class="hljs-number">2</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">7</span>,N,N,N,<span class="hljs-number">8</span>,N,N&#125;;  <br>        matrix[<span class="hljs-number">3</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;N,<span class="hljs-number">9</span>,N,N,N,<span class="hljs-number">4</span>,N&#125;;  <br>        matrix[<span class="hljs-number">4</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;N,N,<span class="hljs-number">8</span>,N,N,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;  <br>        matrix[<span class="hljs-number">5</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;N,N,N,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,N,<span class="hljs-number">6</span>&#125;;  <br>        matrix[<span class="hljs-number">6</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,N,N,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,N&#125;;<br>        <span class="hljs-comment">//创建 Graph对象</span><br>        Graph graph = <span class="hljs-keyword">new</span> Graph(vertex, matrix);<br>        <span class="hljs-comment">//测试, 看看图的邻接矩阵是否ok</span><br>        graph.showGraph();<br>        <span class="hljs-comment">//测试迪杰斯特拉算法</span><br>        graph.dsj(<span class="hljs-number">2</span>);<span class="hljs-comment">//C</span><br>        graph.showDijkstra();<br>        <br>        <br>&#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] vertex; <span class="hljs-comment">// 顶点数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] matrix; <span class="hljs-comment">// 邻接矩阵</span><br><span class="hljs-keyword">private</span> VisitedVertex vv; <span class="hljs-comment">//已经访问的顶点的集合</span><br><br><span class="hljs-comment">// 构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vertex, <span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.vertex = vertex;<br><span class="hljs-keyword">this</span>.matrix = matrix;<br>&#125;<br><br><span class="hljs-comment">//显示结果</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>vv.show();<br>&#125;<br><br><span class="hljs-comment">// 显示图</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] link : matrix) &#123;<br>System.out.println(Arrays.toString(link));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//迪杰斯特拉算法实现</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 表示出发顶点对应的下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dsj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>vv = <span class="hljs-keyword">new</span> VisitedVertex(vertex.length, index);<br>update(index);<span class="hljs-comment">//更新index顶点到周围顶点的距离和前驱顶点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;vertex.length; j++) &#123;<br>index = vv.updateArr();<span class="hljs-comment">// 选择并返回新的访问顶点</span><br>update(index); <span class="hljs-comment">// 更新index顶点到周围顶点的距离和前驱顶点</span><br>&#125; <br>&#125;<br><br><br><br><span class="hljs-comment">//更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点,</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//根据遍历我们的邻接矩阵的  matrix[index]行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[index].length; j++) &#123;<br><span class="hljs-comment">// len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和 </span><br>len = vv.getDis(index) + matrix[index][j];<br><span class="hljs-comment">// 如果j顶点没有被访问过，并且 len 小于出发顶点到j顶点的距离，就需要更新</span><br><span class="hljs-keyword">if</span>(!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;<br>vv.updatePre(j, index); <span class="hljs-comment">//更新j顶点的前驱为index顶点</span><br>vv.updateDis(j, len); <span class="hljs-comment">//更新出发顶点到j顶点的距离</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 已访问顶点集合</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitedVertex</span> </span>&#123;<br><span class="hljs-comment">// 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] already_arr;<br><span class="hljs-comment">// 每个下标对应的值为前一个顶点下标, 会动态更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] pre_visited;<br><span class="hljs-comment">// 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dis;<br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> length :表示顶点的个数 </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index: 出发顶点对应的下标, 比如G顶点，下标就是6</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VisitedVertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.already_arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br><span class="hljs-keyword">this</span>.pre_visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br><span class="hljs-keyword">this</span>.dis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br><span class="hljs-comment">//初始化 dis数组</span><br>Arrays.fill(dis, <span class="hljs-number">65535</span>);<br><span class="hljs-keyword">this</span>.already_arr[index] = <span class="hljs-number">1</span>; <span class="hljs-comment">//设置出发顶点被访问过</span><br><span class="hljs-keyword">this</span>.dis[index] = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置出发顶点的访问距离为0</span><br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能: 判断index顶点是否被访问过</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果访问过，就返回true, 否则访问false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">return</span> already_arr[index] == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能: 更新出发顶点到index顶点的距离</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> len</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateDis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>dis[index] = len;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能: 更新pre这个顶点的前驱顶点为index顶点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pre</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updatePre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>pre_visited[pre] = index;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能:返回出发顶点到index顶点的距离</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">return</span> dis[index];<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateArr</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> min = <span class="hljs-number">65535</span>, index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; already_arr.length; i++) &#123;<br><span class="hljs-keyword">if</span>(already_arr[i] == <span class="hljs-number">0</span> &amp;&amp; dis[i] &lt; min ) &#123;<br>min = dis[i];<br>index = i;<br>&#125;<br>&#125;<br><span class="hljs-comment">//更新 index 顶点被访问过</span><br>already_arr[index] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> index;<br>&#125;<br><br><span class="hljs-comment">//显示最后的结果</span><br><span class="hljs-comment">//即将三个数组的情况输出</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br><br>System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br><span class="hljs-comment">//输出already_arr</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : already_arr) &#123;<br>System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//输出pre_visited</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : pre_visited) &#123;<br>System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//输出dis</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : dis) &#123;<br>System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">//为了好看最后的最短距离，我们处理</span><br><span class="hljs-keyword">char</span>[] vertex = &#123; <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span> &#125;;<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : dis) &#123;<br><span class="hljs-keyword">if</span> (i != <span class="hljs-number">65535</span>) &#123;<br>System.out.print(vertex[count] + <span class="hljs-string">&quot;(&quot;</span>+i+<span class="hljs-string">&quot;) &quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;N &quot;</span>);<br>&#125;<br>count++;<br>&#125;<br>System.out.println();<br><br>&#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="弗洛伊德算法">弗洛伊德算法</h3><p>弗洛伊德算法使用的是类似于上面的额动态规划的思想，不断刷新各个节点之间最短值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FloydAlgorithm</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 测试看看图是否创建成功</span><br><span class="hljs-keyword">char</span>[] vertex = &#123; <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span> &#125;;<br><span class="hljs-comment">//创建邻接矩阵</span><br><span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vertex.length][vertex.length];<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">65535</span>;<br>matrix[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, N, N, N, <span class="hljs-number">2</span> &#125;;<br>matrix[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, N, <span class="hljs-number">9</span>, N, N, <span class="hljs-number">3</span> &#125;;<br>matrix[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">7</span>, N, <span class="hljs-number">0</span>, N, <span class="hljs-number">8</span>, N, N &#125;;<br>matrix[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; N, <span class="hljs-number">9</span>, N, <span class="hljs-number">0</span>, N, <span class="hljs-number">4</span>, N &#125;;<br>matrix[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; N, N, <span class="hljs-number">8</span>, N, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br>matrix[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; N, N, N, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span> &#125;;<br>matrix[<span class="hljs-number">6</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, N, N, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">//创建 Graph 对象</span><br>Graph graph = <span class="hljs-keyword">new</span> Graph(vertex.length, matrix, vertex);<br><span class="hljs-comment">//调用弗洛伊德算法</span><br>graph.floyd();<br>graph.show();<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// 创建图</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] vertex; <span class="hljs-comment">// 存放顶点的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dis; <span class="hljs-comment">// 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] pre;<span class="hljs-comment">// 保存到达目标顶点的前驱顶点</span><br><br><span class="hljs-comment">// 构造器</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> length</span><br><span class="hljs-comment"> *            大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> matrix</span><br><span class="hljs-comment"> *            邻接矩阵</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> vertex</span><br><span class="hljs-comment"> *            顶点数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">char</span>[] vertex)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.vertex = vertex;<br><span class="hljs-keyword">this</span>.dis = matrix;<br><span class="hljs-keyword">this</span>.pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length][length];<br><span class="hljs-comment">// 对pre数组初始化, 注意存放的是前驱顶点的下标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>Arrays.fill(pre[i], i);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 显示pre数组和dis数组</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//为了显示便于阅读，我们优化一下输出</span><br><span class="hljs-keyword">char</span>[] vertex = &#123; <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; dis.length; k++) &#123;<br><span class="hljs-comment">// 先将pre数组输出的一行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dis.length; i++) &#123;<br>System.out.print(vertex[pre[k][i]] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br><span class="hljs-comment">// 输出dis数组的一行数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dis.length; i++) &#123;<br>System.out.print(<span class="hljs-string">&quot;(&quot;</span>+vertex[k]+<span class="hljs-string">&quot;到&quot;</span>+vertex[i]+<span class="hljs-string">&quot;的最短路径是&quot;</span> + dis[k][i] + <span class="hljs-string">&quot;) &quot;</span>);<br>&#125;<br>System.out.println();<br>System.out.println();<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//弗洛伊德算法, 比较容易理解，而且容易实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; <span class="hljs-comment">//变量保存距离</span><br><span class="hljs-comment">//对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G] </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; dis.length; k++) &#123; <span class="hljs-comment">// </span><br><span class="hljs-comment">//从i顶点开始出发 [A, B, C, D, E, F, G]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dis.length; i++) &#123;<br><span class="hljs-comment">//到达j顶点 // [A, B, C, D, E, F, G]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; dis.length; j++) &#123;<br>len = dis[i][k] + dis[k][j];<span class="hljs-comment">// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离</span><br><span class="hljs-keyword">if</span>(len &lt; dis[i][j]) &#123;<span class="hljs-comment">//如果len小于 dis[i][j]</span><br>dis[i][j] = len;<span class="hljs-comment">//更新距离</span><br>pre[i][j] = pre[k][j];<span class="hljs-comment">//更新前驱顶点</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="马踏棋盘算法">马踏棋盘算法</h2><p>将马随机放在国际象棋的8*8的某个方格中，按照马走日字的规则进行移动，每个方格只进入一次，走遍棋盘上的全部64个方格<img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220809220907942.png" alt="image-20220809220907942"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里采用的是回溯（深度优先的思想）实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HorseChessboard</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> X; <span class="hljs-comment">// 棋盘的列数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Y; <span class="hljs-comment">// 棋盘的行数</span><br><span class="hljs-comment">//创建一个数组，标记棋盘的各个位置是否被访问过</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> visited[];<br><span class="hljs-comment">//使用一个属性，标记是否棋盘的所有位置都被访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> finished; <span class="hljs-comment">// 如果为true,表示成功</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;骑士周游算法，开始运行~~&quot;</span>);<br><span class="hljs-comment">//测试骑士周游算法是否正确</span><br>X = <span class="hljs-number">8</span>;<br>Y = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> row = <span class="hljs-number">1</span>; <span class="hljs-comment">//马儿初始位置的行，从1开始编号</span><br><span class="hljs-keyword">int</span> column = <span class="hljs-number">1</span>; <span class="hljs-comment">//马儿初始位置的列，从1开始编号</span><br><span class="hljs-comment">//创建棋盘</span><br><span class="hljs-keyword">int</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[X][Y];<br>visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[X * Y];<span class="hljs-comment">//初始值都是false</span><br><span class="hljs-comment">//测试一下耗时</span><br><span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>traversalChessboard(chessboard, row - <span class="hljs-number">1</span>, column - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;共耗时: &quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br><br><span class="hljs-comment">//输出棋盘的最后情况</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] rows : chessboard) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> step: rows) &#123;<br>System.out.print(step + <span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成骑士周游问题的算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> chessboard 棋盘</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> row 马儿当前的位置的行 从0开始 </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> column 马儿当前的位置的列  从0开始</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> step 是第几步 ,初始位置就是第1步 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traversalChessboard</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] chessboard, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span> step)</span> </span>&#123;<br>chessboard[row][column] = step;<br><span class="hljs-comment">//row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36</span><br>visited[row * X + column] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//标记该位置已经访问</span><br><span class="hljs-comment">//获取当前位置可以走的下一个位置的集合 </span><br>ArrayList&lt;Point&gt; ps = next(<span class="hljs-keyword">new</span> Point(column, row));<br><span class="hljs-comment">//对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序</span><br>sort(ps);<br><span class="hljs-comment">//遍历 ps</span><br><span class="hljs-keyword">while</span>(!ps.isEmpty()) &#123;<br>Point p = ps.remove(<span class="hljs-number">0</span>);<span class="hljs-comment">//取出下一个可以走的位置</span><br><span class="hljs-comment">//判断该点是否已经访问过</span><br><span class="hljs-keyword">if</span>(!visited[p.y * X + p.x]) &#123;<span class="hljs-comment">//说明还没有访问过</span><br>traversalChessboard(chessboard, p.y, p.x, step + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//判断马儿是否完成了任务，使用   step 和应该走的步数比较 ， </span><br><span class="hljs-comment">//如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span><br><span class="hljs-comment">//说明: step &lt; X * Y  成立的情况有两种</span><br><span class="hljs-comment">//1. 棋盘到目前位置,仍然没有走完</span><br><span class="hljs-comment">//2. 棋盘处于一个回溯过程</span><br><span class="hljs-keyword">if</span>(step &lt; X * Y &amp;&amp; !finished ) &#123;<br>chessboard[row][column] = <span class="hljs-number">0</span>;<br>visited[row * X + column] = <span class="hljs-keyword">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>finished = <span class="hljs-keyword">true</span>;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> curPoint</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Point&gt; <span class="hljs-title">next</span><span class="hljs-params">(Point curPoint)</span> </span>&#123;<span class="hljs-comment">//java居然还有point类</span><br><span class="hljs-comment">//创建一个ArrayList</span><br>ArrayList&lt;Point&gt; ps = <span class="hljs-keyword">new</span> ArrayList&lt;Point&gt;();<br><span class="hljs-comment">//创建一个Point</span><br>Point p1 = <span class="hljs-keyword">new</span> Point();<br><span class="hljs-comment">//表示马儿可以走5这个位置</span><br><span class="hljs-keyword">if</span>((p1.x = curPoint.x - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y -<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走6这个位置</span><br><span class="hljs-keyword">if</span>((p1.x = curPoint.x - <span class="hljs-number">1</span>) &gt;=<span class="hljs-number">0</span> &amp;&amp; (p1.y=curPoint.y-<span class="hljs-number">2</span>)&gt;=<span class="hljs-number">0</span>) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走7这个位置</span><br><span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走0这个位置</span><br><span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走1这个位置</span><br><span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">1</span>) &lt; Y) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走2这个位置</span><br><span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">2</span>) &lt; Y) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走3这个位置</span><br><span class="hljs-keyword">if</span> ((p1.x = curPoint.x - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">2</span>) &lt; Y) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-comment">//判断马儿可以走4这个位置</span><br><span class="hljs-keyword">if</span> ((p1.x = curPoint.x - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">1</span>) &lt; Y) &#123;<br>ps.add(<span class="hljs-keyword">new</span> Point(p1));<br>&#125;<br><span class="hljs-keyword">return</span> ps;<br>&#125;<br><br><span class="hljs-comment">//根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(ArrayList&lt;Point&gt; ps)</span> </span>&#123;<br>ps.sort(<span class="hljs-keyword">new</span> Comparator&lt;Point&gt;() &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Point o1, Point o2)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//获取到o1的下一步的所有位置个数</span><br><span class="hljs-keyword">int</span> count1 = next(o1).size();<br><span class="hljs-comment">//获取到o2的下一步的所有位置个数</span><br><span class="hljs-keyword">int</span> count2 = next(o2).size();<br><span class="hljs-keyword">if</span>(count1 &lt; count2) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count1 == count2) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br>&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>11. 并查集</h1><p>//todo</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/06/16/JVM/"/>
    <url>/2022/06/16/JVM/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">        <div>经过一段时间的期末冲刺预习，现在终于有时间进行jvm的学习了😥</div>      <div>更新日志:</div>      <ul>          <div>2022.6.17 根据狂神的视频进行初步了解掌握</div>      </ul></div><h1>1. JVM的探究</h1><ol><li>请你谈谈对于JVM的理解？Java8虚拟机和之前的变化更新</li><li>什么是OOM，什么是栈溢出StackOverFlowError? 怎么分析</li><li>JVM的常用调优参数有哪些</li><li>内存快照如何抓取，怎么分析Dump文件</li><li>谈谈JVM中，你对于类加载器的认识</li></ol><div class = "note note-success">三种jvm</div><ul><li><p>SUN公司 hotpot</p></li><li><p>BEA JRockit</p></li><li><p>IBM J9VM</p></li></ul><h1>2. JVM 结构</h1><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619152717928.png" alt="image-20220619152717928"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220617184022048.png" alt="image-20220617184022048"></p><h2 id="1-类加载器">1. 类加载器</h2><p>类加载器分为四类</p><ul><li><p>虚拟机自带的加载器</p></li><li><p>启动类（根）加载器（使用C++）</p></li><li><p>扩展类加载器</p></li><li><p>应用程序加载器</p></li></ul><h2 id="2-程序计数器">2. 程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里 ，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="3-Native和方法区">3. Native和方法区</h2><h3 id="3-1-Native">3.1 Native</h3><p>有时候我们会在Java的源码里面看见如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>凡是带了native关键字的方法，说明Java的作用范围达不到了  需要去调用底层C语言的库，会进入本地方法栈，然后调用本地方法接口 JNI</p><p>本地方法接口就是为了去调本地方法库 扩展Java的使用 融合不同的编程语言为Java所用</p><h3 id="3-2-方法区">3.2 方法区</h3><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单的来说，所有定义的方法的信息都保存在该区域，此区域书于共享区间；方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个<strong>逻辑部分</strong>，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p><p>常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。静态变量、常量、类信息(构造方法，接口定义)，运行时的常量池存在方法区中，但是实例变量存在<strong>堆内存</strong>中，和方法区无关</p><h2 id="4-栈">4. 栈</h2><p>“栈”通常就是指上面讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。栈内存，主管程序的运行、生命周期和线程同步。线程结束，栈内存也释放。对于栈来说，不存在垃圾回收问题， 一旦线程结束栈就结束</p><p>栈的运行原理  : 栈帧(栈帧也叫过程活动记录，是编译器用来实现过程函数调用的一种数据结构”。实际上，可以简单理解为：栈帧就是存储在用户栈上的（当然内核栈同样适用）每一次函数调用涉及的相关信息的记录单元。</p><h2 id="5-堆">5. 堆</h2><p>heap一个jvm只有一个堆内存 堆内存的大小是可以调节的</p><p>堆内存中还要细分三个区域</p><ul><li><p>新生区(伊甸园区 eden space  幸存0区 幸存1区)</p></li><li><p>养老区</p></li><li><p>永久区(1.8后称为元空间)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220617191448788.png" alt="堆内存"></p><ol><li>新生区</li></ol><p>类诞生和成长的地方 甚至死亡，伊甸园区：所有的对象都是在伊甸园区new出来的</p><ol start="2"><li>永久区(元空间)</li></ol><p>这个区域常驻内存 用来存放自身携带的class对象 interface元数据 存储的是Java运行的一些环境或类信息 这个区域不存在垃圾回收 关闭vm虚拟机就会释放这个区域的内存</p><p>元空间逻辑上存在 物理上不存在</p><h3 id="5-1-堆内存错误">5.1 堆内存错误</h3><p>假设内存满了 OOM  堆内存错误</p><p>java.lang.OutOfMemoryError:Java heap space</p><p>当出现这种错误的时候我们该怎么办呢？</p><p>答案就是JProfiler,可以通过JProfiler进行调优</p><ol><li>下载该插件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220617192619772.png" alt="image-20220617192619772"></p><ol start="2"><li>下载应用，然后在idea中配置</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220617192638260.png" alt="image-20220617192638260"></p><ol start="3"><li>通过命令生成dump文件，然后进行分析</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220617192656192.png" alt="image-20220617192656192"></p><p>常用的一些命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//- Xms 设置初始化内存分配大小 1/64</span><br><span class="hljs-comment">//- Xmx 谈置最大分配’内存，默认1/4</span><br><span class="hljs-comment">//- XX :+ PrintGCDetails // 打印GC垃圾回收信息</span><br><span class="hljs-comment">//- XX :+HeapDumpOn0utOfMemoryError// oom DUMP</span><br><br><span class="hljs-comment">//-Xms1m-Xmx8m- XX :+ HeapDumpOnOutOfMemoryError </span><br></code></pre></td></tr></table></figure><h1>3. Hotpot虚拟机对象探秘</h1><h2 id="3-1-对象的创建">3.1 对象的创建</h2><p>当Java遇到一个新的new指令的时候，它首先会去检查指令的参数能否在常量池中定位到 一个类的符号引用，并且检查这个符号所引用的类是否已经被加载，解析和初始化过，如果没有，则会先进行加载，接下来就会为这个新的对象分配内存，如果Java堆中的内存是规整的，那么分配内存的方法就是把指针向空闲空间的方向挪动一段距离，这种分配方式被称为：“指针碰撞”。如果内存不是规整的，那么就需要建立一个“空闲列表”，用来记录那些内存块分给了哪些对象。</p><p>​    在分配内存的过程中，又会遇到一个问题，就是如果正在给对象A分配内存，但是对象B又同时使用了原来的指针来分配内存的情况。这种时候有两种可选择的方案–一种是堆分配内存的操作进行同步处理，第二种就是建立本地线程分配缓冲</p><p>​    接下来，Java虚拟机还需要对对象进行一些必要的设置，比如这个对象是哪个类的实例，如何找回类的元数据信息，对象的哈希码，对象的GC年龄分代信息。最后执行构造函数等方法，一个完整的对象才被创建出来。</p><div class = "note note-success">一个对象在内存中实例化的过程</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    String name; <span class="hljs-comment">// 定义一个成员变量 name</span><br>    <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 成员变量 age</span><br>    Double height; <span class="hljs-comment">// 成员变量 height</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;人的姓名：&quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;人的年龄：&quot;</span>+age);<br>        System.out.println(<span class="hljs-string">&quot;人的身高：&quot;</span>+height);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String name; <span class="hljs-comment">// 定义一个局部变量 name</span><br>        <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 局部变量 age</span><br>        Double height; <span class="hljs-comment">// 局部变量 height</span><br>    <br>        People people = <span class="hljs-keyword">new</span> People() ; <span class="hljs-comment">//实例化对象people</span><br>        people.name = <span class="hljs-string">&quot;张三&quot;</span> ;       <span class="hljs-comment">//赋值</span><br>        people.age = <span class="hljs-number">18</span>;             <span class="hljs-comment">//赋值</span><br>        people.height = <span class="hljs-number">180.0</span> ;   <span class="hljs-comment">//赋值</span><br>        people.print();              <span class="hljs-comment">//调用方法sing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在还没开始时</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619102309453.png" alt="image-20220619102309453"></p><ol start="2"><li>开始执行，类中的成员变量和方法会先进入到方法区</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619102608309.png" alt="image-20220619102608309"></p><ol start="3"><li>main方法被压入栈中</li></ol><p>​                                                <img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619102825310.png" alt="image-20220619102825310"></p><ol start="4"><li><p>执行到Person person = new Person()；会在栈中创建Person类的引用，在堆中存放实例化的对象，然后将成员变量和成员方法放在实例中（都是取得成员变量和成员方法的地址值）</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619103527954.png" alt="image-20220619103527954"></p><ol start="5"><li>接下来对 person 对象进行赋值， <a href="http://person.name">person.name</a> = “张三” ; person.age = 13; person.height= 180.0;先在栈区找到 person，然后根据地址值找到 new Person() 进行赋值操作。</li></ol><p>​                                              <img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619104355652.png" alt="image-20220619104355652"></p><ol start="6"><li><p>在方法体void ()被调用完成后，就会立刻马上从栈内弹出（出栈)最后，在main()函数完成后，main()函数也会出栈 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220619104854834.png" alt="image-20220619104854834"></p></li></ol></li></ol><h2 id="3-2-对象的内存布局">3.2 对象的内存布局</h2><p>Hotpot虚拟机对象的头部包含两类信息，第一类是存储对象本身运行时的数据，比如哈希码，GC年龄分代，锁状态标志，偏向线程ID，偏向时间戳等，这部分数据被官方称为&quot;Mark word&quot;.如下图所示<img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220622112951852.png" alt="image-20220622112951852"></p><p>还有一类就是类型指针，Java虚拟机通过这个指针来判断该对象是哪个类的实例，如果对象是数组，还会有一个数据来记录数组的长度。</p><h2 id="3-3-对象的访问定位">3.3 对象的访问定位</h2><p>简单的来说，访问主要有句柄访问和指针访问，直接使用指针访问的话，可以节省一次指针定位的时间，累积下来，也是比较可观的，在hotpot中，主要使用指针访问，而在各种语言和框架中，使用句柄访问也很常见</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220622113532052.png" alt="句柄访问"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220622113607252.png" alt="直接指针访问"></p><h1>4. 垃圾回收</h1><h2 id="4-1-什么是垃圾回收">4.1 什么是垃圾回收</h2><p>GC(Garbage Collection )垃圾回收,分为轻量级垃圾回收和重量级垃圾回收 主要是在伊甸园区和年老区</p><p>jvm 在进行GC时，并不是对这三个区域统一回收 回收的都是年轻代</p><p>将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。</p><p>年轻代：所有新生成的对象首先都是放在Eden区。</p><p>年老代：在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。</p><p>持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。</p><p>Minor GC:</p><p>用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到 Survivor1、Survivor2 区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2 只有一个在用，一个为空)</p><p>Major GC:</p><p>用于清理老年代区域。</p><p>Full GC：</p><p>用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。</p><p>垃圾回收过程(不是所有的收集器)</p><ul><li>新创建的对象，绝大多数都会存储在Eden中</li><li>当Eden满了，不能创建新对象，则触发Minor GC，将无用对象清理掉，将剩余对象复制到某个Survivor(S1)中，同时清空Eden区</li><li>当Eden再次满了，会将S1中不能清空的对象存到另一个Survivor(S2)，同时将Eden中不能清空的复制到S1，保证Eden、S1均被清空</li><li>重复15次Survivor中未被清理的对象，则复制到老年代区</li><li>当年老代区满了，则会触发一个一次完整的垃圾回收（Full GC）</li></ul><div class = "note note-success">对象已死？</div><ol><li>引用计数法</li></ol><p>​    在对象中添加一个引用计数器，在一个地方引用它的时候，计数器就加一，当引用失效的时候，计数器就减一，任何时候当计数器为零的时候，这个对象就是不可能再使用的，就坐等被回收吧</p><ol start="2"><li><p>可达性分析</p><p>这个算法的基本思路就是通过一系列称为“GC Roots” 的根对象作为起始节点，向下搜索，所搜走过的路径称为“引用链”，如果某个对象与Roots之间没有任何的链相连接，那么就称这个对象不可达，即对象已死。</p></li></ol><h2 id="4-2-GC-的算法">4.2 GC 的算法</h2><h3 id="分代收集理论">分代收集理论</h3><p>这个理论建立在弱分代学说和强分代学说的基础之上，认为收集器应该将内存区域分为几个区域，然后依据其年龄分开进行存储，分别进行回收</p><h3 id="标记清除法-Mark-Sweep">标记清除法(Mark-Sweep)</h3><p>这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间</p><p>优点： 不需要额外的空间</p><p>缺点：两次扫描 严重浪费时间 会产生大量的内存碎片</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220704101326795.png" alt="image-20220704101326795"></p><h3 id="标记-复制算法-Mark-Copying">标记-复制算法(Mark-Copying)</h3><p>为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题，复制算法最佳的使用场景 对象存活度较低的时候 ，现在的商用Java虚拟机大多都优先采用了这个算法去收集新生代。</p><p>优缺点：没有内存碎片，浪费了一半的内存空间</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220704101610542.png" alt="image-20220704101610542"></p><h3 id="标记-整理算法（Mark-Compact）">标记-整理算法（Mark-Compact）</h3><p>也称标记-压缩法为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存. 压缩防止内存碎片产生 再次扫描 向一段一段存活的对象多了一次移动成本</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220704101709355.png" alt="image-20220704101709355"></p><h3 id="总结">总结</h3><p>内存效率 :复制算法  &gt;  标记清除算法  &gt;  标记压缩算法</p><p>内存整齐度  复制算法  =  标记压缩算法  &gt;  标记清除算法</p><p>内存利用率  标记压缩算法  =  标记清除算法  &gt;  复制算法</p><div class = "note note-danger">没有最好的算法</div><p>年轻代存活率低所以用复制算法</p><p>老年代存活率高用标记清除算法+标记压缩混合实现</p><h2 id="4-3-垃圾回收的作用">4.3 垃圾回收的作用</h2><p>垃圾回收是在内存中中存在没有引用的对象或超过作用域的对象时进行垃圾回收，垃圾回收的目的是识别并且丢弃不再使用的对象来释放和重用资源。查找和回收（清理）无用的对象。以便让JVM更有效的使用内存。</p><h2 id="4-3-经典的垃圾收集器">4.3 经典的垃圾收集器</h2><h3 id="Serial收集器">Serial收集器</h3><p>采用标记-复制算法。这个收集器是最基础，历史最悠久的收集器，看名字就知道，这是一个单线程的收集器，因为是单线程，他在进行垃圾收集的时候必须暂停其他所有的工作，直到它收集完毕，这个过程被称为&quot;stop the world&quot;(砸瓦鲁多！🤔),但是它现在仍然是hotpot虚拟机在客户端模式下的默认新生代收集器。</p><h3 id="ParNew收集器">ParNew收集器</h3><p>采用标记-复制算法。这个收集器是Serial收集器的多线程并行版本，它是不少运行在服务端的虚拟机首选新生代收集器(JDK7之前)，很大的原因就是只有他才能跟CMS配合工作(老年代收集器)，从JDK9开始，ParNew+CMS收集器就不再是官方最推荐的服务器端收集器组合了，因为G1出现了。</p><h3 id="Parallel-Scavenge收集器">Parallel Scavenge收集器</h3><p>同样是基于标记-复制算法实现的新生代多线程并发收集器，这个收集器主要关注的是达到一个可控制的吞吐量</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220704103520606.png" alt="image-20220704103520606"></p><p>它也提供了一些参数用来控制吞吐量，这里不再详述，因为和吞吐量密切相关，因此也被称为“吞吐量优先收集器”</p><h3 id="Serial-Old-收集器">Serial Old 收集器</h3><p>Serial收集器的老年代版本，一个采用标记-整理算法的单线程收集器。主要也是提供给客户端模式下的hotpot虚拟机使用。它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</p><h3 id="Parallel-Old-收集器">Parallel Old 收集器</h3><p>Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。用来和Parallel Scavenge收集器搭配，一起专注于吞吐量的组合。适合注重吞吐量和处理器资源稀缺的场景</p><h3 id="CMS-收集器">CMS 收集器</h3><p>全称Concurrent Mark Sweep收集器，基于标记-清除算法的老年代收集器，是以获取最短回收停顿时间为目标的收集器，但它不是简单的标记-清除。主要分为了  <strong>初识标记</strong>， <strong>并发标记</strong>，<strong>重新标记</strong> ，<strong>并发清除</strong> 四个步骤 ，这个收集器主要特点就是并发收集，低停顿。由于标记-清除算法很容易产生内存碎片，所以CMS收集器予以解决(JDK9后被废除)</p><h3 id="Garbage-First-收集器">Garbage First 收集器</h3><p>G1是一款主要面向服务端应用的垃圾收集器。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><h2 id="4-4-低延迟垃圾收集器">4.4 低延迟垃圾收集器</h2><p>略</p><h1>5. 类文件结构</h1><p>Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据结构：“无符号数”和“表”。</p><h2 id="5-1-魔数和Java版本">5.1 魔数和Java版本</h2><p>每个class版本的头四个字节被称为魔数，Class文件的魔数被早期的开发者取为“0xCAFEBABY”,紧接的四个字节存储的Java的版本信息，高版本的JDK能够兼容低版本的版本。</p><h2 id="5-2-常量池">5.2 常量池</h2><p>紧接着版本号之后，就是Java的常量池入口，由于常量池的数量大多是不固定的，因此，在常量池的入口需要放置一个u2类型的数据，代表常量池的容器计数器。常量池主要存放两大类常量，字面量和符号引用。常量池中每一项常量都是一个表，常量池中一共有17种数据类型的结构。</p><h2 id="5-3-访问标志">5.3 访问标志</h2><p>在常量池结束后紧接的两个字节代表着访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括，这个class是类还是接口，是否是public，是否是abstract类，</p><h2 id="5-4-类索引，父类索引与接口索引集合">5.4 类索引，父类索引与接口索引集合</h2><p>Class文件中由这三项数据来确定该类型的继承关系，，类索引，父类索引和接口索引集合都按照顺序排列在访问标志之后。</p><h2 id="5-5-字段表集合">5.5 字段表集合</h2><p>字段表用于描述接口或者类声明中的变量，Java语言中的字段包括类级变量，以及实例级变量，但是不包括方法内部声明的局部变量，字段可以包括修饰符有字段的作用域，是实例变量还是类变量等一系列信息。值得注意的是，字段表中不会列出从父类或者父接口中继承而来的字段。</p><h2 id="5-6-方法表集合">5.6 方法表集合</h2><p>方法表中的结构如同字段表一样，依次包括访问标志，名称索引，描述符索引，属性表集合几项，而因为有一些关键字不能修饰方法，所以方法表里的访问标志少了一些标志。在Java语言中，要重载方法，除了需要与原方法具有相同的简单名称之外，还需要一个与原方法不同的特征签名，特征签名是值一个方法中各个参数在常量池中的字段符号引用的集合，正是因为返回值不包含在特征签名中，因此Java中的方法无法通过返回值的不同来进行重载。</p><h2 id="5-7-属性表集合">5.7 属性表集合</h2><p>为了正确解析Class文件，在早期的规范中，规定了虚拟机9种应当识别的属性，在Java SE 12的规范中，这个数目已经增加到了29种。</p><p>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220908180421975.png" alt="image-20220908180421975"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220908180450216.png" alt="image-20220908180450216"></p><h1>6. 类加载机制</h1><h2 id="6-1-类加载的流程">6.1 类加载的流程</h2><p>一个类从被加载进虚拟机开始，到卸载出内存为止需要经历 加载 验证 准备 解析 初始化 使用 加载 几个阶段，其中详细的环节这里就不展开介绍了。</p><h2 id="6-2-类加载器">6.2 类加载器</h2><p>前面已经说过类加载器一共有四类</p><ul><li>自定义加载器</li><li>启动类（根）加载器（使用C++）</li><li>扩展类加载器</li><li>应用程序加载器</li></ul><h2 id="6-3-双亲委派机制">6.3 双亲委派机制</h2><p>主要的作用就是保证安全，一般来说一个类启动的时候会按照这个顺序(APP-- EXC --BOOT)寻找加载器,而最终执行的加载器则是从上到下的,BOOT-&gt; EXC-&gt;APP,只有没有找到上面一层的类加载器的时候，才会执行下一层的加载器。.从最内层JVM自带的类加载器开始加载，外层恶意同名类得不到加载从而无法调用</p><ol><li>类加载器收到类的加载的请求</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器</li><li>启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知自家在其进行加载</li><li>重复步骤3</li></ol><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220909102404711.png" alt="image-20220909102404711"></p><h2 id="6-4-沙箱安全机制">6.4 沙箱安全机制</h2><p>沙箱机制就是讲Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。通俗来说就是虚拟机把代码加载到拥有不同权限的域里，然后代码就拥有了该域的所有权限。这样就能控制不同代码拥有不同调用操作系统和本地资源的权限</p><p>组成沙箱的基本组件：<br>1.字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。可以帮助Java程序实现内存保护 。核心类不经过字节码校验<br>2.类装载器：其中类装载器在3个方面对Java沙箱起作用</p><p>防止恶意代码干涉善意代码（双亲委派机制）<br>守护被信任的类库边界<br>它将代码归入保护域，确定了代码可以进行哪些操作</p><h1>7. JMM</h1><p>Java Mermory Model</p><p>(待完善)</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus</title>
    <link href="/2022/05/20/Mybatis-Plus/"/>
    <url>/2022/05/20/Mybatis-Plus/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">     <div>前言：</div>     <ul>         <div>             根据狂神视频整理         </div>         <div>             为什么要学它，因为mybatisplus可以节省我们大量的工作时间，所有的CRUD代码他都可以自动完成，所以才说是懒人后端的福音😁         </div>         <div>             这个是中国人开发的，所以官方写得比较好理解，官方配置文档地址<a href = "https://www.mybatis-plus.com/" target = "_blank">点点我</a>         </div>     <ul></div><h1>1. 简介</h1><p>MyBatis-Plus （简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h1>2. 快速入门</h1><ol><li>对应的数据库脚本</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> <span class="hljs-keyword">user</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br>(<br>id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (id)<br>);<br><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (id, name, age, email) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jone&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@baomidou.com&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test2@baomidou.com&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;test3@baomidou.com&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Sandy&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@baomidou.com&#x27;</span>),<br>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Billie&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;test5@baomidou.com&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>在pom里导入mp（这里是比较早的版本，推荐使用较新的版本</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><div class = "note note-warning">不要同时导入mybatis 和mp,可能会引起版本冲突</div><ol start="3"><li>数据库配置</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/dbtest?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><div class = "note note-warning">这里的时区设置的是东八区</div><ol start="4"><li>写实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.*;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: mybatis-plus-demo1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Like</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-05-19 16:53</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>编写mapper</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt;</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 是的，你没有看错，就这么点</span><br></code></pre></td></tr></table></figure><ol start="6"><li>在springboot的启动类中添加扫描注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.mercury.mybatisplusdemo1.mapper&quot;)</span> <span class="hljs-comment">//mapper层的地址</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusDemo1ApplicationTests</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; users = userMapper.selectList(<span class="hljs-keyword">null</span>);<br>        users.forEach(System.out::println);<br>        <span class="hljs-comment">//comsumer?</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>输出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">User(id=<span class="hljs-number">1</span>, name=Jone, age=<span class="hljs-number">18</span>, email=test1<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">2</span>, name=Jack, age=<span class="hljs-number">20</span>, email=test2<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">3</span>, name=Tom, age=<span class="hljs-number">28</span>, email=test3<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">4</span>, name=Sandy, age=<span class="hljs-number">21</span>, email=test4<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">5</span>, name=Billie, age=<span class="hljs-number">24</span>, email=test5<span class="hljs-meta">@baomidou</span>.com)<br></code></pre></td></tr></table></figure><p>这里配置一下日志信息方便查看</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#配置日志<br>mybatis-plus<span class="hljs-selector-class">.configuration</span>.log-impl=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.stdout</span>.StdOutImpl<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Creating a <span class="hljs-keyword">new</span> SqlSession<br>SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4b65d9f4] was not registered <span class="hljs-keyword">for</span> synchronization because synchronization is not active<br>JDBC Connection [HikariProxyConnection@<span class="hljs-number">1702089463</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@4052c8c2] will not be managed by Spring<br>==&gt; Preparing: SELECT id,name,age,email FROM user   <span class="hljs-comment">//可以看到自动生成的sql</span><br>==&gt; Parameters: <br>&lt;== Columns: id, name, age, email<br>&lt;==  Row: <span class="hljs-number">1</span>, Jone, <span class="hljs-number">18</span>, test1<span class="hljs-meta">@baomidou</span>.com<br>&lt;==  Row: <span class="hljs-number">2</span>, Jack, <span class="hljs-number">20</span>, test2<span class="hljs-meta">@baomidou</span>.com<br>&lt;==  Row: <span class="hljs-number">3</span>, Tom, <span class="hljs-number">28</span>, test3<span class="hljs-meta">@baomidou</span>.com<br>&lt;==  Row: <span class="hljs-number">4</span>, Sandy, <span class="hljs-number">21</span>, test4<span class="hljs-meta">@baomidou</span>.com<br>&lt;==  Row: <span class="hljs-number">5</span>, Billie, <span class="hljs-number">24</span>, test5<span class="hljs-meta">@baomidou</span>.com<br>&lt;==  Total: <span class="hljs-number">5</span>    <br>Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4b65d9f4]<br>User(id=<span class="hljs-number">1</span>, name=Jone, age=<span class="hljs-number">18</span>, email=test1<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">2</span>, name=Jack, age=<span class="hljs-number">20</span>, email=test2<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">3</span>, name=Tom, age=<span class="hljs-number">28</span>, email=test3<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">4</span>, name=Sandy, age=<span class="hljs-number">21</span>, email=test4<span class="hljs-meta">@baomidou</span>.com)<br>User(id=<span class="hljs-number">5</span>, name=Billie, age=<span class="hljs-number">24</span>, email=test5<span class="hljs-meta">@baomidou</span>.com)<br><span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">19</span> <span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">55.314</span> INFO <span class="hljs-number">23644</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource  : HikariPool-<span class="hljs-number">1</span> - Shutdown initiated...<br><span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">19</span> <span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">55.324</span> INFO <span class="hljs-number">23644</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource  : HikariPool-<span class="hljs-number">1</span> - Shutdown completed.<br></code></pre></td></tr></table></figure><h1>3. 主键生成策略</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试插入</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setName(<span class="hljs-string">&quot;mercury02&quot;</span>);<br>    user.setAge(<span class="hljs-number">3</span>);<br>    user.setEmail(<span class="hljs-string">&quot;william@163.com&quot;</span>);<br>    <span class="hljs-keyword">int</span> insert = userMapper.insert(user);<span class="hljs-comment">//自动生成id</span><br>    System.out.println(insert);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><p>插入结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">==&gt; Preparing: <span class="hljs-function">INSERT INTO <span class="hljs-title">user</span> <span class="hljs-params">( id, name, age, email )</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">( ?, ?, ?, ? )</span> </span><br><span class="hljs-function"></span>==&gt; Parameters: <span class="hljs-number">1527226339787800577</span>(Long), mercury(String), <span class="hljs-number">3</span>(Integer), chenning_william@<span class="hljs-number">163.</span>com(String)<br>&lt;== Updates: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这里<strong>默认</strong>使用的是分布式系统唯一id生成 <span class = "label label-danger"> 雪花算法(SnowFlake)</span></p><p>雪花算法的由来：</p><ul><li>Twitter使用scala语言开源了一种分布式 id 生成算法——SnowFlake算法，被翻译成了雪花算法。</li><li>因为自然界中并不存在两片完全一样的雪花的，每一片雪花都拥有自己漂亮独特的形状、独一无二。雪花算法也表示生成的ID如雪花般独一无二。</li></ul><h3 id="3-1-主键自增">3.1 主键自增</h3><p>配置主键自增</p><p>实体类的字段上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class = "label label-danger">同时数据库里面也要设置为主键自增</span></p><p>can can 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IdType</span> </span>&#123;<br>    AUTO(<span class="hljs-number">0</span>),       <span class="hljs-comment">//数据库id自增</span><br>    NONE(<span class="hljs-number">1</span>),       <span class="hljs-comment">//未设置主键</span><br>    INPUT(<span class="hljs-number">2</span>),      <span class="hljs-comment">//手动输入</span><br>    ID_WORKER(<span class="hljs-number">3</span>),  <span class="hljs-comment">//默认的全局唯一id（雪花</span><br>    UUID(<span class="hljs-number">4</span>),       <span class="hljs-comment">//全局唯一id</span><br>    ID_WORKER_STR(<span class="hljs-number">5</span>);<span class="hljs-comment">//ID_WORKER 的字符串表示法</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IdType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>4. 更新操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setId(<span class="hljs-number">5l</span>);<br>    user.setName(<span class="hljs-string">&quot;william&quot;</span>);<br>    userMapper.updateById(user);  <span class="hljs-comment">//注意里面的参数是一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">==&gt; Preparing: UPDATE user SET name=? WHERE id=? <br>==&gt; Parameters: william(String), <span class="hljs-number">5</span>(Long)<br>&lt;== Updates: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1>5. 自动填充</h1><p>创建时间，修改时间，这些操作都是自动化完成的</p><p>在国际标准中所有的数据库表gmt_create  gmt_modified几乎所有的表都要配置上，而且需要自动化</p><h2 id="5-1-数据库级别的修改">5.1 数据库级别的修改</h2><p>增加create_time update_time字段</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220521133004843.png" alt=""></p><p>可以看到默认的时间</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220521133024647.png" alt=""></p><h2 id="5-2-代码级别的修改">5.2 代码级别的修改</h2><p>首先还原数据库的设置，将默认CURRENT_TIMESTAMP和更新取消掉</p><ol><li>实体类字段属性上添加注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> Date createTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> Date updateTime;<br></code></pre></td></tr></table></figure><ol start="2"><li>编写handler</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;start insert fill ...&quot;</span>);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;createTime&quot;</span>,<span class="hljs-keyword">new</span> Date() ,metaObject);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);   <span class="hljs-comment">//第一次填充的时候两个时间都填充上</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;start update fill ...&quot;</span>);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);   <span class="hljs-comment">//后面更新的时候就只需要填充update这个时间就行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>6. 乐观锁配置</h1><p>乐观锁：总认为不会出现问题，无论干什么都不会去上锁，如果出现了问题，再次更新值测试</p><p>悲观锁：它总认为总是出现问题，无论干什么都会去上锁，然后去操作</p><p>什么时候需要乐观锁呢？当要更新一条记录的时候，希望这条记录没有被别人更新</p><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion（整数类型下 newVersion = oldVersion + 1）</li><li>如果version不对，就更新失败</li></ul><ol><li>数据库里增加version字段 (默认初版为1)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220522130711039.png" alt="image-20220522130711039"></p><ol start="2"><li>实体类中增加</li></ol><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">@Version</span><span class="hljs-comment">//乐观锁的注解</span><br><span class="hljs-keyword">private</span> Integer <span class="hljs-keyword">version</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>注册组件</li></ol><p>写个config来统一配置，新版的注册组件有所不同，详情看官方的配置文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.mercury.mybatisplusdemo1.mapper&quot;)</span> <span class="hljs-comment">//可以把扫描mapper层的组件搬到这里</span><br><span class="hljs-meta">@EnableTransactionManagement</span>   <span class="hljs-comment">//处理事务的注解</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//乐观锁插件</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOptimisticLocker</span><span class="hljs-params">()</span></span>&#123;<br><br>    User user1 = userMapper.selectById(<span class="hljs-number">1l</span>);<br>    user1.setName(<span class="hljs-string">&quot;mercury&quot;</span>);<br>    user1.setEmail(<span class="hljs-string">&quot;mercury@163.com&quot;</span>);<br><br>    <span class="hljs-comment">//模拟还没完成修改的时候，突然来了个线程插队，提前完成了修改</span><br>    User user2 = userMapper.selectById(<span class="hljs-number">1l</span>);<br>    user2.setName(<span class="hljs-string">&quot;william&quot;</span>);<br>    user2.setEmail(<span class="hljs-string">&quot;william@163.com&quot;</span>);<br>    userMapper.updateById(user2);<br><br><br>    userMapper.updateById(user1);<span class="hljs-comment">//version不对导致写入失败，如果没有乐观锁就会导致覆盖</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h1>7. 查询操作</h1><h2 id="7-1-单个和多个查询">7.1 单个和多个查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-comment">//查询单个</span><br>       User user = userMapper.selectById(<span class="hljs-number">1l</span>);<br>       System.out.println(user);<br><br>       <span class="hljs-comment">//查询多个</span><br>       List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>       users.forEach(System.out::println);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-条件查询">7.2 条件查询</h2><p>使用map实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectBycondition</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-comment">//根据条件进行查询</span><br><br>       HashMap&lt;String, Object&gt; Map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//自定义条件查询</span><br>       Map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;william&quot;</span>);<br>       Map.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>);<br>       <span class="hljs-comment">//查询名字为william并且年龄为18的数据</span><br>       List&lt;User&gt; users = userMapper.selectByMap(Map);<br>       users.forEach(System.out::println);<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">==&gt;  Preparing: SELECT id,name,age,email,version,deleted,create_time,update_time FROM user WHERE name = ? AND age = ?<br>==&gt; Parameters: william(String), <span class="hljs-number">18</span>(Integer)<br>&lt;==    Columns: id, name, age, email, version, deleted, create_time, update_time<br>&lt;==        Row: <span class="hljs-number">5</span>, william, <span class="hljs-number">18</span>, test5<span class="hljs-meta">@baomidou</span>.com, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">21</span> <span class="hljs-number">13</span>:<span class="hljs-number">15</span>:<span class="hljs-number">42</span>, <span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">22</span> <span class="hljs-number">13</span>:<span class="hljs-number">00</span>:<span class="hljs-number">53</span><br>&lt;==      Total: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="7-3-分页查询">7.3 分页查询</h2><p>分页查询的几种实现方式</p><ul><li><p>原始的limit进行分页</p></li><li><p>pageHelper第三方插件</p></li><li><p>MP分页</p></li></ul><ol><li>配置分页查询的组件(配置在config里)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页插件</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>    PaginationInterceptor paginationInterceptor = <span class="hljs-keyword">new</span> PaginationInterceptor();<br>    <span class="hljs-comment">// 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span><br>    <span class="hljs-comment">// paginationInterceptor.setOverflow(false);</span><br>    <span class="hljs-comment">// 设置最大单页限制数量，默认 500 条，-1 不受限制</span><br>    <span class="hljs-comment">// paginationInterceptor.setLimit(500);</span><br>    <span class="hljs-comment">// 开启 count 的 join 优化,只针对部分 left join</span><br>   <span class="hljs-comment">// paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));</span><br>    <span class="hljs-keyword">return</span> paginationInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>然后直接使用page对象即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testpage</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//分页查询</span><br>    <span class="hljs-comment">//当前页，显示的数据数量</span><br>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);   <span class="hljs-comment">//第二页的数据，每页5个</span><br>    userMapper.selectPage(page,<span class="hljs-keyword">null</span>);<br><br>    page.getRecords().forEach(System.out::println);<br>    System.out.println(page.getTotal());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">==&gt;  Preparing: <span class="hljs-function">SELECT <span class="hljs-title">COUNT</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> FROM user </span><br><span class="hljs-function"></span>==&gt; Parameters: <br>&lt;==    Columns: COUNT(<span class="hljs-number">1</span>)<br>&lt;==        Row: <span class="hljs-number">7</span>        <span class="hljs-comment">//一共7条数据</span><br>==&gt;  Preparing: SELECT id,name,age,email,version,create_time,update_time FROM user WHERE  LIMIT <span class="hljs-number">5</span>,<span class="hljs-number">5</span> <br>==&gt; Parameters: <br>&lt;==    Columns: id, name, age, email, version, create_time, update_time<br>&lt;==        Row: <span class="hljs-number">1527903812435374084</span>, mercury03, <span class="hljs-number">3</span>, william@<span class="hljs-number">163.</span>com, <span class="hljs-number">1</span>, <span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">22</span> <span class="hljs-number">13</span>:<span class="hljs-number">27</span>:<span class="hljs-number">46</span>, <span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">22</span> <span class="hljs-number">13</span>:<span class="hljs-number">27</span>:<span class="hljs-number">46</span><br>&lt;==        Row: <span class="hljs-number">1527903812435374085</span>, mercury04, <span class="hljs-number">3</span>, mercury@<span class="hljs-number">163.</span>com, <span class="hljs-number">1</span>, <span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">22</span> <span class="hljs-number">13</span>:<span class="hljs-number">28</span>:<span class="hljs-number">11</span>, <span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">22</span> <span class="hljs-number">13</span>:<span class="hljs-number">28</span>:<span class="hljs-number">11</span><br>&lt;==      Total: <span class="hljs-number">2</span>        <span class="hljs-comment">//第二页两条数据</span><br></code></pre></td></tr></table></figure><h1>8. 删除操作</h1><h2 id="8-1-单个和批量以及条件删除">8.1 单个和批量以及条件删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdelete</span><span class="hljs-params">()</span></span>&#123;<br>        userMapper.deleteById(<span class="hljs-number">1l</span>);<br>        <span class="hljs-comment">//userMapper.deleteBatchIds();  批量删除</span><br>        <span class="hljs-comment">//userMapper.deleteByMap();     条件删除</span><br>    &#125;<br><br><span class="hljs-comment">//和上面的查询是一样的</span><br></code></pre></td></tr></table></figure><h2 id="8-2-逻辑删除">8.2 逻辑删除</h2><ul><li><p>物理删除  从数据库中直接移除</p></li><li><p>逻辑删除 在数据库中没有被删除，而是通过一个变量来让他失效(类似于回收站</p></li></ul><ol><li>数据库增加deleted字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220522143025600.png" alt="image-20220522143025600"></p><ol start="2"><li>实体类中增加注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span><br><span class="hljs-keyword">private</span> Integer deleted;<br></code></pre></td></tr></table></figure><ol start="3"><li>增加配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ISqlInjector <span class="hljs-title">sqlInjector</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogicSqlInjector();<br>&#125;<br><span class="hljs-comment">//高版本的已经不需要配置这个，具体请参考官方的配置文件</span><br></code></pre></td></tr></table></figure><ol start="4"><li>application配置</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus.global-config.db-config.logic-delete-value</span>= <span class="hljs-string">1 </span><br><span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br><span class="hljs-meta">mybatis-plus.global-config.db-config.logic-not-delete-value</span>= <span class="hljs-string">0 </span><br><span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><ol start="5"><li>测试，运行删除id为1的数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">==&gt; Preparing: UPDATE user SET deleted=<span class="hljs-number">1</span> WHERE id=? AND deleted=<span class="hljs-number">0</span> <span class="hljs-comment">// 可以看出这里虽然是删除，但其实走的是更新</span><br>==&gt; Parameters: <span class="hljs-number">1</span>(Long)<br>&lt;== Updates: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>那既然没有实际的删除，那么查询的时候可以查询出来吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询的时候会自动过滤被删的数据</span><br>==&gt; Preparing: SELECT id,name,age,email,version,deleted,create_time,update_time FROM user WHERE id=? AND deleted=<span class="hljs-number">0</span>   <span class="hljs-comment">//注意这个sql </span><br>==&gt; Parameters: <span class="hljs-number">1</span>(Long)<br>&lt;==  Total: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1>9. 性能分析插件</h1><p>我们在平时的开发中会遇到一些慢sql ，MP也提供性能分析插件，如果超过这个时间就会停止，狂神视频所讲的插件已经移除，官网现在推荐使用p6spy，具体的配置参考官方文档</p><h1>10. 条件构造器</h1><p>前面的所讲的都是一些简单查询，那么我们想实现相对较复杂的查询的时候那么该怎么操作呢，这个时候我们就可以使用mp提供的条件构造器了</p><p>下面六个示例基本够用了，如果不够，依然那句话，去查看官方文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">contextLoadstest1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用条件构造</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>    <span class="hljs-comment">//名字和邮箱不为空且年龄大于12的数据</span><br>    wrapper<br>            .isNotNull(<span class="hljs-string">&quot;name&quot;</span>)<br>            .isNotNull(<span class="hljs-string">&quot;email&quot;</span>)<br>            .ge(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">12</span>);<br>    userMapper.selectList(wrapper).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">contextLoadstest2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用条件构造</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>    <span class="hljs-comment">//查询等于的</span><br>    wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;william&quot;</span>);<br>    System.out.println(userMapper.selectOne(wrapper));<span class="hljs-comment">//查询一个唯一数据时用，不然会报错</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">contextLoadstest3</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用条件构造</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>    <span class="hljs-comment">//查询年龄在20到30之间的</span><br>    wrapper.between(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>);<br>    System.out.println(userMapper.selectCount(wrapper));<span class="hljs-comment">//统计结果数</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">contextLoadstest4</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用条件构造</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>    <span class="hljs-comment">//模糊查询</span><br>    wrapper.notLike(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>)<br>           .likeRight(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>);<span class="hljs-comment">//t%  这里的left和right指的是%的位置</span><br>    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);<br>    maps.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">contextLoadstest5</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用条件构造</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br><br>    <span class="hljs-comment">//子查询</span><br>    wrapper.inSql(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;select id  from user where id &lt;3&quot;</span>);<br>    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);<br>    objects.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">contextLoadstest6</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用条件构造</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br><br>    <span class="hljs-comment">//根据id降序</span><br>    wrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>);<br><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h1>11. 代码生成器</h1><p>这里是旧版的生成器，3.5.1+版本的生成器和旧版的生成器有很大的不同，并且不兼容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代码自动生成器，写在test里</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//我们需要构建一个代码生成器对象</span><br>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<br>        <span class="hljs-comment">//怎么样去执行，配置策略</span><br>        <span class="hljs-comment">//1、全局配置</span><br>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();  <span class="hljs-comment">//注意这里导包的时候注意要导generator下面的那个，不然后面的点不出来</span><br>        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<span class="hljs-comment">//获取当前目录</span><br>        gc.setOutputDir(projectPath+<span class="hljs-string">&quot;/src/main/java&quot;</span>);<span class="hljs-comment">//输出到哪个目录</span><br>        gc.setAuthor(<span class="hljs-string">&quot;mercury&quot;</span>);<br>        gc.setOpen(<span class="hljs-keyword">false</span>);<br>        gc.setFileOverride(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//是否覆盖</span><br>        gc.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>);<span class="hljs-comment">//去Service的I前缀</span><br>        gc.setIdType(IdType.ID_WORKER);<br>        gc.setDateType(DateType.ONLY_DATE);<br>        gc.setSwagger2(<span class="hljs-keyword">true</span>);<br>        mpg.setGlobalConfig(gc);<br>        <br>        <span class="hljs-comment">//2、设置数据源</span><br>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();<br>        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsc.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/db?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;</span>);<br>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        dsc.setDbType(DbType.MYSQL);<br>        mpg.setDataSource(dsc);<br>        <br>        <br>        <span class="hljs-comment">//3、包的配置</span><br>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();<br>        pc.setModuleName(<span class="hljs-string">&quot;study&quot;</span>);<br>        pc.setParent(<span class="hljs-string">&quot;com.wsk&quot;</span>);<br>        pc.setEntity(<span class="hljs-string">&quot;pojo&quot;</span>);<br>        pc.setMapper(<span class="hljs-string">&quot;mapper&quot;</span>);<br>        pc.setService(<span class="hljs-string">&quot;service&quot;</span>);<br>        pc.setController(<span class="hljs-string">&quot;controller&quot;</span>);<br>        mpg.setPackageInfo(pc);<br>        <br>        <span class="hljs-comment">//4、策略配置</span><br>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();<br>        strategy.setInclude(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;danyuan&quot;</span>,<span class="hljs-string">&quot;building&quot;</span>,<span class="hljs-string">&quot;room&quot;</span>);<span class="hljs-comment">//设置要映射的表名,只需改这里即可</span><br>        strategy.setNaming(NamingStrategy.underline_to_camel);<br>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<br>        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//是否使用lombok开启注解</span><br>        strategy.setLogicDeleteFieldName(<span class="hljs-string">&quot;deleted&quot;</span>);<br>        <span class="hljs-comment">//自动填充配置</span><br>        TableFill gmtCreate = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);<br>        TableFill gmtUpdate = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">&quot;gmt_update&quot;</span>, FieldFill.INSERT_UPDATE);<br>        ArrayList&lt;TableFill&gt; tableFills = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        tableFills.add(gmtCreate);<br>        tableFills.add(gmtUpdate);<br>        strategy.setTableFillList(tableFills);<br>        <span class="hljs-comment">//乐观锁配置</span><br>        strategy.setVersionFieldName(<span class="hljs-string">&quot;version&quot;</span>);<br>        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启驼峰命名</span><br>        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//localhost:8080/hello_id_2</span><br>        mpg.setStrategy(strategy);<br>        mpg.execute();<span class="hljs-comment">//执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/04/24/Docker/"/>
    <url>/2022/04/24/Docker/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">     <div>前言：</div>     <ul>         <div>             根据狂神视频整理         </div>     <ul></div><h1>一. Docker概述</h1><h2 id="1-Docker简介">1. Docker简介</h2><p>现在有一个问题，我开发的程序在我的电脑上可以正常运行，版本更新或其他的一些操作可能会导致服务不可用，但是配置环境是十分痛苦的，相信这个大家都有体会😥，在服务器上面配置各种Redis, MySQL, jdk等极其的麻烦，而且还不能跨平台，因此docker诞生了，它给以上的问题给出了一个解决方案。</p><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p>下面是Docker的文档和仓库</p><p><a href="https://docs.docker.com/">文档</a></p><p><a href="https://hub.docker.com/">仓库</a></p><h2 id="2-Docker与虚拟机技术的比较">2. Docker与虚拟机技术的比较</h2><ul><li><p>传统的虚拟机，虚拟出一条硬件，运行出完整的操作系统，然后在这个系统上安装和运行我们的软件、</p></li><li><p>容器内的应用直接运行在宿主机，容器是没有自己的内核的，也没有虚拟的硬件，所以就会轻便许多</p></li><li><p>每个容器之间是互相隔离的，每个容器的内部有自己的文件系统，互不影响</p></li></ul><h1>二. Docker的安装</h1><ol><li>卸载旧版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove docker \<br></code></pre></td></tr></table></figure><ol start="2"><li>安装需要的安装包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils<br></code></pre></td></tr></table></figure><ol start="3"><li>设置镜像仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  <br></code></pre></td></tr></table></figure><p>这里使用的是阿里云的镜像</p><ol start="4"><li>这里最好再更新一下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum makecache fast<br></code></pre></td></tr></table></figure><ol start="5"><li>开始安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>安装docker相关的</p><p>-ce社区</p><p>-ee 企业版</p><ol start="6"><li>启动docker</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure><ol start="7"><li>查看是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Mercury /]<span class="hljs-comment"># docker version</span><br><br>Client: Docker Engine - Community<br><br> Version:   20.10.14<br><br> API version:  1.41<br><br> Go version:  go1.16.15<br><br> Git commit:  a224086<br><br> Built:    Thu Mar 24 01:49:57 2022<br><br> OS/Arch:   linux/amd64<br><br> Context:   default<br><br> Experimental:  <span class="hljs-literal">true</span><br><br><br><br>Server: Docker Engine - Community<br><br> Engine:<br><br> Version:   20.10.14<br><br> API version:  1.41 (minimum version 1.12)<br><br> Go version:  go1.16.15<br><br> Git commit:  87a90dc<br><br> Built:   Thu Mar 24 01:48:24 2022<br><br> OS/Arch:   linux/amd64<br><br> Experimental:  <span class="hljs-literal">false</span><br><br> containerd:<br><br> Version:   1.5.11<br><br> GitCommit:  3df54a852345ae127d1fa3092b95168e4a88e2f8<br><br> runc:<br><br> Version:   1.0.3<br><br> GitCommit:  v1.0.3-0-gf46b6ba<br><br> docker-init:<br><br> Version:   0.19.0<br><br> GitCommit:  de40ad0<br></code></pre></td></tr></table></figure><p>可以打印出以上信息，说明成功了</p><ol start="8"><li>测试是否可以正常运行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Mercury /]<span class="hljs-comment"># docker run hello-world</span><br><br>Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br><br>latest: Pulling from library/hello-world<br><br>2db29710123e: Pull complete <br><br>Digest: sha256:10d7d58d5ebd2a652f4d93fdd86da8f265f5318c6a73cc5b6a9798ff6d2b2e67<br><br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br><br><br>Hello from Docker!<br><br>This message shows that your installation appears to be working correctly.<br><br><br><br>To generate this message, Docker took the following steps:<br><br> 1. The Docker client contacted the Docker daemon.<br><br> 2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub.<br><br> (amd64)<br><br> 3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br><br> executable that produces the output you are currently reading.<br><br> 4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br><br> to your terminal.<br><br><br><br>To try something more ambitious, you can run an Ubuntu container with:<br><br> $ docker run -it ubuntu bash<br><br><br><br>Share images, automate workflows, and more with a free Docker ID:<br><br> https://hub.docker.com/<br><br><br><br>For more examples and ideas, visit:<br><br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><ol start="9"><li>查看镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Mercury /]<span class="hljs-comment"># docker images</span><br><br>REPOSITORY TAG  IMAGE ID  CREATED  SIZE<br><br>hello-world latest feb5d9fea6a5 7 months ago 13.3kB<br></code></pre></td></tr></table></figure><div class = "note note-info">卸载</div><p>首先卸载 Docker 引擎、CLI 和 Containerd 软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rm -rf /var/lib/docker<br>$ sudo rm -rf /var/lib/containerd<br></code></pre></td></tr></table></figure><h2 id="1-配置阿里云镜像加速器">1. 配置阿里云镜像加速器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkdir -p /etc/docker<br><br>sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br><br>&#123;<br><br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://阿里云给你的镜像加速地址.mirror.aliyuncs.com&quot;</span>]<br><br>&#125;<br>EOF<br><br><br>sudo systemctl daemon-reload<br><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h1>三. Docker常用的一些命令</h1><div class = "note note-success">一些基本的命令</div><p>docker version  查看docker 版本信息</p><p>docker info  查看docker的系统信息，包括镜像和容器的数量</p><p>docker --help  查看帮助文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker images --help                                             # 查看image的帮助<br><br>Usage: docker images [OPTIONS] [REPOSITORY[:TAG]]<br><br>List images<br><br>Options:<br><br> -a, --all    Show all images (default hides intermediate images)                  # 可以添加的参数以及对应的解释<br><br>  --digests   Show digests<br><br> -f, --filter filter Filter output based on conditions provided<br><br>  --format string Pretty-print images using a Go template<br><br>  --no-trunc  Don&#x27;t truncate output<br><br> -q, --quiet   Only show image IDs<br></code></pre></td></tr></table></figure><h2 id="1-镜像命令">1. 镜像命令</h2><h3 id="1-1-查看镜像">1.1 查看镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker images                                                    # 查看所有的镜像<br><br>REPOSITORY   TAG    IMAGE ID       CREATED       SIZE<br><br>hello-world  latest feb5d9fea6a5   7 months ago  13.3kB<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 释义</span><br>REPOSITOPY 镜像的仓库<br>TAG        镜像的标签<br>TMAGE      镜像的ID<br>CREATED    镜像的创建时间<br>SIZE       镜像的大小<br></code></pre></td></tr></table></figure><h3 id="1-2-搜索镜像">1.2 搜索镜像</h3><p>docker search</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker search mysql<br>NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql                          MySQL is a widely used, open-source relation…   12527     [OK]       <br>mariadb                        MariaDB Server is a high performing open sou…   4819      [OK]       <br>percona                        Percona Server is a fork of the MySQL relati…   575       [OK]       <br>phpmyadmin                     phpMyAdmin - A web interface for MySQL and M…   527       [OK]       <br>bitnami/mysql                  Bitnami MySQL Docker Image                      70                   [OK]<br>linuxserver/mysql-workbench                                                    36                   <br>linuxserver/mysql              A Mysql container, brought to you by LinuxSe…   35                   <br>ubuntu/mysql                   MySQL open source fast, stable, multi-thread…   31                   <br>circleci/mysql                 MySQL is a widely used, open-source relation…   25                   <br>google/mysql                   MySQL server for Google Compute Engine          21                   [OK]<br>vmware/harbor-db               Mysql container for Harbor                      10                   <br>bitnami/mysqld-exporter                                                        3                    <br>ibmcom/mysql-s390x             Docker image for mysql-s390x                    2                    <br>newrelic/mysql-plugin          New Relic Plugin for monitoring MySQL databa…   1                    [OK]<br>vitess/mysqlctld               vitess/mysqlctld                                1                    [OK]<br>nasqueron/mysql                                                                1                    [OK]<br>cimg/mysql                                                                     0                    <br>silintl/mysql-backup-restore   Simple docker image to perform mysql backups…   0                    [OK]<br>drud/mysql-local-57            ddev mysql local container                      0                    <br>drud/mysql                                                                     0                    <br>drud/mysql-docker-local-57     This repo has been deprecated, new tags are …   0                    <br>drud/mysql-docker-local        docker containers for local womysql rk          0                    [OK]<br>docksal/mysql                  MySQL service images for Docksal - https://d…   0                    <br>mirantis/mysql                                                                 0                    <br>drud/mysqld-exporter<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 可选项 通过搜索来过滤</span><br>--filter=STARS=3000  #搜索星星的数量大于3000的<br>[root@Mercury ~]# docker search mysql --filter=STARS=3000<br>NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source relation…   12527     [OK]       <br>mariadb   MariaDB Server is a high performing open sou…   4819      [OK]<br></code></pre></td></tr></table></figure><h3 id="1-3-下载镜像">1.3 下载镜像</h3><p>docker pull 镜像名[:tag]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker pull mysql<br><br>Using default tag: latest                            #如果不指定的话，默认给你下载最新的<br><br>latest: Pulling from library/mysql<br><br>72a69066d2fe: Pull complete                          # 这里是分层下载，等会再讲<br><br>93619dbc5b36: Pull complete <br><br>99da31dd6142: Pull complete <br><br>626033c43d70: Pull complete <br><br>37d5d7efb64e: Pull complete <br><br>ac563158d721: Pull complete <br><br>d2ba16033dad: Pull complete <br><br>688ba7d5c01a: Pull complete <br><br>00e060b6d11d: Pull complete <br><br>1c04857f594f: Pull complete <br><br>4d7cfa90e6ea: Pull complete <br><br>e0431212d27d: Pull complete <br><br>Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709      # 签名<br><br>Status: Downloaded newer image for mysql:latest<br><br>docker.io/library/mysql:latest     #真实的地址<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 这两个是等价的</span><br>docker pull mysql<br>docker pull docker.io/library/mysql:latest<br></code></pre></td></tr></table></figure><p>指定版本下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker pull mysql:5.7             # 指定5.7版本的下载<br><br>5.7: Pulling from library/mysql<br><br>72a69066d2fe: Already exists                        # 可以看到这里不用再下载，这就是分层下载的优势，可以复用，大大减少内存等的压力<br><br>93619dbc5b36: Already exists <br><br>99da31dd6142: Already exists <br><br>626033c43d70: Already exists <br><br>37d5d7efb64e: Already exists <br><br>ac563158d721: Already exists <br><br>d2ba16033dad: Already exists <br><br>0ceb82207cd7: Pull complete <br><br>37f2405cae96: Pull complete <br><br>e2482e017e53: Pull complete <br><br>70deed891d42: Pull complete <br><br>Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br><br>Status: Downloaded newer image for mysql:5.7<br><br>docker.io/library/mysql:5.7<br><br><br>[root@Mercury ~]# docker images<br><br>REPOSITORY     TAG      IMAGE ID       CREATED         SIZE<br><br>mysql          5.7      c20987f18b13   4 months ago    448MB<br><br>mysql          latest   3218b38490ce   4 months ago    516MB<br><br>hello-world    latest   feb5d9fea6a5   7 months ago    13.3kB<br></code></pre></td></tr></table></figure><h3 id="1-4-删除镜像">1.4 删除镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker rmi -f c20987f18b13       # 删除 通过id 或者名字都行<br><br>Untagged: mysql:5.7<br><br>Untagged: mysql@sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br><br>Deleted: sha256:c20987f18b130f9d144c9828df630417e2a9523148930dc3963e9d0dab302a76<br><br>Deleted: sha256:6567396b065ee734fb2dbb80c8923324a778426dfd01969f091f1ab2d52c7989<br><br>Deleted: sha256:0910f12649d514b471f1583a16f672ab67e3d29d9833a15dc2df50dd5536e40f<br><br>Deleted: sha256:6682af2fb40555c448b84711c7302d0f86fc716bbe9c7dc7dbd739ef9d757150<br><br>Deleted: sha256:5c062c3ac20f576d24454e74781511a5f96739f289edaadf2de934d06e910b92<br><br>[root@Mercury ~]# docker images<br><br>REPOSITORY    TAG     IMAGE ID      CREATED        SIZE<br><br>mysql         latest  3218b38490ce  4 months ago   516MB<br><br>hello-world   latest  feb5d9fea6a5  7 months ago   13.3kB<br></code></pre></td></tr></table></figure><p>全部删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker rmi -f $(docker images -aq)   # 里面的那句话是查询全部的dockerid<br><br>Untagged: mysql:latest<br><br>Untagged: mysql@sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709<br><br>Deleted: sha256:3218b38490cec8d31976a40b92e09d61377359eab878db49f025e5d464367f3b<br><br>Deleted: sha256:aa81ca46575069829fe1b3c654d9e8feb43b4373932159fe2cad1ac13524a2f5<br><br>Deleted: sha256:0558823b9fbe967ea6d7174999be3cc9250b3423036370dc1a6888168cbd224d<br><br>Deleted: sha256:a46013db1d31231a0e1bac7eeda5ad4786dea0b1773927b45f92ea352a6d7ff9<br><br>Deleted: sha256:af161a47bb22852e9e3caf39f1dcd590b64bb8fae54315f9c2e7dc35b025e4e3<br><br>Deleted: sha256:feff1495e6982a7e91edc59b96ea74fd80e03674d92c7ec8a502b417268822ff<br><br>Deleted: sha256:8805862fcb6ef9deb32d4218e9e6377f35fb351a8be7abafdf1da358b2b287ba<br><br>Deleted: sha256:872d2f24c4c64a6795e86958fde075a273c35c82815f0a5025cce41edfef50c7<br><br>Deleted: sha256:6fdb3143b79e1be7181d32748dd9d4a845056dfe16ee4c827410e0edef5ad3da<br><br>Deleted: sha256:b0527c827c82a8f8f37f706fcb86c420819bb7d707a8de7b664b9ca491c96838<br><br>Deleted: sha256:75147f61f29796d6528486d8b1f9fb5d122709ea35620f8ffcea0e0ad2ab0cd0<br><br>Deleted: sha256:2938c71ddf01643685879bf182b626f0a53b1356138ef73c40496182e84548aa<br><br>Deleted: sha256:ad6b69b549193f81b039a1d478bc896f6e460c77c1849a4374ab95f9a3d2cea2<br><br>Untagged: hello-world:latest<br><br>Untagged: hello-world@sha256:10d7d58d5ebd2a652f4d93fdd86da8f265f5318c6a73cc5b6a9798ff6d2b2e67<br><br>Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412<br><br>[root@Mercury ~]# docker images<br>REPOSITORY  TAG    IMAGE ID  CREATED  SIZE                         # 可以看到已经没有镜像了<br></code></pre></td></tr></table></figure><h2 id="2-容器命令">2. 容器命令</h2><h3 id="2-1-启动和退出容器">2.1 启动和退出容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@Mercury ~]# docker images<br><br>REPOSITORY  TAG     IMAGE ID      CREATED       SIZE<br><br>centos      latest  5d0da3dc9764  7 months ago  231MB<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 启动并进入容器</span><br><br>[root@Mercury ~]# docker run -it centos /bin/bash<br><br>[root@2e2aa125d5c4 /]# ls                     # 可以看到root后面的主机号已经变了<br><br>bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var<br></code></pre></td></tr></table></figure><p>退出容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@2e2aa125d5c4 /]# exit                   # 这个是退出并关闭容器<br><br>exit<br><br><br>[root@2e2aa125d5c4 /]  [root@Mercury ~]       # 按住ctrl + p + q ,退出但是并不关闭<br><br></code></pre></td></tr></table></figure><h3 id="2-2-列出所有运行的容器">2.2 列出所有运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker ps   列出当前正在运行的命令</span><br><span class="hljs-meta">#</span><span class="bash">  -a         列出当前运行的容器+历史运行过的容器</span><br><span class="hljs-meta">#</span><span class="bash">  -n=?       显示最近创建过的容器</span><br><span class="hljs-meta">#</span><span class="bash">  -q         只显示容器的编号</span><br><br>[root@Mercury ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED        STATUS        PORTS     NAMES<br>3968ef35633d   centos    &quot;/bin/bash&quot;   25 hours ago   Up 25 hours             quirky_lewin<br><br>[root@Mercury ~]# docker ps -a<br>CONTAINER ID   IMAGE         COMMAND       CREATED        STATUS                   PORTS     NAMES<br>3968ef35633d   centos        &quot;/bin/bash&quot;   25 hours ago   Up 25 hours                        quirky_lewin<br>2e2aa125d5c4   centos        &quot;/bin/bash&quot;   2 days ago     Exited (0) 2 days ago              nervous_golick<br>62c5b7704890   hello-world   &quot;/hello&quot;      2 weeks ago    Exited (0) 2 weeks ago             serene_bohr<br><br>[root@Mercury ~]# docker ps -aq<br>3968ef35633d<br>2e2aa125d5c4<br>62c5b7704890<br><br></code></pre></td></tr></table></figure><h3 id="2-3-删除容器">2.3 删除容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器id                  #删除指定的容器 不能删除正在运行容器<br><br>docker rm -f $(docker ps -aq)    #删除所有的容器<br><br>docker ps -a -q|xargs docker rm  #删除所有的容器<br></code></pre></td></tr></table></figure><h3 id="2-4-启动和停止容器的操作">2.4 启动和停止容器的操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器id               # 启动容器<br>docker restart 容器id             # 重启容器<br>docker stop 容器id                # 停止容器<br>docker kill 容器id                # 强制停止当前的容器<br></code></pre></td></tr></table></figure><div note note-warning>区别</div><p>docker run 后面指定的是一个镜像，而docker start指定的是一个容器，docker run是利用镜像生成容器，并启动容器，而docker start是启动一个之前生成过的容器</p><h2 id="3-常用的其他命令">3. 常用的其他命令</h2><h3 id="3-1-后台启动容器">3.1 后台启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span><br>[root@Mercury /]# docker run -d centos <br><span class="hljs-meta">#</span><span class="bash"> 这里有个坑</span><br><span class="hljs-meta">#</span><span class="bash"> 容器使用后台运行，就必须要一个后台进程，docker发现没有应用，就会自动停止</span><br></code></pre></td></tr></table></figure><div note note-warning> docker run -it centos /bin/bash 后面的 bin/bash的作用</div><p>首先，docker run -it centos 的意思是，为centos这个镜像创建一个容器， -i和-t这两个参数的作用是，为该docker创建一个伪终端，这样就可以进入到容器的交互模式？（也就是直接进入到容器里面）后面的/bin/bash的作用是表示载入容器后运行bash ,docker中必须要保持一个进程的运行，要不然整个容器启动后就会马上kill itself，这样当你使用docker ps 查看启动的容器时，就会发现你刚刚创建的那个容器并不在已启动的容器队列中。这个/bin/bash就表示启动容器后启动bash，但是有些镜像不适合bash shell风格，会报错。</p><h3 id="3-2-查看日志">3.2 查看日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs -f -t --tail 容器id<br><br>-tf              # 显示日志<br>--tail number    # 要显示的日志数<br><br>docker logs -f -t --tail 10 dce7b86172bf     # 显示十条日志<br></code></pre></td></tr></table></figure><h3 id="3-3-查看进程信息">3.3 查看进程信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令docker top 容器id</span><br>[root@Mercury ~]# docker top 3968ef35633d<br>UID       PID           PPID             C              STIME               TTY             TIME          CMD           <br>root      10899         10880            0              May07               pts/0           00:00:00      /bin/bash<br></code></pre></td></tr></table></figure><h3 id="3-4-查看镜像的元数据">3.4 查看镜像的元数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker inspect 容器id</span><br>[root@Mercury ~]# docker inspect 3968ef35633d<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;3968ef35633d72bcb0a27b4a29d24f640e02306f196f392cd0d54967a67c11ee&quot;,<br>        &quot;Created&quot;: &quot;2022-05-07T08:18:55.224515441Z&quot;,<br>        &quot;Path&quot;: &quot;/bin/bash&quot;,<br>        &quot;Args&quot;: [],<br>        &quot;State&quot;: &#123;<br>            &quot;Status&quot;: &quot;running&quot;,<br>            &quot;Running&quot;: true,<br>            &quot;Paused&quot;: false,<br>            &quot;Restarting&quot;: false,<br>            &quot;OOMKilled&quot;: false,<br>            &quot;Dead&quot;: false,<br>            &quot;Pid&quot;: 10899,<br>            &quot;ExitCode&quot;: 0,<br>            &quot;Error&quot;: &quot;&quot;,<br>            &quot;StartedAt&quot;: &quot;2022-05-07T08:18:55.866857542Z&quot;,<br>            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;<br>        &#125;,<br>        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,<br>        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/3968ef35633d72bcb0a27b4a29d24f640e02306f196f392cd0d54967a67c11ee/resolv.conf&quot;,<br>        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/3968ef35633d72bcb0a27b4a29d24f640e02306f196f392cd0d54967a67c11ee/hostname&quot;,<br>        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/3968ef35633d72bcb0a27b4a29d24f640e02306f196f392cd0d54967a67c11ee/hosts&quot;,<br>        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/3968ef35633d72bcb0a27b4a29d24f640e02306f196f392cd0d54967a67c11ee/3968ef35633d72bcb0a27b4a29d24f640e02306f196f392cd0d54967a67c11ee-json.log&quot;,<br>        &quot;Name&quot;: &quot;/quirky_lewin&quot;,<br>        &quot;RestartCount&quot;: 0,<br>        &quot;Driver&quot;: &quot;overlay2&quot;,<br>        &quot;Platform&quot;: &quot;linux&quot;,<br>        &quot;MountLabel&quot;: &quot;&quot;,<br>        &quot;ProcessLabel&quot;: &quot;&quot;,<br>        &quot;AppArmorProfile&quot;: &quot;&quot;,<br>        &quot;ExecIDs&quot;: null,<br>        &quot;HostConfig&quot;: &#123;<br>            &quot;Binds&quot;: null,<br>            &quot;ContainerIDFile&quot;: &quot;&quot;,<br>            &quot;LogConfig&quot;: &#123;<br>                &quot;Type&quot;: &quot;json-file&quot;,<br>                &quot;Config&quot;: &#123;&#125;<br>            &#125;,<br>            &quot;NetworkMode&quot;: &quot;default&quot;,<br>            &quot;PortBindings&quot;: &#123;&#125;,<br>            &quot;RestartPolicy&quot;: &#123;<br>                &quot;Name&quot;: &quot;no&quot;,<br>                &quot;MaximumRetryCount&quot;: 0<br>            &#125;,<br>            &quot;AutoRemove&quot;: false,<br>            &quot;VolumeDriver&quot;: &quot;&quot;,<br>            &quot;VolumesFrom&quot;: null,<br>            &quot;CapAdd&quot;: null,<br>            &quot;CapDrop&quot;: null,<br>            &quot;CgroupnsMode&quot;: &quot;host&quot;,<br>            &quot;Dns&quot;: [],<br>            &quot;DnsOptions&quot;: [],<br>            &quot;DnsSearch&quot;: [],<br>            &quot;ExtraHosts&quot;: null,<br>            &quot;GroupAdd&quot;: null,<br>            &quot;IpcMode&quot;: &quot;private&quot;,<br>            &quot;Cgroup&quot;: &quot;&quot;,<br>            &quot;Links&quot;: null,<br>            &quot;OomScoreAdj&quot;: 0,<br>            &quot;PidMode&quot;: &quot;&quot;,<br>            &quot;Privileged&quot;: false,<br>            &quot;PublishAllPorts&quot;: false,<br>            &quot;ReadonlyRootfs&quot;: false,<br>            &quot;SecurityOpt&quot;: null,<br>            &quot;UTSMode&quot;: &quot;&quot;,<br>            &quot;UsernsMode&quot;: &quot;&quot;,<br>            &quot;ShmSize&quot;: 67108864,<br>            &quot;Runtime&quot;: &quot;runc&quot;,<br>            &quot;ConsoleSize&quot;: [<br>                0,<br>                0<br>            ],<br>            &quot;Isolation&quot;: &quot;&quot;,<br>            &quot;CpuShares&quot;: 0,<br>            &quot;Memory&quot;: 0,<br>            &quot;NanoCpus&quot;: 0,<br>            &quot;CgroupParent&quot;: &quot;&quot;,<br>            &quot;BlkioWeight&quot;: 0,<br>            &quot;BlkioWeightDevice&quot;: [],<br>            &quot;BlkioDeviceReadBps&quot;: null,<br>            &quot;BlkioDeviceWriteBps&quot;: null,<br>            &quot;BlkioDeviceReadIOps&quot;: null,<br>            &quot;BlkioDeviceWriteIOps&quot;: null,<br>            &quot;CpuPeriod&quot;: 0,<br>            &quot;CpuQuota&quot;: 0,<br>            &quot;CpuRealtimePeriod&quot;: 0,<br>            &quot;CpuRealtimeRuntime&quot;: 0,<br>            &quot;CpusetCpus&quot;: &quot;&quot;,<br>            &quot;CpusetMems&quot;: &quot;&quot;,<br>            &quot;Devices&quot;: [],<br>            &quot;DeviceCgroupRules&quot;: null,<br>            &quot;DeviceRequests&quot;: null,<br>            &quot;KernelMemory&quot;: 0,<br>            &quot;KernelMemoryTCP&quot;: 0,<br>            &quot;MemoryReservation&quot;: 0,<br>            &quot;MemorySwap&quot;: 0,<br>            &quot;MemorySwappiness&quot;: null,<br>            &quot;OomKillDisable&quot;: false,<br>            &quot;PidsLimit&quot;: null,<br>            &quot;Ulimits&quot;: null,<br>            &quot;CpuCount&quot;: 0,<br>            &quot;CpuPercent&quot;: 0,<br>            &quot;IOMaximumIOps&quot;: 0,<br>            &quot;IOMaximumBandwidth&quot;: 0,<br>            &quot;MaskedPaths&quot;: [<br>                &quot;/proc/asound&quot;,<br>                &quot;/proc/acpi&quot;,<br>                &quot;/proc/kcore&quot;,<br>                &quot;/proc/keys&quot;,<br>                &quot;/proc/latency_stats&quot;,<br>                &quot;/proc/timer_list&quot;,<br>                &quot;/proc/timer_stats&quot;,<br>                &quot;/proc/sched_debug&quot;,<br>                &quot;/proc/scsi&quot;,<br>                &quot;/sys/firmware&quot;<br>            ],<br>            &quot;ReadonlyPaths&quot;: [<br>                &quot;/proc/bus&quot;,<br>                &quot;/proc/fs&quot;,<br>                &quot;/proc/irq&quot;,<br>                &quot;/proc/sys&quot;,<br>                &quot;/proc/sysrq-trigger&quot;<br>            ]<br>        &#125;,<br>        &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/2a0cabf5bad359705499d87ae235e88f9f35f81a4d990e0ec5cb30de3fe78ded-init/diff:/var/lib/docker/overlay2/c55a40a69f5947ab379bbcf187bb281e1eeaf6bec2e5b85e231ff9c4ba5884aa/diff&quot;,<br>                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/2a0cabf5bad359705499d87ae235e88f9f35f81a4d990e0ec5cb30de3fe78ded/merged&quot;,<br>                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/2a0cabf5bad359705499d87ae235e88f9f35f81a4d990e0ec5cb30de3fe78ded/diff&quot;,<br>                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/2a0cabf5bad359705499d87ae235e88f9f35f81a4d990e0ec5cb30de3fe78ded/work&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;overlay2&quot;<br>        &#125;,<br>        &quot;Mounts&quot;: [],<br>        &quot;Config&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;3968ef35633d&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: true,<br>            &quot;AttachStdout&quot;: true,<br>            &quot;AttachStderr&quot;: true,<br>            &quot;Tty&quot;: true,<br>            &quot;OpenStdin&quot;: true,<br>            &quot;StdinOnce&quot;: true,<br>            &quot;Env&quot;: [<br>                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;<br>            ],<br>            &quot;Cmd&quot;: [<br>                &quot;/bin/bash&quot;<br>            ],<br>            &quot;Image&quot;: &quot;centos&quot;,<br>            &quot;Volumes&quot;: null,<br>            &quot;WorkingDir&quot;: &quot;&quot;,<br>            &quot;Entrypoint&quot;: null,<br>            &quot;OnBuild&quot;: null,<br>            &quot;Labels&quot;: &#123;<br>                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,<br>                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,<br>                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,<br>                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,<br>                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;<br>            &#125;<br>        &#125;,<br>        &quot;NetworkSettings&quot;: &#123;<br>            &quot;Bridge&quot;: &quot;&quot;,<br>            &quot;SandboxID&quot;: &quot;ae8f277d769fa5de37a1ba3b41eec18a0dd9377560570375fad7d3ef95d5501b&quot;,<br>            &quot;HairpinMode&quot;: false,<br>            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,<br>            &quot;LinkLocalIPv6PrefixLen&quot;: 0,<br>            &quot;Ports&quot;: &#123;&#125;,<br>            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/ae8f277d769f&quot;,<br>            &quot;SecondaryIPAddresses&quot;: null,<br>            &quot;SecondaryIPv6Addresses&quot;: null,<br>            &quot;EndpointID&quot;: &quot;20bfd8331adfc270031bd6c2e26cbf4e7a215d5af2394fb173953ac0624cf999&quot;,<br>            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>            &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>            &quot;GlobalIPv6PrefixLen&quot;: 0,<br>            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>            &quot;IPPrefixLen&quot;: 16,<br>            &quot;IPv6Gateway&quot;: &quot;&quot;,<br>            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>            &quot;Networks&quot;: &#123;<br>                &quot;bridge&quot;: &#123;<br>                    &quot;IPAMConfig&quot;: null,<br>                    &quot;Links&quot;: null,<br>                    &quot;Aliases&quot;: null,<br>                    &quot;NetworkID&quot;: &quot;210f490ac0f5fe787e4a55b53622328897a75ad50fabf976732734b961ddcf4a&quot;,<br>                    &quot;EndpointID&quot;: &quot;20bfd8331adfc270031bd6c2e26cbf4e7a215d5af2394fb173953ac0624cf999&quot;,<br>                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>                    &quot;IPPrefixLen&quot;: 16,<br>                    &quot;IPv6Gateway&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6PrefixLen&quot;: 0,<br>                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>                    &quot;DriverOpts&quot;: null<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="3-5-进入当前正在运行的容器">3.5 进入当前正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 方式一</span><br><span class="hljs-meta">#</span><span class="bash"> 命令 docker <span class="hljs-built_in">exec</span> -it 容器id bashshell</span><br><br>[root@Mercury ~]# docker exec -it 3968ef35633d /bin/bash<br>[root@3968ef35633d /]# ls<br>bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var<br>[root@3968ef35633d /]#<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 方式二</span><br><span class="hljs-meta">#</span><span class="bash"> 命令docker attach 容器id</span><br>[root@Mercury ~]# docker attach 3968ef35633d<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">exec</span>   <span class="hljs-comment"># 进入容器后开启一个新的终端，可以再里里面进行操作</span></span><br><span class="hljs-meta">#</span><span class="bash"> docker attach <span class="hljs-comment"># 进入容器正在执行的终端，不会启动新的终端</span></span><br></code></pre></td></tr></table></figure><h3 id="3-6-从容器拷贝文件到主机上">3.6 从容器拷贝文件到主机上</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker cp 容器id : 容器内的路径   目的主机地址</span><br>[root@Mercury ~]# docker cp 3968ef35633d:/home/test.java /home<br></code></pre></td></tr></table></figure><h2 id="4-小小的来实战一波">4. 小小的来实战一波</h2><h3 id="4-1-安装nginx">4.1 安装nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先docekr pull nginx 就不说了</span><br><span class="hljs-meta">#</span><span class="bash"> 下载好后就开始运行</span><br><span class="hljs-meta">#</span><span class="bash">  -d 后台运行</span><br><span class="hljs-meta">#</span><span class="bash">  -p 映射端口</span><br><span class="hljs-meta">#</span><span class="bash">  --name 起个名字</span><br><br>[root@Mercury ~]# docker run -d --name nginx01 -p 3344:80 nginx<br><br>7dfb5ccc4ee6146ca43cfecb66eeb52ad8ee01202e6cf5020b18e5d94e9048f3<br><br>[root@Mercury ~]# docker ps<br><br>CONTAINER ID   IMAGE    COMMAND                  CREATED           STATUS         PORTS                  NAMES<br><br>7dfb5ccc4ee6   nginx    &quot;/docker-entrypoint.…&quot;   11 seconds ago    Up 9 seconds   0.0.0.0:3344-&gt;80/tcp   nginx01<br>s<br>3968ef35633d   centos   &quot;/bin/bash&quot;              2 days ago        Up 2 days                             quirky_lewin<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# curl localhost:3344<br><br>&lt;!DOCTYPE html&gt;<br><br>&lt;html&gt;<br><br>&lt;head&gt;<br><br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br><br>&lt;style&gt;<br><br>html &#123; color-scheme: light dark; &#125;<br><br>body &#123; width: 35em; margin: 0 auto;<br><br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br><br>&lt;/style&gt;<br><br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br><br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br><br>working. Further configuration is required.&lt;/p&gt;<br><br><br><br>&lt;p&gt;For online documentation and support please refer to<br><br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br><br>Commercial support is available at<br><br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br><br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br><br>&lt;/body&gt;<br><br>&lt;/html&gt;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 测试成功！</span><br></code></pre></td></tr></table></figure><h3 id="4-2-安装可视化操作面板portainer">4.2 安装可视化操作面板portainer</h3> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker run -d -p 8080:9000 \<br><span class="hljs-meta"></span><br><span class="hljs-meta">&gt;</span><span class="bash"> --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="hljs-literal">true</span> portainer/portainer</span><br></code></pre></td></tr></table></figure><p>没什么讲的，尽量不适用可视化面板</p><h1>四. Docker镜像讲解</h1><h2 id="1-镜像是什么">1. 镜像是什么</h2><p>镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时的库环境变量和配置文件。所有的应用，直接打包docker镜像，就可以直接跑起来</p><div class = "note note-warning">那么如何得到镜像呢？</div><ul><li>从远程仓库下载</li><li>拷贝</li><li>自己制作一个DockerFile</li></ul><h2 id="2-Docker镜像加载原理">2. Docker镜像加载原理</h2><div class = "note note-success">UnionFS联合文件系统</div><p>UnionFS(联合文件系统)是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union文件系统是docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种集体的应用镜像</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到文件系统，联合加载会把各层文件叠加起来，这样最终的文件系统会包含所有的文件和目录</p><div class = "note note-success">Docker镜像加载原理</div><p>docker的镜像实际上哟一层一层的文件系统组成，这种层级的文件系统UnionFS.</p><p>bootfs(boot file system) 主要包含bootloader和kernal，bootloader主要是引导加载kernal，linux刚启动时会加载bootfs文件系统，在docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix 系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时额你存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</p><p>rootfs(root file system),在bootfs之上。包含的就是典型Linux系统的 /dev,/proc/,/bin,/etc等标准目录和文件。rootf就是各种不同操作系统发行版。比如Ubuntu,Centos等等</p><div note note-success>为什么平时安装虚拟机的Centos都是好几个G，但是Docker才200多M?</div><p>简单的来说就是，这个centos只有最基本的一些命令，是不完全的centos，是被阉割过的(刀法精准)，因此才会比较小</p><h2 id="3-分层理解">3. 分层理解</h2><p>从之前的下载就可以看出，docker下载的时候是分层下载的</p><div note note-danger>为什么要采用分层下载这种方式呢？</div><p>最大的好处就是资源共享，比如这里有多个镜像都从相同的Base镜像构建而来，那么宿主机只需要在磁盘上面保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><div note note-success>特点</div><p>Docker的镜像都是只读的，当容器启动的时候，一个新的可写层被加载到镜像的顶部，这一层就是我们通常所讲的容器层，而容器之下的都叫镜像层。</p><h1>五. 容器数据卷</h1><p>总的来说就是容器的持久化和同步操作，容器之间也是可以数据共享的，这里就需要把容器内的内容同步一下</p><p>挂载命令：docker run -it -v  主机目录: 容器内的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -v  /home/test:/home  centos /bin/bash<br></code></pre></td></tr></table></figure><div note note-warning>注意:</div><p>这里的挂载是双向同步，哪一边修改了，都会进行同步</p><p>可以使用inspect命令查看挂载，里面的mount即是挂载相关的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;Mounts&quot;: [<br>   &#123;<br>    &quot;Type&quot;: &quot;bind&quot;,<br>    &quot;Source&quot;: &quot;/home/test&quot;,<br>    &quot;Destination&quot;: &quot;/home&quot;,<br>    &quot;Mode&quot;: &quot;&quot;,<br>    &quot;RW&quot;: true,<br>    &quot;Propagation&quot;: &quot;rprivate&quot;<br>   &#125;<br>  ]<br></code></pre></td></tr></table></figure><p>我们这里就可以想到一个实际的用途(不然发明挂载干什么🤣) ，比如修改容器内的nginx的配置文件，</p><h2 id="1-持久化mysql数据实战">1. 持久化mysql数据实战</h2><p>安装mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.7<br></code></pre></td></tr></table></figure><p>启动和配置</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag<br># 这个是官方的配置代码<br><br><span class="hljs-deletion">-d 后台运行</span><br><br><span class="hljs-deletion">-p 端口映射</span><br><br><span class="hljs-deletion">-v 卷挂载</span><br><br><span class="hljs-deletion">-e 环境配置</span><br><br><span class="hljs-deletion">--name 容器的名字</span><br></code></pre></td></tr></table></figure><p>我们再额外配置一下端口映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 3310:3306 -v /home/mysql:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<br></code></pre></td></tr></table></figure><p>假设将容器删除，挂载到本地的数据卷依旧并不会丢失，实现持久化功能</p><h2 id="2-具名挂载和匿名挂载">2. 具名挂载和匿名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span><br>-v 容器内路径<br>[root@Mercury dockerfile]# docker run -d -p --name nginx01 -v /et/nginx nginx<br><span class="hljs-meta">#</span><span class="bash"> 就是-v的时候只写了容器内的路径没有写容器外的路径，就是匿名挂载</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看所有volume 的情况</span><br>docker volume ls<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 具名挂载</span><br>[root@Mercury dockerfile]# docker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx nginx<br>[root@Mercury dockerfile]# docker volume ls<br>DRIVER    VOLUME NAME<br>local     2e6932c90fc933391e4481d1360ee083eb3477ceb7a097b1123d3370f43a7611<br>local     45d9e1935720bdab02775b3131bffe2a26bacda3090e2ad807d4a94385f52974<br>local     jumping-nginx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 可以看到最下面的那个有了我们赋值的名字</span><br></code></pre></td></tr></table></figure><p>查看一下这个卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury dockerfile]# docker volume inspect jumping-nginx<br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2022-05-14T19:35:12+08:00&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: null,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/jumping-nginx/_data&quot;,<br>        &quot;Name&quot;: &quot;jumping-nginx&quot;,<br>        &quot;Options&quot;: null,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>所有的docker容器内的卷，没有指定目录情况下都是在<span class = "label label-danger">/var/lib/docker/volumes/xxxx/_data</span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v 容器内路径           # 匿名挂载<br>-v 卷名：容器内路径      # 具名挂载<br>-v 宿主机路径：容器内路径 # 指定路径挂载<br></code></pre></td></tr></table></figure><div class = "note note-success">拓展</div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过-v 容器内路径 ro rw 改变读写权限</span><br>ro         read only <br>rw         read write<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 只要有ro就说明这个路径只能通过宿主机来操作，容器内是无法操作的,默认都是rw</span><br>docker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx:ro nginx<br>docker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx:rw nginx<br></code></pre></td></tr></table></figure><h2 id="3-多个容器数据同步">3. 多个容器数据同步</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury dockerfile]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<br><br>[root@Mercury dockerfile]# docker run -d -p 3310:3306  -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volume-from mysql01 mysql:5.7<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 以上</span><br></code></pre></td></tr></table></figure><p>容器之间的数据传递，数据卷容器的生命周期一直持续到容器停止使用为止，但如果持久化到了本地，便不会丢失</p><h1>六. DockerFile</h1><h2 id="1-初识Docker">1. 初识Docker</h2><p>介绍：</p><p>构建步骤</p><ol><li>编写dockerfile文件</li><li>docker build构建成为一个镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像</li></ol><p>基础知识</p><p>每个关键字 （指令）都必须是大写字母</p><p>执行从上到下顺序执行</p><p># 表示注释</p><p>每一个指令都会创建提交一个新的镜像层，并提交</p><p><img src="https://img.mercuryblog.site/img/image-20220514195654277.png" alt="image-20220514195654277"></p><h2 id="2-dockerfile命令">2. dockerfile命令</h2><ul><li><p>FROM 基础镜像，一切从这里构建</p></li><li><p>MAINTAINER  镜像是谁写的，姓名+邮箱</p></li><li><p>RUN 镜像构建的时候需要运行的命令</p></li><li><p>ADD 步骤，添加镜像内容</p></li><li><p>WORKDIR 镜像的工作目录</p></li><li><p>VOLUME 挂载的目录</p></li><li><p>EXPOSE 暴露端口</p></li><li><p>CMD 指定这个容器启动的时候需要的命令 只有最后一个会生效可以被替代</p></li><li><p>ENTRYPOINT 指定这个容器启动的时候需要的命令可以追加命令</p></li><li><p>ONBUILD 当构建一个被继承DockerFile 这个时候就会运行ONBUILD 的指令</p></li><li><p>COPY 类似ADD 将我们文件拷贝到镜像中</p></li><li><p>ENV 构建的时候设置环境变量</p></li></ul><p>通过这个脚本生成镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos<br><br><br>VOLUME [&quot;volume01&quot;, &quot;volume02 &quot;]<br><br><br>CMD echo &quot;-----end-----&quot;<br><br>CMD /bin/bash<br><br><br>docker build -f dockerfilel -t /kuangshen/centos .<br></code></pre></td></tr></table></figure><h2 id="3-构建一个自己的centos">3. 构建一个自己的centos</h2><p>从源码中可以发现dockerhub中大部分的镜像都是从scratch 过来的，然后配置需要的软件来进行构建</p><ol><li>编写一个dockerfile文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim mydockerfile-centos<br></code></pre></td></tr></table></figure><p>编写脚本安装 vim 和 net-tools</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos:7<br><br>MAINTAINER chenning&lt;chenning_william@163.com&gt;<br><br><br>ENV MYPATH /usr/local<br><br>WORKDIR $MYPATH<br><br><br>RUN yum -y install vim<br><br>RUN yum -y install net-tools<br><br> <br>EXPOSE 80<br><br><br>CMD echo $MYPATH <br><br>CMD echo &quot;----end----&quot;<br><br>CMD /bin/bash<br></code></pre></td></tr></table></figure><p>2.build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 成功后返回</span><br><br>Successfully built 76804282c147<br><br>Successfully tagged mycentos:0.1<br></code></pre></td></tr></table></figure><p>3.测试运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入容器</span><br>[root@4859366666ba local]# pwd<br>/usr/local<br>[root@4859366666ba local]# ifconfig<br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500<br>  inet 172.17.0.6 netmask 255.255.0.0 broadcast 172.17.255.255<br>  ether 02:42:ac:11:00:06 txqueuelen 0 (Ethernet)<br>  RX packets 0 bytes 0 (0.0 B)<br>  RX errors 0 dropped 0 overruns 0 frame 0<br>  TX packets 0 bytes 0 (0.0 B)<br>  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536<br>  inet 127.0.0.1 netmask 255.0.0.0<br>  loop txqueuelen 1000 (Local Loopback)<br>  RX packets 0 bytes 0 (0.0 B)<br>  RX errors 0 dropped 0 overruns 0 frame 0<br>  TX packets 0 bytes 0 (0.0 B)<br>  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0<br><span class="hljs-meta">#</span><span class="bash"> 可以看到工作路径变成了  /usr/<span class="hljs-built_in">local</span> 而且ipconfig也能正常使用，说明成功了</span><br></code></pre></td></tr></table></figure><ol start="4"><li>我们可以列出变更的历史</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury dockerfile]# docker history 76804282c147<br>IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT<br>76804282c147   7 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin…   0B        <br>ef56285a896a   7 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        <br>f43334273bac   7 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        <br>9aee7126d86d   7 minutes ago   /bin/sh -c #(nop)  EXPOSE 80                    0B        <br>ec21bf9df499   7 minutes ago   /bin/sh -c yum -y install net-tools             166MB     <br>61dc5db67561   7 minutes ago   /bin/sh -c yum -y install vim                   221MB     <br>95e5b666e6fc   8 minutes ago   /bin/sh -c #(nop) WORKDIR /usr/local            0B        <br>3febcbabfc09   8 minutes ago   /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B        <br>d08da42f9b1f   8 minutes ago   /bin/sh -c #(nop)  MAINTAINER chenning&lt;chenn…   0B        <br>eeb6ee3f44bd   8 months ago    /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        <br>&lt;missing&gt;      8 months ago    /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        <br>&lt;missing&gt;      8 months ago    /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4…   204MB<br></code></pre></td></tr></table></figure><h2 id="4-CMD和ENTRYPOINT区别">4. CMD和ENTRYPOINT区别</h2><p>CMD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span><br>[root@Mercury dockerfile]# vim dockerfile-cmd-test<br>FROM centos<br>CMD [&quot;ls&quot;,&quot;-a&quot;]<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 构建镜像</span><br>[root@Mercury dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest<br>[root@Mercury dockerfile]# docker run dd8e4401d47f   <br>...<br><span class="hljs-meta">#</span><span class="bash"> ls -a命令生效</span><br><br>[root@Mercury dockerfile]# docker run dd8e4401d47f -l<br>docker:error<br><span class="hljs-meta">#</span><span class="bash"> 但是如果追加命令docker run dd8e4401d47f -l 便会报错，因为-l取代了CMD [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>]命令</span><br></code></pre></td></tr></table></figure><p>ENTRYPOINT</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span><br>[root@Mercury dockerfile]# vim dockerfile-cmd-test<br>FROM centos<br>ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 构建镜像</span><br>[root@Mercury dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest<br>[root@Mercury dockerfile]# docker run dd8e4401d47f   <br>...<br><span class="hljs-meta">#</span><span class="bash"> ls -a命令生效</span><br><br>[root@Mercury dockerfile]# docker run dd8e4401d47f -l<br>...<br><span class="hljs-meta">#</span><span class="bash"> 如果追加命令docker run dd8e4401d47f -l 可以正常追加命令执行。</span><br></code></pre></td></tr></table></figure><h2 id="5-实战tomcat镜像">5. 实战tomcat镜像</h2><ol><li><p>准备tomcat jdk压缩包</p></li><li><p>编写Dockerfile  官方命名<span class = "label label-danger">Dockerfile</span></p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos:7<br><br>MAINTAINER chenning&lt;chenning_william@163.com&gt;<br>COPY readme.txt /usr/local/readme.txt<br><br><br>ADD jdk-8u333-linux-x64.tar.gz /usr/local<br>ADD apache-tomcat-9.0.62.tar.gz /usr/local<br><br><br>RUN yum -y install vim<br><br>ENV MYPATH /usr/local<br>WORKDIR $MYPATH<br><br><br><br>ENV JAVA_HOME /usr/local/jdk1.8.0_333<br>ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>ENV CATALINA_HONE /usr/local/apache-tomcat-9.0.62<br>ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.62<br>ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HONE/bin<br><br><br>EXPOSE 8080<br><br><br>CMD /usr/local/apache-tomcat-9.0.62/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.62/bin/logs/catalina.out<br></code></pre></td></tr></table></figure><ol start="3"><li>构建镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury tomcat]# docker build -t diytomcat .<br></code></pre></td></tr></table></figure><p><span class = "label label-danger">一定需要注意最后面有个点</span></p><ol start="4"><li>启动测试</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury tomcat]# docker run -d -p 9090:8080 --name mercurytomcat -v /home/tomcat/test:/usr/local/apache-tomcat-9.0.62/webapps/test -v /home/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.62/logs diytomcat<br><br>[root@Mercury tomcat]# curl localhost:9090<br><br>&lt;!DOCTYPE html&gt;<br><br>&lt;html lang=&quot;en&quot;&gt;<br><br> &lt;head&gt;<br><br>    &lt;meta charset=&quot;UTF-8&quot; /&gt;<br><br>  &lt;title&gt;Apache Tomcat/9.0.62&lt;/title&gt;<br><br>  &lt;link href=&quot;favicon.ico&quot; rel=&quot;icon&quot; type=&quot;image/x-icon&quot; /&gt;<br><br>  &lt;link href=&quot;tomcat.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;<br><br> &lt;/head&gt;<br></code></pre></td></tr></table></figure><p>可以看到正常加载了，说明成功了,然后就可以在挂载的目录里面直接发布项目了</p><h2 id="6-发布自己的镜像">6. 发布自己的镜像</h2><h3 id="6-1-DockerHub">6.1 DockerHub</h3><ol><li>登录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login -u username<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury tomcat]# docker login -u 52hzmercury<br>Password: <br>WARNING! Your password will be stored unencrypted in /root/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded<br></code></pre></td></tr></table></figure><ol start="2"><li>更改项目名</li></ol><p>就是在前面加上自己的用户名后面家伙是那个版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag image-id 52hzmercury/diytomcat:1.0<br></code></pre></td></tr></table></figure><ol start="3"><li>推送</li></ol><p>尽量带上版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push 52hzmercury/diytomcat:1.0<br></code></pre></td></tr></table></figure><h3 id="6-2-阿里云">6.2 阿里云</h3><p>官方文档里面写得非常的清楚</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker login --username=52hz的mercury registry.cn-hangzhou.aliyuncs.com</span><br><span class="hljs-meta">$</span><span class="bash"> docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/52hzmercury/mercury:[镜像版本号]</span><br><span class="hljs-meta">$</span><span class="bash"> docker push registry.cn-hangzhou.aliyuncs.com/52hzmercury/mercury:[镜像版本号]</span><br></code></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>docker的全部流程</p><p><img src="https://img.mercuryblog.site/img/image-20220515205955013.png" alt="image-20220515205955013"></p><h1>七. Docker网络</h1><h2 id="1-初识docker网络">1. 初识docker网络</h2><p>首先我们知道通过ip addr 可以查看IP的相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    link/ether 00:16:3e:12:a0:63 brd ff:ff:ff:ff:ff:ff<br>    inet 172.26.25.110/18 brd 172.26.63.255 scope global dynamic eth0<br>       valid_lft 312060333sec preferred_lft 312060333sec<br>3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:15:a3:19:b8 brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0<br>       valid_lft forever preferred_lft forever<br>41: veth2731295@if40: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default <br>    link/ether ba:f3:19:6f:a2:7e brd ff:ff:ff:ff:ff:ff link-netnsid 0<br></code></pre></td></tr></table></figure><p>查看容器相关的ip信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker exec -it tomcat01 ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>42: eth0@if43: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>容器无法执行相关的指令，需要进入容器安装，执行<span class = "label label-danger">apt update &amp;&amp; apt install -y iproute2</span></p><p>发现eth0@if43地址,这就是docker分配的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# ping 172.17.0.2<br>PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.<br>64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.114 ms<br>64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.068 ms<br>64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.097 ms<br></code></pre></td></tr></table></figure><div class = "note note-success">原理</div><p>每启动一个docker容器 docker就会给docker容器分配一个ip 只要安装了docker 就会有一个网卡docker0桥接模式吗，使用的技术是evth-pair技术</p><p>容器带来的网卡都是一对一对的,evth-pair 就是一 对的虚拟设备接口，他们都是承兑出现的，一段连着协议，一段彼此相连</p><p>正因为有这个特性，evht-pair充当着桥梁 连接着各种虚拟网络设备启动容器后再次查看容器的ip信息，可以看到多了43这一行，并且后面信息跟着42</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    link/ether 00:16:3e:12:a0:63 brd ff:ff:ff:ff:ff:ff<br>    inet 172.26.25.110/18 brd 172.26.63.255 scope global dynamic eth0<br>       valid_lft 312058161sec preferred_lft 312058161sec<br>3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:15:a3:19:b8 brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0<br>       valid_lft forever preferred_lft forever<br>43: veth7a74e4d@if42: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default <br>    link/ether 9a:72:2b:67:26:e5 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br></code></pre></td></tr></table></figure><p>再启动一个tomcat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker run -d -P --name tomcat02 tomcat<br>3bbabab9c34a800b7663746f07f2ed9ed27aa292d291cfd6bbb4b5a5e0675899<br>[root@Mercury ~]# ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    link/ether 00:16:3e:12:a0:63 brd ff:ff:ff:ff:ff:ff<br>    inet 172.26.25.110/18 brd 172.26.63.255 scope global dynamic eth0<br>       valid_lft 312058079sec preferred_lft 312058079sec<br>3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:15:a3:19:b8 brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0<br>       valid_lft forever preferred_lft forever<br>43: veth7a74e4d@if42: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default <br>    link/ether 9a:72:2b:67:26:e5 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>45: vethccc3ec9@if44: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default <br>    link/ether ce:6b:95:66:9e:f8 brd ff:ff:ff:ff:ff:ff link-netnsid 1<br></code></pre></td></tr></table></figure><p>测试tomcat01 ping tomcat02是可以ping通的，原理就是下面这张图</p><p><img src="https://img.mercuryblog.site/img/image-20220517161020371.png" alt="image-20220517161020371"></p><h2 id="2-容器互联-link">2. 容器互联 --link</h2><p>再来一个容器,把它和tomcat02连接起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -P --name tomcat03 --link tomcat02 tomcat<br></code></pre></td></tr></table></figure><div class = "note note-danger">如果没提示有ping命令</div><p>在容器内执行 apt-get update &amp;&amp; apt-get install iputils-ping</p><p>再ping一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker exec -it tomcat03 ping tomcat02<br>PING tomcat02 (172.17.0.3) 56(84) bytes of data.<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.182 ms<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.081 ms<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.135 ms<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 可以看到是ping通的</span><br></code></pre></td></tr></table></figure><p>反向来一下子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker exec -it tomcat02 ping tomcat03<br>ping: tomcat03: Name or service not known<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">ping 不通</span><br></code></pre></td></tr></table></figure><p>我们来看一下tomcat03的容器配置，可以看到tomcat03在本地配置了tomcat02的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker exec -it tomcat03 cat /etc/hosts<br>127.0.0.1localhost<br>::1localhost ip6-localhost ip6-loopback<br>fe00::0ip6-localnet<br>ff00::0ip6-mcastprefix<br>ff02::1ip6-allnodes<br>ff02::2ip6-allrouters<br>172.17.0.3tomcat02 3bbabab9c34a      #在这里配置了tomcat02的连接<br>172.17.0.476e0fe012ef9<br></code></pre></td></tr></table></figure><p>再来看看tomcat02的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Mercury ~]# docker exec -it tomcat02 cat /etc/hosts<br>127.0.0.1localhost<br>::1localhost ip6-localhost ip6-loopback<br>fe00::0ip6-localnet<br>ff00::0ip6-mcastprefix<br>ff02::1ip6-allnodes<br>ff02::2ip6-allrouters<br>172.17.0.33bbabab9c34a<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 并没有配置</span><br></code></pre></td></tr></table></figure><p>因此反向是ping不通的</p><h2 id="3-网络模式">3. 网络模式</h2><ul><li>bridge: 桥接 docker默认</li><li>none 不配置网络</li><li>host 和容器共享网络</li><li>container 容器网络联通</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看所有docker网络</span><br>[root@Mercury ~]# docker network ls<br>NETWORK ID  NAME  DRIVER SCOPE<br>210f490ac0f5 bridge bridge local<br>6c94eae8c3c6 host  host  local<br>8a937df872e9 none  null  local<br></code></pre></td></tr></table></figure><p>自定义网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet<br></code></pre></td></tr></table></figure><p>网络和容器联通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network connect mynet tomcat01<br></code></pre></td></tr></table></figure><p>=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=END~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2022/04/23/Ajax/"/>
    <url>/2022/04/23/Ajax/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">     <div>前言：</div>     <ul>         <div>             根据狂神视频以及教学ppt整理         </div>     <ul></div><h1>AJax</h1><p>Ajax 全程 Asynchronous JavaScript and XML 即 异步的JavaScript 和XML，AJax是一种无需重新加载整个网页的情况下，能够更新部分网页的技术，AJax不是一种的编程语言，而是一种用于创建更好更快以及更强的Web应用的技术</p><p>在2005年，Google Suggest使用AJax 创建出动态性极强的web界面：当你在谷歌的搜索框输入关键字时，JavaScript会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p><div class = "note note-warning">注意:</div><p>AJax需要引入JQuery</p><h2 id="基本语法">基本语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <br>    /*<br>       所有的参数：<br>                url: 待载入页面的URL地址(必填)<br>                data: 待发送的 key/value 参数<br>                success: 载入成功时的回调函数<br>                 data: 请求返回的数据<br>                 status: 请求返回的状态<br>    <br>    */<br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a1</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            $.ajax(&#123;                         <span class="hljs-comment">//Ajax 默认是get请求，若想改为post，将这里改为$.post 即可</span></span><br><span class="javascript">                <span class="hljs-attr">url</span> :<span class="hljs-string">&quot;&quot;</span>,                     <span class="hljs-comment">//必填</span></span><br><span class="javascript">                <span class="hljs-attr">data</span>: &#123;<span class="hljs-string">&quot;name&quot;</span>:$(<span class="hljs-string">&quot;#textName&quot;</span>).val()&#125;,</span><br><span class="javascript">                <span class="hljs-attr">success</span> :<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data,status</span>)</span>&#123;</span><br><span class="javascript">                    alert(data);</span><br><span class="javascript">                    alert(success);</span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;);</span><br><span class="javascript">           </span><br><span class="javascript">        &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;textname&quot;</span> <span class="hljs-attr">onblur</span>=<span class="hljs-string">&quot;a1()&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="两个实例">两个实例</h2><h3 id="获取数据嵌入到html中">获取数据嵌入到html中</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;获取数据&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    $(<span class="hljs-string">&quot;#btn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-comment">//如果click事件写在这里前面需要加上$(document).ready(function()&#123;&#125;)</span></span><br><span class="javascript">        $.post(&#123;</span><br><span class="javascript">            <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="javascript">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="javascript">                    html +=<span class="hljs-string">&quot;&lt;tr&gt;&quot;</span>+</span><br><span class="javascript">                       <span class="hljs-string">&quot;&lt;td&gt;&quot;</span>+ data[i].name+<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="javascript">                        <span class="hljs-string">&quot;&lt;td&gt;&quot;</span>+data[i].age+<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="javascript">                        <span class="hljs-string">&quot;&lt;td&gt;&quot;</span>+data[i].sex+<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="javascript">                           <span class="hljs-string">&quot;&lt;/tr&gt;&quot;</span> </span><br><span class="javascript">                &#125;</span><br><span class="javascript">                $(<span class="hljs-string">&quot;#content&quot;</span>).html(html);    <span class="hljs-comment">//最后将html塞入到页面中</span></span><br><span class="javascript">            &#125;</span><br><span class="javascript">          &#125;)</span><br><span class="javascript"></span><br><span class="javascript">    &#125;)</span><br><span class="javascript">&#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="登录注册">登录注册</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a2</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            $.post(&#123;</span><br><span class="javascript">                <span class="hljs-attr">url</span> :<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript">                <span class="hljs-attr">data</span>: &#123;<span class="hljs-string">&quot;pwd&quot;</span>:$(<span class="hljs-string">&quot;#name&quot;</span>).val()&#125;,</span><br><span class="javascript">                <span class="hljs-attr">success</span> :<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span>(data.toString()==<span class="hljs-string">&#x27;ok&#x27;</span>)&#123;</span><br><span class="javascript">                        $(<span class="hljs-string">&quot;#userinfo&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>);</span><br><span class="javascript">                    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">                        $(<span class="hljs-string">&quot;#userinfo&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>,<span class="hljs-string">&quot;red&quot;</span>);</span><br><span class="javascript">                    &#125;</span><br><span class="javascript">                    $(<span class="hljs-string">&quot;#userinfo&quot;</span>).html(data);</span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;);</span><br><span class="javascript"></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;textname&quot;</span> <span class="hljs-attr">onblur</span>=<span class="hljs-string">&quot;a2()&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;userinfo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="考试的真题">考试的真题</h3><p>第一个页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>产品录入<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/input.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-id">#search</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:first</span>-child&#123;</span><br><span class="css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="css">            <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">text-align</span>: right;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-id">#submit</span> <span class="hljs-selector-tag">input</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">268px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;js/jquery-3.1.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            $(<span class="hljs-string">&quot;#submit input&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                 <span class="hljs-keyword">var</span> searchText = $(<span class="hljs-string">&quot;#search input&quot;</span>).val();</span><br><span class="javascript">                 <span class="hljs-keyword">if</span>(searchText === <span class="hljs-string">&quot;&quot;</span>)&#123;</span><br><span class="javascript">                     $(<span class="hljs-string">&quot;#error&quot;</span>).text(<span class="hljs-string">&quot;产品名称必须输入&quot;</span>);</span><br><span class="javascript">                     $(<span class="hljs-string">&quot;#error&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>,<span class="hljs-string">&quot;#ff0000&quot;</span>);</span><br><span class="javascript">                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\\d&quot;</span>).test(searchText))&#123;</span><br><span class="javascript">                    $(<span class="hljs-string">&quot;#error&quot;</span>).text(<span class="hljs-string">&quot;产品名称中不能有数字&quot;</span>)</span><br><span class="javascript">                    $(<span class="hljs-string">&quot;#error&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>,<span class="hljs-string">&quot;#ff0000&quot;</span>);</span><br><span class="javascript">                 &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                     <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;product.html&quot;</span>; <span class="hljs-comment">//使用js跳转，类似a标签</span></span><br><span class="javascript">                 &#125;</span><br><span class="javascript">            &#125;);</span><br><span class="javascript">        &#125;);</span><br><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>产品名称<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入产品名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;录入&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二个页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>产品<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;js/jquery-3.1.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span></span><br><span class="css">        &#123;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span> <span class="hljs-selector-tag">td</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span> <span class="hljs-selector-tag">td</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">a</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#00ff00</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-tag">tr</span>&gt;<span class="hljs-selector-tag">td</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>)&#123;</span><br><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffffd0</span>;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            $(<span class="hljs-string">&quot;#search&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                $.post(&#123;</span><br><span class="javascript">                    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://47.108.14.103:8001/getProduct&quot;</span>,</span><br><span class="javascript">                    <span class="hljs-attr">data</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:$(<span class="hljs-string">&quot;#name&quot;</span>).val()&#125;,</span><br><span class="javascript">                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-comment">//document.write(JSON.stringify(data));</span></span><br><span class="javascript">                        <span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="javascript">                        html+=<span class="hljs-string">&quot;&lt;table &gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;品牌&lt;/td&gt; &lt;td&gt;型号&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt;&lt;/tr&gt;&quot;</span></span><br><span class="javascript">                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;data.data.length;i++)&#123; <span class="hljs-comment">//因为是嵌套的。所以需要再.解析访问</span></span><br><span class="javascript">                           <span class="hljs-comment">// alert(data.data[i].image)</span></span><br><span class="javascript">                            html+=<span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&lt;img src=&#x27;http://47.108.14.103:8001/img/&quot;</span>+data.data[i].image+<span class="hljs-string">&quot;&#x27; width=&#x27;100px&#x27; height=&#x27;100px&#x27;&gt;&lt;/td&gt;&lt;td&gt;&quot;</span>+data.data[i].brand+<span class="hljs-string">&quot;&lt;/td&gt; &lt;td&gt;&lt;a href=&#x27;http://47.108.14.103:8001/img/&quot;</span>+data.data[i].image+<span class="hljs-string">&quot;&#x27; target=&#x27;_blank&#x27;&gt;&quot;</span>+data.data[i].model+<span class="hljs-string">&quot;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&quot;</span>+data.data[i].price+<span class="hljs-string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="javascript">                        &#125;</span><br><span class="javascript">                        html+=<span class="hljs-string">&quot;&lt;/table&gt;&quot;</span></span><br><span class="javascript">                        $(<span class="hljs-string">&quot;#product&quot;</span>).html(html);</span><br><span class="javascript"></span><br><span class="javascript">                    &#125;</span><br><span class="javascript"></span><br><span class="javascript">                &#125;)</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;)</span><br><span class="javascript"></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入产品名称&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;搜索&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;product&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery</title>
    <link href="/2022/04/22/jQuery/"/>
    <url>/2022/04/22/jQuery/</url>
    
    <content type="html"><![CDATA[<h1>jQuery</h1><h2 id="导入jQuery">导入jQuery</h2><p>导入在线的 或者本地的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">//在线引用<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;某某在线引用网址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>//本地引用<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;文件的目录&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-1.11.2.js&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>//仔细一想这不是智障吗，我为什么还要拎出来写<br></code></pre></td></tr></table></figure><h2 id="基本语法">基本语法</h2><p>$(“p”)是用于选择网页中所有的p元素；</p><p>$(“p”).click()方法指定选中的<code>&lt;p&gt;</code>元素的click单击事件处理函数</p><p>$(this)是一个 jQuery对象，表示当前引用的HTML元素对象（此处指p元素）。</p><p>$(this).hide()表示选中当前的HTML元素，并将其隐藏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).action() <span class="hljs-comment">//这个就是jQuery最核心的内容</span><br></code></pre></td></tr></table></figure><h2 id="选择器">选择器</h2><h3 id="ID选择器">ID选择器</h3><p>ID选择器可以根据指定ID值返回一个唯一的元素，下面主要就是这个公式的具体应用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test-jqery&quot;</span>&gt;</span>牛逼<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        $(<span class="hljs-string">&quot;#test-jqery&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">//id选择器就是在前面加上一个#</span></span><br><span class="javascript">            alert(<span class="hljs-string">&quot;hello jqery&quot;</span>)</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="标签选择器">标签选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).click();<br></code></pre></td></tr></table></figure><p>选择所有的p标签</p><h3 id="类选择器">类选择器</h3><p>类选择器可以根据元素的CSS类选择一组元素。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;.left&quot;</span>)               <span class="hljs-comment">//为选择页面中所有的class属性为left的元素；</span><br><br>$(<span class="hljs-string">&quot;p.left&quot;</span>)              <span class="hljs-comment">//为选择页面中所有的class为left的p元素。</span><br></code></pre></td></tr></table></figure><h3 id="祖先后代选择器">祖先后代选择器</h3><p>祖先后代选择器中祖先和后代选择符之间使用空格隔开，不限制嵌套层次数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;.left p&quot;</span>) <br><br>$(<span class="hljs-string">&quot;form input&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="父子选择器">父子选择器</h3><p>父子选择器的父元素和子元素之间使用符号“&gt;”隔开，前后元素的嵌套关系只能是一层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div &gt; ul&quot;</span>)       <span class="hljs-comment">//为选择div元素内直接嵌套的ul元素。</span><br></code></pre></td></tr></table></figure><div class = "note note-info">父子选择器和祖先后代选择器的区别</div><p>父子选择器的父元素和子元素之间使用符号“&gt;”隔开，前后元素的嵌套关系只能是一层。</p><p>祖先后代选择器中祖先和后代选择符之间使用空格隔开，不限制嵌套层次数。</p><h3 id="前后选择器">前后选择器</h3><p>前后选择器可以选择某元素的下一个同级兄弟元素</p><p>前后元素中间使用“+”分隔，选择在某元素后面的next元素，相当于next()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;#my+img&quot;</span>)              <span class="hljs-comment">//是选择id为my的元素后的第一个同级别img元素，相当于</span><br><br>$(<span class="hljs-string">&quot;#my&quot;</span>).next(<span class="hljs-string">&quot;img&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="过滤器">过滤器</h2><h3 id="内容过滤器">内容过滤器</h3><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>:contains(text)</td><td>匹配包含给定文本的元素</td></tr><tr><td>:has(selector)</td><td>匹配含有选择器所匹配的元素的元素</td></tr><tr><td>:empty()</td><td>匹配所有不包含子元素或者文本的空元素</td></tr><tr><td>:parent()</td><td>匹配含有子元素或者文本的元素，与:empty()相反</td></tr></tbody></table><h3 id="可见性过滤器">可见性过滤器</h3><p>可见性过滤器可以根据元素的可见性进行选择，可见性过滤器包括:hidden和:visible。</p><p>其中可见选择器“:hidden”不仅包含样式属性 display 为 none 的元素, 也包含文本隐藏域 （<code>&lt;input type=&quot;hidden&quot;&gt;</code>）和visible:hidden之类的元素；</p><p>可见选择器“:visible”可以匹配所有可见的元素。</p><h3 id="属性过滤器">属性过滤器</h3><p>属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>[attribute]</td><td>匹配包含给定属性的元素</td></tr><tr><td>[attribute=value]</td><td>匹配给定属性为特定值的元素</td></tr><tr><td>[attribute!=value]</td><td>匹配给定属性不等于特定值的元素</td></tr><tr><td>[attribute^=value]</td><td>匹配给定属性是以特定值开头的元素</td></tr><tr><td>[attribute$=value]</td><td>匹配给定属性是以特定值结尾的元素</td></tr><tr><td>[attribute*=value]</td><td>匹配给定属性包含特定值的元素</td></tr><tr><td>[attributeFilter1]  [attributeFilter2] …</td><td>复合属性选择器，匹配属性同时满足多个条件的元素</td></tr></tbody></table><h3 id="子元素过滤器">子元素过滤器</h3><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>:first-child</td><td>获取第一个子元素</td></tr><tr><td>:last-child</td><td>获取最后一个子元素</td></tr><tr><td>:nth-child(index|even|eq|odd)</td><td>通过相关指数获取子元素</td></tr><tr><td>:only-child</td><td>获取子元素唯一的元素</td></tr></tbody></table><h2 id="获取或设置HTML元素的内容">获取或设置HTML元素的内容</h2><p>如果要获取HTML元素的内容，其语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> htmlStr= $(selector).html();<br></code></pre></td></tr></table></figure><p>如果要设置HTML元素的内容，其语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).html(<span class="hljs-string">&quot;修改字符串&quot;</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>方    法</th><th>说     明</th></tr></thead><tbody><tr><td>$(selector).text()</td><td>用于返回或设置元素的文本内容；</td></tr><tr><td>$(selector).html()</td><td>用于返回或设置元素的内容（包括HTML标记在内）；</td></tr><tr><td>$(selector).val()</td><td>用于返回或设置表单字段的值；</td></tr></tbody></table><h2 id="jQuery常用事件">jQuery常用事件</h2><table><thead><tr><th>事件函数</th><th>说   明</th></tr></thead><tbody><tr><td>$(“选择器”).click()</td><td>鼠标单击触发事件，参数可选（data，function）</td></tr><tr><td>$(“选择器”).dblclick()</td><td>双击触发，同上</td></tr><tr><td>$(“选择器”).mousedown()/mouseup()</td><td>鼠标按下/弹起触发事件</td></tr><tr><td>$(“选择器”).mousemove()</td><td>鼠标移动事件</td></tr><tr><td>$(“选择器”).mouseover()/mouseout()</td><td>鼠标移入/移出触发事件</td></tr><tr><td>$(“选择器”).mouseenter()/mouseleave()</td><td>鼠标进入/离开触发事件*</td></tr><tr><td>$(“选择器”).hover(func1,func2)</td><td>鼠标移入调用func1函数，移出调用func2函数</td></tr><tr><td>$(“选择器”).focusin()</td><td>鼠标聚焦到该元素时触发事件</td></tr><tr><td>$(“选择器”).focusout()</td><td>鼠标失去焦点时触发事件</td></tr><tr><td>$(“选择器”).focus()/.blur()</td><td>鼠标聚焦/失去焦点触发事件（不支持冒泡）</td></tr><tr><td>$(“选择器”).change()</td><td>表单元素发生改变时触发事件</td></tr><tr><td>$(“选择器”).select()</td><td>文本元素被选中时触发事件</td></tr><tr><td>$(“选择器”).submit()</td><td>表单提交动作触发*</td></tr><tr><td>$(“选择器”).keydown()/keyup()</td><td>键盘按键按下/弹起触发</td></tr><tr><td>$(“选择器”).keypress()</td><td>键盘按下过程中触发</td></tr></tbody></table><h2 id="jQuery显示与隐藏">jQuery显示与隐藏</h2><p>在jQuery中使用show()方法显示，hide()方法进行隐藏。</p><p>其语法格式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;选择器&quot;</span>).hide(speed,callback)<br><br>$(<span class="hljs-string">&quot;选择器&quot;</span>).show(speed,callback)<br></code></pre></td></tr></table></figure><h2 id="jQuery淡入与淡出">jQuery<strong>淡入</strong>与淡出</h2><p>fadeIn()：用于淡入已隐藏的元素；</p><p>fadeOut()：用于淡出可见元素；</p><p>fadeToggle()：可以在 fadeIn() 与 fadeOut() 方法之间进行切换；</p><p>fadeTo()：允许渐变到指定的不透明度</p><h2 id="jQuery向上或向下滑动">jQuery向上或向下滑动</h2><p>slideUp()用于向上滑动元素</p><p>slideDown()方法用于向下滑动元素</p><p>调用方法分别为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).slideUp(speed,[callback])<br><br>$(selector).slideDown(speed,[callback])<br></code></pre></td></tr></table></figure><h2 id="jQuery简单动画">jQuery简单动画</h2><p>自定义动画的语法定义格式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">animate(params,speed,callback)<br></code></pre></td></tr></table></figure><p><strong>停止动画</strong></p><p>网页中有时需要停止匹配元素正在进行的动画，这时要使用停止元素的动画方法stop()，其语法结构形式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">stop([clearQueue],[gotoEnd])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github加速</title>
    <link href="/2022/04/13/github%E5%8A%A0%E9%80%9F/"/>
    <url>/2022/04/13/github%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">前言</p><p>由于众所周知的原因，全球最大的同性交友网站github在国内的连接十分的不稳定，因此十分不方便交到我们交友，经常在推送和下载仓库时断线或者连接超时，这篇博文就是用来解决这个问题(下载和clone仓库时加速)，通过修改系统hosts文件，绕过国内dns解析，直接访问GitHub的CDN节点，从而达到加速的目的.</p><h2 id="查询github的地址">查询github的地址</h2><p>查询的地址链接   <a href = "https://www.ipaddress.com/">https://www.ipaddress.com/</a></p><p>在此网站查询以下三个网址的ip</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">github<span class="hljs-selector-class">.com</span> <br>assets-cdn<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.com</span> <br>github<span class="hljs-selector-class">.global</span><span class="hljs-selector-class">.ssl</span><span class="hljs-selector-class">.fastly</span>.net<br></code></pre></td></tr></table></figure><p>由于时间不同查询到的IP可能不同</p><h2 id="修改host文件">修改host文件</h2><h3 id="host在windows的路径">host在windows的路径</h3><blockquote><p>C:\Windows\System32\drivers\etc</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">140.82.112.3</span>    github.com<br><span class="hljs-number">185.199.109.153</span>    assets-cdn.github.com<br><span class="hljs-number">199.232.69.194</span>    github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure><p>在文件最下面加上上面这三行，前面的IP就是上一步里面你查询的IP，然后保存退出</p><h2 id="刷新DNS缓存">刷新DNS缓存</h2><p>在windows中打开 powershell</p><p>输入命令 <strong>ipconfig /flushdns</strong></p><p>成功刷新后就全部完成了，推送的时候终于不会掉线超时了。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题杂谈</title>
    <link href="/2022/04/07/perpare/"/>
    <url>/2022/04/07/perpare/</url>
    
    <content type="html"><![CDATA[<h2 id="一些常用的eclipse的快捷键">一些常用的eclipse的快捷键</h2><p>ctrl+shift+o   快速导包</p><p>ctrl+alt+down  快速把当前行复制到下一行</p><h1>常用代码</h1><h3 id="交叉排序">交叉排序</h3><p>关于Comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(a, l1, r1 + <span class="hljs-number">1</span>);<br><br>Arrays.sort(a, l2, r2 + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">return</span> o2-o1;<br>&#125;<br><span class="hljs-comment">//实现数组倒序排序</span><br>&#125;);<br><br>Arrays.sort(a, l2, r2 + <span class="hljs-number">1</span>,(o1, o2) -&gt; &#123;<span class="hljs-keyword">return</span> o2 - o1;&#125;)<br>    <span class="hljs-comment">//替换为lambda表达式</span><br><br>Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Dog&gt;() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Dog o1, Dog o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1.name.compareTo(o2.name);<br>          <span class="hljs-comment">/*  如果参数字符串等于此字符串，则返回值 0；</span><br><span class="hljs-comment">              如果此字符串小于字符串参数，则返回一个小于 0 的值；</span><br><span class="hljs-comment">              如果此字符串大于字符串参数，则返回一个大于 0 的值。</span><br><span class="hljs-comment">          */</span><br>        &#125;<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;给狗狗按名字字母顺序排序：&quot;</span>+list);<br>    &#125;<br><br><span class="hljs-comment">//上面也可以替换为lambda表达式</span><br></code></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="获取所有因数的算法">获取所有因数的算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=Math.sqrt(n);i++)&#123;<br>    <span class="hljs-comment">//通过求一半，减少复杂度</span><br><span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>a1.add(i);<br><span class="hljs-keyword">if</span>(n != i*i)&#123;<br>                    <span class="hljs-comment">//这里其实也可以不要，但是最好写上</span><br>a1.add(n/i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="excel算日期">excel算日期</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">=<span class="hljs-built_in">DATEDIF</span>(<span class="hljs-symbol">A1</span>,<span class="hljs-symbol">A2</span>,<span class="hljs-string">&quot;d&quot;</span>) //日期之差<br>=<span class="hljs-built_in">DATEDIF</span>(<span class="hljs-symbol">A1</span>,<span class="hljs-symbol">A2</span>,<span class="hljs-string">&quot;m&quot;</span>) //月份之差<br>=<span class="hljs-built_in">DATEDIF</span>(<span class="hljs-symbol">A1</span>,<span class="hljs-symbol">A2</span>,<span class="hljs-string">&quot;y&quot;</span>) //年之差<br>=<span class="hljs-symbol">A1</span>-<span class="hljs-number">30</span> 日期加减<br></code></pre></td></tr></table></figure><h3 id="斐波拉契">斐波拉契</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> <span class="hljs-constructor">Fbo(<span class="hljs-params">long</span> <span class="hljs-params">n</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>n<span class="hljs-operator">==</span>2) &#123;</span><br><span class="hljs-pattern-match">    return 1;</span><br><span class="hljs-pattern-match">    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">    return <span class="hljs-constructor">Fbo(<span class="hljs-params">n</span>-1)</span>+<span class="hljs-constructor">Fbo(<span class="hljs-params">n</span>-2)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="斐波拉契公约数">斐波拉契公约数</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">gcd(<span class="hljs-name">f</span>(<span class="hljs-name">n</span>),f(<span class="hljs-name">m</span>)) = f(<span class="hljs-name">gcd</span>(<span class="hljs-name">n</span>,m))<br></code></pre></td></tr></table></figure><h3 id="使用hasNextInt">使用hasNextInt</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br><span class="hljs-keyword">if</span>(sc.hasNextInt()) &#123;<br><span class="hljs-built_in">int</span> countA  = sc.nextInt()<span class="hljs-comment">;</span><br><br><span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>&#125;<span class="hljs-keyword">else</span> &#123;<br>sc.<span class="hljs-keyword">next</span>()<span class="hljs-comment">;</span><br>                &#125;<br><br>&#125;//如果需要hasNextInt用来判断需要 .<span class="hljs-keyword">next</span> 用来吃缓存<br></code></pre></td></tr></table></figure><h3 id="字符相关">字符相关</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">char</span> b<span class="hljs-literal">[]</span> = data.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><br>使用这个方法将字符串转换为<span class="hljs-built_in">char</span>数组，方便遍历<br><br>num.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>-<span class="hljs-character">&#x27;0&#x27;</span><br><br>关于ascall码中字符数字转换为数字<br><br><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;num.length<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>;i++) &#123;<br><span class="hljs-comment">//如果式子里面有i+1这种操作，一定要记住不要遍历完，不然会越界</span><br><br><span class="hljs-keyword">if</span>((num.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>-<span class="hljs-character">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+(num.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>+1)</span>-<span class="hljs-character">&#x27;0&#x27;</span>)&gt;<span class="hljs-number">26</span>) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.print((<span class="hljs-built_in">char</span>)((num.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>-<span class="hljs-character">&#x27;0&#x27;</span>)+<span class="hljs-number">64</span>));<br><br><br></code></pre></td></tr></table></figure><h3 id="dfs">dfs</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>],book[<span class="hljs-number">10</span>],n;<br><span class="hljs-comment">//这里还有需要注意的地方C语言全局变量默认为0</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span>&#123; <span class="hljs-comment">//此时在第step盒子面前，需要往里面放第i张扑克牌</span><br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">if</span>(step==n+<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//这里说明前面的n个盒子已经放好了，这是dfs结束的标志 </span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> ;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">注意这个 return 它的作用不是返回主函数，而是返回上一级的dfs函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">例：如果此时是  dfs(5),遇到这个 return 就会回到上一级的 dfs函数 </span><br><span class="hljs-comment">也就是dfs(4),但此时dfs(4)的大部分语句已经执行了，只需要接着执行 book[i]=0</span><br><span class="hljs-comment">然后继续进入for循环进入下一次的 dfs函数，直到结束。 </span><br><span class="hljs-comment">*/</span> <br><br>&#125;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//说明i号扑克牌还在手里，需要放入step号盒子</span><br>a[step]=i;<span class="hljs-comment">//将i号扑克牌放到第step个盒子中</span><br>book[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//此时i号扑克牌已经被使用</span><br><span class="hljs-built_in">dfs</span>(step+<span class="hljs-number">1</span>);<br><span class="hljs-comment">/*注意这里是自己调用自己，表示此时走到了第step+1个盒子面前*/</span><br>book[i]=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/*book[i]=0表示dfs调用结束了，换句话说就是扑克牌已经全部放完了</span><br><span class="hljs-comment">  需要按照顺序将扑克牌收回，重新放，也就是前面所说的</span><br><span class="hljs-comment"> */</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//这里表示这一级别的dfs函数已经结束了，返回上一级 dfs函数 </span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">//dfs函数的开始 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="bfs">bfs</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs processing"><br><span class="hljs-keyword">public</span> class BFS &#123;<br>    <span class="hljs-comment">//存放节点关系的hashtable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> bfs(<span class="hljs-keyword">HashMap</span>&lt;Character, LinkedList&lt;Character&gt;&gt; graph, <span class="hljs-keyword">HashMap</span>&lt;Character, Integer&gt; <span class="hljs-built_in">dist</span>, Character s) &#123;<br>        <span class="hljs-comment">//建立队列</span><br>        Queue&lt;Character&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//给定起始节点</span><br>        Character start = s;<br>        <span class="hljs-comment">//起始节点放到距离表中</span><br>        <span class="hljs-built_in">dist</span>.put(start, <span class="hljs-number">0</span>);<br>        ((LinkedList&lt;Character&gt;) q).<span class="hljs-built_in">add</span>(start);<br>        <span class="hljs-comment">//遍历,一定要取出栈顶节点再加入</span><br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//取出栈顶节点和栈顶节点到起始节点的距离</span><br>            Character poll = q.poll();<br>            <span class="hljs-keyword">if</span>(poll == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Integer distance = <span class="hljs-built_in">dist</span>.<span class="hljs-built_in">get</span>(poll);<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;节点&quot;</span> + poll + <span class="hljs-string">&quot;到起始节点&quot;</span> + start + <span class="hljs-string">&quot;的距离为&quot;</span> + distance);<br>            distance++;<br>            <span class="hljs-comment">//将邻接节点加入</span><br>            <span class="hljs-keyword">for</span> (Character c : graph.<span class="hljs-built_in">get</span>(poll)) &#123;<br>                <span class="hljs-comment">//如果没遍历过这个节点,加入到队列和距离表中</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dist</span>.containsKey(c)) &#123;<br>                    <span class="hljs-built_in">dist</span>.put(c, distance);<br>                    q.offer(c);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>核心代码<br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 广度优先搜索 </span><br><span class="hljs-comment"> * @param Vs 起点 </span><br><span class="hljs-comment"> * @param Vd 终点 </span><br><span class="hljs-comment"> */</span> <br>bool BFS(Node&amp; Vs, Node&amp; Vd)&#123;  <br>    queue&lt;node&gt; Q;  <br>    Node Vn, Vw;  <br>    <span class="hljs-built_in">int</span> i;  <br>   <br>    <span class="hljs-comment">//初始状态将起点放进队列Q  </span><br>    Q.push(Vs);  <br>    hash(Vw) = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//设置节点已经访问过了！  </span><br>   <br>    <span class="hljs-keyword">while</span> (!Q.empty())&#123;<span class="hljs-comment">//队列不为空，继续搜索！  </span><br>        <span class="hljs-comment">//取出队列的头Vn  </span><br>        Vn = Q.front();  <br>   <br>        <span class="hljs-comment">//从队列中移除  </span><br>        Q.pop();  <br>   <br>        <span class="hljs-keyword">while</span>(Vw = Vn通过某规则能够到达的节点)&#123;  <br>            <span class="hljs-keyword">if</span> (Vw == Vd)&#123;<span class="hljs-comment">//找到终点了！  </span><br>                <span class="hljs-comment">//把路径记录，这里没给出解法  </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//返回  </span><br>            &#125;  <br>   <br>            <span class="hljs-keyword">if</span> (isValid(Vw) &amp;&amp; !visit[Vw])&#123;  <br>                <span class="hljs-comment">//Vw是一个合法的节点并且为白色节点  </span><br>                Q.push(Vw);<span class="hljs-comment">//加入队列Q  </span><br>                hash(Vw) = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//设置节点颜色  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//无解  </span><br>&#125;  &lt;/node&gt;<br></code></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>                    <span class="hljs-comment">//查找我（x）的掌门</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> r=x;                      <span class="hljs-comment">//委托 r 去找掌门</span><br>    <span class="hljs-keyword">while</span> (pre[r ]!=r)           <span class="hljs-comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span><br>    r=pre[r ] ;                 <span class="hljs-comment">// r 就接着找他的上级，直到找到掌门为止。</span><br>    <span class="hljs-keyword">return</span>  r ;                <span class="hljs-comment">//掌门驾到~~~</span><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span>          <span class="hljs-comment">//我想让虚竹和周芷若做朋友</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);         <span class="hljs-comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span><br>    <span class="hljs-keyword">if</span>(fx!=fy)                         <span class="hljs-comment">//玄慈和灭绝显然不是同一个人</span><br>    pre[fx ]=fy;                       <span class="hljs-comment">//方丈只好委委屈屈地当了师太的手下啦</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="大数">大数</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>大数相关知识点<br><span class="hljs-regexp">//</span>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qfikh/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">52832196</span><br><br>        BigInteger sum = BigInteger.ZERO;<br>        <span class="hljs-regexp">//</span>还有 BigInteger.ONE    <br>        <span class="hljs-regexp">//</span>还有 BigInteger.TNE    <br>        <span class="hljs-regexp">//</span>还有 BigInteger.TWO  等大数常量    <br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>        BigInteger iB = new BigInteger(i+<span class="hljs-string">&quot;&quot;</span>).pow(<span class="hljs-number">8</span>);<br>        <span class="hljs-regexp">//</span>大数获取值的时候需要使用字符串，如果是个变量i 可以向上面一样变成字符串<br>        <span class="hljs-regexp">//</span>或者使用 BigInteger mod = BigInteger.valueOf(<span class="hljs-number">123456789</span>) 这样取值<br>        sum = sum.add(iB).mod(mod);<span class="hljs-regexp">//</span>每次都取余一下，保证不会溢出<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="文件输出">文件输出</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//改变输出流，输出到work.txt文件</span><br>PrintStream ps = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PrintStream(<span class="hljs-params">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/work.txt&quot;</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>set<span class="hljs-constructor">Out(<span class="hljs-params">ps</span>)</span>;  <span class="hljs-comment">//文件输出  用System.out.println()即可将内容输出到文件中</span><br><span class="hljs-comment">//文件流输出后直接打印就行</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;niub&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(x + <span class="hljs-string">&quot;&quot;</span> + ((y.compare<span class="hljs-constructor">To(BigInteger.ZERO)</span> &gt; <span class="hljs-number">0</span>)? <span class="hljs-string">&quot;+&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) + y + <span class="hljs-string">&quot;i&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>还没整理，考完整理。。。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/03/07/Redis/"/>
    <url>/2022/03/07/Redis/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">前言:依据狂神说视频整理</p><h2 id="一、Nosql概述">一、Nosql概述</h2><h3 id="1、初识Nosql">1、初识Nosql</h3><p>为什么会使用Nosql呢？我们现在所处于大数据时代，用户的个人信息，社交网络，地理位置，用户自己产生的数据等，数据量十分的庞大，而一般的数据库无法进行分析处理。当访问量过大后，一个服务器承受不了，当出现这种情况后，于是Nosql便应运而生了，Nosql 的全程是Not only sql 不仅仅是sql，因此，他能做的sql 更多。</p><h3 id="2、Nosql的特点">2、Nosql的特点</h3><ul><li><p>方便扩展</p></li><li><p>大数据量的高性能</p></li><li><p>数据类型是多样性的</p></li></ul><p class  = "note note-success">传统RDBMS和Nosql</p><p><span class = "label label-primary">传统的RDBMS</span></p><ul><li><p>结构化的组织</p></li><li><p>SQL</p></li><li><p>数据和关系都存在单独的表中</p></li><li><p>数据定义语言</p></li><li><p>严格的一致性</p></li><li><p>基础的事务</p></li></ul><p><span class = "label label-info">Nosql</span></p><ul><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储，列存储、文档存储、图形数据库</li><li>最终一致性</li><li>CAP定理和BASE(异地多活)</li><li>高性能、高可用、高可扩</li><li></li></ul><h3 id="3、3V-3高">3、3V+3高</h3><p>大数据时代的3V：主要是描述问题的<br>1、海量的Volume<br>2、多样的Variety<br>3、实时的Velocity<br>大数据时代的3高：主要是对程序的要求<br>1、高并发<br>2、高可拓<br>3、高性能</p><h3 id="4、Nosql的四大分类">4、Nosql的四大分类</h3><ul><li><p>KV键值对    例如：redis</p></li><li><p>文档型数据库 例如：MongoDB</p></li><li><p>列存储数据库 例如：Hbase</p></li><li><p>图关系型数据库 例如 ：Neo4j</p></li></ul><h2 id="二、Redis入门">二、Redis入门</h2><h3 id="1、概述">1、概述</h3><p>Redis全称remote dictionary server 远程字典服务，是一个使用C语言编写、支持网络、可基于内存亦可持久化的日志型key-Value数据库，并提供了多种语言的API。Redis 是一个开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p><p>链接: <a href="https://redis.io/">redis官网</a>  | <a href="https://github.com/redis">GitHub上的开源地址</a></p><p>不建议windows ，windows端的github上面已经停更很久了，redis推荐linux</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241106153635577.png" alt="image-20241106153635577"></p><h3 id="2、安装">2、安装</h3><p>CSDN上面有很多教程，这里不再赘述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 阿里云服务器redis安装位置</span><br>/usr/local/bin<br></code></pre></td></tr></table></figure><h2 id="三、基本指令">三、基本指令</h2><p>启动redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">../redis-server redis.conf  //启动服务端<br>redis-cli  //进入客户端<br></code></pre></td></tr></table></figure><h3 id="1、切换数据库">1、切换数据库</h3><p>redis 默认有16个数据库</p><p>可以使用select进行切换数据库</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; select <span class="hljs-number">3</span>                 # 切换数据库<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span><span class="hljs-string">[3]</span>&gt; dbsize                #查看数据库所占的大小 <br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span><span class="hljs-string">[3]</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="2、set和get">2、set和get</h3><p>因为是key-vakue类型的数据库。所以需要使用set和get来进行操作</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span><span class="hljs-string">[3]</span>&gt;set name chenning      #set key value<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span><span class="hljs-string">[3]</span>&gt; get name<br><br><span class="hljs-string">&quot;chenning&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3、查看所有键值">3、查看所有键值</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">3</span>]&gt;keys *<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;name&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4、清除">4、清除</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span><span class="hljs-string">[3]</span>&gt;flushdb               # 清除当前数据库的数据<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span><span class="hljs-string">[3]</span>&gt; keys *<br><br>(empty array)<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; flushall                #清空所有数据库的数据<br><br>OK<br></code></pre></td></tr></table></figure><p><strong>补充说明：</strong></p><p>redis是单线程的 redis是基于内存操作的，cpu不是redis的性能瓶颈 redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程 于是就用了单线程</p><blockquote><p>为什么单线程还这么快?</p></blockquote><ul><li><p>误区一 高性能的服务器一定 是多线程的</p></li><li><p>误区二 多线程的一定比单线程的效率高</p></li></ul><p>redis是将所有的数据放在内存中的所有说使用单线程去擦欧总就是最高的 多线程cpu会上下文切换 对于内存系统来说，没有上下文的切换效率就是最高的，在内存情况下，单线程就是效率最高的方案</p><h2 id="四、Redis入门">四、Redis入门</h2><h3 id="1、key-相关指令">1、key 相关指令</h3><h4 id="1-1-查看是否拥有key">1.1 查看是否拥有key</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; exists name                        #查看是否拥有 name这个键<br><br>(integer) <span class="hljs-number">1</span>                                        #拥有则返回<span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; exists name1<br><br>(integer) <span class="hljs-number">0</span>                                        #不拥有则返回<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="1-2、移动key">1.2、移动key</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; move name <span class="hljs-number">1</span>                        #move key db  将key移动到对应的数据库<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; keys *<br><br>(empty array)<br></code></pre></td></tr></table></figure><h4 id="1-3、查看key值是否存在">1.3、查看key值是否存在</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; exists name                        #查看name这个key在这里存在吗<br><br>(integer) <span class="hljs-number">1</span>                                        #存在<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; exists name1<br><br>(integer) <span class="hljs-number">0</span>                                        #不存在<br><br><br></code></pre></td></tr></table></figure><h4 id="1-4、设置存活时间">1.4、设置存活时间</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; set name chenning<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; expire name <span class="hljs-number">10</span>                    # 设置存活时间为<span class="hljs-number">10</span>秒<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl name                          # 查看剩余的时间<br><br>(integer) <span class="hljs-number">5</span>                                       #还剩<span class="hljs-number">5</span>秒<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl name <br><br>(integer) -<span class="hljs-number">2</span>                                      #已经过期<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get name <br><br>(nil)                                             #值已经无法获取<br><br></code></pre></td></tr></table></figure><h4 id="1-5、查看value的类型">1.5、查看value的类型</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set name chenning<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; type name                        #查看value的类型<br><br>string<br></code></pre></td></tr></table></figure><h3 id="2、String">2、String</h3><h4 id="2-1、追加">2.1、追加</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; get name<br><br><span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; append name <span class="hljs-string">&quot;niubi&quot;</span>              #追加 如果没有的话就会新建<br><br>(integer) <span class="hljs-number">13</span>                                     #这里返回的是字符串的长度<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get name<br><br><span class="hljs-string">&quot;chenningniubi&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-2、查询长度">2.2、查询长度</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; strlen name<br><br>(integer) <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h4 id="2-3、自增和自减">2.3、自增和自减</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set views <span class="hljs-number">0</span><br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get views<br><br><span class="hljs-string">&quot;0&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; incr views             # 增加 <span class="hljs-number">1</span><br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; incr views<br><br>(integer) <span class="hljs-number">2</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; decr views             # 减少 <span class="hljs-number">1</span><br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; decr views<br><br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>增加和减少的时候是可以设置步长的</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; incrby views <span class="hljs-number">10</span>        # 设置步长为<span class="hljs-number">10</span>  一次增加<span class="hljs-number">10</span><br><br>(integer) <span class="hljs-number">12</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; decrby views <span class="hljs-number">4</span>         # 设置步长为<span class="hljs-number">4</span>  一次减少<span class="hljs-number">4</span><br><br>(integer) <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="2-4、截取字符串">2.4、截取字符串</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; getrange name <span class="hljs-number">0</span> <span class="hljs-number">3</span>      #截取 <span class="hljs-number">0</span> 到 <span class="hljs-number">3</span> 位置的字符串<br><br><span class="hljs-string">&quot;chen&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; getrange name <span class="hljs-number">0</span> -<span class="hljs-number">1</span>     #获取全部的额字符串<br><br><span class="hljs-string">&quot;chenningniubi&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-5、替代字符串">2.5、替代字符串</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SETRANGE name <span class="hljs-number">1</span> xx     #将<span class="hljs-number">1</span>后的部分字符串替换为xx<br><br>(integer) <span class="hljs-number">13</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get name <br><br><span class="hljs-string">&quot;cxxnningniubi&quot;</span>                        # 结果<br></code></pre></td></tr></table></figure><h4 id="2-6、设置有存活时间的字符串">2.6、设置有存活时间的字符串</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SETEX yy2 <span class="hljs-number">30</span> <span class="hljs-string">&quot;hello&quot;</span>   #setex key time string<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl yy2 <br><br>(integer) <span class="hljs-number">23</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl yy2 <br><br>(integer) <span class="hljs-number">17</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl yy2 <br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl yy2 <br><br>(integer) -<span class="hljs-number">2</span>                           #已过期<br></code></pre></td></tr></table></figure><h4 id="2-7、设置不存在的key">2.7、设置不存在的key</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SETNX mykey <span class="hljs-string">&quot;db&quot;</span><br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SETNX mykey <span class="hljs-string">&quot;mdu&quot;</span>      #如果key已经存在，则不会做出修改，返回<span class="hljs-number">0</span>失败<br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt;get mykey<br><br><span class="hljs-string">&quot;db&quot;</span>                                   #依旧还是原来的值<br></code></pre></td></tr></table></figure><h4 id="2-8、批量操作key和value">2.8、批量操作key和value</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; mset k<span class="hljs-number">1</span> v<span class="hljs-number">1</span> k<span class="hljs-number">2</span> v<span class="hljs-number">3</span> k<span class="hljs-number">3</span> v<span class="hljs-number">3</span>   #使用 mset 操作，一个key后面跟随一个value值<br><br><span class="hljs-attribute">OK</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; mget k<span class="hljs-number">1</span> k<span class="hljs-number">2</span> k<span class="hljs-number">3</span>            #批量获取key的值<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;v1&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;v3&quot;</span><br><br><span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;v3</span><br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; MSETNX k1 v1 k4 v4       #这里的 msetnx 和上面的是一样的操作，需要注意的就是，<br>                                         #这里是原子性操作，要么一起成功 要么一起失败，例如这里因为设置过k1所以失败了<br>(integer) <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h4 id="2-9、设置对象">2.9、设置对象</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> &#123;<span class="hljs-type">name</span>:zhangsan,age:<span class="hljs-number">3</span>&#125;         #设置一个<span class="hljs-type">json</span>字符串来保存对象<br></code></pre></td></tr></table></figure><p>或者有更巧妙的设计</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; mset user:<span class="hljs-number">1</span>:name zhangsan user:<span class="hljs-number">1</span>:age <span class="hljs-number">2</span><br><br><span class="hljs-attribute">ok</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; mget user:<span class="hljs-number">1</span>:name  user:<span class="hljs-number">1</span>:age <br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-10、getset">2.10、getset</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; getset db redis    # 如果不存在，则返回 nil<br>(nil)<br><span class="hljs-number">127.0.0.1:6379</span>&gt; get db<br><span class="hljs-string">&quot;redis&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; getset db mongodb  #如果存在值，获取原来的值，并设置新的值<br><span class="hljs-string">&quot;redis&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get db<br><span class="hljs-string">&quot;mongodb &quot;</span><br></code></pre></td></tr></table></figure><h3 id="3、List">3、List</h3><p>所有的List命令都是L开头的</p><h4 id="3-1、push">3.1、push</h4><p>像队列一样增加</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; LPUSH list one               #在左边增加one<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LPUSH list two <br><br>(integer) <span class="hljs-number">2</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LPUSH list three<br><br>(integer) <span class="hljs-number">3</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span>             #查看list全部的信息<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> <span class="hljs-number">1</span>              #查看list位置 <span class="hljs-number">0</span> 到 <span class="hljs-number">1</span> 的信息<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><br></code></pre></td></tr></table></figure><p>从右边push</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPUSH list four<br><br>(integer) <span class="hljs-number">4</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;four&quot;</span>                                       #可以看到从右边push后这个four是在最后边的<br></code></pre></td></tr></table></figure><h4 id="3-2、-pop">3.2、 pop</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; RPOP list                       #从右边pop一个数据出来<br><br><span class="hljs-string">&quot;four&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;one&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-3、根据下标获取值">3.3、根据下标获取值</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; LINDEX list <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LINDEX list <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;three&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-4、获取长度">3.4、获取长度</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; LLEN list<br><br>(integer) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="3-5、删除指定的元素">3.5、删除指定的元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; lrem list <span class="hljs-number">1</span> three               #从list里面删除一个three,<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span>                #可以看到list里面仍然还有一个three<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;one&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-6、修建枝叶">3.6、修建枝叶</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; ltrim list <span class="hljs-number">1</span> <span class="hljs-number">2</span>                  #只保留list 里面 <span class="hljs-number">1</span> 到 <span class="hljs-number">2</span> 的元素    list是从<span class="hljs-number">0</span>开始的<br><br><span class="hljs-attribute">OK</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span>  <br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;one&quot;</span>                                         #已经是修改过的了<br></code></pre></td></tr></table></figure><h4 id="3-7、组合命令">3.7、组合命令</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPOPLPUSH list otherlist                       # 使右边的元素弹出并push到otherlist<br><br><span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE otherlist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;one&quot;</span>                                                        <br></code></pre></td></tr></table></figure><h4 id="3-8、Lset更新操作">3.8、Lset更新操作</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; LSET list <span class="hljs-number">1</span> item        #将list中的 <span class="hljs-number">1</span> 号元素改为item<br><br>(error) ERR index out of range          #不存在则会报错<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; lset list <span class="hljs-number">0</span> item<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;item&quot;</span>                               #已经成功的变成了item<br><br>                                        #相当于是一个更新操作，如果不存在则会报错<br></code></pre></td></tr></table></figure><h4 id="3-9、insert插入操作">3.9、insert插入操作</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; RPUSH mylist hello<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPUSH mylist world<br><br>(integer) <span class="hljs-number">2</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LINSERT mylist before world niubi          #往world前面插入niubi<br><br>(integer) <span class="hljs-number">3</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;niubi&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LINSERT mylist after world gan             #往world后面插入gan<br><br>(integer) <span class="hljs-number">4</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;niubi&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;gan&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4、Set">4、Set</h3><p>set命令都是S开头，存储的元素不可以重复</p><h4 id="4-1、添加元素和查看元素">4.1、添加元素和查看元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset <span class="hljs-string">&quot;hello&quot;</span>        # 往set里面添加元素<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset <span class="hljs-string">&quot;world&quot;</span><br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SMEMBERS myset            #查看所有的元素    <br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SISMEMBER myset hello     #查看该元素是否在set中<br><br>(integer) <span class="hljs-number">1</span>                               #含有该元素<br><br></code></pre></td></tr></table></figure><h4 id="4-2、查询set的长度">4.2、查询set的长度</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SCARD myset<br><br>(integer) <span class="hljs-number">2</span>                               #含有两个元素<br></code></pre></td></tr></table></figure><h4 id="4-3、移除元素">4.3、移除元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SREM myset hello          #remove指定元素<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SMEMBERS myset<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;world&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="4-4、抽随机">4.4、抽随机</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SRANDMEMBER myset         # 从set里面随机抽取一个元素出来<br><br><span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SRANDMEMBER myset<br><br><span class="hljs-string">&quot;william&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SRANDMEMBER myset<br><br><span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-5、随机移除-弹出-一个元素">4.5、随机移除(弹出)一个元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SPOP myset                #经典的pop   <br><br><span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SPOP myset<br><br><span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-6、将一个元素转移到另外一个set">4.6、将一个元素转移到另外一个set</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; SMOVE myset myset2 hello        # 组合命令 将hello元素从myset转移到myset2<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SMEMBERS myset<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;william&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SMEMBERS myset2<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-7、差，交，并集">4.7、差，交，并集</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset a<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset b<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset1 b<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset1 c<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SDIFF myset myset1          #查询 myset之于myset1的差集<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SINTER myset myset1         #查询 myset和myset1的交集<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;b&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SUNION myset myset1         #查询 myset和myset1的并集<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;c&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; SDIFF myset1 myset          #查询 myset1之于myset的差集<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;c&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="5、hash">5、hash</h3><p>map集合 key-map</p><h4 id="5-1、增加和获取元素">5.1、增加和获取元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hset myhash field1 chenning          #在myhash中增加 field1 -- chenning 这一对键值对 <br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hget myhash field1                   # 在myhash中查询fields所对应的值<br><br><span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hmset myhash field1 hello field2 world   #批量设置myhash 中的key--value<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hmget myhash field1 field2            #批量获取 myhash 中的key所对应的value<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hgetall myhash                        #获取所有的key和value<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;field1&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;field2&quot;</span><br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-2、删除元素">5.2、删除元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hdel myhash field1                    #删除 myhash 中该 key 所对应的 value<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hgetall myhash<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;field2&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-3、查询hash的长度">5.3、查询hash的长度</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hlen myhash<br><br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="5-4、查询是否存在对应的key">5.4、查询是否存在对应的key</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; HEXISTS myhash field1                #经典的 exists 命令<br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; HEXISTS myhash field2<br><br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="5-5、查询所有的key和value">5.5、查询所有的key和value</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; HKEYS myhash                        # 查询所有的key值<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;field2&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;field1&quot;</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; hvals myhash                        # 查询所有的value值<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;chenning&quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-6、自增和自减">5.6、自增和自减</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hset myhash field3 <span class="hljs-number">5</span><br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; HINCRBY myhash field3 <span class="hljs-number">1</span>             #incrby 命令    <br><br>(integer) <span class="hljs-number">6</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; HINCRBY myhash field3 -<span class="hljs-number">1</span>            #增加负值<br><br>(integer) <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="5-7、setnx">5.7、setnx</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; HSETNX myhash field4 hello        #和之前一样，不存在才可以设置，若存在则不可以使用该命令更改<br><br>(integer) <span class="hljs-number">1</span>  <br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; HSETNX myhash field4 world<br><br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>hash适合变更的数据user、name、age 尤其是用户信息之类的经常变动的信息，hash更适合对象的存储，String更适合字符串的存储</p><h3 id="6、Zset-有序集合">6、Zset  有序集合</h3><p>相对于set 就是增加了排序的功能，其他功能set有的，他都有</p><h4 id="6-1、增加和查看元素">6.1、增加和查看元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD myset <span class="hljs-number">1</span> one<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD myset <span class="hljs-number">2</span> two <span class="hljs-number">3</span> three<br><br>(integer) <span class="hljs-number">2</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGE myset <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;three&quot;</span><br></code></pre></td></tr></table></figure><h4 id="6-2、排序">6.2、排序</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD salary <span class="hljs-number">2500</span> xiaohong <br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD salary <span class="hljs-number">5000</span> zhangsan<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD salary <span class="hljs-number">500</span> chenning<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGEBYSCORE salary -inf +inf                #按照从小到大的顺序排序   -inf 负无穷 +inf 正无穷<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;xiaohong&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br><br></code></pre></td></tr></table></figure><p>排序的其他操作</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD salary <span class="hljs-number">2500</span> xiaohong <br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD salary <span class="hljs-number">5000</span> zhangsan<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZADD salary <span class="hljs-number">500</span> chenning<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGEBYSCORE salary -inf +inf<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;xiaohong&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGEBYSCORE salary <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br>(empty array)<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGEBYSCORE salary -inf <span class="hljs-number">2500</span> withscores     #显示从负无穷到<span class="hljs-number">2500</span>的元素，并把数据显示出来  <br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;500&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;xiaohong&quot;</span><br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;2500&quot;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; ZREVRANGE salary <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; ZREVRANGE salary <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores       #使用 revrange 进行倒序排序<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;5000&quot;</span><br><br><span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;500&quot;</span><br></code></pre></td></tr></table></figure><h4 id="6-3、移除元素">6.3、移除元素</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGE salary <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;xiaohong&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; zrem salary xiaohong          # remove 这个元素<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ZRANGE salary <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chenning&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br></code></pre></td></tr></table></figure><h4 id="6-4、获取元素个数">6.4、获取元素个数</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; zcard salary<br><br>(integer) <span class="hljs-number">2</span>  获取个数<br></code></pre></td></tr></table></figure><h2 id="五、三大特殊数据类型">五、三大特殊数据类型</h2><h3 id="1、geospatial">1、geospatial</h3><h4 id="1-1、-getadd">1.1、 getadd</h4><p>添加国家城市的经纬度信息</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; GEOADD china:city <span class="hljs-number">116</span>.<span class="hljs-number">40</span> <span class="hljs-number">39</span>.<span class="hljs-number">90</span> beijing<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; GEOADD china:city <span class="hljs-number">121</span>.<span class="hljs-number">47</span> <span class="hljs-number">31</span>.<span class="hljs-number">23</span> shanghai<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; GEOADD china:city <span class="hljs-number">106</span>.<span class="hljs-number">50</span> <span class="hljs-number">29</span>.<span class="hljs-number">53</span> chongqing<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; GEOADD china:city <span class="hljs-number">114</span>.<span class="hljs-number">05</span> <span class="hljs-number">22</span>.<span class="hljs-number">52</span> shenzheng<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; GEOADD china:city <span class="hljs-number">120</span>.<span class="hljs-number">16</span> <span class="hljs-number">30</span>.<span class="hljs-number">24</span> hangzhou<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; GEOADD china:city <span class="hljs-number">108</span>.<span class="hljs-number">96</span> <span class="hljs-number">34</span>.<span class="hljs-number">26</span> xian<br><br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li>两级无法直接添加，一般可以可以通过Java一键导入所有城市的信息</li><li>有效的经度从-180度到180度</li><li>有效的维度信息从-85.05112878到85.05112878度</li><li>当坐标位置超出上述的指定的范围的时候，该命令回返回一个错误</li></ul><h4 id="1-2、getpos">1.2、getpos</h4><p>获取城市的位置信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEOPOS china:city beijing chongqing<br><br><span class="hljs-attribute">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;116.39999896287918091&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;39.90000009167092543&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;106.49999767541885376&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;29.52999957900659211&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-3、geodist">1.3、geodist</h4><p>获取两点之间的距离信息</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; GEODIST china:city beijing shanghai km       # 这后面的km是可以换的， 比如 m 等都可以<br><br><span class="hljs-string">&quot;1067.3788&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; GEODIST china:city beijing chongqing km<br><br><span class="hljs-string">&quot;1464.0708&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-4、georadius">1.4、georadius</h4><p>查询指定范围内的城市信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEORADIUS china:city <span class="hljs-number">110</span> <span class="hljs-number">30</span> <span class="hljs-number">1000</span> km          #查询以经纬度<span class="hljs-number">110</span> <span class="hljs-number">30</span>为圆心周围<span class="hljs-number">1000</span>km的城市位置信息 <br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;chongqing&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;xian&quot;</span><br><br><span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;shenzheng&quot;</span><br><br><span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;hangzhou&quot;</span><br><br></code></pre></td></tr></table></figure><p>其他的附带参数</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEORADIUS china:city <span class="hljs-number">110</span> <span class="hljs-number">30</span> <span class="hljs-number">500</span> km withcoord     #跟上面的一样，但是带经纬度的参数<br><br><span class="hljs-attribute">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;chongqing&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;106.49999767541885376&quot;</span><br><br>   <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;29.52999957900659211&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;xian&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;108.96000176668167114&quot;</span><br><br>   <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;34.25999964418929977&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEORADIUS china:city <span class="hljs-number">110</span> <span class="hljs-number">30</span> <span class="hljs-number">500</span> km withdist    #带距离指定位置的距离参数<br><br><span class="hljs-attribute">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;chongqing&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;341.9374&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;xian&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;483.8340&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEORADIUS china:city <span class="hljs-number">110</span> <span class="hljs-number">30</span> <span class="hljs-number">500</span> km withdist withcoord count <span class="hljs-number">1</span>   #带只查询一个的指令参数<br><br><span class="hljs-attribute">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;chongqing&quot;</span><br><br>  <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;341.9374&quot;</span><br><br>  <span class="hljs-attribute">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;106.49999767541885376&quot;</span><br><br>   <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;29.52999957900659211&quot;</span><br></code></pre></td></tr></table></figure><p>通过指定元素来查找元素</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEORADIUSBYMEMBER china:city beijing <span class="hljs-number">1000</span> km      #距离北京<span class="hljs-number">1000</span>km的所有元素<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;beijing&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;xian&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-5、将经纬度转化">1.5、将经纬度转化</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; GEOHASH china:city beijing chongqing       #二维的经纬度转换为一位的字符串 字符串长得越想就越接近<br><br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;wx4fbxxfke0&quot;</span><br><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;wm5xzrybty0&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-6、像set一样操作">1.6、像set一样操作</h4><p>因为其实本质上就是zset所有下面这些操作是都可以进行的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">127.0.0.1:6379&gt;</span> ZRANGE <span class="hljs-symbol">china:</span>city <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chongqing&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;xian&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;shenzheng&quot;</span><br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;hangzhou&quot;</span><br><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;shanghai&quot;</span><br><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;beijing&quot;</span><br><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> ZREM <span class="hljs-symbol">china:</span>city beijing<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> ZRANGE <span class="hljs-symbol">china:</span>city <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;chongqing&quot;</span><br><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;xian&quot;</span><br><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;shenzheng&quot;</span><br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;hangzhou&quot;</span><br><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;shanghai&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2、hyperloglog">2、hyperloglog</h3><p>hyperloglog主要就是关于基数的操作，而基数就是不重复的元素</p><p>优点就是占用的内存固定，2^64不同的元素的技术，只需要12kb的内存，例如在统计网站的访问的次数的时候，一个人访问多次，就可以记为一次。虽然有0.81%的错误率，但是可以忽略</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; PFADD mykey a b c d e f g h i j     # 添加元素<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; PFCOUNT mykey                       # 计数元素的个数<br><br>(integer) <span class="hljs-number">10</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; PFADD mykey2 i j z x c v b n m<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; PFMERGE mykey3 mykey mykey2         #将mykey mykey2中的元素合并到mykey3中<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; PFCOUNT mykey3                      #合并后只有不重复的元素，所有这里只有<span class="hljs-number">15</span>个元素<br><br>(integer) <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="3、bitmaps">3、bitmaps</h3><blockquote><p>位存储<br>统计用户信息，是否活跃，是否登录，两个状态的，都可以使用Bitmaps，Bitmap 位图是数据结构，都是操作二进制来进行记录，只有0和1两个状态，</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">0</span> <span class="hljs-number">1</span>                   #为每一位设置状态<br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">2</span> <span class="hljs-number">0</span><br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setbit sign <span class="hljs-number">6</span> <span class="hljs-number">0</span><br><br>(integer) <span class="hljs-number">0</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; getbit sign <span class="hljs-number">3</span>                     #获取状态<br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; getbit sign <span class="hljs-number">5</span><br><br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>获取sign为1的数量</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; BITCOUNT sign<br><br>(integer) <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h2 id="六、事务">六、事务</h2><ul><li>Redis事务的本质就是一组命令的组合，一个事务中所有的命令都会被序列化，在事务执行的过程中，会按照顺序执行，一次性，顺序性，排他性的执行一些列的命令</li><li>Redis的事务没有隔离级别的概念，所有的命令在事务中，只有发起执行命令<strong>exec</strong> 才会执行</li><li>Redis单条命令式保留原子性，但是事务并不保留原子性，</li></ul><blockquote><p>redis的事务</p></blockquote><ul><li>开启事务(multi)</li><li>命令入队</li><li>执行事务(exec)</li></ul><h3 id="1、正常的执行事务">1、正常的执行事务</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; multi               #开启事务命令<br><br><span class="hljs-attribute">OK</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>(TX)&gt; set k<span class="hljs-number">1</span> v<span class="hljs-number">1</span><br><br><span class="hljs-attribute">QUEUED</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>(TX)&gt; set k<span class="hljs-number">2</span> v<span class="hljs-number">2</span><br><br><span class="hljs-attribute">QUEUED</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>(TX)&gt; get k<span class="hljs-number">2</span><br><br><span class="hljs-attribute">QUEUED</span><br><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>(TX)&gt; set k<span class="hljs-number">3</span> v<span class="hljs-number">3</span><br><br><span class="hljs-attribute">QUEUED</span><br> <br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>(TX)&gt; exec            #执行事务命令<br><br><span class="hljs-attribute">1</span>) OK<br><br><span class="hljs-attribute">2</span>) OK<br><br><span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;v2&quot;</span><br><br><span class="hljs-attribute">4</span>) OK<br></code></pre></td></tr></table></figure><h3 id="2、放弃事务">2、放弃事务</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><br><span class="hljs-number">127.0.0.1:6379</span>&gt; MULTI<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k1 v1 <br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k4 v4<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; DISCARD           #放弃事务命令<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get k4<br><br>(nil)<br></code></pre></td></tr></table></figure><h3 id="3、执行事务时的异常">3、执行事务时的异常</h3><p>事务的异常分为两种，编译时的异常和执行时的异常，下面主要写一下两种异常的不同点</p><h4 id="3-1、编译时异常">3.1、编译时异常</h4><p>编译时的异常即代表你的语法可能就有问题，一旦一句有问题，整个事务都不能正常运行</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k1 v1<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k2 v2<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; getset k3<br><br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command         #这里就开始提示有err<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k4 v4<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; exec<br><br>(error) EXECABORT Transaction discarded because of previous errors.         # 导致整个事务都不能正常运行<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get k5<br><br>(nil)<br></code></pre></td></tr></table></figure><h4 id="3-2、运行时错误">3.2、运行时错误</h4><p>运行时错误表示语法没有啥问题，是其他地方除了问题，仅仅只影响那一句话，其他的依旧可以正常的执行</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; MULTI<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; incr k1           #这里的k1对应的value是一个字符串，是不能增加 <span class="hljs-number">1</span> 的<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k2 v2<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; set k3 v3<br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; get k3<br><br>QUEUED                                  #前面的语句语法都没有任何的问题 <br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; exec<br><br><span class="hljs-number">1</span>) (error) ERR value is not an integer or out of range       #事务的第一句不能正常执行<br><br><span class="hljs-number">2</span>) OK<br><br><span class="hljs-number">3</span>) OK<br><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;v3&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get k2<br><br><span class="hljs-string">&quot;v2&quot;</span><br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get k3<br><br><span class="hljs-string">&quot;v3&quot;</span>                                     #事务的其他语句是可以正常运行的<br></code></pre></td></tr></table></figure><h2 id="七、Redis实现乐观锁">七、Redis实现乐观锁</h2><blockquote><p>悲观锁</p></blockquote><p>认为什么时候都会出错，无论做什么都会枷锁，效率低下</p><blockquote><p>乐观锁</p></blockquote><p>-认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人去修改过这个数据</p><ul><li>获取version</li><li>更新的时候比较version</li></ul><p><strong>单线程的时候</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set money <span class="hljs-number">100</span><br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; set out <span class="hljs-number">0</span><br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; watch money    # 加锁<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; DECRBY money <span class="hljs-number">20</span><br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; INCRBY out <span class="hljs-number">20</span><br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; exec<br><br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">80</span><br><br><span class="hljs-number">2</span>) (integer) <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; watch money<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br><br>OK<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; DECRBY money <span class="hljs-number">10</span><br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; INCRBY out <span class="hljs-number">10</span><br><br>QUEUED<br><br><span class="hljs-number">127.0.0.1:6379</span>(TX)&gt; exec      # 在执行这个事务前，有其他的线程改变了这个值，则会导致执行失败<br><br>(nil)<br></code></pre></td></tr></table></figure><p>若执行失败，则正确操作为:<br><img src="https://img-blog.csdnimg.cn/ccf1491997604555802786a4838fb3e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="解锁"></p><h2 id="八、Jedis">八、Jedis</h2><p>就是使用Java操作redis</p><h3 id="1、简单的使用一下Jedis">1、简单的使用一下Jedis</h3><p>首先导入包</p><p><img src="https://s2.loli.net/2022/04/14/V9qPSWK72ebiouh.png" alt="image-20220414100910101"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/14/bC7i5e9qy3Y6AoT.png" alt="image-20220414100943921"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.80<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>简单的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">static</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;&#125;<br>     jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<span class="hljs-comment">//使用对象来操作</span><br>     Sysrtem.out.printn(jedis.ping);<span class="hljs-comment">//测试链接</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、常用的api">2、常用的api</h3><h4 id="String">String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br><br>        jedis.flushDB();<br>        System.out.println(<span class="hljs-string">&quot;===========增加数据===========&quot;</span>);<br>        System.out.println(jedis.set(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;value1&quot;</span>));<br>        System.out.println(jedis.set(<span class="hljs-string">&quot;key2&quot;</span>,<span class="hljs-string">&quot;value2&quot;</span>));<br>        System.out.println(jedis.set(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除键key2:&quot;</span>+jedis.del(<span class="hljs-string">&quot;key2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取键key2:&quot;</span>+jedis.get(<span class="hljs-string">&quot;key2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;修改key1:&quot;</span>+jedis.set(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1Changed&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取key1的值：&quot;</span>+jedis.get(<span class="hljs-string">&quot;key1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;在key3后面加入值：&quot;</span>+jedis.append(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;End&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;key3的值：&quot;</span>+jedis.get(<span class="hljs-string">&quot;key3&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;增加多个键值对：&quot;</span>+jedis.mset(<span class="hljs-string">&quot;key01&quot;</span>,<span class="hljs-string">&quot;value01&quot;</span>,<span class="hljs-string">&quot;key02&quot;</span>,<span class="hljs-string">&quot;value02&quot;</span>,<span class="hljs-string">&quot;key03&quot;</span>,<span class="hljs-string">&quot;value03&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="hljs-string">&quot;key01&quot;</span>,<span class="hljs-string">&quot;key02&quot;</span>,<span class="hljs-string">&quot;key03&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="hljs-string">&quot;key01&quot;</span>,<span class="hljs-string">&quot;key02&quot;</span>,<span class="hljs-string">&quot;key03&quot;</span>,<span class="hljs-string">&quot;key04&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="hljs-string">&quot;key01&quot;</span>,<span class="hljs-string">&quot;key02&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="hljs-string">&quot;key01&quot;</span>,<span class="hljs-string">&quot;key02&quot;</span>,<span class="hljs-string">&quot;key03&quot;</span>));<br><br>        jedis.flushDB();<br>        System.out.println(<span class="hljs-string">&quot;===========新增键值对防止覆盖原先值==============&quot;</span>);<br>        System.out.println(jedis.setnx(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>));<br>        System.out.println(jedis.setnx(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>));<br>        System.out.println(jedis.setnx(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2-new&quot;</span>));<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;key1&quot;</span>));<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;key2&quot;</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;===========新增键值对并设置有效时间=============&quot;</span>);<br>        System.out.println(jedis.setex(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;value3&quot;</span>));<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;key3&quot;</span>));<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;key3&quot;</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;===========获取原值，更新为新值==========&quot;</span>);<br>        System.out.println(jedis.getSet(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;key2GetSet&quot;</span>));<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;key2&quot;</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;获得key2的值的字串：&quot;</span>+jedis.getrange(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="List">List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestList</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.flushDB();<br>        System.out.println(<span class="hljs-string">&quot;===========添加一个list===========&quot;</span>);<br>        jedis.lpush(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-string">&quot;ArrayList&quot;</span>, <span class="hljs-string">&quot;Vector&quot;</span>, <span class="hljs-string">&quot;Stack&quot;</span>, <span class="hljs-string">&quot;HashMap&quot;</span>, <span class="hljs-string">&quot;WeakHashMap&quot;</span>, <span class="hljs-string">&quot;LinkedHashMap&quot;</span>);<br>        jedis.lpush(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-string">&quot;HashSet&quot;</span>);<br>        jedis.lpush(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-string">&quot;TreeSet&quot;</span>);<br>        jedis.lpush(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-string">&quot;TreeMap&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<span class="hljs-comment">//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部</span><br>        System.out.println(<span class="hljs-string">&quot;collections区间0-3的元素：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br>        <span class="hljs-comment">// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈</span><br>        System.out.println(<span class="hljs-string">&quot;删除指定元素个数：&quot;</span>+jedis.lrem(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;HashMap&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除下表0-3区间之外的元素：&quot;</span>+jedis.ltrim(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections列表出栈（左端）：&quot;</span>+jedis.lpop(<span class="hljs-string">&quot;collections&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections添加元素，从列表右端，与lpush相对应：&quot;</span>+jedis.rpush(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-string">&quot;EnumMap&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections列表出栈（右端）：&quot;</span>+jedis.rpop(<span class="hljs-string">&quot;collections&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;修改collections指定下标1的内容：&quot;</span>+jedis.lset(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;LinkedArrayList&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;collections的长度：&quot;</span>+jedis.llen(<span class="hljs-string">&quot;collections&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取collections下标为2的元素：&quot;</span>+jedis.lindex(<span class="hljs-string">&quot;collections&quot;</span>, <span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br>        jedis.lpush(<span class="hljs-string">&quot;sortedList&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;sortedList排序前：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;sortedList&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>        System.out.println(jedis.sort(<span class="hljs-string">&quot;sortedList&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sortedList排序后：&quot;</span>+jedis.lrange(<span class="hljs-string">&quot;sortedList&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Set">Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.flushDB();<br>        System.out.println(<span class="hljs-string">&quot;============向集合中添加元素（不重复）============&quot;</span>);<br>        System.out.println(jedis.sadd(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>,<span class="hljs-string">&quot;e2&quot;</span>,<span class="hljs-string">&quot;e4&quot;</span>,<span class="hljs-string">&quot;e3&quot;</span>,<span class="hljs-string">&quot;e0&quot;</span>,<span class="hljs-string">&quot;e8&quot;</span>,<span class="hljs-string">&quot;e7&quot;</span>,<span class="hljs-string">&quot;e5&quot;</span>));<br>        System.out.println(jedis.sadd(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e6&quot;</span>));<br>        System.out.println(jedis.sadd(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e6&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除一个元素e0：&quot;</span>+jedis.srem(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e0&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除两个元素e7和e6：&quot;</span>+jedis.srem(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e7&quot;</span>,<span class="hljs-string">&quot;e6&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;随机的移除集合中的一个元素：&quot;</span>+jedis.spop(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;随机的移除集合中的一个元素：&quot;</span>+jedis.spop(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet中包含元素的个数：&quot;</span>+jedis.scard(<span class="hljs-string">&quot;eleSet&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;e3是否在eleSet中：&quot;</span>+jedis.sismember(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e3&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;e1是否在eleSet中：&quot;</span>+jedis.sismember(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;e1是否在eleSet中：&quot;</span>+jedis.sismember(<span class="hljs-string">&quot;eleSet&quot;</span>, <span class="hljs-string">&quot;e5&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;=================================&quot;</span>);<br>        System.out.println(jedis.sadd(<span class="hljs-string">&quot;eleSet1&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>,<span class="hljs-string">&quot;e2&quot;</span>,<span class="hljs-string">&quot;e4&quot;</span>,<span class="hljs-string">&quot;e3&quot;</span>,<span class="hljs-string">&quot;e0&quot;</span>,<span class="hljs-string">&quot;e8&quot;</span>,<span class="hljs-string">&quot;e7&quot;</span>,<span class="hljs-string">&quot;e5&quot;</span>));<br>        System.out.println(jedis.sadd(<span class="hljs-string">&quot;eleSet2&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>,<span class="hljs-string">&quot;e2&quot;</span>,<span class="hljs-string">&quot;e4&quot;</span>,<span class="hljs-string">&quot;e3&quot;</span>,<span class="hljs-string">&quot;e0&quot;</span>,<span class="hljs-string">&quot;e8&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;将eleSet1中删除e1并存入eleSet3中：&quot;</span>+jedis.smove(<span class="hljs-string">&quot;eleSet1&quot;</span>, <span class="hljs-string">&quot;eleSet3&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>));<span class="hljs-comment">//移到集合元素</span><br>        System.out.println(<span class="hljs-string">&quot;将eleSet1中删除e2并存入eleSet3中：&quot;</span>+jedis.smove(<span class="hljs-string">&quot;eleSet1&quot;</span>, <span class="hljs-string">&quot;eleSet3&quot;</span>, <span class="hljs-string">&quot;e2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet1中的元素：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet3中的元素：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet3&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;============集合运算=================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;eleSet1中的元素：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet2中的元素：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet1和eleSet2的交集:&quot;</span>+jedis.sinter(<span class="hljs-string">&quot;eleSet1&quot;</span>,<span class="hljs-string">&quot;eleSet2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet1和eleSet2的并集:&quot;</span>+jedis.sunion(<span class="hljs-string">&quot;eleSet1&quot;</span>,<span class="hljs-string">&quot;eleSet2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;eleSet1和eleSet2的差集:&quot;</span>+jedis.sdiff(<span class="hljs-string">&quot;eleSet1&quot;</span>,<span class="hljs-string">&quot;eleSet2&quot;</span>));<span class="hljs-comment">//eleSet1中有，eleSet2中没有</span><br>        jedis.sinterstore(<span class="hljs-string">&quot;eleSet4&quot;</span>,<span class="hljs-string">&quot;eleSet1&quot;</span>,<span class="hljs-string">&quot;eleSet2&quot;</span>);<span class="hljs-comment">//求交集并将交集保存到dstkey的集合</span><br>        System.out.println(<span class="hljs-string">&quot;eleSet4中的元素：&quot;</span>+jedis.smembers(<span class="hljs-string">&quot;eleSet4&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Hash">Hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHash</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.flushDB();<br>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>        map.put(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;value1&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;key2&quot;</span>,<span class="hljs-string">&quot;value2&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;key3&quot;</span>,<span class="hljs-string">&quot;value3&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;key4&quot;</span>,<span class="hljs-string">&quot;value4&quot;</span>);<br>        <span class="hljs-comment">//添加名称为hash（key）的hash元素</span><br>        jedis.hmset(<span class="hljs-string">&quot;hash&quot;</span>,map);<br>        <span class="hljs-comment">//向名称为hash的hash中添加key为key5，value为value5元素</span><br>        jedis.hset(<span class="hljs-string">&quot;hash&quot;</span>, <span class="hljs-string">&quot;key5&quot;</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="hljs-string">&quot;hash&quot;</span>));<span class="hljs-comment">//return Map&lt;String,String&gt;</span><br>        System.out.println(<span class="hljs-string">&quot;散列hash的所有键为：&quot;</span>+jedis.hkeys(<span class="hljs-string">&quot;hash&quot;</span>));<span class="hljs-comment">//return Set&lt;String&gt;</span><br>        System.out.println(<span class="hljs-string">&quot;散列hash的所有值为：&quot;</span>+jedis.hvals(<span class="hljs-string">&quot;hash&quot;</span>));<span class="hljs-comment">//return List&lt;String&gt;</span><br>        System.out.println(<span class="hljs-string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="hljs-string">&quot;hash&quot;</span>, <span class="hljs-string">&quot;key6&quot;</span>, <span class="hljs-number">6</span>));<br>        System.out.println(<span class="hljs-string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="hljs-string">&quot;hash&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="hljs-string">&quot;hash&quot;</span>, <span class="hljs-string">&quot;key6&quot;</span>, <span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="hljs-string">&quot;hash&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除一个或者多个键值对：&quot;</span>+jedis.hdel(<span class="hljs-string">&quot;hash&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="hljs-string">&quot;hash&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;散列hash中键值对的个数：&quot;</span>+jedis.hlen(<span class="hljs-string">&quot;hash&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;判断hash中是否存在key2：&quot;</span>+jedis.hexists(<span class="hljs-string">&quot;hash&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;判断hash中是否存在key3：&quot;</span>+jedis.hexists(<span class="hljs-string">&quot;hash&quot;</span>,<span class="hljs-string">&quot;key3&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="hljs-string">&quot;hash&quot;</span>,<span class="hljs-string">&quot;key3&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="hljs-string">&quot;hash&quot;</span>,<span class="hljs-string">&quot;key3&quot;</span>,<span class="hljs-string">&quot;key4&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Key">Key</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestKey</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;清空数据：&quot;</span>+jedis.flushDB());<br>        System.out.println(<span class="hljs-string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="hljs-string">&quot;username&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;kuangshen&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>));<br>        System.out.print(<span class="hljs-string">&quot;系统中所有的键如下：&quot;</span>);<br>        Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>        System.out.println(keys);<br>        System.out.println(<span class="hljs-string">&quot;删除键password:&quot;</span>+jedis.del(<span class="hljs-string">&quot;password&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="hljs-string">&quot;password&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="hljs-string">&quot;username&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());<br>        System.out.println(<span class="hljs-string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="hljs-string">&quot;name&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());<br>        System.out.println(<span class="hljs-string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());<br>        System.out.println(<span class="hljs-string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Password">Password</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPassword</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//验证密码，如果没有设置密码这段代码省略</span><br><span class="hljs-comment">//        jedis.auth(&quot;password&quot;);</span><br><br>        jedis.connect(); <span class="hljs-comment">//连接</span><br>        jedis.disconnect(); <span class="hljs-comment">//断开连接</span><br><br>        jedis.flushAll(); <span class="hljs-comment">//清空所有的key</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、事务">3、事务</h3><p>让我们看看在boot里面如何使用事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Transaction;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMulti</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建客户端连接服务端，redis服务端需要被开启</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.flushDB();<br><br>        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();<br>        jsonObject.put(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>);<br>        <span class="hljs-comment">//开启事务</span><br>        Transaction multi = jedis.multi();<br>        String result = jsonObject.toJSONString();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//向redis存入一条数据</span><br>            multi.set(<span class="hljs-string">&quot;json&quot;</span>, result);<br>            <span class="hljs-comment">//再存入一条数据</span><br>            multi.set(<span class="hljs-string">&quot;json2&quot;</span>, result);<br>            <span class="hljs-comment">//这里引发了异常，用0作为被除数</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//如果没有引发异常，执行进入队列的命令</span><br>            multi.exec();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">//如果出现异常，回滚</span><br>            multi.discard();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            System.out.println(jedis.get(<span class="hljs-string">&quot;json&quot;</span>));<br>            System.out.println(jedis.get(<span class="hljs-string">&quot;json2&quot;</span>));<br>            <span class="hljs-comment">//最终关闭客户端</span><br>            jedis.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4、Springboot-整合">4、Springboot 整合</h3><p>在spring boot2.x之后，原来使用的jedis被替换成了lettuce</p><ul><li><p>jedis所采用的直连，多个线程操作的时候不安全，如果想要追求安全 ，可以使用jedis pool连接池</p></li><li><p>lettuce 采用netty 实例可以在多个线程中进行共享，不存在线程不安全的情况，更像NIO</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">    name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>    <span class="hljs-comment">//两个泛型都是object 类，我们后使用需要强制转换</span><br>    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate();<br>    template.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-keyword">return</span> template;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-comment">//由于String时redis最常使用的类型，所以单独提出来了一个方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>    template.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-keyword">return</span> template;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1、整合步骤">1、整合步骤</h4><p>1.导入依赖    --上面的jedis的包</p><p>2.配置链接</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">password:</span> <br>      <span class="hljs-attr">jedis:</span><br>        <span class="hljs-attr">pool:</span><br>          <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>          <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span><br>          <span class="hljs-attr">max-idle:</span> <span class="hljs-number">500</span><br>          <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">lettuce:</span><br>        <span class="hljs-attr">shutdown-timeout:</span> <span class="hljs-string">0ms</span><br></code></pre></td></tr></table></figure><p>3.测试</p><h4 id="2、编写自己的-redisTemplate">2、编写自己的 redisTemplate</h4><p>这里需要注意一下要直接传输对象的话需要将对象序列化，比如下面这样讲pojo的类实现序列化的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">user</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己的template</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>      RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();<br><br>      template.setConnectionFactory(factory);<br><br>      <span class="hljs-comment">//序列化配置</span><br>      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br><br>      ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>      jackson2JsonRedisSerializer.setObjectMapper(om);<br><br>      <span class="hljs-comment">//String序列化</span><br>      StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br><br>      <span class="hljs-comment">// key采用String的序列化方式</span><br>      template.setKeySerializer(stringRedisSerializer);<br>      <span class="hljs-comment">// hash的key也采用String的序列化方式</span><br>      template.setHashKeySerializer(stringRedisSerializer);<br>      <span class="hljs-comment">// value序列化方式采用jackson</span><br>      template.setValueSerializer(jackson2JsonRedisSerializer);<br>      <span class="hljs-comment">// hash的value序列化方式采用jackson</span><br>      template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>      template.afterPropertiesSet();<br><br>      <span class="hljs-keyword">return</span> template;<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用工具类封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtil</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;redisTemplate&quot;)</span><span class="hljs-comment">//指定那个redisTemplate,可以不写</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-comment">// =============================common============================</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定缓存失效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                redisTemplate.expire(key, time, TimeUnit.SECONDS);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key 获取过期时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断key是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasKey</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.hasKey(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 可以传一个值 或多个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String... key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span> &amp;&amp; key.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (key.length == <span class="hljs-number">1</span>) &#123;<br>                redisTemplate.delete(key[<span class="hljs-number">0</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                redisTemplate.delete(CollectionUtils.arrayToList(key));<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// ============================String=============================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : redisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存放入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForValue().set(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存放入并设置时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false 失败</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递增</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要增加几(大于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递增因子必须大于0&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, delta);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递减</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要减少几(小于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">decr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递减因子必须大于0&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);<br>    &#125;<br><br><br>    <span class="hljs-comment">// ================================Map=================================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashGet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hget</span><span class="hljs-params">(String key, String item)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().get(key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取hashKey对应的所有键值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对应的多个键值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Object, Object&gt; <span class="hljs-title">hmget</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().entries(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashSet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 对应多个键值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().putAll(key, map);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashSet 并设置时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map  对应多个键值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().putAll(key, map);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                expire(key, time);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().put(key, item, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().put(key, item, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                expire(key, time);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除hash表中的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 可以使多个 不能为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hdel</span><span class="hljs-params">(String key, Object... item)</span> </span>&#123;<br>        redisTemplate.opsForHash().delete(key, item);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断hash表中是否有该项的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hHasKey</span><span class="hljs-params">(String key, String item)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要增加几(大于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hincr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash递减</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要减少记(小于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hdecr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);<br>    &#125;<br><br><br>    <span class="hljs-comment">// ============================set=============================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key获取Set中的所有值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">sGet</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().members(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据value从一个set中查询,是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sHasKey</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(key, value);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将数据放入set缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSet</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().add(key, values);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将set数据放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time   时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSetAndTime</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long count = redisTemplate.opsForSet().add(key, values);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取set缓存的长度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sGetSetSize</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除值为value的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">setRemove</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long count = redisTemplate.opsForSet().remove(key, values);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ===============================list=================================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取list缓存的内容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 开始</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   结束 0 到 -1代表所有值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">lGet</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().range(key, start, end);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取list缓存的长度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lGetListSize</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().size(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过索引 获取list中的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">lGetIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().index(key, index);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPush(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPush(key, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPushAll(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPushAll(key, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引修改list中的某条数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lUpdateIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().set(key, index, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除N个值为value</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 移除多少个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lRemove</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> count, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long remove = redisTemplate.opsForList().remove(key, count, value);<br>            <span class="hljs-keyword">return</span> remove;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowird</span><br><span class="hljs-keyword">private</span> RedisUtil redisUtil; <span class="hljs-comment">//装配工具类</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>  redisUtil.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;chenning&quot;</span>);<span class="hljs-comment">//直接使用就行</span><br>  System.out.println(redisUtil.get(<span class="hljs-string">&quot;name&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>重要的是去理解redis的思想和使用情景</p><h2 id="九、redis-conf详解">九、redis.conf详解</h2><p>文件的位置<p class="label label-success">默认路径 /usr/local/bin/Nconfig</p></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220414174009767.png" alt="image-20220414174009767"></p><p>配置文件对于大小写不敏感</p><h3 id="1、包含-INCLUDES">1、包含 INCLUDES</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">include /path/to/local.conf<br><br>include /path/to/other.conf<br></code></pre></td></tr></table></figure><p>好比是spring里面的import</p><h3 id="2、网络-NETWORK">2、网络 NETWORK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1 -::1<br><br><br><span class="hljs-comment"># 是否开启保护模式</span><br>protected-mode yes<br><br><br><span class="hljs-comment"># 端口设置</span><br>port 6379<br></code></pre></td></tr></table></figure><h3 id="3、通用配置-GENERAL">3、通用配置 GENERAL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以守护进程的方式进行</span><br>daemonize yes  <br><span class="hljs-comment"># 默认是关闭的，我们这里选择开启</span><br><br><br><br><span class="hljs-comment"># 如果以后台的形式运行 需要指定一个pid文件</span><br>pidfile /var/run/redis_6379.pid<br><br><br><br><span class="hljs-comment"># 日志</span><br><span class="hljs-comment"># Specify the server verbosity level.</span><br><span class="hljs-comment"># This can be one of:</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br>    <br>loglevel notice<br><br><span class="hljs-comment">#日志文件位置名</span><br>logfile <span class="hljs-string">&quot;&quot;</span><br>    <br><span class="hljs-comment">#默认库的数量是16个</span><br>databases 16<br></code></pre></td></tr></table></figure><h3 id="4、快照-SNAPSHOT">4、快照 SNAPSHOT</h3><p>所谓的快照就是持久化</p><p>在持久化的过程中，redis中的数据会持久化到以<span class="label label-primary"> .rdb </span>或者<span class="label label-primary"> .aof </span></p><p>因为redis是内存数据库，因此数据断电即失，所以需要隔一段时间就持久化一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">save 3600 1       <span class="hljs-comment"># 如果3600内有1次修改数据就持久化一次</span><br><br>save 300 100      <span class="hljs-comment"># 如果300内有100次修改数据就持久化一次</span><br><br>save 60 10000     <span class="hljs-comment"># 如果60内有10000次修改数据就持久化一次</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">stop-writes-on-bgsave-error yes <span class="hljs-comment"># 持久化操作错误后是否操作</span><br><br>rdbcompression yes              <span class="hljs-comment"># 是否压缩持久化数据</span><br><br>rdbchecksum yes                 <span class="hljs-comment"># 持久化后是否检查</span><br><br>dir ./                          <span class="hljs-comment"># .rdb文件保存的目录</span><br></code></pre></td></tr></table></figure><h3 id="5、安全">5、安全</h3><p>限制client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 最大的连接数</span><br><span class="hljs-comment"># maxclients 10000</span><br><br><span class="hljs-comment"># 控制节点能使用的最大内存</span><br><span class="hljs-comment"># maxmemory &lt;bytes&gt;</span><br><br><span class="hljs-comment"># 内存满之后的处理策略</span><br><span class="hljs-comment"># maxmemory-policy noeviction</span><br></code></pre></td></tr></table></figure><p class="note note-danger">有六种淘汰策略</p><ol><li><p>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</p></li><li><p>allkeys-lru：从所有key中使用LRU算法进行淘汰</p></li><li><p>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</p></li><li><p>allkeys-random：从所有key中随机淘汰数据</p></li><li><p>volatile-random：从设置了过期时间的key中随机淘汰</p></li><li><p>volatile-ttl：在设置了过期时间的key中，淘汰过期时间剩余最短的</p></li></ol><h3 id="6、append-only-模式-aof配置">6、append only 模式 aof配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认使用rdb 因为完全够用 不开启aof  </span><br>appendonly no  <br><br><span class="hljs-comment"># aof文件的名字</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br><br><span class="hljs-comment">#下面三个只选择一个开</span><br><span class="hljs-comment"># appendfsync always  # 每次修改都会同步，但过于消耗性能</span><br><br>appendfsync everysec  <span class="hljs-comment"># 每秒执行一次同步，但会丢失这1s的数据</span><br><br><span class="hljs-comment"># appendfsync no      # 不执行同步，操作系统自己同步数据，速度最快</span><br></code></pre></td></tr></table></figure><h2 id="十、持久化">十、持久化</h2><p>持久化是 <span class="label label-danger">重点</span></p><p class="note note-primary">为什么需要持久化</p><p>redis是一个内存数据库，如果不将数据库里面的数据保存到磁盘，服务一旦停止，那么数据就会全部丢失!因此redis需要通过持久化将数据都保存下来,redis的持久化有两种方式，RDB和AOF</p><h3 id="1、RDB">1、RDB</h3><p>RDB的全程就是redis database，它通过再指定的时间间隔内将内存种的数据集快照写入磁盘，也就是snapshot快照，他恢复时是将快照文件直接读取到内存里面(感觉像是我以前写的租车管理系统😐)，Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件种，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程时是不进行任何IO操作的。这就确保了极高的性能。如果要进行大规模数据的恢复，且对于数据恢复的完整性不是特别的敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化的数据可能会丢失，Redis默认的就是RDB，一般需要修改。</p><h4 id="1-1-触发机制">1.1 触发机制</h4><p>RDB的触发机制有下面三种</p><ol><li><p>save规则满足（save的配置上一节有）</p></li><li><p>执行flushAll 命令</p></li><li><p>退出redis</p></li></ol><h4 id="1-2-如何恢复">1.2 如何恢复</h4><p>这个比较容易，只需要将rdb文件放在我们的启动目录下就行，redis启动的时候会自动检查dump.rdb恢复其中的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; config get dir  <span class="hljs-comment">#输入这个指令就可以得到启动目录，将rdb放里面就行</span><br>1) <span class="hljs-string">&quot;dir&quot;</span><br>2) <span class="hljs-string">&quot;/usr/local/bin&quot;</span> <br></code></pre></td></tr></table></figure><h4 id="1-3-优缺点">1.3 优缺点</h4><p class="label label-success">优点</p><ol><li><p>适合大规模的数据恢复</p></li><li><p>对数据的完整性要不高</p></li></ol><p class="label label-danger">缺点</p><ol><li><p>需要一定的时间间隔进程操作，如果redis意外宕机，最后一次的数据就无了</p></li><li><p>fork进程的时候，会占用一定的内容空间</p></li></ol><h3 id="2、AOF">2、AOF</h3><p>AOF全称appendonly file，只追加保存，默认是不保存的，需要手动配置然后 重启redis就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly no <span class="hljs-comment"># 把这里改成yes就行</span><br></code></pre></td></tr></table></figure><h4 id="2-1-AOF文件受损恢复">2.1 AOF文件受损恢复</h4><p>redis提供了一个修复aof的工具 “redis-check-aof --fix”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-check-aof --fix appendonly.aof     <span class="hljs-comment"># 输入这个指令进行AOf修复</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/20220415223451.png" alt="修复截图"></p><p>修复之后可能会损失一些数据,但总比全部丢了好</p><h4 id="2-2-AOF的rewrite">2.2 AOF的rewrite</h4><p>aof默认就是文件无限制的追加，因此如果一个文件太大之后，AOF会fork一个新的进程进行重写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure><h4 id="2-2-优点以及缺点">2.2 优点以及缺点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendoly no   <span class="hljs-comment"># 默认不开启</span><br>appendfilename <span class="hljs-string">&quot;appendoly.aof&quot;</span> <span class="hljs-comment">#aof文件的名字 </span><br><br>appendfsync always   <span class="hljs-comment"># 每次修改都执行同步操作，消耗性能</span><br>appendfsync everysec <span class="hljs-comment"># 每秒执行一次，可能会丢失那一秒的数据</span><br>appendfsync no       <span class="hljs-comment"># 不执行同步，操作系统进行同步，速度最快</span><br></code></pre></td></tr></table></figure><p class="label label-success">优点</p><ol><li>每一次修改都同步，文件完整性会更加的好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从来不同步，速度最快</li></ol><p class="label label-danger">缺点</p><ol><li><p>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</p></li><li><p>AOF运行效率也要比rdb慢，所以redis默认的配置就是rdb持久化</p></li></ol><h3 id="3、总结以及拓展">3、总结以及拓展</h3><ol><li>RDB持久化方式能够再指定的时间间隔内对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来会恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的额体积不至于太大</li><li>只做缓存，如果你只希望你的数据再服务器运行的时候存在，你也可以不使用持久化</li><li>同时开启两种持久化模式<ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常的情况下AOF文件保存的数据集要比RDB文件保存的数据集更加的完整</li><li>RDB的数据不实时，同时使用两种服务器重启也只会找AOF文件，那要不要只使用AOF呢🙌？答案是建议不要，因为RDB更加的适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的BUG，作为一个留着以防万一的手段</li></ul></li><li>性能建议<ul><li>因为RDB文件只用作后备用途，建议旨在Slave（附机）持久化RDB文件，而且只要15分钟备份一次就行了，只需要保留save 900 1  这条规则</li><li>如果Enable AOF，好处是在最恶劣情况下也只会失去不超过两秒的数据，启动脚本只load自己的文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞时不可避免的，只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值太小了，可以设置到5G以上，默认超过原大小100%大小重写可以改到适当的数值</li><li>如果不Enable AOF，仅靠 Master-Slave实现高可用性也可以，能够省掉一大笔的IO，也减少了rewrite时带来的系统波动，代价时如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个，微博就是这种架构</li></ul></li></ol><h2 id="十一、发布订阅">十一、发布订阅</h2><p>redis中提供了类似消息队列的功能–发布订阅，但是更加专业的功能仍然需要消息队列来做，比如Kafaka等</p><h3 id="1-简单的来实现一下">1. 简单的来实现一下</h3><p>订阅一个频道</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; SUBSCRIBE chenning<br><br>Reading messages... (press Ctrl-C to quit)<br><br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br><br>2) <span class="hljs-string">&quot;chenning&quot;</span><br><br>3) (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>发送端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; PUBLISH chenning <span class="hljs-string">&quot;hell chenning&quot;</span>  <span class="hljs-comment"># 发送一则消息</span><br><br>(<span class="hljs-built_in">integer</span>) 1<br><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><p>再次回到刚刚订阅的那个窗口，可以看到以下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1) <span class="hljs-string">&quot;message&quot;</span><br><br>2) <span class="hljs-string">&quot;chenning&quot;</span><br><br>3) <span class="hljs-string">&quot;hell chenning&quot;</span><br></code></pre></td></tr></table></figure><p>上述就是一个简单的发布订阅</p><h3 id="2-原理">2. 原理</h3><p>Redis 是使用c实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加加深对 Redis 的理解。Redis 通过 PUBLISH 、 SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p><p>通过 SUBSCRIBE 命令订阅某频道后， redis - server 里维护了一个字典，字典的键就是一个个 channel 而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。 SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p><p>通过PUBLSH 命令向订订阅者发送消息， redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户的链表，遍历这个链表，将消息发布给所有订阅者。</p><p>Pub / Sub 从字面上理解就是发布（ Publish ）与订阅（ Subscribe )，在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><h2 id="十二、主从复制">十二、主从复制</h2><h3 id="1-概念">1. 概念</h3><p>主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点（ master / leader )，后者称为从节点( slave / folower )；数据的复制是单向的，只能由主节点到从节点。 Master 以写为主， Slave 以读为主。</p><p>默认情况下，每台 Redis 服务器都是王节点；且一个王节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><p><span class = "label label-success">主从复制的作用主要包括：</span></p><p>1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br>3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。<br>4、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。</p><p>一般来说，要将 Redis 运用于工程项目中，只使用一台 Redis 是万万不能的，原因如下：</p><p>1、从结构上，单个 Redis 服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>2、从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为256G，也不能将所有内存用作 Redis 存储内存，<br>一般来说，单台 Redis 最大使用内存不应该超过20G。</p><h3 id="2-环境配置">2. 环境配置</h3><p>只配置从库 不配置主库,因为默认自己为主库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication<br><br><span class="hljs-comment"># Replication</span><br><br>role:master                                     <span class="hljs-comment"># 可以看到这里默认自己是主机</span><br><br>connected_slaves:0<br><br>master_failover_state:no-failover<br><br>master_replid:4fbf9a6eb1fa637393710a004aa2839976897b2c<br><br>master_replid2:0000000000000000000000000000000000000000<br><br>master_repl_offset:0<br><br>second_repl_offset:-1<br><br>repl_backlog_active:0<br><br>repl_backlog_size:1048576<br><br>repl_backlog_first_byte_offset:0<br><br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><p>接下来我们使用三个端口启动三个redis服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Mercury Nconfig]<span class="hljs-comment"># cp redis.conf redis79.conf </span><br><br>[root@Mercury Nconfig]<span class="hljs-comment"># cp redis.conf redis80.conf </span><br><br>[root@Mercury Nconfig]<span class="hljs-comment"># cp redis.conf redis81.conf    # 复制了三份配置文件</span><br><br>[root@Mercury Nconfig]<span class="hljs-comment"># ll</span><br><br>total 368<br><br>-rw-r--r-- 1 root root 93725 Apr 15 18:56 redis79.conf<br><br>-rw-r--r-- 1 root root 93725 Apr 15 18:56 redis80.conf<br><br>-rw-r--r-- 1 root root 93725 Apr 15 18:56 redis81.conf<br><br>-rw-r--r-- 1 root root 93725 Apr 14 17:22 redis.conf<br><br><span class="hljs-comment"># 为保证不重名，配置文件里需要修改 端口 pid名字 log文件名字 dump.rdb名字</span><br><br>[root@Mercury bin]<span class="hljs-comment"># redis-server Nconfig/redis79.conf</span><br>[root@Mercury bin]<span class="hljs-comment"># redis-server Nconfig/redis80.conf</span><br>[root@Mercury bin]<span class="hljs-comment"># redis-server Nconfig/redis81.conf     #分别指定配置文件进行启动</span><br><br><br>[root@Mercury bin]<span class="hljs-comment"># ps -ef|grep redis</span><br><br>root  6093  1 0 19:05 ?  00:00:00 redis-server 127.0.0.1:6380<br><br>root  6108  1 0 19:05 ?  00:00:00 redis-server 127.0.0.1:6381<br><br>root  6277 19173 0 19:06 pts/1 00:00:00 grep --color=auto redis<br><br>root  27191  1 0 Apr14 ?  00:02:28 redis-server 127.0.0.1:6379    <span class="hljs-comment"># 可以看到已经分别启动了</span><br></code></pre></td></tr></table></figure><h3 id="3-一主二从">3. 一主二从</h3><p>所谓一主二从就是一台主机两台从机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379          <span class="hljs-comment"># 通过这个命令将6380设为6379的从机</span><br><br>OK<br><br>127.0.0.1:6380&gt; info replication<br><br><span class="hljs-comment"># Replication</span><br><br>role:slave                                      <span class="hljs-comment"># 可以看到已经变为从机</span><br><br>master_host:127.0.0.1<br><br>master_port:6379<br><br>master_link_status:up<br><br>master_last_io_seconds_ago:5<br><br>master_sync_in_progress:0<br><br>slave_read_repl_offset:14<br><br>slave_repl_offset:14<br><br>slave_priority:100<br><br>slave_read_only:1<br><br>replica_announced:1<br><br>connected_slaves:0<br><br>master_failover_state:no-failover<br><br>master_replid:1f474dfc54aedd694b971cefafd50927b55f97a4<br><br>master_replid2:0000000000000000000000000000000000000000<br><br>master_repl_offset:14<br><br>second_repl_offset:-1<br><br>repl_backlog_active:1<br><br>repl_backlog_size:1048576<br><br>repl_backlog_first_byte_offset:1<br><br>repl_backlog_histlen:14<br></code></pre></td></tr></table></figure><p>再次查看6379</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Mercury bin]<span class="hljs-comment"># redis-cli -p 6379</span><br><br>127.0.0.1:6379&gt; info replication<br><br><span class="hljs-comment"># Replication</span><br><br>role:master<br><br>connected_slaves:1                            <span class="hljs-comment"># 显示已连接从机数量</span><br><br>slave0:ip=127.0.0.1,port=6380,state=online,offset=84,lag=1  <span class="hljs-comment"># 显示从机状态     </span><br><br>master_failover_state:no-failover<br><br>master_replid:1f474dfc54aedd694b971cefafd50927b55f97a4<br><br>master_replid2:0000000000000000000000000000000000000000<br><br>master_repl_offset:84<br><br>second_repl_offset:-1<br><br>repl_backlog_active:1<br><br>repl_backlog_size:1048576<br><br>repl_backlog_first_byte_offset:1<br><br>repl_backlog_histlen:84<br></code></pre></td></tr></table></figure><p>以同样的步骤连接上6381</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication<br><br><span class="hljs-comment"># Replication</span><br><br>role:master<br><br>connected_slaves:2                <span class="hljs-comment"># 两个从机</span><br><br>slave0:ip=127.0.0.1,port=6380,state=online,offset=280,lag=0<br><br>slave1:ip=127.0.0.1,port=6381,state=online,offset=280,lag=1<br><br>master_failover_state:no-failover<br><br>master_replid:1f474dfc54aedd694b971cefafd50927b55f97a4<br><br>master_replid2:0000000000000000000000000000000000000000<br><br>master_repl_offset:280<br><br>second_repl_offset:-1<br><br>repl_backlog_active:1<br><br>repl_backlog_size:1048576<br><br>repl_backlog_first_byte_offset:1<br><br>repl_backlog_histlen:280<br><br><br></code></pre></td></tr></table></figure><p>因为这里我们是通过指令操作的，所以关闭服务后就不再是从机了，而是会变回主机，如果想一直是从机，我们可以在配置文件里面修改</p><p><span lable label-success>配置文件里面</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">replicaof   &lt;masterip&gt;   &lt;masterport&gt;<br></code></pre></td></tr></table></figure><h4 id="3-1-细节了解">3.1 细节了解</h4><p>主机可以设置值，从机不能写只能读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 <span class="hljs-string">&quot;v1&quot;</span><br><br>OK<br><br>127.0.0.1:6379&gt; get k1<br><br><span class="hljs-string">&quot;v1&quot;</span><br><br><span class="hljs-comment"># 主机设置 key-value</span><br><br><br><br>127.0.0.1:6380&gt; get k1<br><br><span class="hljs-string">&quot;v1&quot;</span><br><br><span class="hljs-comment"># 从机可以拿到</span><br><br><br>127.0.0.1:6380&gt; <span class="hljs-built_in">set</span> k2 <span class="hljs-string">&quot;v2&quot;</span><br><br>(error) READONLY You can<span class="hljs-string">&#x27;t write against a read only replica.</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 从机不可以写</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主机断开</span><br><br>127.0.0.1:6379&gt; SHUTDOWN  <br><br>not connected&gt;<br><br><br><br>127.0.0.1:6380&gt; info replication<br><br><span class="hljs-comment"># Replication</span><br><br>role:slave                 <span class="hljs-comment"># 依然是从机</span><br><br>master_host:127.0.0.1<br><br>master_port:6379<br><br>master_link_status:down<br><br>master_last_io_seconds_ago:-1<br><br>master_sync_in_progress:0<br><br>slave_read_repl_offset:962<br><br>slave_repl_offset:962<br><br>master_link_down_since_seconds:33<br><br>slave_priority:100<br><br>slave_read_only:1<br><br>replica_announced:1<br><br>connected_slaves:0<br><br>master_failover_state:no-failover<br><br>master_replid:1f474dfc54aedd694b971cefafd50927b55f97a4<br><br>master_replid2:0000000000000000000000000000000000000000<br><br>master_repl_offset:962<br><br>second_repl_offset:-1<br><br>repl_backlog_active:1<br><br>repl_backlog_size:1048576<br><br>repl_backlog_first_byte_offset:1<br><br>repl_backlog_histlen:962<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主机重新启动</span><br><br>[root@Mercury bin]<span class="hljs-comment"># redis-server Nconfig/redis79.conf </span><br><br>[root@Mercury bin]<span class="hljs-comment"># redis-cli -p 6379</span><br><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 <span class="hljs-string">&quot;v2&quot;</span><br><br>OK<br><br><span class="hljs-comment">#再次设置值</span><br><br>127.0.0.1:6380&gt; get k2<br><br><span class="hljs-string">&quot;v2&quot;</span><br><br><span class="hljs-comment"># 依然可以拿到</span><br></code></pre></td></tr></table></figure><p>主机断开连接，从机依然连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息，但如果是使用命令行来配置的从机，重启后就会变回主机，不再和原来的主机同步，无法获取之后写入的信息，但只要再变回从机，立刻就可以从主机中获取值。</p><h3 id="4-复制原理">4. 复制原理</h3><p>Slave 启动成功连接到 master 后会发送一个 sync 命令</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后， master 将传送整个数据文件到 slave ，并完成一次完全同步。</p><p>全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>增量复制： Master 继续将新的所有收集到的修改命令依次传给 slave ，完成同步但是只要是重新连接 master ，一次完全同步（全量复制）将被自动执行🚗</p><h3 id="5-层层链路">5. 层层链路</h3><p>使用下面的方式将三个 redis 服务连接起来</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">79</span>-----------<span class="hljs-number">80</span>---------<span class="hljs-number">81</span> <br><br> <span class="hljs-attribute">M</span>          M  S        S<br></code></pre></td></tr></table></figure><p>此时的80端口依旧是从节点，输入命令可以看到依然显示为Salve</p><p>一般层层链路不常用</p><h3 id="6-谋朝篡位-🤪">6. 谋朝篡位 🤪</h3><p>如果主机断开了连接，我们可以使用<span class = "label label-danger">SLAVEOF no one</span>命令使自己变成主机，其他主机可以手动连接到这个主节点</p><h2 id="十三、哨兵模式">十三、哨兵模式</h2><h3 id="1-概念-2">1. 概念</h3><p>简单的来说，哨兵模式就是自动选举主机的模式。一般情况下，当主服务器宕机后，需要手动把一台服务器切换为主服务器，但是手动对于程序员来讲还是太麻烦了🙌,所以Redis从2.8正式提供了Sentinel哨兵模式来解决这个问题</p><p>哨兵模式能够在后台自动监测主机是否故障，如果故障了将根据投票数自动将从机转换为主机，哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程。原理就是哨兵通过发送命令，等待服务器响应，从而监控多个redis实例</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220417190613545.png" alt="哨兵示意图"></p><p>过程：假设主服务器宕机(比如断电啥的)，哨兵会检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong></p><h3 id="2-实际测试一波">2. 实际测试一波</h3><p>简单编辑配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Mercury Nconfig]<span class="hljs-comment"># vim sentinel.conf</span><br><br>sentinel monitor myredis 127.0.0.1 6379 1<br><br><span class="hljs-comment"># 后面这个数字1代表有多少个哨兵认为这个主机挂了就执行换主机的操作</span><br><br></code></pre></td></tr></table></figure><p>启动哨兵服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动命令</span><br>[root@Mercury bin]<span class="hljs-comment"># redis-sentinel Nconfig/sentinel.conf</span><br>32048:X 17 Apr 2022 18:15:13.108 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>32048:X 17 Apr 2022 18:15:13.108 <span class="hljs-comment"># Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=32048, just started</span><br>32048:X 17 Apr 2022 18:15:13.108 <span class="hljs-comment"># Configuration loaded</span><br>32048:X 17 Apr 2022 18:15:13.109 * monotonic clock: POSIX clock_gettime<br>                _._                                                  <br>           _.-``__ <span class="hljs-string">&#x27;&#x27;</span>-._                                             <br>      _.-``    `.  `_.  <span class="hljs-string">&#x27;&#x27;</span>-._           Redis 6.2.6 (00000000/0) 64 bit<br>  .-`` .-```.  ```\/    _.,_ <span class="hljs-string">&#x27;&#x27;</span>-._                                  <br> (    <span class="hljs-string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="hljs-string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="hljs-string">&#x27;|     Port: 26379</span><br><span class="hljs-string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 32048<br>  `-._    `-._  `-./  _.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |           https://redis.io       </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |                                  </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br>      `-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                       <br>          `-._        _.-<span class="hljs-string">&#x27;                                           </span><br><span class="hljs-string">              `-.__.-&#x27;</span>                                               <br><br>32048:X 17 Apr 2022 18:15:13.110 <span class="hljs-comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br>32048:X 17 Apr 2022 18:15:13.114 <span class="hljs-comment"># Sentinel ID is b7a639b54bcccf0219a5c5390726703b88a2d628</span><br>32048:X 17 Apr 2022 18:15:13.114 <span class="hljs-comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span><br>32048:X 17 Apr 2022 18:15:13.115 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379<br></code></pre></td></tr></table></figure><p>然后我们关闭6379这个主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; SHUTDOWN<br>not connected&gt;<br></code></pre></td></tr></table></figure><p>等待一段时间后可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">32048:X 17 Apr 2022 18:21:49.348 <span class="hljs-comment"># +sdown master myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.348 <span class="hljs-comment"># +odown master myredis 127.0.0.1 6379 #quorum 1/1         #满足了条件</span><br><br>32048:X 17 Apr 2022 18:21:49.348 <span class="hljs-comment"># +new-epoch 1</span><br><br>32048:X 17 Apr 2022 18:21:49.348 <span class="hljs-comment"># +try-failover master myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.351 <span class="hljs-comment"># +vote-for-leader b7a639b54bcccf0219a5c5390726703b88a2d628 1</span><br><br>32048:X 17 Apr 2022 18:21:49.351 <span class="hljs-comment"># +elected-leader master myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.351 <span class="hljs-comment"># +failover-state-select-slave master myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.442 <span class="hljs-comment"># +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.442 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379<br><br>32048:X 17 Apr 2022 18:21:49.508 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379<br><br>32048:X 17 Apr 2022 18:21:49.716 <span class="hljs-comment"># +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.716 <span class="hljs-comment"># +failover-state-reconf-slaves master myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.789 <span class="hljs-comment"># +failover-end master myredis 127.0.0.1 6379</span><br><br>32048:X 17 Apr 2022 18:21:49.789 <span class="hljs-comment"># +switch-master myredis 127.0.0.1 6379 127.0.0.1 6380          # 6380成为了主机</span><br><br>32048:X 17 Apr 2022 18:21:49.790 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380<br><br>32048:X 17 Apr 2022 18:21:50.420 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380<br><br>32048:X 17 Apr 2022 18:22:19.834 <span class="hljs-comment"># +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380</span><br></code></pre></td></tr></table></figure><p>我们再来看看6380的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6380&gt; info replication<br><br><span class="hljs-comment"># Replication</span><br><br>role:master                            <span class="hljs-comment"># 很明显这里已经成为了主机</span><br><br>connected_slaves:1<br><br>slave0:ip=127.0.0.1,port=6381,state=online,offset=265004,lag=1<br><br>master_failover_state:no-failover<br><br>master_replid:4e0b279d0bae3d59691444c3d8a264de3859340b<br><br>master_replid2:9ea51c7e5cefa6a5b8e281bb4fa433fb34f9292d<br><br>master_repl_offset:265136<br><br>second_repl_offset:258784<br><br>repl_backlog_active:1<br><br>repl_backlog_size:1048576<br><br>repl_backlog_first_byte_offset:1<br><br>repl_backlog_histlen:265136<br></code></pre></td></tr></table></figure><p>以上就是哨兵模式的实际测试，如果主机此时回来了，只能归到新的主机下</p><h3 id="3-优缺点">3. 优缺点</h3><p><span class = "label label-success">优点</span></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置的优点，它全都有</li><li>主从是可以切换的，故障可以转移，系统的可用性会更好</li><li>哨兵模式就是主从模式的升级，手动到自动</li></ol><p><span class = "label label-danger">缺点</span></p><ol><li>Redis不好在线扩容，集群的数量一旦达到上限，在线扩容就十分的麻烦</li><li>实现哨兵模式的配置比较麻烦，里面有很多选择</li></ol><h3 id="哨兵模式的全部配置">哨兵模式的全部配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Example sentinel.conf</span><br><br><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认26379</span><br><br>port 26379<br><br><br><br><span class="hljs-comment"># 哨兵sentinel的工作目录</span><br><br>dir /tmp<br><br><br><br><span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port</span><br><br><span class="hljs-comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><br><span class="hljs-comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><br><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><br>sentinel monitor mymaster 127.0.0.1 6379 2<br><br><br><br><span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><br><span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><br><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br><br><br><br><span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><br><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><br>sentinel down-after-milliseconds mymaster 30000<br><br><br><br><span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><br><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><br>sentinel parallel-syncs mymaster 1<br><br><br><br><span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><br><span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><br><span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><br><span class="hljs-comment">#3.当想要取消一个正在进行的failover所需要的时间。 </span><br><br><span class="hljs-comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><br><span class="hljs-comment"># 默认三分钟</span><br><br><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><br>sentinel failover-timeout mymaster 180000<br><br><br><br><span class="hljs-comment"># SCRIPTS EXECUTION</span><br><br><span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><br><span class="hljs-comment">#对于脚本的运行结果有以下规则：</span><br><br><span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><br><span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><br><span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><br><span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><br><span class="hljs-comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><br><br><br><span class="hljs-comment">#通知脚本</span><br><br><span class="hljs-comment"># shell编程</span><br><br><span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><br>sentinel notification-script mymaster /var/redis/notify.sh<br><br><br><br><span class="hljs-comment"># 客户端重新配置主节点参数脚本</span><br><br><span class="hljs-comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><br><span class="hljs-comment"># 以下参数将会在调用脚本时传给脚本:</span><br><br><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><br><span class="hljs-comment"># 目前&lt;state&gt;总是“failover”,</span><br><br><span class="hljs-comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><br><span class="hljs-comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><br><span class="hljs-comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><br><span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="hljs-comment"># 一般都是由运维来配置！</span><br><br><br></code></pre></td></tr></table></figure><h2 id="十四、缓存穿透和雪崩">十四、缓存穿透和雪崩</h2><h3 id="1-缓存穿透">1. 缓存穿透</h3><h4 id="1-1-概念">1.1 概念</h4><p>缓存穿透的概念很简单，用户想要查询一个数据，发现 redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><h4 id="1-2-解决方案">1.2 解决方案</h4><h5 id="布隆过滤器">布隆过滤器</h5><p>布隆过滤器是一种数据结构，对所有可能査询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220417194623551.png" alt="布隆过滤器"></p><h5 id="缓存空对象">缓存空对象</h5><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据会从缓存中获取，保护了后端数据源</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220417194749943.png" alt="缓存空对象"></p><p>但是这种方法会存在两个问题：<br>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；<br>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会<br>有影响。</p><h3 id="2-缓存击穿">2. 缓存击穿</h3><h4 id="2-1-概述">2.1 概述</h4><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><h4 id="2-2-解决方案">2.2 解决方案</h4><h5 id="设置热点数据永不过期">设置热点数据永不过期</h5><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p><h5 id="加互斥锁">加互斥锁</h5><p>分布式锁：使用分布式锁，保证对于每个 key 同时只有一个线程去査询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><h3 id="3-缓存雪崩">3. 缓存雪崩</h3><h4 id="3-1-概念">3.1 概念</h4><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。 Redis 宕机！发生雪崩的原因之一，比如在双十一零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知知的，很有可能瞬间就把数据库压垮。</p><h4 id="3-2-解决方案">3.2 解决方案</h4><h5 id="redis-高可用">redis 高可用</h5><p>这个思想的含义是，既然 redis 有可能挂掉，那我多增设几台 redis ，这样一台挂掉之后其他的还可以继续工作，实就是搭建的集群。（异地多活！)</p><h5 id="限流降级">限流降级</h5><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p><h5 id="数据预热">数据预热</h5><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的 key ，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/03/05/Git/"/>
    <url>/2022/03/05/Git/</url>
    
    <content type="html"><![CDATA[<h1>一、版本控制</h1><h2 id="1、什么是版本控制">1、什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。其目的就是用于管理多人协同开发项目而诞生的技术。</p><h2 id="2、常见的版本控制工具">2、常见的版本控制工具</h2><p>目前市面上主流的版本控制工具主要有</p><ul><li>Git</li><li>SVN</li><li>CVS</li><li>VSS</li><li>TFS</li><li>Visual studio Online</li></ul><p>Git 是目前全世界最为先进的分布式版本管理工具。</p><h2 id="3、版本控制的分类">3、版本控制的分类</h2><h3 id="3-1、本地版本控制分类">3.1、本地版本控制分类</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163113787.png" alt="image-20240409163113787"></p><h3 id="3-2、集中版本控制分类">3.2、集中版本控制分类</h3><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163155941.png" alt="集中版本控制"></p><h3 id="3-3、分布式版本控制分类">3.3、分布式版本控制分类</h3><p>最具有代表性的当然就是Git啦，所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163244033.png" alt="分布式版本控制"></p><h1>二、初识Git</h1><h2 id="1、下载地址">1、下载地址</h2><p>打开 <a href="https://git-scm.com/">git官网</a>或可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><h2 id="2、三个程序">2、三个程序</h2><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163330164.png" alt="git的三个程序"></p><h2 id="3、配置">3、配置</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 查看配置</span><br>git config -l<br><br><span class="hljs-comment">#查看系统config</span><br>git config <span class="hljs-params">--system</span> <span class="hljs-params">--list</span><br>　　<br><span class="hljs-comment">#查看当前用户（global）配置</span><br>git config <span class="hljs-params">--global</span>  <span class="hljs-params">--list</span><br></code></pre></td></tr></table></figure><p>如图：<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163401024.png" alt="image-20240409163401024"></p><h1>三、使用Git</h1><h2 id="1、工作原理">1、工作原理</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。加上远程的git仓库(Remote Directory)就可以分为四个工作区域。</p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><h2 id="2、工作流程">2、工作流程</h2><ul><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到git仓库。</p></li></ul><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163425025.png" alt="image-20240409163425025"></p><h2 id="3、常用指令">3、常用指令</h2><h3 id="3-1-克隆仓库">3.1 克隆仓库</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><br> git <span class="hljs-keyword">clone</span> <span class="hljs-title">[url</span>]  <br><br><span class="hljs-comment"># 克隆仓库指定的分支的代码，develop为需要拉取的分支，giturl为git仓库地址</span><br><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> develop giturl<br><br></code></pre></td></tr></table></figure><p>克隆之后，git的目录下面就会有对应名字的一个项目仓库<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163446960.png" alt="image-20240409163446960"><br>打开显示隐藏的项目，就会有一个.git文件夹<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163505722.png" alt="image-20240409163505722"><br>把这个文件夹复制一份到你的项目文件下就可以和你远程仓库形成类似于绑定的关系，复制到项目文件后，用idea打开的话就会自动多出来几个按钮</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163527895.png" alt="image-20240409163527895"><br>按钮作用在后面</p><h3 id="3-2-文件状态">3.2 文件状态</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#查看指定文件状态</span><br>git status [filename]<br><br><span class="hljs-meta">#查看所有文件状态</span><br>git status<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163548782.png" alt="image-20240409163548782"></p><ul><li>红褐色：创建之后没有add，没提交，不在Git版本控制范围之内，这时候文件是红褐色的，需要先add文件；</li><li>绿色：add之后是文件绿色的，没有提交（commit）;</li><li>蓝色：原本有一个文件，改动过后没有提交（commit）是蓝色的，提交之后，变成正常颜色。</li></ul><h3 id="3-2-添加和提交">3.2 添加和提交</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 添加所有文件到暂存区</span><br><br>git add .                  <br><br><span class="hljs-meta"># 提交暂存区中的内容到本地仓库 -m 提交信息</span><br><br>git commit -m <span class="hljs-string">&quot;消息内容&quot;</span>    <br><br><span class="hljs-meta"># push到远程仓库</span><br><br>git push<br><br><br><span class="hljs-meta">#版本发布  当前的版本号 发布版本 比如</span><br><br>git tag -a v1<span class="hljs-number">.0</span><br> <br><br>把这个版本发布到线上<br><br>git push --tags<br></code></pre></td></tr></table></figure><p>在idea中:<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163610069.png" alt="image-20240409163610069"></p><h1>四、忽略文件</h1><p>就是选择不上传到仓库的文件，通常用在主目录下建立&quot;.gitignore&quot;文件用来配置，此文件有如下规则：</p><ul><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p></li></ul> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#为注释</span><br>*.txt        <span class="hljs-comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br>!lib.txt     <span class="hljs-comment">#但lib.txt除外</span><br>/temp        <span class="hljs-comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br>build<span class="hljs-regexp">/       #忽略build/</span>目录下的所有文件<br>doc<span class="hljs-regexp">/*.txt    #会忽略 doc/</span>notes.txt 但不包括 doc<span class="hljs-regexp">/server/</span>arch.txt<br></code></pre></td></tr></table></figure><h1>五、Git分支</h1><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240409163638542.png" alt="image-20240409163638542"><br>分支常用的命令：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 列出所有本地分支</span><br>git branch<br><br><span class="hljs-meta"># 列出所有远程分支</span><br>git branch -r<br><br><span class="hljs-meta"># 新建一个分支，但依然停留在当前分支</span><br>git branch [branch-name]<br><br><span class="hljs-meta"># 新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><br><span class="hljs-meta"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-meta"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class="hljs-meta"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><h1>六、将远程代码强制同步到本地</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">fetch</span> <span class="hljs-comment">--all</span><br><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard origin/master</span><br></code></pre></td></tr></table></figure><p><code>git fetch</code> 只下载远程仓库的内容，不做任何的合并，<code>git reset</code> 把HEAD指向刚刚下载的最新版本</p><p>愉快的Git结束。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2022/02/21/Nginx/"/>
    <url>/2022/02/21/Nginx/</url>
    
    <content type="html"><![CDATA[<p>俗话说得好，没有问题是加一层解决不了的，如果有，那就再加一层。Nginx就是这样的一种技术。</p><h2 id="一、Nginx简介">一、Nginx简介</h2><p>Nginx 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</p><p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好</p><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p><h2 id="二、-Nginx的作用">二、 Nginx的作用</h2><p>Nginx的主要功能有HTTP代理、负载均衡和动静分离。</p><h3 id="1、正向代理">1、正向代理</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185635114.png" alt="image-20241026185635114"><br>正向代理是代理客户端</p><h3 id="2、反向代理">2、反向代理</h3><p><img src="https://img-blog.csdnimg.cn/6e3abcc0be4b403594e126738ff1fb05.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="反向代理"><br>反向代理是代理服务器端，是web服务器最常用的功能之一</p><p>让你无感知的访问一个域名就能够连接</p><h3 id="3、负载均衡">3、负载均衡</h3><p>Nginx的负载均衡主要有内置策略和扩展策略，内置策略为轮询，加权轮询，Ip hash。扩展策略就非常多了。</p><p><strong>轮询</strong><br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185700663.png" alt="image-20241026185700663"><br><strong>加权轮询</strong></p><p><img src="https://img-blog.csdnimg.cn/88ae6e7914094e6b99e49d26c516b75e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="加权轮询"><br><strong>Iphash</strong></p><p>对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185717165.png" alt="image-20241026185717165"></p><h3 id="4、动静分离">4、动静分离</h3><p>简单的来说就是把一些不需要经过后台处理的文件交由<br>静态资源服务器处理，直接从这个服务器加载静态资源，提高速度<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185741359.png" alt="image-20241026185741359"></p><h2 id="三、安装及注意事项">三、安装及注意事项</h2><h3 id="1、windows">1、windows</h3><p>通过官网下载windows版后解压<br><a>http://nginx.org/en/download.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185802339.png" alt="image-20241026185802339"></p><p>启动 直接双击exe 或者cmd</p><p>从配置文件中可以看出nginx默认配置的是80端口<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185828849.png" alt="image-20241026185828849"></p><p>配置文件的位置<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185851721.png" alt="image-20241026185851721"></p><p>因为是默认80端口，所以这里可以不写,输入IP地址，然后就可以看到欢迎界面</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185911519.png" alt="image-20241026185911519"></p><h3 id="2、Linux">2、Linux</h3><p>这里不详解,主要推荐一篇文章<br><a>https://blog.csdn.net/qq_44170721/article/details/109022427</a><br>或者直接宝塔安装</p><p><strong>特别注意</strong><br>在我使用宝塔面板进行nginx的安装的时候，安装完成后，发现死活进不了欢迎界面，本应正常访问的欢迎页却是找不到页面，并且配置文件也不一样，后来我才发现宝塔上面的是改过的，更适合在拥有图形化界面的宝塔面板中使用，一键傻瓜式操作(都给你弄好了)，之所以会出现提示找不到页面，原因是宝塔把index页欢迎页改成了提示找不到页面，是用于部署了项目后，项目没有加载出来等的提示页面。而官方的nginx则没有这个改动，可以正常显示欢迎页。<br><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026185933727.png" alt="改动后的页面"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026190026783.png" alt="安装官方的可以正常显示"></p><h2 id="四、Nginx的使用">四、Nginx的使用</h2><p>常用的一些命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/usr/local/nginx/sbin/</span><br><span class="hljs-string">./nginx</span>  启动<br><span class="hljs-string">./nginx</span> -s stop  停止<br><span class="hljs-string">./nginx</span> -s <span class="hljs-keyword">quit</span>  安全退出<br><span class="hljs-string">./nginx</span> -s <span class="hljs-keyword">reload</span>  重新加载配置文件<br>ps aux|grep nginx  查看nginx进程<br></code></pre></td></tr></table></figure><h2 id="五、配置文件">五、配置文件</h2><p>在使用nginx的过程中最为重要的就是配置文件的书写</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>conf    <span class="hljs-comment">#默认的 nginx.conf 文件的地址</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#源文件</span><br><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment"># 全局块</span><br><span class="hljs-comment"># 从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。</span><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-comment"># events块</span><br><span class="hljs-comment">#主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否 允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</span><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment"># http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</span><br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br>  <br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>      <br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment"># 类似虚拟机，可以有多个server配置</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-comment"># 监听的端口号</span><br>        <br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <span class="hljs-comment">#服务器地址</span><br>        <br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>       <br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;       <br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>反向代理配置实例</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    <br>        location / &#123;<br>            root   <span class="hljs-regexp">/www/</span>wwwroot<span class="hljs-regexp">/LostandFound/</span>frontgroundSystem;  <br>            <span class="hljs-comment"># 这里配置的是前端的dist文件目录</span><br>            <br>            index index.html;<br>            <br>            try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html; <br>            <span class="hljs-comment">#用于重定向</span><br>        &#125;<br> <br>        location   <span class="hljs-regexp">/back/</span> &#123;<br>            proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>/;<br>            <span class="hljs-comment"># 主机地址及项目端口号</span><br>        &#125;<br>        <span class="hljs-comment"># 前缀有字符串/back/ (这里有大坑)</span><br>        <br>        <br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        location = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>添加ssl证书</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs awk">server&#123;<br>       <br>        listen <span class="hljs-number">443</span> ssl;<br>        <span class="hljs-comment"># 新版本的nginx不用再写ssl on</span><br>        <br>        server_name mercuryblog.site;<br>        <span class="hljs-comment">#写域名</span><br>        <br>        ssl_certificate <span class="hljs-regexp">/etc/</span>ssl/<span class="hljs-number">7231943</span>_mercuryblog.site.pem;<br>        <span class="hljs-comment">#证书的pem文件地址</span><br>       <br>        ssl_certificate_key <span class="hljs-regexp">/etc/</span>ssl/<span class="hljs-number">7231943</span>_mercuryblog.site.key;<br>        <span class="hljs-comment">#证书的密钥地址</span><br>        <br>        ssl_session_timeout <span class="hljs-number">5</span>m;<br>        ssl_protocols TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>        <span class="hljs-comment"># 加密协议</span><br>        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br>        <span class="hljs-comment"># 加密算法</span><br>        ssl_prefer_server_ciphers on;<br>     <br>        location / &#123;<br>            root   <span class="hljs-regexp">/www/</span>wwwroot<span class="hljs-regexp">/LostandFound/</span>frontgroundSystem;<br>            index index.html;           <br>            try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html;<br>        &#125;<br> <br>        location   <span class="hljs-regexp">/back/</span> &#123;<br>            proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>/;<br>        &#125;<br>        <br>        <br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        location = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br>        <br><br>    &#125;<br></code></pre></td></tr></table></figure><p>负载均衡配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> myserver &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">208.208.128.122:8081</span> weight=<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">208.208.128.122:8082</span> weight=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment"># weight代表权重，默认为1，这里的意思是，如果有三次访问，那么会有一次转发到8081，两次转发到8082</span><br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  <span class="hljs-number">208.208.128.122</span>;<br><br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   html;<br>        <span class="hljs-attribute">proxy_pass</span>   http://myserver;<br>        <span class="hljs-comment"># 这里的myserver相当于就是一个代号了，真正的转发在上面的upsteam</span><br>        <br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>特别注意</strong></p><p>location 中 / 的使用</p><ul><li><p>proxy_pass代理地址端口后无任何字符，转发后地址：代理地址+访问URL目录部分</p></li><li><p>proxy_pass代理地址端口后有目录(包括 / )，转发后地址：代理地址+访问URL目录部分去除location匹配目录</p></li></ul><p>例如</p><p>访问<a href="http://127.0.0.1/v1/pt/apply/page%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80">http://127.0.0.1/v1/pt/apply/page这个地址</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">location <span class="hljs-regexp">/v1/</span> &#123;<br>    proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8899</span>;<br>&#125;<br><br>实际地址：http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8765</span><span class="hljs-regexp">/v1/</span>pt<span class="hljs-regexp">/apply/</span>page<br><br>location <span class="hljs-regexp">/v1/</span> &#123;<br>    proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8899</span>/;<br>&#125;<br><br>实际地址：http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8765</span><span class="hljs-regexp">/pt/</span>apply/page<br></code></pre></td></tr></table></figure><h2 id="六、部署前端的过程中遇到的各种情况">六、部署前端的过程中遇到的各种情况</h2><h3 id="1、前端项目打包">1、前端项目打包</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026190106483.png" alt="image-20241026190106483"></p><p>通过<strong>npm run build</strong>命令</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026190123017.png" alt="image-20241026190123017"></p><p>打包完成后会有一个dist文件夹，这个就是需要部署的项目。</p><h3 id="2、前端打包的时候出现下面的情况">2、前端打包的时候出现下面的情况</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026190147543.png" alt="image-20241026190147543"></p><p>缺少less_loader导致的，通过<strong>npm install less-loader</strong> 即可。</p><h3 id="3、安装依赖">3、安装依赖</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026190204146.png" alt="image-20241026190204146"><br>一般情况下，前端的项目上传到github等网站上面的时候是忽略了依赖的，所以打包之前需要执行下面的指令进行安装依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install<br><span class="hljs-built_in">npm</span> run serve<br></code></pre></td></tr></table></figure><h3 id="4、页面404">4、页面404</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20241026190229670.png" alt="image-20241026190229670"><br>前端在写axios的时候在访问的路径上面多加了一个back前缀，导致404，这个时候就需要通过nginx配置，把这个/back/给填上。</p><h3 id="5、页面502">5、页面502</h3><p>多半是你在测试的时候导致程序报错，停止了服务。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2022/02/17/linux/"/>
    <url>/2022/02/17/linux/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Linux简介">一、Linux简介</h2><p>此笔记所使用的Linux版本为CentOS 7</p><p>linux的核心思想</p><p><strong>一切皆文件</strong></p><p>现在很多的大型项目都是部署在Linux服务器端，所以Linux地位依然不可动摇，作为一个后端程序员，会Linux是基本功</p><p>Linux最初是由一个芬兰人在上大学的时候出于个人的爱好写出来的，Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统</p><h3 id="1、Linux的版本">1、Linux的版本</h3><p>版本一览</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927165755443.png" alt="版本一览"></p><p>市面上有很多Linux发行版，比如CentOS,Ubuntu，RedHat等等，其中还有kali linux 这个主要是用作安全渗透测试</p><h3 id="2、Linux环境搭建">2、Linux环境搭建</h3><p>略，我这里使用的是阿里云轻量级服务器搭载的CentOS 7操作系统</p><h2 id="二、Linux基本了解">二、Linux基本了解</h2><h3 id="1、关机">1、关机</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sync </span><span class="hljs-comment"># 将数据由内存同步到硬盘中。</span><br><br><span class="hljs-keyword">shutdown </span><span class="hljs-comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><br><span class="hljs-keyword">shutdown </span>–h <span class="hljs-number">10</span> <span class="hljs-comment"># 这个命令告诉大家，计算机将在10分钟后关机</span><br><br><span class="hljs-keyword">shutdown </span>–h now <span class="hljs-comment"># 立马关机</span><br><br><span class="hljs-keyword">shutdown </span>–h <span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-comment"># 系统会在今天20:25关机</span><br><br><span class="hljs-keyword">shutdown </span>–h +<span class="hljs-number">10</span> <span class="hljs-comment"># 十分钟后关机</span><br><br><span class="hljs-keyword">shutdown </span>–r now <span class="hljs-comment"># 系统立马重启</span><br><br><span class="hljs-keyword">shutdown </span>–r +<span class="hljs-number">10</span> <span class="hljs-comment"># 系统十分钟后重启</span><br><br>reboot <span class="hljs-comment"># 就是重启，等同于 shutdown –r now</span><br><br>halt <span class="hljs-comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span><br></code></pre></td></tr></table></figure><p>需要注意的是，重启和关机最好都在操作前，进行一下同步操作，在Linux里面，只要指令没有输出，就是指令成功了</p><h3 id="2、系统目录结构">2、系统目录结构</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927165945820.png" alt="image-20240927165945820"></p><p>Linux采用的是树状目录结构，这点和Windows类似</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/bin</span>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。<br><br><span class="hljs-string">/boot</span>： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。<br><br><span class="hljs-string">/dev</span> ： dev是Device<span class="hljs-params">(设备)</span>的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。<br><br><span class="hljs-string">/etc</span>： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。<br><br><span class="hljs-string">/home</span>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。<br><br><span class="hljs-string">/lib</span>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。<br><br><span class="hljs-string">/lost</span>+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。<br><br><span class="hljs-string">/media</span>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。<br><br><span class="hljs-string">/mnt</span>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在<span class="hljs-string">/mnt/</span>上，然后进入该目录就可以查看光驱里的内容了。<br><br><span class="hljs-string">/opt</span>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。<br><br><span class="hljs-string">/proc</span>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br><br><span class="hljs-string">/root</span>：该目录为系统管理员，也称作超级权限者的用户主目录。<br><br><span class="hljs-string">/sbin</span>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。<br><br><span class="hljs-string">/srv</span>：该目录存放一些服务启动之后需要提取的数据。<br><br><span class="hljs-string">/sys</span>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。<br><br><span class="hljs-string">/tmp</span>：这个目录是用来存放一些临时文件的。<br><br><span class="hljs-string">/usr</span>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。<br><br><span class="hljs-string">/usr/bin</span>： 系统用户使用的应用程序。<br><br><span class="hljs-string">/usr/sbin</span>： 超级用户使用的比较高级的管理程序和系统守护程序。<br><br><span class="hljs-string">/usr/src</span>： 内核源代码默认的放置目录。<br><br><span class="hljs-string">/var</span>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。<br><br><span class="hljs-string">/run</span>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。<br><br><span class="hljs-string">/www</span>: 默认放置网站的文件夹，里面拥有wwwroot等默认建站文件夹以及日志文件夹等<br><br><span class="hljs-string">/etc</span> <span class="hljs-string">/sysconfig/network-scripts</span> 网络配置目录<br></code></pre></td></tr></table></figure><h2 id="三、常见命令">三、常见命令</h2><p>常见命令</p><h3 id="1、xshell的使用">1、xshell的使用</h3><p>ctrl+滚轮 调节字体大小</p><p>clear 清屏</p><h3 id="2、cd">2、cd</h3><p>切换目录</p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@iZbp17dj5r3z9624ikd288Z ~] <span class="hljs-keyword">cd</span> /                   <span class="hljs-comment">#进入根目录</span><br><br>[root@iZbp17dj5r3z9624ikd288Z ~] <span class="hljs-keyword">cd</span> <span class="hljs-string">/home</span>               <span class="hljs-comment">#进入home目录</span><br></code></pre></td></tr></table></figure><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成这样的：cd …/man 这就是相对路径的写法，也可以 cd 目录名直接进入下一层目录</p><p>补充说明一下</p><p>cd root = cd ~</p><p>cd … 返回上一级目录 （这中间有个空格</p><h3 id="3、ls">3、ls</h3><p>展示当前目录的文件</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">[root@iZbp17dj5r3z9624ikd288Z ~] <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p>-a 参数 ：all 查看全部的文件 包括隐藏文件</p><p>-l  参数 ：列出所有的文件 包含文件按的属性和权限 没有隐藏文件</p><p>所有的Linux可以组合使用，即可以使用<strong>ls -al</strong>，用以查看所有文件的信息</p><h3 id="4、pwd">4、pwd</h3><p>显示当前用户所在的目录</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">[root@iZbp17dj5r3z9624ikd288Z ~] <span class="hljs-keyword">pwd</span><br></code></pre></td></tr></table></figure><p>-P ：显示出确实的路径，而非使用连接(link) 路径。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 单纯显示出目前的工作目录</span><br>[root<span class="hljs-symbol">@iZbp17dj5r3z9624ikd288Z</span> ~]<span class="hljs-meta"># pwd</span><br>/root<br><br><span class="hljs-meta"># 如果是链接，要显示真实地址，可以使用 -P参数</span><br>[root<span class="hljs-symbol">@iZbp17dj5r3z9624ikd288Z</span> /]<span class="hljs-meta"># cd bin</span><br>[root<span class="hljs-symbol">@iZbp17dj5r3z9624ikd288Z</span> bin]<span class="hljs-meta"># pwd -P</span><br>/usr/bin<br></code></pre></td></tr></table></figure><h3 id="5、mkdir">5、mkdir</h3><p>新建文件夹</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir 文件夹名字<br></code></pre></td></tr></table></figure><p>递归创建目录（创建多级目录）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> -p test<span class="hljs-number">1</span>/test<span class="hljs-number">2</span>/test<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>删除目录 <strong>rmdir 目录名</strong></p><p>如果目录不为空文件夹,则删除不会成功，需要删除文件</p><p>需要删除多个目录的话(递归删除) 需要加上-p参数</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rmdir</span> -p test<span class="hljs-number">1</span>/test<span class="hljs-number">2</span>/test<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="6、cp">6、cp</h3><p>拷贝文件</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> 文件 新的地方<br></code></pre></td></tr></table></figure><p>选项与参数：</p><p>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</p><p>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</p><p>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</p><p>-r：递归持续复制，用於目录的复制行为；(常用)</p><p>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</p><p>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</p><p>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。</p><p>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</p><p>-u：若 destination 比 source 旧才升级 destination ！</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"># 复制 root目录下的install.sh 到 home目录下<br>[root@Mercury home]<span class="hljs-meta"># cp /root/install.sh  /home</span><br>[root@Mercury home]<span class="hljs-meta"># ls</span><br>install.sh<br></code></pre></td></tr></table></figure><h3 id="7、rm">7、rm</h3><p>移除文件或者目录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rm</span> 文件名<br></code></pre></td></tr></table></figure><p>-f 忽略不存在的文件 不会出现警告， 强制删除</p><p>-r 递归删除目录</p><p>-i 互动 删除询问是否删除</p><p>rm -rf  /  系统中所有的文件全部被删除，（删库跑路）</p><h3 id="8、mv">8、mv</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">mv</span> 文件名 位置/文件名<br></code></pre></td></tr></table></figure><p>移动文件或者目录 重命名文件</p><p>-f 强制移动</p><p>-u 只替换已经更新过的文件</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 创建一个文件夹 test</span><br>[root<span class="hljs-symbol">@Mercury</span> home]<span class="hljs-meta"># mkdir test</span><br><br><span class="hljs-meta"># 将复制过来的文件移动到我们创建的目录，并查看</span><br>[root<span class="hljs-symbol">@Mercury</span> home]<span class="hljs-meta"># mv install.sh test</span><br>[root<span class="hljs-symbol">@Mercury</span> home]<span class="hljs-meta"># ls</span><br>test<br>[root<span class="hljs-symbol">@Mercury</span> home]<span class="hljs-meta"># cd test</span><br>[root<span class="hljs-symbol">@Mercury</span> test]<span class="hljs-meta"># ls</span><br>install.sh<br><br><span class="hljs-meta"># 将文件夹重命名，然后查看</span><br>[root<span class="hljs-symbol">@Mercury</span> test]<span class="hljs-meta"># cd ..</span><br>[root<span class="hljs-symbol">@Mercury</span> home]<span class="hljs-meta"># mv test mvtest</span><br>[root<span class="hljs-symbol">@Mercury</span> home]<span class="hljs-meta"># ls</span><br>mvtest<br></code></pre></td></tr></table></figure><p><strong>补充说明</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ifconfig</span>  命令查看网络配置<br></code></pre></td></tr></table></figure><h2 id="四、文件详解">四、文件详解</h2><h3 id="1、文件的属性">1、文件的属性</h3><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927170101988.png" alt="image-20240927170101988"></p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li><p>当为[ d ]则是目录</p></li><li><p>当为[ - ]则是文件；</p></li><li><p>若是[ l ]则表示为链接文档 ( link file )；</p></li><li><p>若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</p></li><li><p>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</p></li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。每个文件的属性由左边第一部分的10个字符来确定（如下图）</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927170131740.png" alt="image-20240927170131740"></p><p>从左至右用0-9这些数字来表示。第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户)拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中：<br>第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-“字符表示，则没有读权限；<br>第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用”-“字符表示没有写权限；<br>第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用”-&quot;字符表示，则没有执行权限。</p><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><h3 id="2、修改文件的属性">2、修改文件的属性</h3><h4 id="2-1、chgrp">2.1、chgrp</h4><p><strong>更改文件属组</strong></p><p>chgrp [-R] 属组名 文件名<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><h4 id="2-2、chown">2.2、chown</h4><p><strong>更改文件属主，也可以同时更改文件属组</strong></p><p>chown [–R] 属主名 文件名<br>chown [-R] 属主名：属组名 文件名</p><h4 id="2-3、chmod">2.3、chmod</h4><p><strong>更改文件9个属性</strong></p><p>chmod [-R] xyz 文件或目录<br>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">r</span>:<span class="hljs-number">4</span>     w:<span class="hljs-number">2</span>         x:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><p>owner = rwx = 4+2+1 = 7</p><p>group = rwx = 4+2+1 = 7</p><p>others= — = 0+0+0 = 0</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">chmod</span> <span class="hljs-number">777</span> filename   <span class="hljs-comment">#赋予文件全部权限</span><br></code></pre></td></tr></table></figure><p><strong>补充说明</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解压文件 tar -zxvf 文件名<br></code></pre></td></tr></table></figure><h3 id="3、查看文件">3、查看文件</h3><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li><p>cat 由第一行开始显示文件内容</p></li><li><p>tac 从最后一行开始显示，可以看出 tac 其实就是 cat 的倒着写</p></li><li><p>nl  显示的时候，顺道输出行号！</p></li><li><p>more 一页一页的显示文件内容</p></li><li><p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</p></li><li><p>head 只看头几行</p></li><li><p>tail 只看尾巴几行</p></li></ul><p>语法：</p><h4 id="3-1-cat">3.1 cat</h4><p>选项与参数：</p><ul><li><p>-A ：相当于-vET 的整合选项，可列出一些特殊字符而不是空白而已；</p></li><li><p>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</p></li><li><p>-E ：将结尾的断行字节 $ 显示出来；</p></li><li><p>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</p></li><li><p>-T ：将 [tab] 按键以 ^I 显示出来；</p></li><li><p>-v ：列出一些看不出来的特殊字符</p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span><br><span class="hljs-section">[root@Mercury ~]</span><span class="hljs-comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="hljs-attr">DEVICE</span>=eth0<br><span class="hljs-attr">BOOTPROTO</span>=dhcp<br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h4 id="3-2-tac">3.2 tac</h4><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[root@Mercury ~]</span><span class="hljs-comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">BOOTPROTO</span>=dhcp<br><span class="hljs-attr">DEVICE</span>=eth0<br></code></pre></td></tr></table></figure><h4 id="3-3-nl">3.3 nl</h4><p>显示行号</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">nl <span class="hljs-selector-attr">[-bnw]</span> 文件<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><p>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</p></li><li><p>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</p></li><li><p>-w ：行号栏位的占用的位数。</p></li></ul><p>测试：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[root@Mercury ~]</span><span class="hljs-comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="hljs-attr">1DEVICE</span>=eth0<br><span class="hljs-attr">2BOOTPROTO</span>=dhcp<br><span class="hljs-attr">3ONBOOT</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h4 id="3-4-more">3.4 more</h4><p>一页一页翻动</p><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li><p>空白键 (space)：代表向下翻一页；</p></li><li><p>Enter     ：代表向下翻『一行』；</p></li><li><p>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</p></li><li><p>:f      ：立刻显示出档名以及目前显示的行数；</p></li><li><p>q       ：代表立刻离开 more ，不再显示该文件内容。</p></li><li><p>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@kuangshen etc]<span class="hljs-comment"># more /etc/csh.login</span><br><span class="hljs-string">....</span><span class="hljs-params">(中间省略)</span><span class="hljs-string">....</span><br><span class="hljs-params">--More--</span><span class="hljs-params">(28%)</span> <span class="hljs-comment"># 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></code></pre></td></tr></table></figure><h4 id="3-5-less">3.5 less</h4><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p><p>less运行时可以输入的命令有：</p><ul><li><p>空白键  ：向下翻动一页；</p></li><li><p>[pagedown]：向下翻动一页；</p></li><li><p>[pageup] ：向上翻动一页；</p></li><li><p>/字串   ：向下搜寻『字串』的功能；</p></li><li><p>?字串   ：向上搜寻『字串』的功能；</p></li><li><p>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</p></li><li><p>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</p></li><li><p>q     ：离开 less 这个程序；</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@kuangshen etc]<span class="hljs-comment"># more /etc/csh.login</span><br><span class="hljs-string">....</span><span class="hljs-params">(中间省略)</span><span class="hljs-string">....</span><br>:   <span class="hljs-comment"># 这里可以等待你输入命令！</span><br></code></pre></td></tr></table></figure><h4 id="3-6-head">3.6 head</h4><p>取出文件前面几行</p><p>语法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">head [-n <span class="hljs-built_in">number</span>] 文件<br></code></pre></td></tr></table></figure><p>选项与参数：-n 后面接数字，代表显示几行的意思！</p><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@Mercury</span> etc]<span class="hljs-meta"># head -n 20 /etc/csh.login</span><br></code></pre></td></tr></table></figure><h4 id="3-7-tail">3.7 tail</h4><p>取出文件后面几行</p><p>语法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">tail [-n <span class="hljs-built_in">number</span>] 文件<br></code></pre></td></tr></table></figure><p>选项与参数：</p><p>-n ：后面接数字，代表显示几行的意思</p><p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@Mercury</span> etc]<span class="hljs-meta"># tail -n 20 /etc/csh.login</span><br></code></pre></td></tr></table></figure><h2 id="五、Linux链接">五、Linux链接</h2><p>Linux链接的概念分为两种硬链接和软链接</p><h3 id="1、硬链接">1、硬链接</h3><p>允许一个文件拥有多个路径 用户可以通过这种机制建立硬链接到一些重要文件上，防止误删</p><p>感觉像是文件复制了一份，存在了别的地方，即使原文件已经删除了，这个还是可以访问的</p><h3 id="2、软链接">2、软链接</h3><p>类似windows的快捷方式，和硬链接的区别就是，原文件如果已经删除了，这里使用ls查看的时候，该链接会变成红色，且无法打开(打开时会提示错误信息)</p><h2 id="六、Vim编辑器">六、Vim编辑器</h2><p><strong>三种使用模式</strong><br>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是：</p><h3 id="1、命令模式">1、命令模式</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><p>i 切换到输入模式，以输入字符。</p></li><li><p>x 删除当前光标所在处的字符。</p></li><li><p>：切换到底线命令模式，以在最底一行输入命令。</p></li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><h3 id="2、输入模式">2、输入模式</h3><p>在命令模式下按下 <strong>i</strong> 就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><p>字符按键以及Shift组合，输入字符</p></li><li><p>ENTER，回车键，换行</p></li><li><p>BACK SPACE，退格键，删除光标前一个字符</p></li><li><p>DEL，删除键，删除光标后一个字符</p></li><li><p>方向键，在文本中移动光标</p></li><li><p>HOME/END，移动光标到行首/行尾</p></li><li><p>Page Up/Page Down，上/下翻页</p></li><li><p>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</p></li><li><p>ESC，退出输入模式，切换到命令模式</p></li></ul><h3 id="3、底线命令模式">3、底线命令模式</h3><p>在命令模式下按下 <strong>:</strong> （英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li><p>q 退出程序</p></li><li><p>w 保存文件</p></li></ul><p>一般会wq一起使用，保存退出</p><p>按ESC键可随时退出底线命令模式。</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927170200816.png" alt="image-20240927170200816"></p><h2 id="七、账号用户和磁盘管理">七、账号用户和磁盘管理</h2><h3 id="1、账号用户管理">1、账号用户管理</h3><p>root是Linux系统中的最高权限</p><h4 id="1-1、添加用户">1.1、添加用户</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">useradd</span> -选项 用户名<br></code></pre></td></tr></table></figure><p>一些参数说明</p><ul><li><p>-c comment 指定一段注释性描述。</p></li><li><p>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</p></li><li><p>-g 用户组 指定用户所属的用户组。</p></li><li><p>-G :在创建用户的时候就添加进组</p></li><li><p>-m :自动创建这个用户的主目录 /home/william</p></li><li><p>-s Shell文件 指定用户的登录Shell。</p></li><li><p>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。<br>实际上就是添加了一个用户的目录</p></li></ul><h4 id="1-2、切换用户">1.2、切换用户</h4><p>切换用户的命令为：<strong>su username 【username即你的用户名】</strong></p><p>从普通用户切换到root用户，还可以使用命令：<strong>sudo su</strong></p><p>在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p><p>在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：<strong>【su - root】</strong></p><p>$表示普通用户</p><p>#表示超级用户，也就是root用户</p><h4 id="1-3、删除用户">1.3、删除用户</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">userdel</span> 选项 用户名       <span class="hljs-comment">#  删除用户</span><br><br>userdel -r 用户名        <span class="hljs-comment">#  删除用户并删除他的目录页</span><br></code></pre></td></tr></table></figure><h4 id="1-4、修改用户">1.4、修改用户</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">usermod</span> 选项 用户名<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">usermod -d <span class="hljs-regexp">/home/</span><span class="hljs-number">233</span> william<br><br><span class="hljs-comment"># 把William的用户配置文件换到233文件夹</span><br><br><span class="hljs-comment"># 这里的参数和上面的add命令里面的意义是一样的</span><br></code></pre></td></tr></table></figure><p><strong>临时插入</strong></p><p>hostname 查看主机名</p><p>hostname 想改的成名字  即可更改主机名     (不过这是临时的,永久的需要配置文件修改</p><h4 id="1-5-用户的密码设置">1.5 用户的密码设置</h4><p>先了解基本的查看所有的用户</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>psaawd<br></code></pre></td></tr></table></figure><p>查看所有的用户，如果你拥有<strong>超级用户</strong>的权限</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd username</span><br></code></pre></td></tr></table></figure><p>即可更改，不过输入密码的时候需要注意，Linux是不会显示密码的</p><p><strong>锁定账户</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">password</span> -l william    锁定账户<br><br><span class="hljs-keyword">password</span> -d william    删除账户的密码，没有密码也能登录<br></code></pre></td></tr></table></figure><h4 id="1-6、用户组管理">1.6、用户组管理</h4><p><strong>创建一个用户组</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">groupadd <br>cat <span class="hljs-regexp">/etc/g</span>roup 查看用户组<br></code></pre></td></tr></table></figure><p>创建后会有一个id 可以使用-g 520 指定 若不指定，则会自增</p><p><strong>删除用户组</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">groupdel <span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><p><strong>修改用户组</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">groupmod -g <span class="hljs-number">666</span> -n <span class="hljs-keyword">new</span><span class="hljs-type">william</span> william<br></code></pre></td></tr></table></figure><p>对Willam组修改id和名字</p><p><strong>用户切换用户组</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type">grp</span> groupname<br></code></pre></td></tr></table></figure><p>文件查看</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>密码存储在 /etc/shadow 里面</p><p>所有的密码都是加密过的</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927170226061.png" alt="image-20240927170226061"></p><h3 id="2、磁盘管理">2、磁盘管理</h3><h4 id="2-1、df-列出文件系统的磁盘使用量">2.1、df  列出文件系统的磁盘使用量</h4><ul><li><p>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</p></li><li><p>-k ：以 KBytes 的容量显示各文件系统；</p></li><li><p>-m ：以 MBytes 的容量显示各文件系统；</p></li><li><p>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</p></li><li><p>-H ：以 M=1000K 取代 M=1024K 的进位方式；</p></li><li><p>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</p></li><li><p>-i ：不用硬盘容量，而以 inode 的数量来显示</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927170259354.png" alt="image-20240927170259354"></p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20240927170331216.png" alt="image-20240927170331216"></p><h4 id="2-2、du-检查磁盘空间使用量">2.2、du  检查磁盘空间使用量</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">du <span class="hljs-selector-attr">[-ahskm]</span> 文件或目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><p>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</p><p>-h ：以人们较易读的容量格式 (G/M) 显示；</p><p>-s ：列出总量而已，而不列出每个各别的目录占用容量；</p><p>-S ：不包括子目录下的总计，与 -s 有点差别。</p><p>-k ：以 KBytes 列出容量显示；</p><p>-m ：以 MBytes 列出容量显示；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">du -h --max-depth=1<br>//查看各文件夹所占容量大小<br></code></pre></td></tr></table></figure><h2 id="八、-进程管理">八、 进程管理</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ps</span><br></code></pre></td></tr></table></figure><p>查看档期那系统正在执行的各种进程信息</p><ul><li><p>-a 显示当前终端运行的所有的进程信息</p></li><li><p>-u 以用户的信息显示进程</p></li><li><p>-x 显示后台运行进程的参数</p></li></ul><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">ps -<span class="hljs-built_in">aux</span> <br></code></pre></td></tr></table></figure><p>查看所有的进程，如果是想看到指定程序的进程可以，使用管道符过滤</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ps -aux <span class="hljs-string">| mysql      查看MySQL的进程</span><br><br>ps -aux <span class="hljs-string">| redis      查看redis的进程</span><br></code></pre></td></tr></table></figure><p>如果想查询相关的父进程的信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ps</span> -ef 可以查看到父进程的一些信息<br></code></pre></td></tr></table></figure><p>使用进程树查看</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree -pu</span><br></code></pre></td></tr></table></figure><h2 id="九、关于部署项目">九、关于部署项目</h2><ol><li>springboot的项目直接打包成jar包然后通过xftp上传到云服务器的root目录下</li><li>通过命令 <strong>netstat -anp | grep &lt;端口号&gt;</strong> 查看端口使用情况 <strong>lsof -i : (项目端口号)</strong>  查询当前端口是否有进程在使用</li><li>什么都没有显示，则表示没有进程在使用这个端口，如果有有进程，则通过命令 <strong>kill -9 (进程PID)</strong> 结束进程，空出端口号</li><li>通过命令   <strong>java -jar jar包名.jar</strong>  （单次）启动项目或者命令 <strong>nohup java -jar  jar包名.jar  &amp;</strong>     （后台运行，永久）</li><li><strong>tail -f nohup.out</strong> 查看日志</li></ol><p>注意：</p><ol><li><p>在部署前要记得改数据库的用户名和密码以及文件的映射路径（如果你配置了的话）</p></li><li><p>查看想开的端口是否已开</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">firewall-cmd <span class="hljs-attribute">--query-port</span>=8888/tcp     提示<span class="hljs-literal">yes</span>表示已开通，提示<span class="hljs-literal">no</span>表示未开通。<br></code></pre></td></tr></table></figure></li><li><p>有时在云服务器的管理界面直接开放端口不管用，需要手动输入命令开放项目所使用的端口</p></li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">firewall-cmd <span class="hljs-params">--zone=public</span> <span class="hljs-params">--add-port=8889/tcp</span> <span class="hljs-params">--permanent</span><br>firewall-cmd <span class="hljs-params">--reload</span>  <br><br><span class="hljs-comment"># 这里在写一些其他的关于防火墙的命令</span><br><span class="hljs-comment"># 开启</span><br>service firewalld start<br><span class="hljs-comment"># 重启</span><br>service firewalld restart<br><span class="hljs-comment"># 关闭</span><br>service firewalld stop<br><span class="hljs-comment"># 查看防火墙规则</span><br>firewall-cmd <span class="hljs-params">--list-all</span><br><span class="hljs-comment"># 查询端口是否开放</span><br>firewall-cmd <span class="hljs-params">--query-port=8080/tcp</span><br><span class="hljs-comment"># 开放80端口</span><br>firewall-cmd <span class="hljs-params">--permanent</span> <span class="hljs-params">--add-port=80/tcp</span><br><span class="hljs-comment"># 移除端口</span><br>firewall-cmd <span class="hljs-params">--permanent</span> <span class="hljs-params">--remove-port=8080/tcp</span><br><span class="hljs-comment">#重启防火墙(修改配置后要重启防火墙)</span><br>firewall-cmd <span class="hljs-params">--reload</span><br><span class="hljs-comment"># 参数解释</span><br>1、firwall-cmd：是Linux提供的操作firewall的一个工具；<br>2、<span class="hljs-params">--permanent</span>：表示设置为持久；<br>3、<span class="hljs-params">--add-port</span>：标识添加的端口；<br></code></pre></td></tr></table></figure><p>这里需要注意一下，一般需要先在阿里云上面的服务器添加规则，然后还需要在服务器上面执行相应的命令，这才可以成功的访问。</p><p>最后 ctrl+c退出指令。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tree</title>
    <link href="/2021/12/17/Tree/"/>
    <url>/2021/12/17/Tree/</url>
    
    <content type="html"><![CDATA[<h1>一、初识树</h1><p>不同于之前学过的一般的一对一的结构，树是一种一对多的结构，树一个节点可能对应着一个节点或者好几个节点<br>（从书上嫖的定义：</p><p><strong>树是n（n&gt;=0）个结点的有限集。</strong> 当n = 0时，称为空树。在任意一棵非空树中应满足：</p><ul><li>有且仅有一个特定的称为根的结点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。</li></ul><h1>二、 基本概念</h1><h2 id="1、节点的分类">1、节点的分类</h2><p>结点拥有的子树数称为结点的度。度为0的结点称为叶结点(Leaf) 或终端结点;度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。<strong>树的度是树内各结点的度的最大值。</strong><br><img src="https://img-blog.csdnimg.cn/90970a4049b045169f2ebc62eb613363.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="2、节点之间的关系">2、节点之间的关系</h2><p>节点之间的称呼比较有意思，互相叫爸爸(bushi ,节点子树的根称为该节点的孩子，然后呢，孩子节点按照辈分要叫这个节点为爸爸，即父节点。同一个双亲节点之间互称兄弟。所以下图中  A节点是B、C的父节点，B、C是A节点的子节点，B、C之间互称兄弟节点。<br><img src="https://img-blog.csdnimg.cn/818480bb433f439d8d6b1f05f0b69fe4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="3、树的层次">3、树的层次</h2><p>结点的层次从根开始算起，根为第一层，根的孩子为第二层 。树中结点的最大层次称为树<br>的深度或高度，下图中树的深度为4<br><img src="https://img-blog.csdnimg.cn/dea4df363f05470aa9860e8c26f5ba2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树的层次"></p><h1>三、树的抽象数据类型（ADT）</h1><p><img src="https://img-blog.csdnimg.cn/f6eaeda9c2e541daa8588cd64487f451.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>(书上摘的，记得下来自己看</p><h1>四、树的存储结构</h1><p>一般说起存储结构，就会想起前面学过的栈和队列，拥有两种存储结构，一种是顺序存储结构，<s>一种还是顺序结构</s>，另外一种是链式存储结构，但是树因为其较为复杂的机制，所以只使用顺序存储结构会很麻烦，因此树一般使用的是链式结构，主要有三种表示法用来表示树。以下表示法中的示例都是本树<br><img src="https://img-blog.csdnimg.cn/5c7c2be045d84c94a1a0f84730cc3016.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="为方便，我们把它命名为M树"></p><h2 id="1-双亲表示法">1. 双亲表示法</h2><p>这种表示法中，每一个节点中专门设置一个域用来指示双亲的位置，如下图所示<br><img src="https://img-blog.csdnimg.cn/cce19ec1b4494c81980ee827d87f7dc8.png" alt="双亲表示法"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*树的双亲表示法结点结构定义*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> TElemType;<span class="hljs-comment">//树结点的数据类型，目前暂定为整型</span><br><span class="hljs-comment">/*结点的结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span><br>TElemType data;<span class="hljs-comment">//结点数据</span><br><span class="hljs-keyword">int</span> parent;<span class="hljs-comment">//双亲位置</span><br>&#125;TNode;<br><span class="hljs-comment">/*树结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>TNode nodes[MAX_TREE_SIZE];<span class="hljs-comment">//结点数组</span><br><span class="hljs-keyword">int</span> r, n;<span class="hljs-comment">//根的位置和结点数</span><br>&#125;Tree;<br><br></code></pre></td></tr></table></figure><p>由此就可以推导出来上图中的M树的结构就如下图所示<br><img src="https://img-blog.csdnimg.cn/2857e61a37ef47e8acb262244e83df41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="双亲表示法结构图"><br>思考：上图中的 -1 表示什么意思</p><p>这种表示法我们可以根据结点的 parent 指针很容易找到色的双亲结点，所用的时间复杂度为 O(1)，但是如果想要知道孩子节点是哪一个则需要全部遍历完才行，比较麻烦</p><h2 id="2-孩子表示法">2.孩子表示法</h2><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，如图所示。<img src="https://img-blog.csdnimg.cn/dffd9e59e222443da9714cddc23de18c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="孩子表示法"><br>孩子表示法中需要两种结构，一种是孩子结点的结构，还有一种是表头结点<br><img src="https://img-blog.csdnimg.cn/c55dffc097c8443b998bcfacdcb60577.png" alt="孩子结点的结构"><br>child保存数据，next是指针域，用于保存下一个结点的位置<br><img src="https://img-blog.csdnimg.cn/d163d229787341338b3328331dac6ae4.png" alt="表头结点"><br>同理，data用于保存数据，firstchild用于保存第一个孩子结点的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*树的孩子表示法结构定义*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-comment">/*孩子结点*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>&#123;</span><br><span class="hljs-keyword">int</span> child;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;*ChildPtr;<br><span class="hljs-comment">/*表头结点*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>TElemType data;<br>ChildPtr firstchild;<br>&#125;CTBox;<br><span class="hljs-comment">/*树结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>CTBox nodes[MAX_TREE_SIZE];<span class="hljs-comment">//结点数组</span><br><span class="hljs-keyword">int</span> r, n;<span class="hljs-comment">//根的位置和结点数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-孩子兄弟表示法">3.孩子兄弟表示法</h2><p>任意一棵树， 它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。 因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*树的孩子兄弟表示法结构定义*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span>&#123;</span><br>TElemtype data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>, *<span class="hljs-title">rightsib</span>;</span><br>&#125; CSNode, *CSTree;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/33b9e0c1d20049bf944e1af6e613cbfb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="孩子兄弟表示法"><br>(即生成一棵二叉树，至于怎么生成，后面会讲</p><h1>五、二叉树</h1><h2 id="1、什么是二叉树">1、什么是二叉树</h2><p>二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。<br>与树相似，二叉树也以递归的形式定义。二叉树是n (n≥0) 个结点的有限集合:</p><h2 id="2、二叉树的特点">2、二叉树的特点</h2><ul><li>每个结点<strong>最多有</strong>两棵子树，.注意不是只有两棵子树，而是最多有.没有子树或者有一棵子树都可以</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。即使树中某结点只有一个子树，也要区分它是左子树还是右子树.</li></ul><p><img src="https://img-blog.csdnimg.cn/7f82d256469640a2a8679d6b5193afa2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt=""><br>二叉树的5种基本形态<br><img src="https://img-blog.csdnimg.cn/7a526a04419a4b8687592eff967f5b86.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="5种形态"></p><h2 id="3、特殊的二叉树">3、特殊的二叉树</h2><h3 id="3-1斜树">3.1斜树</h3><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><h3 id="3-2满二叉树">3.2满二叉树</h3><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都同一层上，这样的二叉树称为满二叉树<br><img src="https://img-blog.csdnimg.cn/f27fd59b4fa244b18b08723c836cebfd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="3-3完全二叉树">3.3完全二叉树</h3><p>对一棵具有n个结点的二叉树按层序编号，如果编号为 (l&lt;i&lt;n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树<br><img src="https://img-blog.csdnimg.cn/b11208870f4d45b69f1c80ec6a923122.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><ul><li>若i ≤ n / 2, 则结点i为分支结点，否则为叶子结点。</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。</li><li>若有度为1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子(重要特征)。</li><li>按层序编号后，一旦出现某结点(编号为i)为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。</li><li>若n为奇数，则每个分支结点都有左孩子和右孩子;若n为偶数，则编号最大的分支结点(编号为n / 2 )只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li></ul><p><strong>注意：</strong><br>完全二叉树和满二叉树的区别，满二叉树一定是棵完全二叉树，但完全二叉树不一定是满二叉树</p><h2 id="4-二叉树的性质">4.二叉树的性质</h2><p><img src="https://img-blog.csdnimg.cn/a6254509679e47f1992a4c7951a32885.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_16,color_FFFFFF,t_70,g_se,x_16" alt=""></p><ol><li>非空二叉树上第i层上至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2 ^ {i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> 0）</li><li>高度为h的二叉树至多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 ^ h − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点（h <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> 1）</li><li>任意一棵树，若结点数量为n,则边的数量为n − 1</li><li>非空二叉树上的叶子结点数(度为0的节点数)等于度为2的结点数加1，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0 = n_2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>具有n个( n &gt; 0 )结点的完全二叉树的高度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log_2n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>对有n个结点的完全二叉树按从上到下、从左到右的顺序依次编号1 , 2… ∗ , n 则有以下关系:<ul><li>i = 1时，结点i是二叉树的根，没有双亲；若 i &gt; 1结点i的双亲的编号为[i / 2]</li><li>当2i &gt;n时，则结点 无左孩子(结点 为叶子结点) ;否则其左孩子是结点2i</li><li>如果 2i+1&gt;n ，则结点 无右孩子;否则其右孩子是结点 2i+1</li></ul></li></ol><h2 id="5-二叉树的存储结构">5.二叉树的存储结构</h2><p>直接上链式结构、二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。<br><img src="https://img-blog.csdnimg.cn/22c46fabe0fe47938be7fc3d02683a5a.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*二叉树的二叉链表结点构造定义*/</span><br><span class="hljs-comment">/*结点结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>TElemType data;<span class="hljs-comment">//结点数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125; BiTNode, *BiTree;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/43919b58fdc547e39ebc822464c78827.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="6-遍历二叉树">6.遍历二叉树</h2><h3 id="6-1-先序遍历">6.1 先序遍历</h3><p>顺序为：根-&gt;左-&gt;右<br><img src="https://img-blog.csdnimg.cn/22fdc94421da45afb7db1a077964050a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//使用递归算法进行先序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br><span class="hljs-keyword">if</span>(T != <span class="hljs-literal">NULL</span>)&#123;<br>visit(T);<span class="hljs-comment">//访问根节点输出</span><br>PreOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>PreOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-2-中序遍历">6.2 中序遍历</h3><p>顺序：左-&gt;根-&gt;右<br><img src="https://img-blog.csdnimg.cn/789ba64239ef4b80b7046e4941d435a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//递归版</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br><span class="hljs-keyword">if</span>(T != <span class="hljs-literal">NULL</span>)&#123;<br>InOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>visit(T);<span class="hljs-comment">//访问根结点</span><br>InOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-3-后序遍历">6.3 后序遍历</h3><p>顺序为：左-&gt;右-&gt;根<br><img src="https://img-blog.csdnimg.cn/e97540b04d0b41d683c8585cda7562c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//递归版</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br><span class="hljs-keyword">if</span>(T != <span class="hljs-literal">NULL</span>)&#123;<br>PostOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>PostOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>visit(T);<span class="hljs-comment">//访问根结点</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-4三种遍历的非递归算法">6.4三种遍历的非递归算法</h3><p>以下图这棵树为例<br><img src="https://img-blog.csdnimg.cn/8bd149999c474d97b6a6778618f1e058.png" alt=""></p><p><strong>1. 中序遍历的非递归算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>InitStack(S);<span class="hljs-comment">//初始化栈S</span><br>BiTree p = T;<span class="hljs-comment">//p是遍历指针</span><br><span class="hljs-keyword">while</span>(p || !IsEmpty(S))&#123;<span class="hljs-comment">//栈不空或p不空时循环</span><br><span class="hljs-keyword">if</span>(p)&#123;<br>Push(S, p);<span class="hljs-comment">//当前节点入栈</span><br>p = p-&gt;lchild;<span class="hljs-comment">//左孩子不空，一直向左走</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Pop(S, p);<span class="hljs-comment">//栈顶元素出栈</span><br>visit(p);<span class="hljs-comment">//访问出栈结点</span><br>p = p-&gt;rchild;<span class="hljs-comment">//向右子树走，p赋值为当前结点的右孩子</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后的遍历结果就是DBEAC</p><p><strong>2. 先序遍历的非递归算法（和中序遍历是类似的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>InitStack(S);<span class="hljs-comment">//初始化栈S</span><br>BiTree p = T;<span class="hljs-comment">//p是遍历指针</span><br><span class="hljs-keyword">while</span>(p || !IsEmpty(S))&#123;<span class="hljs-comment">//栈不空或p不空时循环</span><br><span class="hljs-keyword">if</span>(p)&#123;<br>visit(p);<span class="hljs-comment">//访问出栈结点</span><br>Push(S, p);<span class="hljs-comment">//当前节点入栈</span><br>p = p-&gt;lchild;<span class="hljs-comment">//左孩子不空，一直向左走</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Pop(S, p);<span class="hljs-comment">//栈顶元素出栈</span><br>p = p-&gt;rchild;<span class="hljs-comment">//向右子树走，p赋值为当前结点的右孩子</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后的遍历结果就是ABDEC</p><p><strong>3. 后序遍历的非递归算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>InitStack(S);<br>p = T;<br>r = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span>(p || !IsEmpty(S))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">//走到最左边</span><br>push(S, p);<br>p = p-&gt;lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//向右</span><br>GetTop(S, p);<span class="hljs-comment">//读栈顶元素（非出栈）</span><br><span class="hljs-comment">//若右子树存在，且未被访问过</span><br><span class="hljs-keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)&#123;<br>p = p-&gt;rchild;<span class="hljs-comment">//转向右</span><br>push(S, p);<span class="hljs-comment">//压入栈</span><br>p = p-&gt;lchild;<span class="hljs-comment">//再走到最左</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则，弹出结点并访问</span><br>pop(S, p);<span class="hljs-comment">//将结点弹出</span><br>visit(p-&gt;data);<span class="hljs-comment">//访问该结点</span><br>r = p;<span class="hljs-comment">//记录最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后的遍历结果就是DEBCA</p><h3 id="6-5-层序遍历">6.5 层序遍历</h3><p>故名思意，层序遍历就是按照每一层的顺序进行遍历，例如下图所示<br><img src="https://img-blog.csdnimg.cn/3a563960ce4f4305ad78caa328f40794.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_8,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//（其实就和广度优先搜索是一样的，使用队列实现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>InitQueue(Q);<span class="hljs-comment">//初始化辅助队列</span><br>BiTree p;<br>EnQueue(Q, T);<span class="hljs-comment">//将根节点入队</span><br><span class="hljs-keyword">while</span>(!IsEmpty(Q))&#123;<span class="hljs-comment">//队列不空则循环</span><br>DeQueue(Q, p);<span class="hljs-comment">//队头结点出队</span><br>visit(p);<span class="hljs-comment">//访问出队结点</span><br><span class="hljs-keyword">if</span>(p-&gt;lchild != <span class="hljs-literal">NULL</span>)&#123;<br>EnQueue(Q, p-&gt;lchild);<span class="hljs-comment">//左子树不空，则左子树根节点入队</span><br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;rchild != <span class="hljs-literal">NULL</span>)&#123;<br>EnQueue(Q, p-&gt;rchild);<span class="hljs-comment">//右子树不空，则右子树根节点入队</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="7-反推遍历结果">7.反推遍历结果</h2><p>首先记住几个点：</p><ul><li>由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。</li><li>由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。</li><li>由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树。</li><li><strong>只知道二叉树的先序序列和后序序列,则无法唯一确定一棵二叉树。</strong></li></ul><p>下面以这个序列作为演示<br>已知某一棵树的遍历结果如下图所示，请画出这棵树<br>前序遍历：ABCDEF<br>中序遍历：CBAEDF</p><p>分析：首先，根据前面所讲的前序和中序恶的遍历顺序，可以得知，A是该树的根节点，再结合中序遍历CB <em><strong>A</strong></em> EDF，可以得知，CB结点在根节点的左子树，EDF在根结点的右子树。由于先序先输出了B，所以B是A的孩子，而C是B的孩子，再根据中序中先输出了C，所以C是B的右孩子。右子树中根据先序遍历可得EF是D的子节点，再根据中序就可以确定E在左，D在右。即如下图所示的树。<br><img src="https://img-blog.csdnimg.cn/a5ff3ea8f1914fe7b9e6279de116f152.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_13,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="8-创建二叉树">8.创建二叉树</h2><p>创建一棵二叉树和之前的遍历没有什么区别，唯一的不同就是多了内存分配。下面以先序遍历为例创建一棵二叉树<br><img src="https://img-blog.csdnimg.cn/ecd3546b67f7450da6e186c94b41a199.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_13,color_FFFFFF,t_70,g_se,x_16" alt=""><br>若想要创建如图所示的一棵二叉树，我们需要补全一下，这棵树的结构，把所有的结点都改成度为的结点，不够的就以符号‘＃’补齐，以便让程序知道到了终点<br><img src="https://img-blog.csdnimg.cn/fa346b3c0fd04e3b81daee268eaab68e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br>补齐之后按照前序遍历的方式输入如下字符：AB###C##</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//前序遍历创建一棵树</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBiTree</span> <span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123; <br>   TElemType ch; <br>   <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch) ;<span class="hljs-comment">//输入先序遍历的字符串 </span><br>   <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&quot;#&quot;</span> ) &#123;<br>         *T=<span class="hljs-literal">NULL</span>;<br>      &#125; <br>   <span class="hljs-keyword">else</span>&#123; <br>         *T=(BiTree) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(BiTNode));<span class="hljs-comment">//如果不为#就给分配一个内存空间</span><br>      &#125; <br>      <span class="hljs-keyword">if</span> (!*T)&#123; <br>         <span class="hljs-built_in">exit</span>(OVERFLOW) ;<span class="hljs-comment">//内存分配失败</span><br>         &#125;<br>      (*T) -&gt;data = ch;<span class="hljs-comment">// 生成根结点，并把数据读入数据域</span><br>      CreateBiTree (&amp;(*T) -&gt;lchild); <span class="hljs-comment">//递归构造左子树</span><br>      CreateBiTree (&amp;(*T) -&gt;rchild);<span class="hljs-comment">//递归构造右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理和之前的先序遍历是一样的，如果想使用中序遍历或者是后序遍历创建一棵树，只需要把递归代码的顺序改一下即可。</p><h1>六、树、二叉树、森林的转换</h1><h2 id="1-树转换为二叉树">1. 树转换为二叉树</h2><ul><li>加线。在所有兄弟结点之间加一条连线。</li><li>去钱。对树中每个结点，只保留它与第一个孩子结点的连线，删除与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转 定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ul><p><img src="https://img-blog.csdnimg.cn/66e2fe96701345df94119767e7fbe42c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="给兄弟之间加线"><br><img src="https://img-blog.csdnimg.cn/1661a2a134e548ac8e89ae842dc8b8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="去线"></p><h2 id="2-森林转换为二叉树">2. 森林转换为二叉树</h2><ul><li>把每个树转换为二叉树。</li><li>第一 棵二叉树不动，从第二棵二叉树开始，依次把后一棵 叉树的根结点作为<br>棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后<br>就得到了由森林转换来的二叉树。</li></ul><p><img src="https://img-blog.csdnimg.cn/84d628fb789e40648e0ab4cb0f2cc413.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="森林"></p><p><img src="https://img-blog.csdnimg.cn/84df22d0a9a343f0a6b246905a17e455.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="把每一棵树转换为二叉树"></p><p><img src="https://img-blog.csdnimg.cn/bf8c5d80f3474fa3be07efbb15ca62f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="把每一棵树作为前一棵树的右子树连接起来"></p><h2 id="3-二叉树转换为树">3. 二叉树转换为树</h2><ul><li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的</li><li>右孩子结点、右孩子的右孩 的右孩子结点……将该结点与这些右孩子结点用线连接起来。</li><li>去钱。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整使之结构层次分明。</li></ul><p><img src="https://img-blog.csdnimg.cn/3f08aa4960234221aa4092a066720f58.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="二叉树"></p><p><img src="https://img-blog.csdnimg.cn/ca684fa4c4f644d8b16acbfdf97ba087.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="加线"></p><p><img src="https://img-blog.csdnimg.cn/3150978ae6fb4830bf76a26a153498d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="去线"></p><p><img src="https://img-blog.csdnimg.cn/5b603c2200414ef1995dd341b04672d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="层次调整"></p><h2 id="4-二叉树转换为森林">4. 二叉树转换为森林</h2><ul><li>从根结点开始 若右孩子存在，则把与右孩子结点的连线 ，再查看分离后的二叉树，若右孩子存在，则连续去除……，直到所有右孩子连线都删除为止，得到分离的 叉树再将每棵分离后的 叉树转换为树即可（就是过程反一下而已</li></ul><p><img src="https://img-blog.csdnimg.cn/db8b4cd5a9ef49e9a50328c6085bc27e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="二叉树"></p><p><img src="https://img-blog.csdnimg.cn/9a5882b52f9f44538ce525beb753da7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="寻找右孩子去线"></p><p><img src="https://img-blog.csdnimg.cn/cb75e4708e6f4ba5a72176ed60ebc957.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="将分离的二叉树转换为树"></p><h1>七、哈夫曼树</h1><h2 id="1-带权路径长度及哈夫曼树的定义">1. 带权路径长度及哈夫曼树的定义</h2><p>树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度，树中所有叶结点的带权路径长度之和称为该树的带权路径长度。<strong>在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树。</strong> 例如，下图中的3棵二叉树都有4个叶子结点a, b,c,d,分别带权7,5,2,4，它们的带权路径长度分别为</p><p><img src="https://img-blog.csdnimg.cn/eefc1b5f75a341beb43e3d3676ede415.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""><br>上图中C树的带权路径长度最小，因此为哈夫曼树</p><h2 id="2-构建一棵哈夫曼树">2. 构建一棵哈夫曼树</h2><p>采用贪心算法的思想构造</p><ol><li>先把有权值的叶子结点按照从大到小（从小到大也可以）的顺序排列成一个有序序列。</li><li>取最后两个最小权值的结点作为一个新节点的两个子结点，注意相对较小的是左孩子。</li><li>用第2步构造的新结点替掉它的两个子节点，插入有序序列中，保持从大到小排列。</li><li>重复步骤2到步骤3，直到根节点出现。</li></ol><p><img src="https://img-blog.csdnimg.cn/ce5fbd7136c748458ff74a9c1c718e93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="3-哈夫曼编码">3. 哈夫曼编码</h2><p>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码<br>例如将这串字符用二进制转换</p><pre><code class="hljs">BADCADFEED</code></pre><p>得到的代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/88f44e2917c44e3b9f7911e522d1017b.png" alt=""><br>采用哈夫曼树进行编码，根据出现的次数确定权重。构造的哈夫曼树如下图所示：<br><img src="https://img-blog.csdnimg.cn/c4c683ed99a64db08d56968d2f4714cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>然后转换为二进制代码：<br><img src="https://img-blog.csdnimg.cn/187f72f293954aee85731636911d9054.png" alt=""><br>和原来的相比，就会压缩了许多<br><img src="https://img-blog.csdnimg.cn/062df6ce4a1a411eb4976adaf04a096c.png" alt=""><br>哈夫曼树博大精深，这里只是粗浅的讲一下。</p><p>———————————————————————————————《完结撒花，感谢陪伴》</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2021/11/23/Swagger/"/>
    <url>/2021/11/23/Swagger/</url>
    
    <content type="html"><![CDATA[<h1>一、为什么要使用swagger</h1><p>在前后端分离的时代，前端人员和后端人员无法做到“及时协商，尽早解决”，最终会导致许多的问题出现。<br>解决方案：</p><ul><li>首先制定一个schema，实时更新最新的API，降低集成的风险；</li><li>前后端分离<ul><li>前端测试后端接口：postman</li><li>后端提供接口，需要实时更新最新的消息及改动<br>这里可以参考swagger的官网 <a href="https://swagger.io/">https://swagger.io/</a></li></ul></li></ul><h1>二、springboot集成swagger</h1><p>这里是以springboot 2.6.0和swagger3.0.0版本作为演示</p><p>首先在pom.xml文档里面加入这个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后需要写一个对于swagger的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableOpenApi</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//分组</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;A&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .enable(<span class="hljs-keyword">true</span>)<span class="hljs-comment">//默认为true 关闭后，则不能使用swagger</span><br>                .select()<br>                <span class="hljs-comment">//指定接口的位置</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.swagger.controller&quot;</span>))<br>                <span class="hljs-comment">//过滤什么路径</span><br>                <span class="hljs-comment">//.paths()</span><br>                .build();<br>                <span class="hljs-comment">//.globalOperationParameters(pars);</span><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//作者信息</span><br>        Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;William&quot;</span>,<span class="hljs-string">&quot;https://mercurys-52hz.gitee.io/&quot;</span>,<span class="hljs-string">&quot;chening_william@163.com&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<br>                <span class="hljs-string">&quot;William的接口文档&quot;</span>,<br>                <span class="hljs-string">&quot;前端根据接口进行测试&quot;</span>,<br>                <span class="hljs-string">&quot;1.0&quot;</span>,<br>                <span class="hljs-string">&quot;https://mercurys-52hz.gitee.io/&quot;</span>,<br>                contact,<br>                <span class="hljs-string">&quot;Apache 2.0&quot;</span>,<br>                <span class="hljs-string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,<br>                <span class="hljs-keyword">new</span> ArrayList()<br>        );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1>三、配置详解</h1><h2 id="1-swagger配置">1.swagger配置</h2><p>在swagger3.0.0版本中，需要在配置类的上面加上 <strong>@EnableOpenApi</strong>，当然还有配置类需要的@Configuration注解，最重要的就是一定需要加上 <strong>@EnableWebMvc</strong>注解，不然控制面板就会报错，就是这个错误浪费了我一下午的时间</p><p><img src="https://img-blog.csdnimg.cn/c56545e911d04ed2846559866babdb15.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="更多的配置"><br>可以通过设置 <strong>.apis(RequestHandlerSelectors.basePackage(“com.swagger.controller”))</strong> 里面的参数用来指定需要扫描的包，这里面还可以设置更多的参数，详情可以参照上面的这张图片。加上 <strong>paths()</strong> 后可以在里面设置过滤的路径不扫描。</p><h2 id="2-信息配置">2.信息配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//作者信息</span><br>        Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;William&quot;</span>,<span class="hljs-string">&quot;https://mercurys-52hz.gitee.io/&quot;</span>,<span class="hljs-string">&quot;chening_william@163.com&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<br>                <span class="hljs-string">&quot;William的接口文档&quot;</span>,<br>                <span class="hljs-string">&quot;前端根据接口进行测试&quot;</span>,<br>                <span class="hljs-string">&quot;1.0&quot;</span>,<br>                <span class="hljs-string">&quot;https://mercurys-52hz.gitee.io/&quot;</span>,<br>                contact,<br>                <span class="hljs-string">&quot;Apache 2.0&quot;</span>,<br>                <span class="hljs-string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,<br>                <span class="hljs-keyword">new</span> ArrayList()<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7738d84b0a794a7a8870ffb54cdcd915.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="里面一些参数的名字"><br>这里主要就是配置一些作者的信息的名字好联系啥的，不太重要，就不细讲了。</p><h2 id="3-配置多api分组">3.配置多api分组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分组</span><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;A&quot;</span>);<br>   &#125;<br><br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;B&quot;</span>);<br>   &#125;<br><br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;C&quot;</span>);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>作用就是为每个api分一下组。作用效果如下图<br><img src="https://img-blog.csdnimg.cn/13fe5463f9b240b0a2d76be6183d9d63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="分组详情"></p><h2 id="4-通过注解配置注释">4.通过注解配置注释</h2><p>凭空传过去，前端一定会一脸懵逼的，这时候就需要注释来帮助理解了。<br><img src="https://img-blog.csdnimg.cn/b7caed00139349b499335c18b7b094c7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1>四、swagger的使用</h1><p>1、访问</p><p>swagger3.0的默认的访问地址为  主机地址+/swagger-ui/index.html</p><p>2、注释的使用</p><p>Swagger使用的注解及其说明：</p><p>@Api：用在类上，说明该类的作用。</p><p>@ApiOperation：注解来给API增加方法说明。</p><p>@ApiImplicitParams : 用在方法上包含一组参数说明。</p><p>@ApiImplicitParam：用来注解来给方法入参增加说明。</p><p>@ApiResponses：用于表示一组响应</p><p>@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</p><pre><code class="hljs">   code：数字，例如400   message：信息，例如&quot;请求参数没填好&quot;   response：抛出异常的类   </code></pre><p>@ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）</p><pre><code class="hljs">  @ApiModelProperty：描述一个model的属性</code></pre><table><thead><tr><th style="text-align:left">paramType：指定参数放在哪个地方</th><th style="text-align:left">header：请求参数放置于Request Header，使用@RequestHeader获取 <br> query：请求参数放置于请求地址，使用@RequestParam获取<br>path：（用于restful接口）–&gt;请求参数的获取：@PathVariable<br>body：（不常用）<br>form（不常用</th></tr></thead><tbody><tr><td style="text-align:left">name：参数名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">dataType：参数类型</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">required：参数是否必须传</td><td style="text-align:left">true / false</td></tr><tr><td style="text-align:left">value：说明参数的意思</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">defaultValue：参数的默认值</td><td style="text-align:left"></td></tr></tbody></table><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Api(&quot;登录控制器&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">loginController</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;输入用户的id和密码，查询用户信息，如果数据库没有或者密码不对应则会返回空值&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParams(&#123; @ApiImplicitParam(paramType = &quot;query&quot;,name = &quot;id&quot;,value = &quot;用户的id&quot;,required = true,dataType = &quot;Integer&quot;,dataTypeClass = Integer.class,example = &quot;123&quot;),</span><br><span class="hljs-meta">                         @ApiImplicitParam(paramType = &quot;query&quot;,name = &quot;password&quot;, value = &quot;密码&quot;,required = true,dataType = &quot;String&quot;,dataTypeClass = String.class)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span><span class="hljs-keyword">int</span> id, <span class="hljs-meta">@RequestParam(&quot;password&quot;)</span> String password)</span></span>&#123;<br><br>        User loginuser = userService.doLogin(id,password);<br><br>        <span class="hljs-keyword">if</span>(loginuser == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> loginuser;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里补充一点，在使用swagger(version 3.0)的进行上传文件的调试的时候需要注意一点，记得把把参数那里的文件的注解换一下，才能使swagger显示出来上传文件的按钮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file<br></code></pre></td></tr></table></figure><h4><<<<<完结撒花>>>>></h4>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot</title>
    <link href="/2021/10/24/springboot/"/>
    <url>/2021/10/24/springboot/</url>
    
    <content type="html"><![CDATA[<h1>一、初识boot</h1><p><img src="https://img-blog.csdnimg.cn/cb9ab8a3d43543849f3b99943bee9000.png" alt=""><br><img src="https://img-blog.csdnimg.cn/37911160829e4ddf8031e998b114b15c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>可以从Spring或者idea上面直接创建boot项目</p><p><strong>@RestController//返回字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-comment">//返回字符串</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hellocontroller</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello,world&quot;</span>;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在application中启动程序<br><img src="https://img-blog.csdnimg.cn/42b5d70b2c06457d9cdbb5e588c594fc.png" alt=""></p><h2 id="1-pom-xml分析">1. pom xml分析</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 这个boot的依赖集成了tomcat dispatcherServlet xml     --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br><span class="hljs-comment">&lt;!--测试用的有依赖--&gt;</span><br><br><span class="hljs-comment">&lt;!--有一个共同的前缀就是spring-boot-starter--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br><span class="hljs-comment">&lt;!--这里有时候需要收到导入一下这个web依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--打包的依赖，打包成jar包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-配置端口">2. 配置端口</h2><p><img src="https://img-blog.csdnimg.cn/bb17c9cf3a8547639146187eb765bfe1.png" alt=""></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">server.port = <span class="hljs-number">8081</span>   <span class="hljs-regexp">//</span>properties配置端口文件<br></code></pre></td></tr></table></figure><h2 id="3-启动器">3. 启动器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>启动器:就是boot的启动场景</li><li>比如spring-boot-starter-web,他就会帮我们自动导入web环境的所有依赖</li><li>springboot会将所有的场景功能,都变成一个个的启动器</li><li>我们要使用什么功能,就只要找到对应的启动器就行了</li></ul><h2 id="4-自动配置">4. 自动配置</h2><p>boot所有的自动配置都是启动的时候扫描并加载, spring,factories所有的自动配置都在这里面,但是不一定生效,要判断条件是否成立,只要导入了对应的start,就有对应的启动器了,有了启动器,我们的自动装配就会生效,然后就会配置成功</p><ol><li>springboot在启动的时候,从类路径下/META/spring.factorirs 获取指定的值;</li><li>将这些自动配置导入容器,自动配置就会生效,帮我进行自动配置</li><li>整合JavaEE,解决方案和自动配置的东西都在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包下.</li><li>它会把所有需要导入的组件,以类名的方式返回,这些组件就会被添加到容器</li><li>容器也会存在非常多的xxxAutoConfiguration 的文件,  就是这些类给容器中导入了这个场景需要的所有组件</li></ol><h1>二、一些简单的boot操作</h1><h2 id="1-yaml语句">1. yaml语句</h2><p><strong>一定要记住有空格!!!  空格很重要  代表了他们之间的层级关系</strong></p><p><img src="https://img-blog.csdnimg.cn/604fbd34eb62486587f3a6d8bde347ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="1-基础语法">1) 基础语法</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">william</span><br><span class="hljs-comment">#对象</span><br><br><span class="hljs-attr">student:</span><br>  <span class="hljs-string">name:william</span><br>  <span class="hljs-string">age:3</span><br><span class="hljs-comment"># 行内写法</span><br><span class="hljs-string">student</span> &#123;<span class="hljs-string">name:william</span>,<span class="hljs-string">age:3</span>&#125;<br>     <br><span class="hljs-comment"># 数组</span><br><span class="hljs-string">pets</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span><br><br><span class="hljs-attr">pets:</span> [<span class="hljs-string">cat</span>,<span class="hljs-string">dog</span>,<span class="hljs-string">pig</span>]     <br></code></pre></td></tr></table></figure><p>可以同时存在两个配置文件,但是他们有优先级<br><img src="https://img-blog.csdnimg.cn/808c9f56c6b94255915b74f98fda238f.png" alt=""></p><h3 id="2-yaml可以直接个实体类赋值">2) yaml可以直接个实体类赋值</h3><ol><li>常规方法</li></ol><p>@Componet  标记为spring的组件  spring才会扫描</p><p>@Value (“”)   为属性添加值</p><p><img src="https://img-blog.csdnimg.cn/fc2bfab5037c4a62ac5f1a8f3b353315.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_12,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>@Autowired自动装配过来</p><ol start="2"><li>yaml方法<br><img src="https://img-blog.csdnimg.cn/cb891492fd19434fbbc15b5768832385.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><p>配置了上图的configurationProperties()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span>;<br><span class="hljs-comment">//这里就将yaml里person和类绑定起来了,就可以给类进行赋值</span><br></code></pre></td></tr></table></figure><p>再加上对应的名  和yaml中的一样就可以赋值成功了</p><h2 id="2-ConfigurationProperties">2. ConfigurationProperties</h2><p><img src="https://img-blog.csdnimg.cn/128d7f927e674c558982aaf244bc8c26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><ol><li>自定义配置文件</li></ol><p>也可以自定义自己的配置文件绑定一下就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySouce(value = &quot;classpath:qinjiang.properties&quot;)</span><br>...类...<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3b9261d3808f41459886d9ba7a437864.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_16,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/57e795efb2a34ffea55efb1fc19475e9.png" alt=""></p><ol start="2"><li>也可以使用el表达式</li></ol><p><img src="https://img-blog.csdnimg.cn/e639db1cd8e142c9baf114c78688ad24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang$&#123;random.uuid&#125;</span><br> <span class="hljs-attr">age:</span> <span class="hljs-string">$&#123;random,int&#125;</span>  <span class="hljs-comment"># 给属性赋随机值</span><br> <span class="hljs-attr">happy:</span> <span class="hljs-literal">false</span><br> <span class="hljs-attr">birth:</span> <span class="hljs-number">2021</span><span class="hljs-string">/10/13</span><br> <span class="hljs-attr">maps:</span> &#123;<span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>&#125;<br> <span class="hljs-attr">list:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">code</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">music</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">girl</span> <br><span class="hljs-attr">dog:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">$&#123;person.hello:hello&#125;_旺财</span><br> <span class="hljs-attr">age:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><a href="http://xn--dog-du5f943k.name">或者dog.name</a> 那里  使用该表达式，如果person里(就上面那个类)有person.hello  就赋值person.hello 的值,否则就赋值&quot;hello&quot;</p><h2 id="4-松散绑定">4. 松散绑定</h2><p><img src="https://img-blog.csdnimg.cn/2309a3700f664d71b43f0684ff25b041.png" alt=""></p><h2 id="5-配置文件相关">5. 配置文件相关</h2><p><img src="https://img-blog.csdnimg.cn/55e108936b3c4ec9ad3024eb9e76d17b.png" alt=""></p><p>几个能配置appliction的位置</p><p><strong>配置多个端口</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>   <span class="hljs-comment">#激活yaml中的端口  active</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br><br></code></pre></td></tr></table></figure><h1>三、web开发</h1><p><img src="https://img-blog.csdnimg.cn/9e8afeda4ade46c48524a431e4d8d050.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="1-导入静态资源">1. 导入静态资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//导入静态资源的源码，了解</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>        <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>            registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>) &#123;<br>                ServletContextResource resource = <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, <span class="hljs-string">&quot;/&quot;</span>);<br>                registration.addResourceLocations(<span class="hljs-keyword">new</span> Resource[]&#123;resource&#125;);<br>            &#125;<br><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c25d5881db2443719781738e6b82670a.png" alt=""><br>静态资源主要可以放在这三个资源目录下，就可以直接通过  8080/wenjian_name.html来访问</p><p>如果存在相同名字的文件， 他们之间存在一个优先级为</p><blockquote><p>resources&gt;static&gt;public</p><p><img src="https://img-blog.csdnimg.cn/3346e158563e4e6cb87105b73e95bbc1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p></blockquote><h2 id="2-定制首页">2. 定制首页</h2><p>把index文件放到静态资源的那三个目录里面,注意一定要是index这个名字</p><p>如果不放在那三个目录下，要放在template下则需要添加模板引擎，然后添加一个controller跳转<br>使用模板引擎thymeleaf</p><p>在pom.xml中导入这个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--thymeleaf--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样以后template里的html文件通过controller 的跳转就可以访问了</p><p><strong>简单的controller和thymeleaf使用</strong><br><img src="https://img-blog.csdnimg.cn/91d9cddff4df47ea938b9110e56d9b48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/c1d74c71b7564e138f116aa2ebbf6df1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="3-mvc配置原理">3. mvc配置原理</h2><p><img src="https://img-blog.csdnimg.cn/3339e9bc1c6640929271bbfd4efdeb31.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*自定义一个视图解析器，并设置对应的url跳转到哪个位置</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcconfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<span class="hljs-comment">//自定义视图解析器</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);<span class="hljs-comment">//输入这两个 url时会跳转到 templates 下的 index</span><br>        registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        registry.addViewController(<span class="hljs-string">&quot;/main.html&quot;</span>).setViewName(<span class="hljs-string">&quot;dashboard&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/07557ed6001c4697a26e9e346cdd29ea.png" alt=""></p><h2 id="4-使用Lombok">4. 使用Lombok</h2><p>Lombok注解快速注解一个标准类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- lombok--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">public</span> String departName;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1addc28352f84c7c99a7de23f0cad44a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_12,color_FFFFFF,t_70,g_se,x_16" alt=""><br>只需要几行代码，就已经配置好了上面所示的结构</p><h2 id="5-thymeleaf使用">5. thymeleaf使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-comment">&lt;!--在使用的时候都需要导入命名空间， thymeleaf的语法才会生效--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 命名空间 --&gt;</span><br><span class="hljs-comment">&lt;!-- Bootstrap core CSS --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/css/bootstrap.min.css&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Custom styles for this template --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/css/signin.css&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mb-4&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/img/bootstrap-solid.svg&#125;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;72&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意导入命名空间和   @{  }  就是用来放链接的</p><p>本地的链接 都需要改+th:<br>只要是被thymeleaf接管就需要加上th:</p><p><strong>给默认路径前面增加一个chen 的url</strong><br>在配置文件(application)里面加上这段代码就行了<br>server.servlet.context-path=/chen</p><h2 id="6-数据层的实现">6. 数据层的实现</h2><p><img src="https://img-blog.csdnimg.cn/2b26c58a43b547c3a6fd45a96e0ac508.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*员工数据层</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDao</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-meta">@Autowired</span><span class="hljs-comment">//这里从仓库中获取之后才可以使用，注意这里注入之后DepartmentDao就变成了紫色</span><br>    <span class="hljs-keyword">private</span>  DepartmentDao DepartmentDao;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        employees = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Employee&gt;();<br><br>        employees.put(<span class="hljs-number">1001</span>,<span class="hljs-keyword">new</span> Employee( <span class="hljs-number">1001</span>,<span class="hljs-string">&quot;AA&quot;</span>,<span class="hljs-string">&quot;2230035341@qq.com&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">101</span>,<span class="hljs-string">&quot;教学部&quot;</span>)));<br>        employees.put(<span class="hljs-number">1002</span>,<span class="hljs-keyword">new</span> Employee( <span class="hljs-number">1002</span>,<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-string">&quot;6454564456@qq.com&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">102</span>,<span class="hljs-string">&quot;市场部&quot;</span>)));<br>        employees.put(<span class="hljs-number">1003</span>,<span class="hljs-keyword">new</span> Employee( <span class="hljs-number">1003</span>,<span class="hljs-string">&quot;CC&quot;</span>,<span class="hljs-string">&quot;2230044447@qq.com&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">103</span>,<span class="hljs-string">&quot;教研部&quot;</span>)));<br>        employees.put(<span class="hljs-number">1004</span>,<span class="hljs-keyword">new</span> Employee( <span class="hljs-number">1004</span>,<span class="hljs-string">&quot;DD&quot;</span>,<span class="hljs-string">&quot;2230454441@qq.com&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">104</span>,<span class="hljs-string">&quot;运营部&quot;</span>)));<br>        employees.put(<span class="hljs-number">1005</span>,<span class="hljs-keyword">new</span> Employee( <span class="hljs-number">1005</span>,<span class="hljs-string">&quot;EE&quot;</span>,<span class="hljs-string">&quot;8599855697@qq.com&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">105</span>,<span class="hljs-string">&quot;后勤部&quot;</span>)));<br><br>    &#125;<br><br>    <span class="hljs-comment">//主键自增</span><br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  Integer initId = <span class="hljs-number">1006</span>;<br>    <span class="hljs-comment">//增加一个员工</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span> <span class="hljs-params">(Employee employee)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(employee.getId()==<span class="hljs-keyword">null</span>)&#123;<br>            employee.setId(initId++);<br>        &#125;<br>        employee.setDepartment(DepartmentDao.getDepartmentById(employee.getDepartment().getId()));<br>        employees.put(employee.getId(),employee);<br><br>    &#125;<br><br>    <span class="hljs-comment">//查询员工的信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Employee&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> employees.values();<span class="hljs-comment">//注意这里,map集合.value()的返回值是Collection集合</span><br>    &#125;                             <br><br>    <span class="hljs-comment">//通过id查询员工</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">getEmployeeById</span><span class="hljs-params">(Integer id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> employees.get(id);<span class="hljs-comment">// 通过key获取对应的value值</span><br>    &#125;<br><br>    <span class="hljs-comment">//删除员工</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Integer id)</span></span>&#123;<br>        employees.remove(id);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*部门数据层</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Department&gt; departments = <span class="hljs-keyword">null</span>;<br><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        departments = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Department&gt;();<br>        departments.put(<span class="hljs-number">101</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">101</span>,<span class="hljs-string">&quot;教学部&quot;</span>));<br>        departments.put(<span class="hljs-number">102</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">102</span>,<span class="hljs-string">&quot;市场部&quot;</span>));<br>        departments.put(<span class="hljs-number">103</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">103</span>,<span class="hljs-string">&quot;教研部&quot;</span>));<br>        departments.put(<span class="hljs-number">104</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">104</span>,<span class="hljs-string">&quot;运营部&quot;</span>));<br>        departments.put(<span class="hljs-number">105</span>,<span class="hljs-keyword">new</span> Department(<span class="hljs-number">105</span>,<span class="hljs-string">&quot;后勤部&quot;</span>));<br><br>    &#125;<br><br>    <span class="hljs-comment">//获得所有部门的信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Department&gt; <span class="hljs-title">getDepartment</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> departments.values();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">getDepartmentById</span><span class="hljs-params">(Integer id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> departments.get(id);<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>map集合.value()的返回值是Collection集合,并且<strong>一定</strong>要在该类的上面写上 <strong>@Repository</strong>注解,告诉spring这是一个dao的数据的层,封装一个bean,方便调用</p><h2 id="7-登录功能的实现">7. 登录功能的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//登录的controller</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">loginController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="hljs-meta">@RequestParam(&quot;password&quot;)</span> String password, Model model, HttpSession session)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(username)&amp;&amp;<span class="hljs-string">&quot;123456&quot;</span>.equals(password))&#123;<br>             session.setAttribute(<span class="hljs-string">&quot;loginuser&quot;</span>,username);<br>             <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/main.html&quot;</span>;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br>            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping(&quot;/user/logout&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">logout</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>        session.invalidate();<span class="hljs-comment">//注销session</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:index.html&quot;</span>;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>同样的道理，也需要在controller的类上加上@Controller注解，方法里面返回字符串，spring才会<strong>执行</strong>字符串里的内容，如果是@Restcontroller的话，就只会把它当作普通的字符串返回给前端</li><li>@RequestParam简单的来讲就是把参数绑定在了url上</li></ol><blockquote><p>详情请见     <a href="https://blog.csdn.net/sswqzx/article/details/84195043?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163473054216780366541664%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163473054216780366541664&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84195043.pc_search_es_clickV2&amp;utm_term=%40RequestParam&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/sswqzx/article/details/84195043?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163473054216780366541664%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163473054216780366541664&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84195043.pc_search_es_clickV2&amp;utm_term=%40RequestParam&amp;spm=1018.2226.3001.4187</a></p></blockquote><ol start="3"><li>并且设置了一个session将用户的名字以 “loginuser” 的名字保存了下来<br><img src="https://img-blog.csdnimg.cn/a5e196246a9947c9b21c2010bbf4824f.png" alt=""><br>然后前端在接收一波就可以在dashboard的界面中获取到登录的信息了，这里的这种写法[[${…}]]等同于th:text:&quot; ${ …}&quot;</li><li>最后重定向到&quot;main.html&quot;这个url，因为前面 自定义了一个视图解析器，&quot;main.html&quot;这个url会跳转到dashboard这个html文件中。这样会比较安全</li><li>如果登录错误就将一个msg的数据通过model回传到前端<br><img src="https://img-blog.csdnimg.cn/93a4b317a40a4d879b33448aa8894eb8.png" alt=""><br>前端在刚刚的表单中用thymeleaf接收输出一下，就可以提示错误信息了</li><li>退出登录就是将session注销就行了 session.invalidate();</li></ol><h2 id="8-拦截器的配置">8. 拦截器的配置</h2><p>这个时候可以登录了，发现一个问题，你直接输入mian的url照样可以进入登录的后的界面，这又问题啊，这里就需要用到我们的拦截器了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHanderInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Object loginuser = request.getSession().getAttribute(<span class="hljs-string">&quot;loginuser&quot;</span>);<br>        <span class="hljs-keyword">if</span>(loginuser==<span class="hljs-keyword">null</span>)&#123;<br>            request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;没有权限，请您先登录！&quot;</span>);<span class="hljs-comment">//</span><br>            request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request,response);<span class="hljs-comment">//把这个请求专发到index页面</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//设置拦截</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//设置放行</span><br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>写拦截器首先需要实现一下HandlerInterceptor</li><li>然后重写preHandle</li><li>这里采用的是获取刚刚登录时发送的session 数据，要数据匹配才能登录</li><li>然后设置一个request的请求，设置一段话</li><li>通过转发的方法将这句话返回到登录的界面</li></ol><blockquote><p>request.getRequestDispatcher(“/index.html”).forward(request,response);//把这个请求专发到index页面</p></blockquote><p>登录失败的时候就会显示这段话提醒<br>6. 最后还有一步<img src="https://img-blog.csdnimg.cn/d62ef09993dd405c96a59cbd6607db9e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加刚刚配置的那个视图解析器</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>       registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHanderInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>               .excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;/css/*&quot;</span>,<span class="hljs-string">&quot;/js/**&quot;</span>,<span class="hljs-string">&quot;/img/**&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>最后一步就是将刚刚写好的拦截器配置一下，到刚刚继承了configurer的类里面重写一个addInterceptors的方法，配置他的拦截路径，new一个刚刚写好的拦截器，这里的addPathPatterns就是添加拦截路径，excludePathPatterns就是放行的路径。<br>然后一个拦截器就配置好了</p><h2 id="9-增删改查的实现">9. 增删改查的实现</h2><p>最重要的功能–增删改查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    EmployeeDao employeeDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DepartmentDao departmentDao;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/emps&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        Collection&lt;Employee&gt; employees = employeeDao.getAll();<br>        <span class="hljs-comment">//这里map.value返回的是Collection的集合</span><br>        model.addAttribute(<span class="hljs-string">&quot;emps&quot;</span>,employees);<br>        <span class="hljs-comment">//通过model将数据返回给前端,前端通过使用循环一下,展现出所有的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;list&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/add&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        Collection&lt;Department&gt; departments = departmentDao.getDepartment();<br>        model.addAttribute(<span class="hljs-string">&quot;departments&quot;</span>,departments);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add&quot;</span>;<span class="hljs-comment">//和前面同样的道理</span><br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><span class="hljs-comment">//这里使用是post请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toadd</span><span class="hljs-params">(Employee employee)</span> </span>&#123;<br>        employeeDao.save(employee);<span class="hljs-comment">//将数据存储到假的数据库中</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/emps&quot;</span>;<span class="hljs-comment">//重定向到emps</span><br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/emp/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,Model model)</span> </span>&#123;<br>        Employee employee = employeeDao.getEmployeeById(id);<br>        model.addAttribute(<span class="hljs-string">&quot;emp&quot;</span>,employee);<br><br>        Collection&lt;Department&gt; departments = departmentDao.getDepartment();<br>        model.addAttribute(<span class="hljs-string">&quot;departments&quot;</span>,departments);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/updateEmp&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toupdate</span><span class="hljs-params">(Employee employee)</span> </span>&#123;<br>        employeeDao.save(employee);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/emps&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,Model model)</span> </span>&#123;<br>        employeeDao.delete(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/emps&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这一部分主要是对数据库的操作,原理都差不多的.<br>构建一个简单的网站就差不多到这儿了</p><h1>四、springboot♂♀数据库</h1><h2 id="1-springboot整合JDBC">1. springboot整合JDBC</h2><p>首先最重要的就是链接数据库</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-comment"># 设置时区和编码等</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>这里使用的yaml配置,当然你使用properties也是差不多的<br>这里链接的是一个叫做mybatis的数据库,里面有一张叫做user的表<img src="https://img-blog.csdnimg.cn/83ef857fa466462fa7bb40d8a76086f5.png" alt=""><br>接着就是写jdbcController了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-comment">//因为没有写对应的页面,所以就是直接返回字符串了</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCcontroller</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JdbcTemplate jdbcTemplate;<br>    <span class="hljs-comment">//只要配置了数据库就有这个类了</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/select&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;<br>        String sql = <span class="hljs-string">&quot;select *from user&quot;</span>;<br>        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);<span class="hljs-comment">//返回list的值</span><br>        <span class="hljs-keyword">return</span> maps;<br>    &#125;<br><br><br>    <span class="hljs-meta">@GetMapping(&quot;/adduser&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">adduserList</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;insert into mybatis.user(id,name,pwd) values (4,&#x27;小明&#x27;,&#x27;123456&#x27;)&quot;</span>;<br>        jdbcTemplate.update(sql);<span class="hljs-comment">//返回list的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add_ok&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/update/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateuserList</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;update mybatis.user set name= ?,pwd = ? where id = &quot;</span>+id;<br>        <span class="hljs-comment">//拼接sql</span><br>        Object[] objects = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">2</span>];<br>        objects[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;小明&quot;</span>;<br>        objects[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;123445&quot;</span>;<br><br>        jdbcTemplate.update(sql,objects);<span class="hljs-comment">//这里是提供了重载的方法的,传入进取取代两个?,使用数组注入</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update_ok&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@GetMapping(&quot;/deleteuser/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteuserList</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;delete from mybatis.user where id = ?&quot;</span>;<br>        jdbcTemplate.update(sql,id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update_ok&quot;</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里唯一需要特别注意的就是第一个获取所有的数据的时候,jdbcTemplate.queryForList(sql)这里返回的是一个 List&lt;Map&lt;String, Object&gt;&gt;的数据类型</p><h2 id="2-springboot集成Druid数据源">2. springboot集成Druid数据源</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-comment"># 设置时区和编码等</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span> <span class="hljs-comment">#配置这个druid数据源</span><br><br>      <span class="hljs-comment">#SpringBoot默认是不注入这些的，需要自己绑定</span><br>      <span class="hljs-comment">#druid数据源专有配置</span><br><br>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">#配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入</span><br>    <span class="hljs-comment">#如果允许报错，java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br>    <span class="hljs-comment">#则导入log4j 依赖就行</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j2</span> <span class="hljs-comment">#要使用这个日志功能需要导入log4j</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></code></pre></td></tr></table></figure><p>前面的数据源的配置和前面的jdbc都是一样的,就是多了后一大堆,多了记录日志的功能,要使用这个功能需要再在xml里面导入log4j的依赖;</p><p><img src="https://img-blog.csdnimg.cn/b321b4be9ae94f26be563d95ebc16a22.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>并且添加一个Druid的config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDatasource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();<br>    &#125;<br><br>    <span class="hljs-comment">//后台监控</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">//因为boot内置了servlet的容器  所以么有web.xml  取而代之的时ServletRegistrationBean，想注册什么new 就欧克</span><br>        ServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">&quot;/druid/*&quot;</span>);<br><br>        <span class="hljs-comment">//后台的账号密码</span><br>        HashMap&lt;String, String&gt; InitParameter = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        InitParameter.put(<span class="hljs-string">&quot;loginUsername&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);  <span class="hljs-comment">//这里需要使用固定的key  loginUsername  loginPassword</span><br>        InitParameter.put(<span class="hljs-string">&quot;loginPassword&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br><span class="hljs-comment">//自己设置一个密码和账号</span><br><br>        <span class="hljs-comment">//允许谁可以访问</span><br>        InitParameter.put(<span class="hljs-string">&quot;allow&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><br>        bean.setInitParameters(InitParameter);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br><br>    <span class="hljs-comment">//filter,,配置一个过滤器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span> </span>&#123;<br><br>        FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>        bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());<br>        <span class="hljs-comment">//可以过滤哪些请求呢?</span><br>        Map&lt;String, String&gt; initParameters = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">//这些东西不进行统计</span><br>        initParameters.put(<span class="hljs-string">&quot;exclusions&quot;</span>,<span class="hljs-string">&quot;*.js ,*.css,/druid/*&quot;</span>);<br>        bean.setInitParameters(initParameters);<br>        <span class="hljs-keyword">return</span> bean;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>配置好了以后,你在url中输入druid就可以进入一个登录界面<br><img src="https://img-blog.csdnimg.cn/80db75072ab64477adec2de5f0237c29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>输入刚刚配置的账号和密码后就可以进入页面了；<br><img src="https://img-blog.csdnimg.cn/0343486a3b6d4d4bb889c7b108a4debf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>里面有各种日志信息<br>比如查询一下刚刚数据库里面的数据<br><img src="https://img-blog.csdnimg.cn/2c9771f147a94db4871597876880397c.png" alt=""><br>就会有对应的sql信息<br><img src="https://img-blog.csdnimg.cn/5d7624b17c4648a7a859e4f8f71f2025.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>五、SpringSecurity</h1><p>SpringSecurity是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，它可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-security模块，进行少量的配置，即可实现强大的安全管理</p><p>记住几个类</p><ul><li>WebSecurityConfigurerAdapter: 自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity:开启WebSecurity模式<br>SpringSecurity的两个主要目标是“认证”和“授权”(访问控制)。<br>“认证”（Authentication）<br>“授权”（Authorization）<br>这个概念是通用的，而不是只在Spring Security中存在</li></ul><h2 id="1-设置页面的访问权限">1. 设置页面的访问权限</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br><br>    <span class="hljs-comment">//链式编程</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//首页所有人可以访问，功能页只有对应有权限的人才能访问</span><br><br>        http.authorizeHttpRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()            <span class="hljs-comment">//首页所有人都可以访问</span><br>                .antMatchers(<span class="hljs-string">&quot;/level1/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip1&quot;</span>)  <span class="hljs-comment">//只有vip1 的用户才可以访问level1下面的页面</span><br>                .antMatchers(<span class="hljs-string">&quot;/level2/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip2&quot;</span>)  <span class="hljs-comment">//只有vip2 的用户才可以访问level2下面的页面</span><br>                .antMatchers(<span class="hljs-string">&quot;/level3/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip3&quot;</span>); <span class="hljs-comment">//只有vip3 的用户才可以访问level3下面的页面</span><br>                <br>        <span class="hljs-comment">//没有权限默认到那个登录页，需要 写这个代码进行开启  加上后面的.loginPage后就可以定制登录页</span><br>        http.formLogin().loginPage(<span class="hljs-string">&quot;/tologin&quot;</span>);<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>通过继承和重写authorizeHttpRequests方法用以实现页面的访问权限，有点类似于拦截器配置路径</p><h2 id="2-设置认证授权">2.设置认证授权</h2><p>通过对用户的认证授权，赋予用户不同的访问权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//认证授权</span><br>    <span class="hljs-comment">//这里密码需要加密一下才能够使用</span><br>    <span class="hljs-comment">//这里使用的是BCryptPasswordEncoder</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder())<br>                .withUser(<span class="hljs-string">&quot;kuangshen&quot;</span>).password( <span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>) ).roles(<span class="hljs-string">&quot;vip2&quot;</span>,<span class="hljs-string">&quot;vip3&quot;</span>)<br>                .and()<br>                .withUser(<span class="hljs-string">&quot;root&quot;</span>).password( <span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>) ).roles(<span class="hljs-string">&quot;vip1&quot;</span>,<span class="hljs-string">&quot;vip2&quot;</span>,<span class="hljs-string">&quot;vip3&quot;</span>)<br>                .and()<br>                .withUser(<span class="hljs-string">&quot;guest&quot;</span>).password( <span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>) ).roles(<span class="hljs-string">&quot;vip1&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是直接写密码是会报错的，因为spring会认为这不安全，需要加密一下，这里采用的是BCryptPasswordEncoder加密的方式，如果需要增加用户只需要加上and就行。</p><h2 id="3-注销和记住我功能">3.注销和记住我功能</h2><p>emmmm,然后第三个功能注销和记住我功能的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//链式编程</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//首页所有人可以访问，功能页只有对应有权限的人才能访问</span><br><br>       http.authorizeHttpRequests()<br>               .antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()<br>               .antMatchers(<span class="hljs-string">&quot;/level1/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip1&quot;</span>)<br>               .antMatchers(<span class="hljs-string">&quot;/level2/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip2&quot;</span>)<br>               .antMatchers(<span class="hljs-string">&quot;/level3/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip3&quot;</span>);<br>       <span class="hljs-comment">//没有权限默认到那个登录页，需要 写这个代码进行开启  加上后面的.loginPage后就可以定制登录页</span><br>       http.formLogin().loginPage(<span class="hljs-string">&quot;/tologin&quot;</span>);<br><br>       <span class="hljs-comment">//开启注销的功能  并且设置注销后的跳转地址</span><br>       http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);<br><br>       <span class="hljs-comment">//开启记住我功能  就是使用cookie实现的  默认保存两周</span><br>       http.rememberMe();<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>感觉没有啥写的，主要就是在那个方法里面配置这两行代码就行</p><h2 id="4-SpringSecurity集成thymeleaf">4.SpringSecurity集成thymeleaf</h2><p>虽然一直觉得thymeleaf拉跨得一批，但是该学得还是要学</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span> <span class="hljs-attr">xmlns:sec</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这里自动配置得命名空间是不是这个地址，需要手动修改一下--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span> <span class="hljs-attr">sec:authorize</span> = <span class="hljs-string">&quot;hasRole(&#x27;vip1&#x27;)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--这里得sec 就是security--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui raised segment&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Level 1<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level1/1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level1/2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level1/3&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的   sec:authorize = “hasRole(‘vip1’)”  的意思就是只有登录的用户的权限是vip1的时候这短前端代码才会展示出来</p><h1>六、一些常用的任务</h1><h2 id="1-异步任务">1.异步任务</h2><p>首先我们来看看普通的方法</p><p>使用多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Serice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncService</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">try</span>&#123;<br>           Thread.sleep(<span class="hljs-number">3000</span>);<span class="hljs-comment">//使用线程使他停止三秒钟</span><br>       &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>           e.printStackTrace()<br>       &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;系统正在处理。。。。。&quot;</span>);<span class="hljs-comment">//然后再打印这个</span><br>&#125; <br><br><br><span class="hljs-comment">/*---------------------------------------------------------*/</span><br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncController</span></span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    AsyncService asyncService;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>       asyncService.hello();<span class="hljs-comment">//停止三秒</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用springboot实现，只需要两步就可以实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Serice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncService</span></span>&#123;<br><br><span class="hljs-comment">//首先告诉spring这是一个异步的方法,加上一个注解就行</span><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">try</span>&#123;<br>           Thread.sleep(<span class="hljs-number">3000</span>);<br>       &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>           e.printStackTrace()<br>       &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;系统正在处理。。。。。&quot;</span>);<br>&#125; <br><br><br><span class="hljs-comment">/*---------------------------------------------------------*/</span><br><br><span class="hljs-comment">//第二步就是开启功能</span><br><span class="hljs-comment">//这个只需要使用Enable那个注解在主类上面加上就ok</span><br><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YibuApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(YibuApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成，这样就可以实现异步任务了。</p><h2 id="2-邮件任务">2.邮件任务</h2><p>邮件任务也是经常需要写的任务。</p><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>获取你邮箱的POP3/SMTP的码<br><img src="https://img-blog.csdnimg.cn/07a213bdc487485fbe89732349366f13.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="这里以QQ邮箱为例"></li><li>在配置文件里面配置相关信息</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spring.mail.username=2108796780@qq.com</span><br><span class="hljs-string">spring.mail.password=刚刚的那个码</span><br><span class="hljs-string">spring.mail.host=smtp.qq.com</span><br><span class="hljs-comment"># 开启加密验证</span><br><span class="hljs-string">spring.mail.properties.mail.smtp.ssl.enable=true</span><br></code></pre></td></tr></table></figure><p>这里需要注意：<br>host主机是qq就写qq，是163就写163<br>qq的才有开启加密验证，163没有</p><ol start="4"><li><p>好的，现在来一个简单的邮件<br><img src="https://img-blog.csdnimg.cn/7aa70e1207ab4683888715377fcf65f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="简单的邮件"></p></li><li><p>一个复杂的邮件<br><img src="https://img-blog.csdnimg.cn/888591744f7248dfa857be2a83aa6a43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="复杂的邮件"></p></li><li><p>你也可以把这个发邮件的方法封装一下<br><img src="https://img-blog.csdnimg.cn/a8e7f44b8cba41e285d91a63c447cc0b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="封装的的邮件方法"><br>ok,邮件任务没了</p></li></ol><h2 id="3-定时任务">3.定时任务</h2><p>定时任务的实现也很简单，主要就是cron表达式有点难理解</p><ul><li>首先需要开启定时功能，这个和之前的一样，只需要Enable就可以<br>这里使用的是 <strong>@EnableScheduling</strong> 注解，也是直接加到主类上面就可以了。</li><li>第二步就是编写一个方法，在方法的上面加上 <strong>@Scheduled()</strong> 就行，注解里面需要填写表达式，这个不需要记忆，需要的时候去查就行，附上一个链接<a href="https://cron.qqe2.com/">在线的cron生成器</a>,为了方便理解，附上一张图，如下图。<br><img src="https://img-blog.csdnimg.cn/d0f52b456603435a80aa249a7bc792c2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="简单的cron"></li></ul><h2 id="4-文件上传">4.文件上传</h2><p>最近在写一个项目的时候，需要用到文件的上传的任务，因此把代码粘在这里，以便后面继续回顾和使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileController</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DynamicService dynamicService;<br><br>    <span class="hljs-meta">@PostMapping(value = &quot;/fileload&quot;)</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileUpload</span><span class="hljs-params">(<span class="hljs-meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request )</span> </span>&#123;<br><br>        String fileName = file.getOriginalFilename();<span class="hljs-comment">//获取文件的原始的名字</span><br>        String suffixName = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<span class="hljs-comment">//文件后缀</span><br>        String filePath = <span class="hljs-string">&quot;D:/文档/新鲜出炉的程序/SpringBoot/LostandFound/src/main/resources/static/img/dynamic/&quot;</span>;<br>        fileName = UUID.randomUUID() + suffixName;<span class="hljs-comment">//通过uuid生成唯一标识符</span><br>        File dest = <span class="hljs-keyword">new</span> File(filePath + fileName);<br>        <span class="hljs-keyword">if</span> (!dest.getParentFile().exists()) &#123;<br>            dest.getParentFile().mkdirs();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            file.transferTo(dest);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            HttpSession session = request.getSession();<br>            System.out.println(session.getId() +<span class="hljs-string">&quot; &quot;</span>+session.getAttribute(<span class="hljs-string">&quot;uid&quot;</span>)+(String)session.getAttribute(<span class="hljs-string">&quot;dtext&quot;</span>)+session.getAttribute(<span class="hljs-string">&quot;dtag&quot;</span>));<br>            dynamicService.addImg(<span class="hljs-string">&quot;img/dynamic/&quot;</span>+fileName, (Integer) session.getAttribute(<span class="hljs-string">&quot;uid&quot;</span>),(String)session.getAttribute(<span class="hljs-string">&quot;dtext&quot;</span>),(String)session.getAttribute(<span class="hljs-string">&quot;dtag&quot;</span>));<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2021/09/17/CSS/"/>
    <url>/2021/09/17/CSS/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">    <p>更新日志:<p>    <ul>       <p>2021.9.17：根据狂神说的视频整理出该笔记</p>      <p>2022.4.18：由于学校前端选修课要考试了，根据沈大佬的笔记以及教学ppt做了一些修订和补充</p>    </ul></div><h1>CSS</h1><p>Cascading Style Sheets 层叠样式表</p><h2 id="1-内联样式-行内样式-：">1. 内联样式(行内样式)：</h2><p>在标签内使用style属性指定css代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> style = &quot;<span class="hljs-attribute">color</span> :red ;&quot;&gt;hello css&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="2-内部样式：">2. 内部样式：</h2><p>在head标签内，定义style标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;head&gt;<br>    &lt;style&gt;<br>                  <span class="hljs-selector-tag">div</span>&#123;<br>                         <span class="hljs-attribute">color</span>:blue;<br>                   &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span>&gt;hello css&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="3-外部样式">3. 外部样式</h2><ul><li><p>定义css资源文件</p></li><li><p>在head标签内，定义link标签，引入外部资源文件</p></li></ul><p>a.css文件:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">color</span> : green;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;css/a.css&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 这个不用写在style里面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-keyword">@import</span>  <span class="hljs-string">&quot;css/a.css&quot;</span>;    &lt;!-- 来引入 --&gt;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><div class = "note note-warning">注意</div><ul><li><p>外部样式表的文件名称必须带后缀名.css。</p></li><li><p>CSS文件一定是纯文本格式。</p></li><li><p>外部样式表修改后所有引用的页面样式自动地更新；</p></li><li><p>外部样式表优先级低于内部样式表；</p></li><li><p>同时链接几个外部样式表时按“最近优先的原则”</p></li></ul><h2 id="4-css的语法">4. css的语法</h2><p>格式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器&#123;<br><br>           属性名：属性值；<br><br>           属性名：属性值；<br><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个属性可以不加  ；</p><h2 id="5-选择器">5. 选择器</h2><h3 id="5-1-基础选择器">5.1 基础选择器</h3><h4 id="类选择器">类选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>        <span class="hljs-selector-class">.cls1</span>&#123;                      &lt;!--前面是一个 . --&gt;<br>            <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#ff2</span><br>            color:blue<br>        &#125;<br>        <span class="hljs-selector-class">.test</span>&#123;<br>            <span class="hljs-attribute">color</span>:green<br>        &#125;<br>&lt;style&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class = &quot;cls1&quot;&gt;Mercury牛逼&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class = &quot;test&quot;&gt;Mercury牛逼&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class = &quot;cls1 test&quot;&gt;Mercury牛逼&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><div class = "note note-warning">类选择器注意事项</div> <ul><li>类选择器是可以多次使用的</li><li>一个标签可以可以有多个class,后面的内容会覆盖掉前面的(写在class里面的顺序)</li></ul><h4 id="id选择器：">id选择器：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>        <span class="hljs-selector-id">#div</span>&#123;                      &lt;!-- 前面是一个 # --&gt;<br>            <span class="hljs-attribute">color</span>:blue;<br>        &#125;<br>&lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">div</span> id = &quot;div1&quot; &gt;hello css&lt;/<span class="hljs-selector-tag">div</span>&gt; <br></code></pre></td></tr></table></figure><div class = "note note-info">ID选择符与类选择符的区别：</div>    <ul><li>类选择符可以给任意多的标记定义样式，但ID选择符在页面中标记中只能使用一次，<strong>具有唯一标识性</strong>；</li><li>ID选择符样式比类选择符样式优先级高。ID选择符局限性大，只能单独定义某个元素的样式（特殊情况下使用）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#a-good-id&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个可以实现跳转到id为a-good-id的标签所在的位置。那么可不可以写class呢？当然不能，因为class可能“重名”，这样就不知道到底该跳转到哪里。</p><h4 id="元素选择器-标记选择">元素选择器(标记选择)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>            <span class="hljs-selector-tag">div</span>&#123;<br><br>                <span class="hljs-attribute">color</span>:blue;<br><br>              &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="5-2-扩展选择器">5.2 扩展选择器</h3><pre><code class="hljs">  选择所有元素  &#123;&#125;</code></pre><h4 id="并集选择器">并集选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">p</span>&#123;<br>               <span class="hljs-attribute">color</span>:blue;<br>     &#125;         <br></code></pre></td></tr></table></figure><h4 id="子选择器">子选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span>&#123; <br>                    <span class="hljs-attribute">color</span>:blue;<br><br>       &#125;<br>&lt;!-- 选择<span class="hljs-selector-tag">div</span>下的<span class="hljs-selector-tag">p</span>标签 --&gt;       <br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)<br>&lt;!--父元素下的第几个子元素--&gt;<br><br>   <span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">p</span> &#123; <br>                    <span class="hljs-attribute">color</span>:blue;<br><br>            &#125;<br>&lt;!-- 选择父标签是<span class="hljs-selector-tag">div</span>标签的<span class="hljs-selector-tag">p</span>标签 --&gt;   <br></code></pre></td></tr></table></figure><h4 id=""></h4><h4 id="属性选择器">属性选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span><br>&#123;<br><span class="hljs-attribute">background-color</span>:<span class="hljs-number">#ff0000</span>;<br>&#125;<br><span class="hljs-selector-attr">[type]</span><br>&#123;<br><span class="hljs-attribute">border</span>:<span class="hljs-number">5px</span> solid blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述两个样式都能作用于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="伪类选择器">伪类选择器</h4><p>一种特殊的类选择符，最大的作用就是对链接<code>&lt;a&gt;</code>的不同状态定义不同的样式效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#339999</span>;text-decration:none;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#33cc00</span>;text-decration:none&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">color</span>:red;text-decration:underline;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;<span class="hljs-attribute">color</span>:blue;text-decration:underline;&#125;<br><br>&lt;!--<br><br>link:初始化状态<br><br>visited:被访问过的状态<br><br>hover:鼠标悬浮的状态<br><br>active:正在访问的状态<br><br>--&gt;<br></code></pre></td></tr></table></figure><p>在支持CSS的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：未被访问状态,  已被访问状态，鼠标悬停状态,  活动状态。</p><div class = "note note-warning"> 注意：</div>- a:hover 必须被置于a:link 和a:visited 之后，才是有效的。a:active必须被置于a:hover之后，才是有效的- CSS规定样式的优先级 <span class = "label label-danger">行内样式 > id样式 > 类样式 > 标记样式 </span>- CSS的继承：样式表的继承规则是子标记继承父标记的样式<p>附表</p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">例子</th><th style="text-align:left">例子描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_class.asp">.<em>class</em></a></td><td style="text-align:left">.intro</td><td style="text-align:left">选择 class=“intro” 的所有元素。</td></tr><tr><td style="text-align:left">.<em>class1</em>.<em>class2</em></td><td style="text-align:left">.name1.name2</td><td style="text-align:left">选择 class 属性中同时有 name1 和 name2 的所有元素。</td></tr><tr><td style="text-align:left">.<em>class1</em> .<em>class2</em></td><td style="text-align:left">.name1 .name2</td><td style="text-align:left">选择作为类名 name1 元素后代的所有类名 name2 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_id.asp">#<em>id</em></a></td><td style="text-align:left">#firstname</td><td style="text-align:left">选择 id=“firstname” 的元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_all.asp">*</a></td><td style="text-align:left">*</td><td style="text-align:left">选择所有元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_element.asp"><em>element</em></a></td><td style="text-align:left">p</td><td style="text-align:left">选择所有 <code>&lt;p&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_element_class.asp"><em>element</em>.<em>class</em></a></td><td style="text-align:left">p.intro</td><td style="text-align:left">选择 class=“intro” 的所有 <code>&lt;p&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_element_comma.asp"><em>element</em>,<em>element</em></a></td><td style="text-align:left">div, p</td><td style="text-align:left">选择所有 <code>&lt;div&gt;</code> 元素和所有<code>&lt;p&gt;</code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_element_element.asp"><em>element</em> <em>element</em></a></td><td style="text-align:left">div p</td><td style="text-align:left">选择 <code>&lt;div&gt; </code>元素内的所有<code>&lt;p&gt;</code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_element_gt.asp"><em>element</em>&gt;<em>element</em></a></td><td style="text-align:left">div &gt; p</td><td style="text-align:left">选择父元素是 <code>&lt;div&gt;</code> 的所有 <code>&lt;p&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_element_plus.asp"><em>element</em>+<em>element</em></a></td><td style="text-align:left">div + p</td><td style="text-align:left">选择紧跟 <code>&lt;div&gt;</code> 元素的首个<code> &lt;p&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_gen_sibling.asp"><em>element1</em>~<em>element2</em></a></td><td style="text-align:left">p ~ ul</td><td style="text-align:left">选择前面有 <code>&lt;p&gt; </code>元素的每个 <code>&lt;ul&gt; </code>元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute.asp"><em>attribute</em>]</a></td><td style="text-align:left">[target]</td><td style="text-align:left">选择带有 target 属性的所有元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute_value.asp"><em>attribute</em>=<em>value</em>]</a></td><td style="text-align:left">[target=_blank]</td><td style="text-align:left">选择带有 target=“_blank” 属性的所有元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute_value_contain.asp"><em>attribute</em>~=<em>value</em>]</a></td><td style="text-align:left">[title~=flower]</td><td style="text-align:left">选择 title 属性包含单词 “flower” 的所有元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute_value_start.asp"><em>attribute</em>|=<em>value</em>]</a></td><td style="text-align:left">[lang|=en]</td><td style="text-align:left">选择 lang 属性值以 “en” 开头的所有元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attr_begin.asp"><em>attribute</em>^=<em>value</em>]</a></td><td style="text-align:left">a[href^=“https”]</td><td style="text-align:left">选择其 src 属性值以 “https” 开头的每个<code> &lt;a&gt;</code> 元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attr_end.asp"><em>attribute</em>$=<em>value</em>]</a></td><td style="text-align:left">a[href$=“.pdf”]</td><td style="text-align:left">选择其 src 属性以 “.pdf” 结尾的所有<code>&lt;a&gt;</code>元素。</td></tr><tr><td style="text-align:left">[<a href="https://www.w3school.com.cn/cssref/selector_attr_contain.asp"><em>attribute</em>*=<em>value</em>]</a></td><td style="text-align:left">a[href*=“w3schools”]</td><td style="text-align:left">选择其 href 属性值中包含 “abc” 子串的每个 <code>&lt;a&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_active.asp">:active</a></td><td style="text-align:left">a:active</td><td style="text-align:left">选择活动链接。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_after.asp">::after</a></td><td style="text-align:left">p::after</td><td style="text-align:left">在每个<code> &lt;p&gt;</code> 的内容之后插入内容。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_before.asp">::before</a></td><td style="text-align:left">p::before</td><td style="text-align:left">在每个<code> &lt;p&gt;</code> 的内容之前插入内容。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_checked.asp">:checked</a></td><td style="text-align:left">input:checked</td><td style="text-align:left">选择每个被选中的<code>&lt;input&gt;</code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_default.asp">:default</a></td><td style="text-align:left">input:default</td><td style="text-align:left">选择默认的 <code>&lt;input&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_disabled.asp">:disabled</a></td><td style="text-align:left">input:disabled</td><td style="text-align:left">选择每个被禁用的 <code>&lt;input&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_empty.asp">:empty</a></td><td style="text-align:left">p:empty</td><td style="text-align:left">选择没有子元素的每个 <code>&lt;p&gt;</code> 元素（包括文本节点）。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_enabled.asp">:enabled</a></td><td style="text-align:left">input:enabled</td><td style="text-align:left">选择每个启用的<code> &lt;input&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_first-child.asp">:first-child</a></td><td style="text-align:left">p:first-child</td><td style="text-align:left">选择属于父元素的第一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_first-letter.asp">::first-letter</a></td><td style="text-align:left">p::first-letter</td><td style="text-align:left">选择每个 <code>&lt;p&gt; </code>元素的首字母。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_first-line.asp">::first-line</a></td><td style="text-align:left">p::first-line</td><td style="text-align:left">选择每个 <code>&lt;p&gt;</code> 元素的首行。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_first-of-type.asp">:first-of-type</a></td><td style="text-align:left">p:first-of-type</td><td style="text-align:left">选择属于其父元素的首个<code> &lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_focus.asp">:focus</a></td><td style="text-align:left">input:focus</td><td style="text-align:left">选择获得焦点的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_fullscreen.asp">:fullscreen</a></td><td style="text-align:left">:fullscreen</td><td style="text-align:left">选择处于全屏模式的元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_hover.asp">:hover</a></td><td style="text-align:left">a:hover</td><td style="text-align:left">选择鼠标指针位于其上的链接。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_in-range.asp">:in-range</a></td><td style="text-align:left">input:in-range</td><td style="text-align:left">选择其值在指定范围内的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_indeterminate.asp">:indeterminate</a></td><td style="text-align:left">input:indeterminate</td><td style="text-align:left">选择处于不确定状态的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_invalid.asp">:invalid</a></td><td style="text-align:left">input:invalid</td><td style="text-align:left">选择具有无效值的所有 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_lang.asp">:lang(<em>language</em>)</a></td><td style="text-align:left">p:lang(it)</td><td style="text-align:left">选择 lang 属性等于 “it”（意大利）的每个 <code>&lt;p&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_last-child.asp">:last-child</a></td><td style="text-align:left">p:last-child</td><td style="text-align:left">选择属于其父元素最后一个子元素每个<code>&lt;p&gt;</code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_last-of-type.asp">:last-of-type</a></td><td style="text-align:left">p:last-of-type</td><td style="text-align:left">选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code> &lt;p&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_link.asp">:link</a></td><td style="text-align:left">a:link</td><td style="text-align:left">选择所有未访问过的链接。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_not.asp">:not(<em>selector</em>)</a></td><td style="text-align:left">:not(p)</td><td style="text-align:left">选择非 <code>&lt;p&gt;</code> 元素的每个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_nth-child.asp">:nth-child(<em>n</em>)</a></td><td style="text-align:left">p:nth-child(2)</td><td style="text-align:left">选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt; </code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_nth-last-child.asp">:nth-last-child(<em>n</em>)</a></td><td style="text-align:left">p:nth-last-child(2)</td><td style="text-align:left">同上，从最后一个子元素开始计数。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_nth-of-type.asp">:nth-of-type(<em>n</em>)</a></td><td style="text-align:left">p:nth-of-type(2)</td><td style="text-align:left">选择属于其父元素第二个 <code>&lt;p&gt; </code>元素的每个<code> &lt;p&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_nth-last-of-type.asp">:nth-last-of-type(<em>n</em>)</a></td><td style="text-align:left">p:nth-last-of-type(2)</td><td style="text-align:left">同上，但是从最后一个子元素开始计数。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_only-of-type.asp">:only-of-type</a></td><td style="text-align:left">p:only-of-type</td><td style="text-align:left">选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_only-child.asp">:only-child</a></td><td style="text-align:left">p:only-child</td><td style="text-align:left">选择属于其父元素的唯一子元素的每个<code>&lt;p&gt;</code>元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_optional.asp">:optional</a></td><td style="text-align:left">input:optional</td><td style="text-align:left">选择不带 “required” 属性的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_out-of-range.asp">:out-of-range</a></td><td style="text-align:left">input:out-of-range</td><td style="text-align:left">选择值超出指定范围的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_placeholder.asp">::placeholder</a></td><td style="text-align:left">input::placeholder</td><td style="text-align:left">选择已规定 “placeholder” 属性的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_read-only.asp">:read-only</a></td><td style="text-align:left">input:read-only</td><td style="text-align:left">选择已规定 “readonly” 属性的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_read-write.asp">:read-write</a></td><td style="text-align:left">input:read-write</td><td style="text-align:left">选择未规定 “readonly” 属性的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_required.asp">:required</a></td><td style="text-align:left">input:required</td><td style="text-align:left">选择已规定 “required” 属性的 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_root.asp">:root</a></td><td style="text-align:left">:root</td><td style="text-align:left">选择文档的根元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_selection.asp">::selection</a></td><td style="text-align:left">::selection</td><td style="text-align:left">选择用户已选取的元素部分。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_target.asp">:target</a></td><td style="text-align:left">#news:target</td><td style="text-align:left">选择当前活动的 #news 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_valid.asp">:valid</a></td><td style="text-align:left">input:valid</td><td style="text-align:left">选择带有有效值的所有 input 元素。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/selector_visited.asp">:visited</a></td><td style="text-align:left">a:visited</td><td style="text-align:left">选择所有已访问的链接。</td></tr></tbody></table><h2 id="6-属性">6. 属性</h2><h3 id="6-1-字体">6.1 字体</h3><table><thead><tr><th>属性</th><th>作用</th><th>属性值</th></tr></thead><tbody><tr><td>font-size</td><td>字体大小</td><td>40px|2.5em   （px/16=em）</td></tr><tr><td>color</td><td>文本颜色</td><td>#FFCCFF</td></tr><tr><td>text-align</td><td>对其方式</td><td>center | left | right | justify</td></tr><tr><td>line-height</td><td>行高</td><td>px</td></tr><tr><td>font-style</td><td>字体样式 正常|斜体</td><td>normal|italic</td></tr><tr><td>font-weight</td><td>指定字体的粗细</td><td>px</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--关于字体下划线等--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">text-decoration</span>: overline&#125;</span><br><span class="css"><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">text-decoration</span>: line-through&#125;</span><br><span class="css"><span class="hljs-selector-tag">h3</span> &#123;<span class="hljs-attribute">text-decoration</span>: underline&#125;</span><br><span class="css"><span class="hljs-selector-tag">h4</span> &#123;<span class="hljs-attribute">text-decoration</span>:blink&#125;</span><br><span class="css"><span class="hljs-selector-tag">a</span> &#123;<span class="hljs-attribute">text-decoration</span>: none&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是标题 1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这是标题 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这是标题 3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>这是标题 4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.w3school.com.cn/index.html&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://img.mercuryblog.site/img/image-20220427205032344.png" alt="image-20220427205032344"></p><h3 id="6-2-边框">6.2 边框</h3><table><thead><tr><th>属性</th><th>作用</th><th>属性值</th></tr></thead><tbody><tr><td>border</td><td>设置边框粗细 、实虚线 、颜色</td><td>1px  solid | dashed   red</td></tr></tbody></table><h3 id="6-3-背景">6.3  背景</h3><table><thead><tr><th>属性</th><th>作用</th><th>属性值</th></tr></thead><tbody><tr><td>background</td><td>控制背景图片、不重复、居中</td><td>url(“…”)     no-repeat     center</td></tr></tbody></table><h3 id="6-4-尺寸">6.4  尺寸</h3><table><thead><tr><th>属性</th><th>属性值</th></tr></thead><tbody><tr><td>width</td><td>…px</td></tr><tr><td>height</td><td>…px</td></tr></tbody></table><h2 id="7-布局">7. 布局</h2><h3 id="display">display</h3><ul><li><p>inline：此元素将显示为行内元素（行内元素默认的 display属性值）</p></li><li><p>block：此元素将显示为块元素（块元素默认的 display属性值）。</p></li><li><p>inline- block：此元素将显示为行内块元素，可以对其设置宽度、高度和对齐等属性，但是该元素不会独占一行。</p></li><li><p>none：此元素将被隐藏，不显示，也不占用页面空间，相当于该元素不存在。</p></li></ul><h3 id="position">position</h3><h4 id="静态定位-static">静态定位 static</h4><ol><li>静态定位是元素默认的定位方式，是各个元素在HTML文档流中默认的位置。</li><li>块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。</li><li>在静态定位方式中，无法通过位置偏移属性（top、bottom、left或right）来改变元素的位置</li></ol><h4 id="相对定位-relative">相对定位 relative</h4><ol><li>相对定位是普通文档流的一部分，相当于本元素在文档流原来出现位置的左上角进行定位。</li><li>可以通过位置偏移属性（top、bottom、left或right）来改变元素的位置。</li><li>虽然其移动到其他位置，但该元素仍占据原来未移动时的位置，该元素移动后会导致其覆盖其他的框元素。</li></ol><h4 id="绝对定位-absolute">绝对定位 <strong>absolute</strong></h4><ol><li>绝对定位是脱离文档流的，不占据其原来未移动时的位置,是相对于父级元素或更高的祖先级中有relative（相对）定位,并且离本元素层级关系上最近元素的左上角进行定位,如果在祖先元素中没有relative定位的，就默认相对于body进行定位。</li><li>使用绝对定位的时候，一般要给出上一个相对定位的元素作为参考点。</li></ol><h4 id="固定定位-fixed">固定定位 fixed</h4><ol><li>当元素被设置为固定定位的时候，该元素将脱离标准文档流的控制，始终依据浏览器窗口的左上角位置来定义自己的显示位置。</li></ol><div class = "note note-info">总结：</div>   <table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><strong>absolute</strong></td><td>生成绝对定位的元素，相对于  static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”,  “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td><strong>fixed</strong></td><td>生成固定定位的元素，相对于浏览器窗口左上角进行定位。元素的位置通过  “left”, “top”, “right” 以及 “bottom”  属性进行规定。</td></tr><tr><td><strong>relative</strong></td><td>生成相对定位的元素，相对于其正常位置进行定位。因此，“left:20”  会向元素的 LEFT 位置添加 20 像素。</td></tr><tr><td><strong>static</strong></td><td>默认值。没有定位，元素出现在正常的流中（忽略  top, bottom, left, right 或者 z-index 声明）。</td></tr><tr><td><strong>inherit</strong></td><td>规定应该从父元素继承  position 属性的值。</td></tr></tbody></table><h3 id="z-index-层叠次序">z-index(层叠次序)</h3><p><strong>z 轴</strong>定义为<strong>垂直</strong>延伸到显示区(垂直于你的显示器)的<strong>轴</strong>。如果为<strong>正数</strong>，则离用户更<strong>近</strong>，为<strong>负数</strong>则表示离用户更<strong>远</strong></p><ul><li><p>元素可拥有负的z-index 属性值</p></li><li><p>z-index 仅能在绝对定位元素（例如 position:absolute;）上起作用</p></li></ul><h3 id="float">float</h3><p>所谓的float就是CSS浮动，需要注意的是浮动脱离<strong>文档流</strong>，并且可以<strong>左</strong>浮动、<strong>右</strong>浮动</p><ul><li><p>元素左浮动后，则元素将会脱离文档流，直到其左边缘碰到包含框的左边缘。</p></li><li><p>三个框都左浮动，那么第一个框其左边缘碰到包含框的左边缘，另外两个框左浮动直到碰到前一个浮动框的右边框。</p></li><li><p>如果包含框太窄，无法容纳水平排列，则会向下进行浮动。</p></li></ul><div class = "note note-info">说明：</div>   <p>以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素</p><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><strong>left</strong></td><td>元素向左浮动。</td></tr><tr><td><strong>right</strong></td><td>元素向右浮动。</td></tr><tr><td><strong>none</strong></td><td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td></tr><tr><td><strong>inherit</strong></td><td>规定应该从父元素继承  float属性的值。</td></tr></tbody></table><div class = "note note-warning">注意：</div>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。使用 clear 属性往文本中添加图片廊<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text_line</span><br>&#123;<br>    <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS溢出">CSS溢出</h3><p>在盒子模型中的代表块元素的矩形对象，可以通过CSS样式来定义内容区域的高度与宽度，当这个内容无法容纳子矩形对象时，对于这些子矩形对象必须决定怎么显示，显示什么，这样的处理规则就称为溢出处理</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>：visible｜hidden｜scroll｜<span class="hljs-attribute">auto</span><br></code></pre></td></tr></table></figure><h3 id="visibility属性">visibility属性</h3><p>在CSS中可以使用 <strong>visibility</strong>（可见性）来设置对象是否<strong>可见</strong>，该属性的语法格式如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">visibility</span>: visible | hidden<br></code></pre></td></tr></table></figure><p>visibility属性设置隐藏，但隐藏后其原来位置仍然被占用。注意与display:none的区别</p><p></p><h3 id="边框">边框</h3><p>元素的边框（border）是围绕元素内容和内边距的一条或多条线。CSS中使用border属性设置元素边框的样式、宽度和颜色。</p><p>边框线定义方式如下：</p><p>border: 宽度、样式，颜色;</p><p>border-width，border-color</p><p>border-top…</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2021/09/17/HTML/"/>
    <url>/2021/09/17/HTML/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">    <p>更新日志:<p>    <ul>       <p>2021.9.17：根据狂神说的视频整理出该笔记</p>      <p>2022.4.18：由于学校前端选修课要考试了，根据沈大佬的笔记以及教学PPT做了一些修订和补充</p>    </ul></div><p class = "note note-info">关于前端的学习，这里推荐<a herf = "https://developer.mozilla.org/zh-CN/docs/Web">mdn文档 </a></p><h1>HTML</h1><h2 id="1-初识html">1. 初识html</h2><p>全称是Hyper Text Market Language（超文本标记语言) , 而超文本指的是流媒体、图片、声音、视频等等.</p><h3 id="1-1-特殊符号的表达">1.1 特殊符号的表达</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--  特殊符号的样式  &amp;   ; --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>                           <span class="hljs-comment">&lt;!--换行--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>i love you <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>     <span class="hljs-comment">&lt;!--粗体--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>i love you<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>              <span class="hljs-comment">&lt;!--斜体--&gt;</span><br><span class="hljs-symbol">&amp;nbsp;</span>                          <span class="hljs-comment">&lt;!--空格--&gt;</span><br><span class="hljs-symbol">&amp;gt;</span>                            <span class="hljs-comment">&lt;!--大于&gt;--&gt;</span><br><span class="hljs-symbol">&amp;lt;</span>                            <span class="hljs-comment">&lt;!--小于&lt;--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-行级元素和块级元素">1.2 行级元素和块级元素</h3><table><thead><tr><th>类型</th><th>效果</th><th>例子</th></tr></thead><tbody><tr><td>块级元素(block)</td><td>独占一行</td><td>div h p ul teble</td></tr><tr><td>行级元素(inline)</td><td>只占据内容的大小</td><td>span td a img</td></tr></tbody></table><p><span class = "label label-success" >示例</span></p><div style="background-color: #FFCCFF">HTML</div><p><span style="background-color: #FFCCFF">HTML</span></p><p>一个行内元素通常会和其前后的其他行内元素显示在同一行中，不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构.一般不可以设置高度、对齐等属性，常用于控制页面中文本的样式</p><h3 id="1-3-关于图片，视频和音频">1.3 关于图片，视频和音频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--img </span><br><span class="hljs-comment">src : 图片地址  相对地址 绝对地址 或者 图片的链接</span><br><span class="hljs-comment">alt : 图片的名字</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;../resources/imge/1.jpg&quot;</span> <span class="hljs-attr">alt</span> = <span class="hljs-string">&quot;chen&quot;</span> <span class="hljs-attr">title</span> = <span class="hljs-string">&quot;悬停文字&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span> = <span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;https://s2.loli.net/2022/04/13/qzsEFCRXW89Vc7I.jpg&quot;</span> <span class="hljs-attr">alt</span> = <span class="hljs-string">&quot;chen&quot;</span> <span class="hljs-attr">title</span> = <span class="hljs-string">&quot;悬停文字&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span> = <span class="hljs-string">&quot;250&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--视频和音频--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;../resources/video/chen.mp4&quot;</span> &gt;</span>                    <span class="hljs-comment">&lt;!--同理这里也可以放链接--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;../resources/video/chen.mp4&quot;</span>  <span class="hljs-attr">controls</span>&gt;</span>           <span class="hljs-comment">&lt;!--加上进度条--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;../resources/video/chen.mp4&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span>&gt;</span>   <span class="hljs-comment">&lt;!--自动播放--&gt;</span><br><br></code></pre></td></tr></table></figure><p><span class = "label label-success" >示例</span></p><center><img src = "https://s2.loli.net/2022/04/13/qzsEFCRXW89Vc7I.jpg" alt = "chen" title = "悬停文字" width = "200" height = "250"></center><h3 id="1-4-超链接">1.4 超链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--a标签</span><br><span class="hljs-comment">href : 必填，表示要跳转到的那个页面</span><br><span class="hljs-comment">target ：表示窗口在哪里打开</span><br><span class="hljs-comment">          _blank : 在新标签打开</span><br><span class="hljs-comment">          _self: 在此窗口打开             </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;https://space.bilibili.com/399488488&quot;</span> <span class="hljs-attr">target</span> = <span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success" >示例</span></p><p><a href = "https://space.bilibili.com/399488488" target = "_blank">点我</a></p><h3 id="1-5-锚链接">1.5 锚链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--锚链接</span><br><span class="hljs-comment">1. 需要一个锚标记</span><br><span class="hljs-comment">2. 跳转到标记</span><br><span class="hljs-comment"> #</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#&quot;</span> &gt;</span>回到顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><span class = "label label-success" >示例</span></p><p><a href = "#" >回到顶部</a></p><h3 id="1-6-功能性链接">1.6 功能性链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:chenning_william@163.com&quot;</span>&gt;</span>点击联系我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span> 此为分割线<br></code></pre></td></tr></table></figure><p><span class = "label label-success" >示例</span></p><p><a href="mailto:chenning_william@163.com">点击联系我</a></p> <hr/> 此为分割线<h3 id="1-7-列表">1.7 列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--有序列表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c/c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>运维<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--无序列表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c/c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>运维<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--自定义列表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>学科<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>c/c++<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>位置<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>成都<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>西安<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">效果展示</span></p><!--有序列表--><ol>   <li>java</li>   <li>python</li>   <li>c/c++</li>   <li>运维</li></ol><!--无序列表--><ul>   <li>java</li>   <li>python</li>   <li>c/c++</li>   <li>运维</li></ul><!--自定义列表--><dl>   <dt>学科</dt>      <dd>c/c++</dd>      <dd>java</dd>   <dt>位置</dt>      <dd>成都</dd>      <dd>西安</dd></dl><h3 id="1-8-表格">1.8 表格</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">效果展示</span></p><table>    <caption>表格标题</caption>    <tr>      <td>1-1</td>      <td>1-2</td>      <td>1-3</td>      <td>1-4</td>    </tr>    <tr>      <td>2-1</td>      <td>2-2</td>      <td>2-3</td>      <td>2-4</td>    </tr>    <tr>      <td>3-1</td>      <td>3-2</td>      <td>3-3</td>      <td>3-4</td>    </tr></table><p class = "note note-success">colspan  跨列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1px&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--添加边线--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;4&quot;</span>&gt;</span> 1-1 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-comment">&lt;!--跨四列--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table >     <tbody border = "1px"> <!--添加边线-->        <tr>          <td colspan = "4"> 1-1 </td>  <!--跨四列-->        </tr>        <tr>          <td>2-1</td>          <td>2-2</td>          <td>2-3</td>          <td>2-4</td>        </tr>        <tr>          <td>3-1</td>          <td>3-2</td>          <td>3-3</td>          <td>3-4</td>        </tr>    </tbody></table><p class = "note note-success">rowspan 跨行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1px&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--添加边线--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;4&quot;</span>&gt;</span> 1-1 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-comment">&lt;!--跨四列--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--rowspan 跨行--&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span> = <span class="hljs-string">&quot;2&quot;</span>&gt;</span> 2-1 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-comment">&lt;!--跨两行--&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table>     <tbody border = "1px"><!--添加边线-->        <tr>          <td colspan = "4"> 1-1 </td>  <!--跨四列-->        </tr>        <tr>         <!--rowspan 跨行-->          <td rowspan = "2"> 2-1 </td>  <!--跨两行-->          <td>2-2</td>          <td>2-3</td>          <td>2-4</td>        </tr>        <tr>          <td>3-2</td>          <td>3-3</td>          <td>3-4</td>        </tr>    </tbody></table><h2 id="2-页面结构分析">2. 页面结构分析</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span> = <span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span> = <span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>页面结构分析<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>网页头部<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>网页主体<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>网页脚部<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="head部分">head部分</h3><p>HTML文档的头部标记主要包含页面标题标记、元信息标记、样式标记、脚本标记、链接标记等。头部标记所包含的信息一般不会显示在网页上</p><h4 id="页面标题title">页面标题title</h4><p>title标题信息显示在浏览器的标题栏上</p><h4 id="元信息meta">元信息meta</h4><p>META标记用来描述一个HTML网页文档的属性，也称为元信息（meta-information），这些信息并不会显示在浏览器的页面中。例如作者、日期和时间、网页描述、关键词、页面刷新等。<code>&lt;meta&gt;</code>标记位于文档的头部，其属性定义了与文档相关联的“名称/值”对。</p><p class = "note note-success">name属性与content属性<p>    <p>name属性用于描述网页，它是以“名称/值”形式的名称，name属性的值所描述的内容(值)通过content属性表示，便于搜索引擎机器人查找、分类。其中最重要的是description、keywords和robots。</p><p class = "note note-success">http-equiv属性与content属性<p>    <p>​    http-equiv属性用于提供HTTP协议的响应头报文(MIME文档头)，它是以“名称/值”形式的名称，http-equiv属性的值所描述的内容(值)通过content属性表示，通常为网页加载前提供给浏览器等设备使用。其中最重要的是content-type charset提供编码信息，refresh刷新与跳转页面，no-cache页面缓存，expires网页缓存过期时间。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">content</td><td style="text-align:left">some_text</td><td>定义与http-equiv或name属性相关的元信息</td></tr><tr><td style="text-align:left">http-equiv</td><td style="text-align:left">content-type   expires refresh   set-cookie</td><td>把content属性关联到HTTP头部。内容类型网页缓存过期时间刷新与跳转(重定向)页面  如果网页过期，那么存盘的cookie将被删除</td></tr><tr><td style="text-align:left">name</td><td style="text-align:left">author  description  keywords generator</td><td>把content属性关联到一个名称。定义网页作者  定义网页简短描述  定义网页关键词 定义编辑器</td></tr><tr><td style="text-align:left">scheme</td><td style="text-align:left">some_text</td><td>定义用于翻译content属性值的格式。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;信息参数&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;信息参数&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=信息参数&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;generator&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;信息参数&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;信息参数&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;时间； url=网址参数&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">contect</span>=<span class="hljs-string">&quot;信息参数&quot;</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="body部分">body部分</h3><table><thead><tr><th>元素名</th><th>描述</th></tr></thead><tbody><tr><td>header</td><td>标题头部区域的内容(用于页面或页面中的一块区域)</td></tr><tr><td>footer</td><td>标题脚部区域的内容(用于整个页面或页面中的一块区域)</td></tr><tr><td>section</td><td>Web页面中的一块独立区域</td></tr><tr><td>article</td><td>独立的文章内容</td></tr><tr><td>aside</td><td>相关内容或应用(常用于侧边栏)</td></tr><tr><td>nav</td><td>导航类辅助内容</td></tr></tbody></table><p class = "note note-info">在网页设计中，HTML提供了4种颜色设置方法：<p> <ul><li>使用RGB（R，G，B），其中R、G、B是整数，取值范围：0～255；</li><li>使用RGB（R%，G%，B%），其中R、G、B是整数，取值范围：0～100；</li><li>使用3位或6位十六进制数#RGB或#RRGGBB，R、G、B为十六进制数，取值范围：0～9、A～F，每一种颜色用2位十六进制数表示，RR：红色部分，GG：绿色部分，BB：蓝色部分。红色为#FF0000；#RGB可以转换为#RRGGBB 。例如红色 分别 表示为#F00、#FF0000。</li><li>使用颜色英文名称，如red表示红色，green表示绿色，blue表示蓝色等。</li></ul><h2 id="3-内联框架">3. 内联框架</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">src : 引用页面的地址</span><br><span class="hljs-comment">name : 框架标识名</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;mainFrame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="嵌套网页">嵌套网页</h3><iframe src="https://52hzmercury.github.io/" width="100%" height="500" name="topFrame" scrolling="yes"  noresize="noresize" frameborder="0" id="topFrame"></iframe><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--示例嵌套网页--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://52hzmercury.github.io/&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topFrame&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;yes&quot;</span>  <span class="hljs-attr">noresize</span>=<span class="hljs-string">&quot;noresize&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;topFrame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><p class = "note note-warning">参数说明</p<p><code>width=&quot;100%&quot;</code> 为宽度自适应，高度请根据实际需求跳转， <code>scrolling</code> 为滚动条参数。<code>frameborder</code> 为边框参数。<code>noresize</code> 属性规定用户无法调整框架的大小。</p><h3 id="嵌套B站视频">嵌套B站视频</h3><iframe src="//player.bilibili.com/player.html?aid=972845916&bvid=BV1cp4y147ex&cid=329159472&page=1&high_quality=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=375588815&amp;bvid=BV1so4y1m7U5&amp;cid=339262048&amp;page=1&amp;high_quality=1&amp;danmaku=0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;allowfullscreen&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">sandbox</span>=<span class="hljs-string">&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><p class = "note note-warning">参数说明</p><p>BILIBILI 地址PC端参数</p><ul><li><p>&amp;high_quality=1   (1=最高画质 0=最低画质)</p></li><li><p>&amp;danmaku=0   (1=打开弹幕 0=关闭弹幕)</p></li></ul><p>iframe 参数</p><ul><li>allowfullscreen=“allowfullscreen” 移动端全屏</li><li>sandbox=“allow-top-navigation allow-same-origin allow-forms allow-scripts” 禁止弹出网页</li></ul><h2 id="4-表单">4. 表单</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--表单from</span><br><span class="hljs-comment">action : 表单提交的位置，可以是网站，也可以是一个请求处理额地址</span><br><span class="hljs-comment">method : post ,get的提交方式</span><br><span class="hljs-comment">post: 速度较慢，但url上不会显示提交的数据，相对较安全</span><br><span class="hljs-comment">get: 速度较快，但url上会显示提交的数据，不太安全  </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;chenkong.html&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!--文本输入框 : input type = &quot;text&quot;--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <br>   <br>   <span class="hljs-comment">&lt;!--密码输入框 : input type = &quot;password&quot;--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;pwd&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">  <p>名字：<input type = "text" name = "username"></p>    <p> 密码：<input type = "password" name = "pwd" ></p>  <p>     <input type = "submit">     <input type = "reset">  </p></form><h3 id="4-1-表单元素的格式">4.1 表单元素的格式</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>指定元素的类型。text、password、checkbox、radio、submit、reset、file、hidden、ingage和button，默认为text</td></tr><tr><td>name</td><td>指定表单元素的名称</td></tr><tr><td>value</td><td>元素的初始值。type为radio时必须指定一个值</td></tr><tr><td>size</td><td>指定表单元素的宽度，当type为text或password时，表单元素的大小易字符为单位。对于其他类型，宽度以像素为单位</td></tr><tr><td>maxlength</td><td>type为text或password时，输入的最大字符数</td></tr><tr><td>checked</td><td>type为radio或checkbox时，指定按钮是否被选中</td></tr></tbody></table><h3 id="4-2-radio-单选器">4.2 radio 单选器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--文本输入框:input type = &quot;text&quot;</span><br><span class="hljs-comment">value = &quot;陈William牛逼&quot; 默认初始值</span><br><span class="hljs-comment">maxlength = &quot;8&quot;  最长能写几个字符</span><br><span class="hljs-comment">size = &quot;30&quot;     文本框的长度</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;chenkong.html&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;pwd&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--radio 单选器</span><br><span class="hljs-comment">input type = &quot;radio&quot;</span><br><span class="hljs-comment">value  单选框的值</span><br><span class="hljs-comment">name  表示组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>  = <span class="hljs-string">&quot;boy&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span>&gt;</span> 男<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>  = <span class="hljs-string">&quot;girl&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span>&gt;</span> 女<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里的name属性必须要一样，表示他们是一个组的，这样就只能选一个了--&gt;</span><br>    <br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">  <p>名字：<input type = "text" name = "username"></p>    <p> 密码：<input type = "password" name = "pwd" ></p>  <span>     <input type = "radio" value  = "boy" name = "sex"> 男  </span>  <span>     <input type = "radio" value  = "girl" name = "sex"> 女    </span>  <p>     <input type = "submit">     <input type = "reset">  </p> </form><h3 id="4-3-多选框">4.3 多选框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;sleep&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">hobby</span>&gt;</span>睡觉<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">hobby</span>&gt;</span>敲代码<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;chat&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">hobby</span>&gt;</span>聊天<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;game&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">hobby</span>&gt;</span>游戏<br>   <br><span class="hljs-comment">&lt;!--这也是在from表单里的--&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">   <input type = "checkbox" value = "sleep" name = hobby>睡觉    <input type = "checkbox" value = "code" name = hobby>敲代码    <input type = "checkbox" value = "chat" name = hobby>聊天    <input type = "checkbox" value = "game" name = hobby>游戏 </form><h3 id="4-4-关于按钮">4.4 关于按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">input type = &quot;buttion&quot;  普通的按钮</span><br><span class="hljs-comment">input  type = &quot;image&quot;  图像按钮   点击会提交 相当于submit</span><br><span class="hljs-comment">input  type = &quot;submit&quot;  提交按钮</span><br><span class="hljs-comment">input  type = &quot;reset&quot;  重置按钮</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;chenkong.html&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;https://s2.loli.net/2022/04/13/qzsEFCRXW89Vc7I.jpg&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">height</span> = <span class="hljs-string">&quot;70&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;buttion&quot;</span>  &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>          <input type = "image" src = "https://s2.loli.net/2022/04/13/qzsEFCRXW89Vc7I.jpg" width = "50" height = "70">    </p>    <p>          <input type = "buttion"  >    </p>    <p>          <input  type = "submit">   </p>  <p>          <input type = "checkbox">   </p>   <p>          <input  type = "reset">   </p> </form><p class = "note note-warning">注意：</p><p>上图中在后面加上check后就是默认选中，图片的是可以提交的</p><h3 id="4-5-下拉框">4.5 下拉框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;列表名称&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;选项的值&quot;</span>&gt;</span>中国<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;选项的值&quot;</span>&gt;</span>美国<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;选项的值&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>瑞士<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-comment">&lt;!--加上selected就是下拉框的默认选项值--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;选项的值&quot;</span>&gt;</span>印度<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <select name = "列表名称">       <option value = "选项的值">中国</option>       <option value = "选项的值">美国</option>       <option value = "选项的值" selected>瑞士</option>  <!--加上selected就是下拉框的默认选项值-->       <option value = "选项的值">印度</option>    </select> </form><h3 id="4-6-文本域">4.6 文本域</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;textarea&quot;</span> <span class="hljs-attr">cols</span> = <span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">rows</span> = <span class="hljs-string">&quot;10&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>     <br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>        <textarea name = "textarea" cols = "50" rows = "10"> </textarea>         </p> </form><h3 id="4-7-文件域">4.7 文件域</h3><p class = "note note-danger">input必须要有name属性，不然上传不了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;files&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;上传&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;upload&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>       <input type = "file" name = "files">       <input type = "button" value = "上传" name = "upload">     </p> </form><h3 id="4-8-简单的邮件地址和url验证验证">4.8 简单的邮件地址和url验证验证</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;chenkong.html&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>      email: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;email&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       url: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;url&quot;</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;url&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>      email: <input type = "email" name = "email">    </p>     <p>       url: &nbsp&nbsp&nbsp&nbsp&nbsp<input type = "url"  name = "url">     </p></form><h3 id="4-9-数字验证">4.9 数字验证</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">max</span> = <span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">step</span> = <span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>       number:<input type = "number" name = "num" max = "100" min = "0" step = "1">    </p></form><h3 id="4-10-滑块">4.10 滑块</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;vocie&quot;</span> <span class="hljs-attr">min</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">MAX</span> = <span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">step</span> = <span class="hljs-string">&quot;2&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>音量：       <input type = "range" name = "vocie" min = "0" MAX = "100" step = "2">    </p></form><h3 id="4-11-搜索框">4.11 搜索框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;search&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>搜索：       <input type = "search" name = "search">    </p></form><h3 id="4-12-只读标签">4.12 只读标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">readonly</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><p>名字：<input type = "text" name = "username" value = "admin" readonly></p><h3 id="4-13-禁用标签">4.13 禁用标签</h3><p>加上 checked disabled</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;boy&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">checked</span> <span class="hljs-attr">disabled</span>/&gt;</span>男   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;girl&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>女   <br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><p>  <input type = "radio" value = "boy" name = "sex" checked disabled/>男     <input type = "radio" value = "girl" name = "sex"/>女   </p><h3 id="4-14-隐藏域">4.14 隐藏域</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">hidden</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><p>密码<input type = "password" name = "pwd" hidden ></p><p>在隐藏域中设置默认值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">hidden</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;123456&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-15-增强鼠标">4.15 增强鼠标</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span> = <span class="hljs-string">&quot;mark&quot;</span>&gt;</span>point<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mark&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点一下point，就可以到文本框中，增强鼠标的可用性</p><p><span class = "label label-success">示例</span></p><form action = "chenkong.html" method = "get">    <p>        <label for = "mark">point</label>    </p>    <p>        <input type = "text" id = "mark">    </p></form><h3 id="4-16-表单的初级验证">4.16 表单的初级验证</h3><p class = "note note-info">常用方式</p><ul><li>placeholder</li><li>required</li><li>pattern</li></ul><p><span class = "label label-success"><strong>placeholder</strong></span></p><p>加上后会在框中有提示信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span> = <span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><p> name: <input type = "text" name = "username" placeholder = "请输入用户名"></p><p><span class = "label label-info"><strong>required</strong></span></p><p>使用户不能提交空，加上required</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span> = <span class="hljs-string">&quot;请输入用户名&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-warning"><strong>pattern</strong></span></p><p>在pattern里面放入正则表达式判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;diyemail&quot;</span> <span class="hljs-attr">pattern</span> = <span class="hljs-string">&quot;/^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]&#123;2,4&#125;)$/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述正则的意思是：以数字字母开头中间可以是多个数字字符下划线或 ‘ - ’，然后是字符 ‘@’ ，后面是数字字符，最后是字符 ‘ . ’ 加上2-4个字母结尾。</p><h2 id="5-文本处理">5. 文本处理</h2><h3 id="5-1-标题字标记">5.1 标题字标记</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用h1-h6和align控制--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>  &gt;</span>Web前端开发技术<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>  &gt;</span>Web前端开发技术<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>  &gt;</span>Web前端开发技术<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>  &gt;</span>Web前端开发技术<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;justify&quot;</span>  &gt;</span>Web前端开发技术<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>   <span class="hljs-comment">&lt;!--均等对齐。有些浏览器不支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>  &gt;</span>Web前端开发技术<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p>  <h6 align="center"  >Web前端开发技术</h6>  <h6 align="left"  >Web前端开发技术</h6>  <h6 align="center"  >Web前端开发技术</h6>  <h6 align="right"  >Web前端开发技术</h6>  <h6 align="justify"  >Web前端开发技术</h6>  <h6 align="center"  >Web前端开发技术</h6><h3 id="5-2-特殊符号">5.2 特殊符号</h3><table><thead><tr><th>显示结果</th><th>说明</th><th>Entity  Name</th></tr></thead><tbody><tr><td></td><td>显示一个空格</td><td><code>&amp;nbsp;</code></td></tr><tr><td>&lt;</td><td>小于</td><td><code>&amp;lt; </code></td></tr><tr><td>&gt;</td><td>大于</td><td><code>&amp;gt; </code></td></tr><tr><td>&amp;</td><td>&amp;符号</td><td><code>&amp;amp; </code></td></tr><tr><td>&quot;</td><td>双引号</td><td><code>&amp;quot;</code></td></tr><tr><td>©</td><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>&amp;reg; </code></td></tr><tr><td>×</td><td>乘号</td><td><code>&amp;times; </code></td></tr><tr><td>÷</td><td>除号</td><td><code>&amp;divide; </code></td></tr></tbody></table><h3 id="5-3-物理样式标记">5.3 物理样式标记</h3><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;b&gt;软件工程专业！&lt;/b&gt;</code></td><td>黑体</td></tr><tr><td><code>&lt;i&gt;软件工程专业！&lt;/i&gt; </code></td><td>斜体</td></tr><tr><td><code> &lt;u&gt;软件工程专业！&lt;/u&gt;</code></td><td>下划线</td></tr><tr><td><code>&lt;del&gt;软件工程专业！&lt;/del&gt;</code></td><td>删除线</td></tr><tr><td><code>&lt;small&gt;软件工程专业！&lt;/samll&gt;</code></td><td>变小字号</td></tr><tr><td><code>&lt;big&gt;软件工程专业！&lt;/big&gt;</code></td><td>变大字号</td></tr><tr><td><code>&lt;sup&gt;软件工程专业！&lt;/sup&gt;   </code></td><td>上标</td></tr><tr><td><code>&lt;sub&gt;软件工程专业！&lt;/sub&gt;   </code></td><td>下标</td></tr><tr><td><code>&lt;tt&gt;软件工程专业！&lt;/tt&gt; </code></td><td>打字机字体</td></tr></tbody></table><h3 id="5-4-换行">5.4 换行</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> 换行<br><span class="hljs-tag">&lt;<span class="hljs-name">nobr</span>&gt;</span> 不换行 <span class="hljs-tag">&lt;/<span class="hljs-name">nobr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wbr</span>&gt;</span>  强制换行 <span class="hljs-tag">&lt;/<span class="hljs-name">wbr</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-5-段落缩进">5.5 段落缩进</h3><p>一对blockquote标记能够向右缩进5个西方字符的位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>段落缩进标记的应用<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span><br>没有缩进的文字内容<br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span>缩进的文字内容<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span>缩进的文字内容<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p> <h5 align="center">段落缩进标记的应用</h5> <hr color="green"> 没有缩进的文字内容 <blockquote>缩进的文字内容</blockquote>    <blockquote><blockquote>缩进的文字内容</blockquote></blockquote><h3 id="5-6-预格式化标记">5.6 预格式化标记</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs <pre></pre>```标记对网页中的文字段落进行预格式化，浏览器会完整保留设计者在源文件中所定义的格式，包括各种空格、缩进以及其他特殊格式。"><br>```html<br>&lt;pre&gt;预格式化文本 &lt;/pre &gt; <br>&lt;pre&gt;<br>  春 晓     <br>    孟浩然 <br>         春眠不觉晓，<br>         处处闻啼鸟。<br>         夜来风雨声，<br>         花落知多少。<br>&lt;/pre&gt;<br></code></pre></td></tr></table></figure><p><span class = "label label-success">示例</span></p><pre>预格式化文本 </pre > <pre>  春 晓         孟浩然          春眠不觉晓，         处处闻啼鸟。         夜来风雨声，         花落知多少。</pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2021/09/17/JavaScript/"/>
    <url>/2021/09/17/JavaScript/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">    <p>更新日志:<p>    <ul>       <p>2021.9.17：根据狂神说的视频整理出该笔记</p>      <p>2022.4.21：由于学校前端选修课要考试了，根据教学ppt做了一些修订和补充</p>    </ul></div><h1>JavaScript基础</h1><h2 id="简介">简介</h2><p>JavaScript是一种基于对象和事件驱动并具有相对安全性的客户端脚本语言。被广泛应用于各种客户端Web程序尤其是HTML开发中，能给HTML网页添加动态功能，响应用户各种操作，实现诸如欢迎信息、数字日历、跑马灯，显示浏览器停留时间等特殊效果，提高网页的可观性。决定WEB页面的行为，具有客户端数据验证、用户交互等功能</p><h2 id="1-JavaScript放置">1. JavaScript放置</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span><br><span class="xml"><span class="handlebars">   alert(&#x27;JSnb&#x27;)</span></span><br><span class="xml"><span class="handlebars"><span class="hljs-comment">&lt;!--可以直接在这里面写--&gt;</span></span></span><br><span class="xml"><span class="handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!--这个写js的标签放在头部或者身体都可以--&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;js1.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span><br><span class="xml"><span class="handlebars"></span></span><br><span class="xml"><span class="handlebars"><span class="hljs-comment">&lt;!--也可以新建一个js文件然后导入--&gt;</span></span></span><br><span class="xml"><span class="handlebars"></span></span><br><span class="xml"><span class="handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript代码放置有4种情形:</p><ol><li>头部;</li><li>主体;</li><li>单独的js文件;</li><li>直接在事件处理代码中。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- edu_12_1_4.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>直接在事件处理代码中加入JavaScript代码<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;直接在事件处理代码中加入JavaScript代码&#x27;)&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;直接调用JavaScript代码&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript程序本身不能独立存在，它是依附于某个HTML页面，在浏览器端运行的。</p><div class = "note note-warning">注：如果引入引入了外部js文件，在<span><</span><span>script></span><span><</span>/script></span>标记之间的所有JS语句都被忽略，不会执行</div><h2 id="2-消息对话框">2. 消息对话框</h2><p>JavaScript中的消息对话框分为告警框、确认框和提示框。</p><h3 id="警告框">警告框</h3><p>​          alert (message)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- edu_12_2_1.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>告警消息框使用实例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  alert(<span class="hljs-string">&quot;这是告警消息框！&quot;</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><div class = "note note-warning">注：确定按钮必须响应，否则屏蔽一切操作。告警信息为纯文本信息或字符串，不能含有HTML标记</div><h3 id="确认框">确认框</h3><p>​         confirm (message)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- edu_12_2_2.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>确认框使用实例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show_confirm</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> r=confirm(<span class="hljs-string">&quot;请选择按钮!&quot;</span>);</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (r==<span class="hljs-literal">true</span>)&#123;</span><br><span class="javascript">            alert(<span class="hljs-string">&quot;您按了确定按钮！&quot;</span>);</span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">            alert(<span class="hljs-string">&quot;您按了取消按钮！&quot;</span>); </span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;show_confirm()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;显示确认框&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><div class = "note note-warning">注：确认按钮的返回值，类型为逻辑值，确定true，取消false</div><h3 id="提示框">提示框</h3><p>​        prompt (text, defaultText)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- edu_12_2_3.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>提示框使用实例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp_prompt</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">var</span> name=prompt(<span class="hljs-string">&quot;请输入您的姓名&quot;</span>,<span class="hljs-string">&quot;李大为&quot;</span>);</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (name!=<span class="hljs-literal">null</span> &amp;&amp; name!=<span class="hljs-string">&quot;&quot;</span>) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您好，&quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>); </span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;disp_prompt()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;单击显示提示框&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><div class = "note note-warning">注：选择“确定”返回输入的值，选择“取消”返回null。</div><h2 id="3-命令规范">3. 命令规范</h2><h3 id="标识符">标识符</h3><p>标识符是计算机语言中用来表示变量名、函数名等的有效字符序列，简单来说，标识符就是一个名字，JavaScript关于标识符的规定如下：</p><ul><li><p>必须使用字母或者下划线开始。</p></li><li><p>必须使用英文字母、数字、下划线组成，不能出现空格或制表符。</p></li><li><p>不能使用JavaScript关键字与JavaScript保留字。</p></li><li><p>不能使用JavaScript语言内部的单词，比如Infinity，NaN，undefined等。</p></li><li><p>大小写敏感，如name和Name是不同的两个标识符。</p></li></ul><h3 id="关键字">关键字</h3><p>​    关键字是JavaScript中已经被赋予特定意义的一些单词，关键字不能作为标识符来使用。</p><table><thead><tr><th>JavaScript的关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>break</strong></td><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>continue</strong></td><td><strong>default</strong></td></tr><tr><td><strong>delete</strong></td><td><strong>do</strong></td><td><strong>else</strong></td><td><strong>finally</strong></td><td><strong>for</strong></td></tr><tr><td><strong>function</strong></td><td><strong>if</strong></td><td><strong>in</strong></td><td><strong>instanceof</strong></td><td><strong>new</strong></td></tr><tr><td><strong>return</strong></td><td><strong>switch</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>try</strong></td></tr><tr><td><strong>typeof</strong></td><td><strong>var</strong></td><td><strong>void</strong></td><td><strong>while</strong></td><td><strong>with</strong></td></tr></tbody></table><table><thead><tr><th>JavaScript的保留字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>abstract</strong></td><td><strong>boolean</strong></td><td><strong>byte</strong></td><td><strong>char</strong></td><td><strong>class</strong></td></tr><tr><td><strong>const</strong></td><td><strong>debugger</strong></td><td><strong>double</strong></td><td><strong>enum</strong></td><td><strong>export</strong></td></tr><tr><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>float</strong></td><td><strong>goto</strong></td><td><strong>implements</strong></td></tr><tr><td><strong>import</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td><td><strong>short</strong></td></tr><tr><td><strong>static</strong></td><td><strong>super</strong></td><td><strong>synchronized</strong></td><td><strong>throws</strong></td><td><strong>transient</strong></td></tr><tr><td><strong>volatile</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="4-数据类型">4. 数据类型</h2><p>所有的变量直接使用var声明就行  如 var a = 1; 输出是console.log();</p><p>js不区分小数和整数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">123<br>123.1<br>1.23e3<br>-99<br>NaN     //not a number<br>Infinity  //表示无限大<br></code></pre></td></tr></table></figure><p>这里就是多了NaN  (not a number类型和Infinity 无限大的类型, 再说一下比较运算符有点不一样</p><p>比较运算符</p><ul><li>=  赋值</li><li>== 等于(类型不一样，值一样，也会判断为true)</li><li><span class = "label label-danger">===</span> 绝对等于(类型一样，值一样，结果为true)</li></ul><div class = "note note-warning">须知</div><ul><li>NaN===NaN 这个于所有的之都不相等，包括自己</li><li>只能通过isNaN(NaN)来判断是不是NaN</li><li>还有就是老生长谈的精度问题,不要直接比较浮点数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> i = <span class="hljs-number">304</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> f = <span class="hljs-number">3.87</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> s = <span class="hljs-number">8.1e3</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> o = <span class="hljs-number">034</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> h = <span class="hljs-number">0x2A</span>;</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;十进制整型数304的输出结果：&quot;</span>+i+<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;十进制浮点型数3.87的输出结果：&quot;</span>+f+<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;十进制数科学计数法8.1e3的输出结果：&quot;</span>+s+<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;八进制整型数034的输出结果：&quot;</span>+o+<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;十六进制整型数0x2A的输出结果：&quot;</span>+h+<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-数组">5. 数组</h2><p>基本和Java类似,不详谈,不一样的就是什么类型都可以装,有点像集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>];<br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">new</span> array(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>数组越界会undefined</p><p>同时数组还有一些方法如sort(),reverse(),concat();都是 <span class = "label label-success">数组名.方法名();</span></p><p>来调用,就是多了一个join连接符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&quot;C&quot;</span> <span class="hljs-string">&quot;B&quot;</span> <span class="hljs-string">&quot;A&quot;</span>]<br>arr.join(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-string">&quot;C-B-A&quot;</span><br></code></pre></td></tr></table></figure><p>多维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr =  [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]];<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="6-对象">6. 对象</h2><p>js是一个面向对象的语言，因此也有对象这个概念</p><p>声明一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;niubi&quot;</span>,<br>  <span class="hljs-attr">age</span>:<span class="hljs-number">3</span>,<br>  <span class="hljs-attr">tags</span>:[<span class="hljs-string">&#x27;js&#x27;</span>,<span class="hljs-string">&#x27;is&#x27;</span>,<span class="hljs-string">&#x27;niubi&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里注意,对象是大括号,数组是中括号.而且对象的前几个属性使用逗号隔 ( , ) 开,最后一个不用符号</li><li>调用的话直接person.age  就行了</li></ul><div class = "note note-info">严格检查模式</div><p>在&lt; script &gt; 标签里<strong>第一句</strong>写上  'use strict’就行<br>这样局部变量就只能使用let声明 (局部变量推荐使用let声明)</p><h2 id="7-字符串">7. 字符串</h2><p>和Java类似,不同的多了一个多行字符串的编写</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">`chen</span><br><span class="hljs-string">shuai</span><br><span class="hljs-string">niu</span><br><span class="hljs-string">bi`</span><br></code></pre></td></tr></table></figure><p>这个符号声明的符号就是tab键上面的那个键<br>字符串是不可以变的,就像是Java里的String一样</p><h2 id="8-流程控制">8. 流程控制</h2><p>for-in循环</p><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(变量 <span class="hljs-keyword">in</span> 对象)<br>    &#123;<br>        在此执行代码<br>    &#125;<br></code></pre></td></tr></table></figure><p>感觉就是for-each循环，这里的变量可以是数组元素，也可以是对象的属性</p><p><span class = "label label-success">例如</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> age)&#123;<br>   <span class="hljs-built_in">console</span>.log(num);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-map和set集合">9. map和set集合</h2><p>和Java没啥区别</p><h4 id="map集合">map集合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">100</span>],[<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">90</span>],[<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-number">80</span>]]);<br><span class="hljs-keyword">var</span> name = map.get(<span class="hljs-string">&quot;tom&quot;</span>);<span class="hljs-comment">//通过key来获取value</span><br>map.set(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-number">123456</span>);<br><span class="hljs-built_in">console</span>.log(name);<br>map.delete(<span class="hljs-string">&quot;tom&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="set集合">set集合</h4><p>set: 无序不重复的集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);<span class="hljs-comment">//set是可以去重的</span><br>&gt; <span class="hljs-function"><span class="hljs-title">Set</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span> &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;       <span class="hljs-comment">//前面的2是指长度，后面的是含有的元素</span><br><br>set.add(<span class="hljs-number">2</span>);     <span class="hljs-comment">//添加</span><br>set.delete(<span class="hljs-number">1</span>);  <span class="hljs-comment">//删除</span><br>&gt; <span class="hljs-function"><span class="hljs-title">Set</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span> &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-built_in">console</span>.log(set.has(<span class="hljs-number">3</span>)); <span class="hljs-comment">//</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="遍历">遍历</h4><p>同时遍历的方法多了个for-of循环…就是把 <strong>in</strong> 改成了 <strong>of</strong> 然后没有啥区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">100</span>],[<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">90</span>],[<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-number">80</span>]]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> map)&#123; <span class="hljs-built_in">console</span>.log(x) &#125;<br>(<span class="hljs-number">2</span>) [<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;tom&#x27;</span>]<br>(<span class="hljs-number">2</span>) [<span class="hljs-number">90</span>, <span class="hljs-string">&#x27;jack&#x27;</span>]<br>(<span class="hljs-number">2</span>) [<span class="hljs-number">80</span>, <span class="hljs-string">&#x27;haha&#x27;</span>]<br><br><span class="hljs-comment">//set遍历同理</span><br></code></pre></td></tr></table></figure><h2 id="10-函数来一点点">10. 函数来一点点</h2><h3 id="函数相关">函数相关</h3><ul><li>JavaScript函数分为系统内部函数和系统对象定义的函数及用户自定义函数。</li><li>函数就是完成一个特定的功能的程序代码。函数只需要定义一次，可以多次使用，从而提高程序代码的复用率，既减轻开发人员的负担，以降低了代码的重复度。</li><li>函数需要先定义后使用，JavaScript函数一般定义在HTML文件的头部head标记或外部JS文件中，而函数的调用可以在HTML文件的主体body标记中任何位置。</li><li>常用系统内部函数又称为内部函数（内部方法），与任何对象无关，可以直接使用。</li></ul><h3 id="基本语法">基本语法</h3><p>function 函数名(参数1, 参数2, … 参数N) {函数体；}</p><p>语法说明：</p><ol><li><p>可以没有参数，但括号必须保留、以及包含在大括号内的由若干条语句构成的函数体。</p></li><li><p>不能在其他语句或其自身中嵌套function语句，也就是说，每个函数声明都是独立的。</p></li><li><p>函数名（参数），形参是用来接收函数调用者传递过来的实参。</p></li><li><p>调用实参与形参要一一对应，主要表现在类型、顺序、数量、内容要一致。</p></li></ol><h3 id="定义函数">定义函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第一种方式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params">x</span>)</span>&#123;<br>   <span class="hljs-keyword">if</span>()&#123;<br>   ...<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>   ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<br>     <span class="hljs-keyword">if</span>()&#123;<br>   ...<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>   ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//两种定义的方式是等价的</span><br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">abs(-<span class="hljs-number">10</span>)<br>abs(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="ES6引入的新特性">ES6引入的新特性</h3><p>rest类似于Java中的可变参数</p><p>ES6引入的新特性，获取除了已经定义的参数之外的所有参数，ES6新特性中还可以使用const定义常量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params">a,b...rest</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a=&gt;&quot;</span>+a);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b=&gt;&quot;</span>+b);<br>    <span class="hljs-built_in">console</span>.log(rest);<br>&#125;<br></code></pre></td></tr></table></figure><p>rest参数只能写在最后面，且必须使用…标示</p><h2 id="11-方法">11. 方法</h2><p>定义一个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chenshuai = &#123;<br>   <span class="hljs-attr">name</span>:chen,<br>   <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<br>   <span class="hljs-attr">run</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    ....<span class="hljs-comment">//一些方法体</span><br>   &#125;<br><span class="hljs-comment">//方法要写在对象里面</span><br><br>&#125;<br><br>chenshuai.name<span class="hljs-comment">//直接点就可以进行调用</span><br></code></pre></td></tr></table></figure><h2 id="12-date对象的使用">12. date对象的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//获取date对象</span><br>now.getFullyear();<span class="hljs-comment">//年</span><br>now.getMonth();<span class="hljs-comment">//月</span><br>now.getDate();<span class="hljs-comment">//日期</span><br>now.getDay();<span class="hljs-comment">//星期几</span><br>now.getHours();<span class="hljs-comment">//小时</span><br>now.getMinutes();<span class="hljs-comment">//分钟</span><br>now.getSeconds();<span class="hljs-comment">//秒</span><br><br>now.getTime();<span class="hljs-comment">//时间戳</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1595555665</span>))  <span class="hljs-comment">//时间戳转换为时间</span><br></code></pre></td></tr></table></figure><h2 id="13-初识Json">13. 初识Json</h2><p>这里只是简单的了解一下json，后面我会出专门的json篇<br><strong>简单的三点</strong></p><ul><li>对象都使用{}</li><li>数组都使用[]</li><li>所有的键值对都是用key:value</li></ul><p>来一点代码理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user  = &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;chenshuai&quot;</span>,<br>   <span class="hljs-attr">age</span>:<span class="hljs-number">3</span>,<br>   <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//对象转换为json对象&#123;&quot;name&quot;:&quot;chenhsuai&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;</span><br><span class="hljs-keyword">var</span> jsonUser = <span class="hljs-built_in">JSON</span>.stringify(user);<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;chenhsuai&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span>)<br><br><span class="hljs-comment">//注意这里如果里面是双引号,外面就要用单引号.反之亦然</span><br></code></pre></td></tr></table></figure><p>关于js和Json的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;hellob&#x27;</span>&#125;; <span class="hljs-comment">//js</span><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;hellob&quot;</span>&#125;; <span class="hljs-comment">//json</span><br></code></pre></td></tr></table></figure><h2 id="14-原型">14. 原型</h2><p>相当于Java中的继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;chenhsuai&quot;</span>,<br>   <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<br>   <span class="hljs-attr">run</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;student&quot;</span>);<br>  &#125;<br><br>&#125; <br><br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaoming&quot;</span>,<br>   <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<br>&#125; <br><br>xiaoming._proto_ = student;<br><span class="hljs-comment">//将xiaoming的原型设置为student，相当于继承，这个时候小明就可以调用student中的run方法</span><br></code></pre></td></tr></table></figure><p>小明的原型是student 然后就可以使用student的方法了.在这里student也是一个对象</p><p>原型链：不深入了解</p><h2 id="15-操作BOM对象">15. 操作BOM对象</h2><p>javascript由三部分组成</p><ul><li><p>核心：描述了javascript的语法和基本对象。</p></li><li><p>文档对象模型（DOM）：是处理网页内容的方法和接口，是HTML和xml的应用程序接口（API）。</p></li><li><p>浏览器对象模型（BOM）：各个浏览器厂商根据DOM在各个浏览器上的实现。</p></li></ul><p>bom对象就是浏览器的对象模型，核心是对window的操作，主要针对浏览器窗口交互，BOM包含了DOM</p><p><img src="https://cdn.jsdelivr.net/gh/52HZMercury/img/blog/image-20220422214828118.png" alt="bom对象模型图"></p><h3 id="window对象">window对象</h3><p>代表浏览器窗口</p><p>页面跳转和重定向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;url&quot;</span>;<br><span class="hljs-built_in">window</span>.location.replace(<span class="hljs-string">&quot;url&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Navigator对象">Navigator对象</h3><p>封装了浏览器的信息（大多数时候不会使用这个对象，因为会被认为的修改<br>所以不建议使用这些属性来判断和编写代码<br>）</p><h3 id="screen对象">screen对象</h3><p>screen.width  获取屏幕的宽度</p><p>screen.height 获取长度</p><h3 id="location">location</h3><p>代表当前页面的URL信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">host:<span class="hljs-string">&quot;www.baidu.com&quot;</span><br><span class="hljs-attr">href</span>:<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span><br><span class="hljs-attr">protocol</span>:<span class="hljs-string">&quot;https:&quot;</span><br><span class="hljs-attr">reload</span>:f reload() <span class="hljs-comment">//刷新网页</span><br><span class="hljs-comment">//设置新的地址</span><br>location.assign(<span class="hljs-string">&#x27;https://blog.mercury.com/&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="document">document</h3><ul><li><p>document对象是客户端JavaScript最为常用的对象之一，在浏览器对象模型中，它位于window对象的下一层级。</p></li><li><p>document对象包含一些简单的属性，提供了有关浏览器中显示文档的相关信息，例如：该文档的URL、字体颜色，修改日期等。</p></li><li><p>document对象还包含一些引用数组的属性，这些属性可以代表文档中的表单、图象、链接、锚以及applet。</p></li><li><p>同其他对象一样，document对象还定义了一系列的方法，通过这些方法，可以使JavaScript在解析文档时动态地将HTML文本添加到文档中。</p></li></ul><h4 id="获取具体的文档树结点">获取具体的文档树结点</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>javaSE<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>javaEE<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> dl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="getElementById">getElementById</h5><ul><li><p>通过getElementById方法可以快速访问某个HTML元素，而不必通过DOM层层遍历。</p></li><li><p>使用getElementById方法时如果元素的ID不是唯一的，那么会获得第一个符合条件的元素。</p></li></ul><h5 id="getElementsByName">getElementsByName</h5><ul><li>getElementsByName方法用于返回HTML元素中指定name属性的元素数组 ，而且仅用于像input,radio,checkbox等表单元素对象。</li></ul><h5 id="getElementsByTagName">getElementsByTagName</h5><ul><li><p>getElementsByTagName方法返回指定HTML标记名的元素数组</p></li><li><p>通过遍历这个数组获得每一个单独的子元素</p></li></ul><p>定义多个P标记元素，通过getElementsByTagName(“p”)方法选中HTML标记是<p>的元素，返回是一个对象数组，可以通过下标访问这个数组。</p><h5 id="appendChild">appendChild</h5><p>appendChild方法向当前节点对象追加节点，经常用于给页面动态的添加内容。</p><h5 id="removeChild">removeChild</h5><p>removeChild方法是删除当前节点下的某个子节点，并返回被删除的节点。</p><h5 id="其他方法">其他方法</h5><ul><li><p>cloneNode();</p></li><li><p>replaceChild(newChild,oldChild);</p></li><li><p>inserBefore(newElement,targeElement);</p></li></ul><h4 id="获取cookie">获取cookie</h4><p>例如：  document.cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.cookie<br><span class="hljs-string">&quot;buvid3=C1B1E27B-2C84-63F6-4A26-B4E8B02E8F6161085infoc&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//你先要在html中设置那个标签的id是&#x27;h1&#x27;，以下相同</span><br><span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&#x27;h1&#x27;</span>);<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-built_in">document</span>.getElementByID(<span class="hljs-string">&#x27;p1&#x27;</span>);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">document</span>.getElementByclassName(<span class="hljs-string">&#x27;p2&#x27;</span>);<br><span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.getElementByID(<span class="hljs-string">&#x27;father&#x27;</span>);<br><br><span class="hljs-keyword">var</span> childrens = father.children; <span class="hljs-comment">//获取父节点下的所有子结点</span><br><span class="hljs-comment">//father.firstChild</span><br><span class="hljs-comment">//father.lastChild</span><br></code></pre></td></tr></table></figure><h4 id="获取页面标题">获取页面标题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.title<br><span class="hljs-string">&quot;百度一下，你就知道&quot;</span><br></code></pre></td></tr></table></figure><div class = "note note-warning">注意</div><ul><li><p>通过getElementById方法可以快速访问某个HTML元素，而不必通过DOM层层遍历。</p></li><li><p>使用getElementById方法时如果元素的ID不是唯一的，那么会获得第一个符合条件的元素。</p></li><li><p>getElementsByName方法用于返回HTML元素中指定name属性的元素数组。而且仅用于像input,radio,checkbox等表单元素对象</p></li></ul><h3 id="history">history</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">history.back() <span class="hljs-comment">//后退</span><br><br>history.forward() <span class="hljs-comment">//前进</span><br></code></pre></td></tr></table></figure><h2 id="16-操作DOM对象节点">16. 操作DOM对象节点</h2><h3 id="DOM简介">DOM简介</h3><p>DOM是一个发展中的标准，它指定了JavaScript等脚本语言访问和操作HTML或者XML文档各个结构的方法，随着技术的发展和需求的变化，DOM中的对象、属性和方法也在不断地变化</p><div class = "note note-success">对于大多数HTML文档来说，主要由以下几个节点构成：</div><p>•元素节点 (Element Node ),元素节点构成了DOM基础。在文档结构中，<code>&lt;html&gt;,&lt;head&gt;、&lt;body&gt;、&lt;h1&gt;、&lt;p&gt;,&lt;ul&gt;</code>等标签都是元素节点。</p><p>•文本节点(Text Node),文本节点包含在元素节点内，如h1、p、li等节点就可以包含一些文本节点。</p><p>•属性节点(Attribute Node),属性节点总是被包含在元素节点当中，可以通过元素节点对象调用getAttribute( )方法来获取属性节点。</p><h3 id="DOM应用实例">DOM应用实例</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>createElement(tagname)</td><td>创建标记名为tagname的结点</td></tr><tr><td>createTextNode(text)</td><td>创建包含文本text的文本结点</td></tr><tr><td>creatDocumentFragment()</td><td>创建文档碎片</td></tr><tr><td>removeChild(node)</td><td>删除一个名为node的子节点</td></tr><tr><td>appendChild(node)</td><td>添加一个名为node的子节点</td></tr><tr><td>insertBefore(node B ,node A)</td><td>在名为nodeA节点前插入一个名为nodeB的节点</td></tr><tr><td>replaceChild(node B ,node A)</td><td>用一个名为nodeB节点替换另一个名为nodeA节点</td></tr><tr><td>cloneNode(boolean)</td><td>克隆一个节点，它接收一个boolean参数，为true时表示该节点带文字；false表示该节点不带文字</td></tr></tbody></table><h3 id="更新节点">更新节点</h3><p>在DOM中有两个很重要的属性，这两个属性分别是innerText和innerHTML，通过这两个属性，可以更方便的进行文档操作。</p><p>在DOM中，如果需要动态地获取及设置节点属性的话，可以通过getAttribute( )方法setAttribute( )方法来处理</p><p>先获取一个节点,然后进行相应的操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;id1&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">   <span class="hljs-keyword">var</span> id1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;id1&quot;</span>);</span><br><span class="javascript">   id1.innerText = <span class="hljs-string">&#x27;456&#x27;</span>                     <span class="hljs-comment">// 修改文本的值</span></span><br><span class="javascript">   id1.innerHTML = <span class="hljs-string">&#x27;&lt;strong&gt;123&lt; strong&gt;&#x27;</span>   <span class="hljs-comment">// 向标签中添加HTML语句</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="删除节点">删除节点</h3><p>需要通过父节点来删除子节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;p2&quot;</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">   </span><br><span class="javascript">    <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);      <span class="hljs-comment">//获得p1这个节点</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> father = p1.getElementById;                <span class="hljs-comment">//获得p1的父亲节点</span></span><br><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//第一种    </span></span><br><span class="javascript">    father.removechild(p1);                        <span class="hljs-comment">//通过父亲节点来删除儿子节点</span></span><br><span class="javascript"><span class="hljs-comment">//第二种</span></span><br><span class="javascript">    father.removeChild(father.child[<span class="hljs-number">0</span>]);           <span class="hljs-comment">//通过数组的形式来删除</span></span><br><span class="javascript">    father.removeChild(father.child[<span class="hljs-number">1</span>]);</span><br><span class="javascript">    <span class="hljs-comment">//需要注意的是这种方式是动态的，删除了0号，1号就变成了0号；</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="插入节点">插入节点</h3><h4 id="1-追加">1. 追加</h4><p>可以通过append方法来追加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;se&quot;</span>&gt;</span>JavaSE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;ee&quot;</span>&gt;</span>JavaEE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;me&quot;</span>&gt;</span>JavaME<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElemntById(<span class="hljs-string">&#x27;js&#x27;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><br><span class="javascript">    list.appendChild(js);        <span class="hljs-comment">//追加到后面</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-通过js创建一个新的节点">2. 通过js创建一个新的节点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newp = <span class="hljs-built_in">document</span>.creatElement(<span class="hljs-string">&#x27;p&#x27;</span>)<span class="hljs-comment">//创建一个p标签</span><br>newp.id = <span class="hljs-string">&#x27;newp&#x27;</span>;<br>newp.innerText = <span class="hljs-string">&#x27;hello chengshuai&#x27;</span><br></code></pre></td></tr></table></figure><p>插入到前面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;se&quot;</span>&gt;</span>JavaSE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;ee&quot;</span>&gt;</span>JavaEE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;me&quot;</span>&gt;</span>JavaME<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;list&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> newnode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>);<span class="hljs-comment">//创建一个p标签</span></span><br><span class="javascript">    newnode.innerHTML = <span class="hljs-string">&quot;hello chengshuai&quot;</span>;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> ee = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;ee&quot;</span>);</span><br><span class="javascript"></span><br><span class="javascript">    list.insertBefore(newnode,ee);<span class="hljs-comment">//将list插入到ee到前面  list必须是父标签</span></span><br><span class="javascript">   <span class="hljs-comment">// list.insertBefore(newnode,list.childNodes[0]);</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-通过函数">3. 通过函数</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>创建节点举例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatp</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> op = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> otext = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&quot;hello world&quot;</span>);</span><br><span class="javascript">            op.appendChild(otext);</span><br><span class="javascript">            <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].appendChild(op);</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;from1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击创建节点&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;creatp()&quot;</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!--这里主要是要记住可以在标签里加入 onclik 事件，然后在里面放函数，就会执行函数的内容--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-操作css">4. 操作css</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">id1.style.color = <span class="hljs-string">&#x27;yellow&#x27;</span>;<br>id1.style.fronSize = <span class="hljs-string">&#x27;20px&#x27;</span>;<br>id1.style.padding = <span class="hljs-string">&#x27;2px&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java进阶</title>
    <link href="/2021/09/03/Java%E8%BF%9B%E9%98%B6/"/>
    <url>/2021/09/03/Java%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<div class = "note note-success">    <p>更新日志:<p>    <ul>       <p>2021.9.3：根据狂神说的视频整理出该笔记</p>      <p>2022.9.16：准备明年春招，对照一些面经等资料，做了一定修改和补充</p>    </ul></div><h1>一、常用类</h1><h2 id="1）-String相关类">1） String相关类</h2><h3 id="1-String">1.String</h3><h4 id="1-1-初识字符串">1.1 初识字符串</h4><p><strong>声明字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一 声明时直接赋值</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;uden&quot;</span>);<br><span class="hljs-comment">//方法二 先声明后赋值</span><br>String s = <span class="hljs-keyword">new</span> String();<br>s = sc.next();<br></code></pre></td></tr></table></figure><p>转换为二进制的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//插一个函数 重要</span><br>result = Integer.toBinaryString(num)<span class="hljs-comment">//将int 数字转换为二进制字符串（String）</span><br></code></pre></td></tr></table></figure><h4 id="1-2字符串的一系列操作">1.2字符串的一系列操作</h4><p><strong>连接字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">join</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Java&quot;</span>);<br>        String s = s1+<span class="hljs-string">&quot; &quot;</span>+s2;<br>        System.out.println(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取字符串长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> size = str.length();<br></code></pre></td></tr></table></figure><p><strong>字符串查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> index = str.indexOf(substr);<span class="hljs-comment">//返回substr首次出现在str里的下标；</span><br><span class="hljs-comment">//例如</span><br><span class="hljs-keyword">int</span> index = str.indexOf(<span class="hljs-string">&quot;a&quot;</span>);<br><br><span class="hljs-keyword">int</span> index = str.lastindexOf(substr);<span class="hljs-comment">//返回substr最后一次出现在str里的下标；</span><br><span class="hljs-comment">//例如</span><br><span class="hljs-keyword">int</span> index = str.lastindexOf(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>获取指定位置的字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> mychar = str.charAt(<span class="hljs-keyword">int</span> index);<br></code></pre></td></tr></table></figure><p><strong>获取子字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String substr = str.substring(<span class="hljs-keyword">int</span> beginIndex);<span class="hljs-comment">//获取从指定索引位置开始直到该字符串结尾的子串</span><br><br>String substr = str.substring(<span class="hljs-keyword">int</span> beginIndex，<span class="hljs-keyword">int</span> endIndex);<span class="hljs-comment">//从begin到end的子串</span><br></code></pre></td></tr></table></figure><p><strong>去除空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.trim();<br></code></pre></td></tr></table></figure><p><strong>字符串替换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">str.replace(<span class="hljs-keyword">char</span> oldChar,<span class="hljs-keyword">char</span> newChar);<br>str.replaceAll(String regex,String newstr);<span class="hljs-comment">//注意这里需使用正则表达式</span><br></code></pre></td></tr></table></figure><p><strong>比较字符串</strong><br>比较字符串不能用 “==” 因为字符串是对象，即使是内容相同，内存地址也是不同的，也会是false;<br>这里应该使用equals方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">str.equals(String otherString);<span class="hljs-comment">//返回Boolean类型</span><br><br>str.equalsIgnoreCase(String otherString);<span class="hljs-comment">//忽视大小写的情况下比较字符串  返回Boolean类型</span><br></code></pre></td></tr></table></figure><p><strong>按字典顺序比较两个字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.compareTo(String otherstr);<span class="hljs-comment">//如果str在otherstr之前则返回一个负值，否则返回正值，如果相等则返回0；</span><br></code></pre></td></tr></table></figure><p><strong>大小写转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc DEF&quot;</span>);<br>    String newstr1 = str.toUpperCase();<span class="hljs-comment">//转换为大写</span><br>    String newstr2 = str.toLowerCase();<span class="hljs-comment">//转换为小写</span><br>    System.out,println(newstr1);<span class="hljs-comment">//注意，转换时,数字或非字符是不受影响的</span><br>    System.out,println(newstr1);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符串分割</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] firstArray = str.split(<span class="hljs-string">&quot;\\.&quot;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//第一个参数为正则表达式，第二个分割次数，也可以不写</span><br><br></code></pre></td></tr></table></figure><p><strong>字符串反转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder(s);<br>System.out.print(stringBuilder.reverse().toString());<br></code></pre></td></tr></table></figure><h4 id="1-3-关于正则表达式（初级）">1.3 关于正则表达式（初级）</h4><p><strong>注意：</strong> 在正则表达式中“.”代表任何一个字符，因此在正则表达式如果想使用普通意义的&quot;.&quot; ，需要写成&quot;\.&quot;;<br><img src="https://img-blog.csdnimg.cn/b6fab23d0d6143cfbb8598b42ad198a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="正则表达式"></p><h3 id="2-StringBuffer">2. StringBuffer</h3><h4 id="2-1初始化">2.1初始化</h4><p>StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;william&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="2-2-关于StringBuffer的一些方法">2.2 关于StringBuffer的一些方法</h4><p><strong>添加字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//append方法  在末尾添加字符或者字符串</span><br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;william&quot;</span>);<br>sb.append(<span class="hljs-string">&quot;wiam&quot;</span>);<span class="hljs-comment">//结果应是williamwiam,即添加到末尾</span><br>System.out.println(sb);<br><br><span class="hljs-comment">//insert方法  在指定位置添加字符</span><br> sb.insert(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;w&quot;</span>);<br> System.out.println(sb);<span class="hljs-comment">//结果为wabcb</span><br></code></pre></td></tr></table></figure><p><strong>删除字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//deleteCharAt()方法  删除指定位置的字符</span><br>sb.deleteCharAt(<span class="hljs-number">1</span>); <br>System.out.println(sb);<span class="hljs-comment">//结果wbcb</span><br><br><span class="hljs-comment">//delete方法  删除指定位置的字符</span><br>sb.delete(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>System.out.println(sb);<span class="hljs-comment">//结果wb  即不包括位置的最后一位</span><br></code></pre></td></tr></table></figure><p><strong>替换指定位置的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//Buffer里的replace方法</span><br>sb.replace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chengningzuishuai&quot;</span>);<br>System.out.println(sb);<span class="hljs-comment">//结果chengningzuishuaib 最后一个依然为开区间</span><br></code></pre></td></tr></table></figure><p><strong>反转字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//reverse方法</span><br>sb.reverse();<br>System.out.println(sb);<span class="hljs-comment">//结果biauhsiuzgningnehc</span><br></code></pre></td></tr></table></figure><blockquote><p>参考:<a href="https://blog.csdn.net/weixin_44519467/article/details/103947361?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163092725916780265450059%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163092725916780265450059&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-103947361.first_rank_v2_pc_rank_v29&amp;utm_term=stringbuffer&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_44519467/article/details/103947361?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163092725916780265450059%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163092725916780265450059&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-103947361.first_rank_v2_pc_rank_v29&amp;utm_term=stringbuffer&amp;spm=1018.2226.3001.4187</a></p></blockquote><h3 id="3-StringBuilder">3. StringBuilder</h3><h4 id="3-1-初始化">3.1 初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder  sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello mercury&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-2-几个常用的方法">3.2 几个常用的方法</h4><p>和StringBuffer的都一样<br><strong>添加字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//append方法</span><br>sb.append(<span class="hljs-string">&quot;chenningzuishuai&quot;</span>);<br>System.out.println(sb);<span class="hljs-comment">//结果Hello mercurychenningzuishuai</span><br><br><span class="hljs-comment">//insert</span><br>sb.insert(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;william&quot;</span>);<br>System.out.println(sb);<span class="hljs-comment">//结果为Hewilliamllo mercurychenningzuishuai</span><br></code></pre></td></tr></table></figure><p><strong>删除字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//deleteCharAt()方法  删除指定位置的字符</span><br>sb.deleteCharAt(<span class="hljs-number">1</span>); <br>System.out.println(sb);<span class="hljs-comment">//结果Hwilliamllo mercurychenningzuishuai</span><br><br><span class="hljs-comment">//delete方法  删除指定位置的字符</span><br>sb.delete(<span class="hljs-number">1</span>,<span class="hljs-number">30</span>);<br>System.out.println(sb);<span class="hljs-comment">//结果Hshuai  即不包括位置的最后一位</span><br></code></pre></td></tr></table></figure><p><strong>替换指定位置的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//Builder里的replace方法</span><br>sb.replace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chengningzuishuai&quot;</span>);<br>System.out.println(sb);```<br></code></pre></td></tr></table></figure><p><strong>反转字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//reverse方法</span><br>sb.reverse();<br>System.out.println(sb);<br></code></pre></td></tr></table></figure><h3 id="4-关于这几个字符串的区别">4. 关于这几个字符串的区别</h3><table><thead><tr><th>String</th><th style="text-align:center">StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>String的值是不可变的（里面是final），这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td><td style="text-align:center">StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td><td>可变类，速度更快</td></tr><tr><td>不可变</td><td style="text-align:center">可变</td><td>可变</td></tr><tr><td></td><td style="text-align:center">线程安全</td><td>线程不安全</td></tr><tr><td></td><td style="text-align:center">多线程操作字符串</td><td>单线程操作字符串</td></tr></tbody></table><p>（1）如果要操作少量的数据用 String；</p><p>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；</p><p>（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</p><p><strong>在不考虑线程安全的情况下，现阶段应使用StringBuilder而不是StringBuffer</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163092981516780366546179%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163092981516780366546179&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-89966303.first_rank_v2_pc_rank_v29&amp;utm_term=stringbuilder&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163092981516780366546179%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163092981516780366546179&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-89966303.first_rank_v2_pc_rank_v29&amp;utm_term=stringbuilder&amp;spm=1018.2226.3001.4187</a></p></blockquote><h2 id="2-Math类">2) Math类</h2><p>定义了一些常量,如 Math.PI   Math.E</p><h3 id="1-常用的数学方法">1.常用的数学方法</h3><ol><li>三角函数方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mathdemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;90度的正弦值：&quot;</span>+Math.sin(Math.PI/<span class="hljs-number">2</span>));<span class="hljs-comment">//注意这几个函数参数和返回值都是double</span><br>        System.out.println(<span class="hljs-string">&quot;0度的余弦值：&quot;</span>+Math.cos(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;60度的正弦值：&quot;</span>+Math.tan(Math.PI/<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>指数函数方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExponentFunction</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//这几个函数依旧是double参数和double返回值</span><br>        System.out.println(<span class="hljs-string">&quot;e的平方值&quot;</span> + Math.exp(<span class="hljs-number">2</span>));<span class="hljs-comment">//e的二次方</span><br>        System.out.println(<span class="hljs-string">&quot;以e为底2的对数值&quot;</span> + Math.log(<span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;以10为底2的对数值&quot;</span> + Math.log10(<span class="hljs-number">2</span>));<span class="hljs-comment">//这个10不可以变哈</span><br>        System.out.println(<span class="hljs-string">&quot;4的平方根值&quot;</span> + Math.sqrt(<span class="hljs-number">4</span>));<br>        System.out.println(<span class="hljs-string">&quot;8的立方根值&quot;</span> + Math.cbrt(<span class="hljs-number">8</span>));<br>        System.out.println(<span class="hljs-string">&quot;2的2次方值&quot;</span> + Math.pow(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>取整函数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Math类里的取整函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">ceil</span><span class="hljs-params">( <span class="hljs-keyword">double</span> a)</span></span>;<span class="hljs-comment">//向上取整</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">floor</span><span class="hljs-params">( <span class="hljs-keyword">double</span> a)</span></span>;<span class="hljs-comment">//向下取整</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rint</span><span class="hljs-params">( <span class="hljs-keyword">double</span> a)</span></span>;<span class="hljs-comment">//返回和参数最接近的整数，如果同样接近，则结果取整数</span><br></code></pre></td></tr></table></figure><ol start="4"><li>取最大值，最小值，绝对值函数方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;4和8较大者&quot;</span>+Math.max(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>));<br>   System.out.println(<span class="hljs-string">&quot;4.4和4较小者&quot;</span>+Math.min(<span class="hljs-number">4.4</span>,<span class="hljs-number">4</span>));<br>   System.out.println(<span class="hljs-string">&quot;-7的绝对值&quot;</span>+Math.abs(-<span class="hljs-number">7</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Random类">3) Random类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">randomdemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Random r = <span class="hljs-keyword">new</span> Random();<span class="hljs-comment">//实例化一个random</span><br>        <span class="hljs-comment">//随机产生一个整数s</span><br>        System.out.println(<span class="hljs-string">&quot;随机产生一个整数&quot;</span>+r.nextInt());<br>        <span class="hljs-comment">//随机产生一个大于等于0且小于10的整数</span><br>        System.out.println(<span class="hljs-string">&quot;随机产生一个大于等于0且小于10的整数&quot;</span>+r.nextInt(<span class="hljs-number">10</span>));<br>        System.out.println(<span class="hljs-string">&quot;随机产生布尔型的值&quot;</span>+r.nextBoolean());<br>        System.out.println(<span class="hljs-string">&quot;随机产生一个双精度型的的值&quot;</span>+r.nextDouble());<br>        System.out.println(<span class="hljs-string">&quot;随机产生一个浮点型的的值&quot;</span>+r.nextFloat());<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-大数字计算类">4) 大数字计算类</h2><h3 id="1-BigInteger">1. BigInteger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigIntegerdemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BigInteger big = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//实例化一个大数据</span><br>        <span class="hljs-comment">//取该数据加2的操作</span><br>        System.out.println(<span class="hljs-string">&quot;加法操作&quot;</span>+ big.add(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;2&quot;</span>)));<br>        System.out.println(<span class="hljs-string">&quot;减法操作&quot;</span>+ big.subtract(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;2&quot;</span>)));<br>        System.out.println(<span class="hljs-string">&quot;乘法操作&quot;</span>+ big.multiply(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;2&quot;</span>)));<br>        System.out.println(<span class="hljs-string">&quot;除法操作&quot;</span>+ big.divide(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&quot;2&quot;</span>)));<br>        System.out.println(<span class="hljs-string">&quot;乘方操作&quot;</span>+ big.pow(<span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;取相反数操作&quot;</span>+ big.negate());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-BigDecimal">2. BigDecimal</h3><p>与BigInteger不同的是，BigDecimal可以进行小数的计算，包括float和double，值得注意的是，这个的加法减法等方法需要自己去定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有两种构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BigDecimal</span><span class="hljs-params">(<span class="hljs-keyword">double</span> val)</span></span>;<span class="hljs-comment">//将double变为大数类型</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BigDecimal</span><span class="hljs-params">(String val)</span></span>;<span class="hljs-comment">//将字符串变为大数类型</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDecimalDemo</span> </span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>            BigDecimalDemo  big = <span class="hljs-keyword">new</span> BigDecimalDemo();<br>            System.out.println(<span class="hljs-string">&quot;两数相加的结果&quot;</span>+big.add(<span class="hljs-number">7.5</span>,<span class="hljs-number">8.9</span>));<br>        &#125;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value1, <span class="hljs-keyword">double</span> value2)</span></span>&#123;<span class="hljs-comment">//加法</span><br>            BigDecimal b1 = <span class="hljs-keyword">new</span> BigDecimal(Double.toString(value1));<span class="hljs-comment">//这里直接填value1也可以</span><br>            BigDecimal b2 = <span class="hljs-keyword">new</span> BigDecimal(Double.toString(value2));<br>            <span class="hljs-keyword">return</span> b1.add(b2);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1>二、集合</h1><p>集合的索引也是从0开始</p><h2 id="1）Collection接口">1）Collection接口</h2><p>Collection是根接口,一般不直接使用,后面的list接口和Set接口都继承了Collection接口,因此是通用的;而遍历集合一般都是通过迭代器实现;这里给出一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util*<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Muster</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>       Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>       Iterator&lt;String&gt; it = list.iterator();<span class="hljs-comment">//迭代器是集合的一种方法</span><br>       <span class="hljs-keyword">while</span>(it.hasNext())&#123;<span class="hljs-comment">//这个判断一定要记得,不然会抛异常</span><br>          String str = it.next();<br>          System.out.println(str);<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外,collection中主要有以下方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>add(E e)</td><td>添加指定对象</td></tr><tr><td>remove(Object o)</td><td>将指定对象移除</td></tr><tr><td>isEmpty</td><td>判断是否为空</td></tr><tr><td>itertor()</td><td>迭代器</td></tr><tr><td>size()</td><td>获取元素个数</td></tr></tbody></table><h2 id="2）List集合">2）List集合</h2><p>List中主要包含了两种实现类，即ArrayList和LinkedList，他们的主要区别就是，List中类似数组存储，而LinkedList则是使用链表存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实例化</span><br>List&lt;E&gt;  list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;E&gt;  list2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br></code></pre></td></tr></table></figure><p>List集合继承了collection接口，有他的所有方法，并且多了两个方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>get(int index)</td><td>获取指定那个位置的集合元素</td></tr><tr><td>set(int index,Object obj)</td><td>顾名思义就是设置元素的</td></tr></tbody></table><p>来个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListdemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        list.remove(<span class="hljs-number">2</span>);<span class="hljs-comment">//移除指定位置的集合元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(list.get(i));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3）Set集合">3）Set集合</h2><p>Set继承了Collection接口；Set集合对象不按特定的顺序排序，只是简单的加入数据，但是Set集合中不能包含重复的对象，常用的实现类有HashSet类和TreeSet类</p><h3 id="1-HashSet实现类">1. HashSet实现类</h3><p>数据结构：JDK1.8之前：哈希表（数组+单向链表）；JDK1.8之后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p>特点：查询快，元素无序，元素不可重复，没有索引；</p><p>底层分析：哈希表底层用数组+单向链表实现，即使用链表处理冲突，同一Hash值的元素都存储在一个链表里，但是当位于一个链表中的元素较多，即Hash值相等的元素较多，通过key值依次查找的效率降低。JDK1.8之后，哈希表底层采用数据+单向链表+红黑树实现，当链表长度超过阈值（8）时，链表将转换为红黑树，极大缩短查询时间。</p><h3 id="2-TreeSet实现类">2. TreeSet实现类</h3><p>数据结构：红黑树</p><p>特点：查询快，元素有序，元素不可重复，没有索引；</p><p>底层分析：TreeSet实现了继承于Set接口的SortedSet接口 ，它支持两种排序方法，自然排序和定制排序，自然排序的意思就是放入元素“a”，“b”，a会自然地排在b前面，其中还有几个特有方法。</p><p>first() 返回第一个元素； last() 返回最后一个元素；comparator() 返回排序比较器；</p><blockquote><p>引用自<a href="https://blog.csdn.net/weixin_42559574/article/details/108203595?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163110337616780255269862%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163110337616780255269862&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108203595.first_rank_v2_pc_rank_v29&amp;utm_term=Java%E9%9B%86%E5%90%88%E7%B1%BB&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_42559574/article/details/108203595?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163110337616780255269862%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163110337616780255269862&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108203595.first_rank_v2_pc_rank_v29&amp;utm_term=Java集合类&amp;spm=1018.2226.3001.4187</a></p></blockquote><h2 id="3）Map集合">3）Map集合</h2><p>Map没有继承collection类，它提供的是key到value的映射，Map中不能包含相同的key,每个key只能映射一个value；其实key就相当于下标。</p><h3 id="1-Map接口">1. Map接口</h3><p>其包含的主要方法</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>put(K key,V value)</td><td>添加指定的key到value的映射关系</td></tr><tr><td>containKey(Object key)</td><td>如果包含指定key的映射关系，则返回true</td></tr><tr><td>containsValue(Object value)</td><td>如果包含指定key的映射关系，则返回true</td></tr><tr><td>get(Object key)</td><td>如果存在指定的key对象，则返回对应的value值，否则返回null</td></tr><tr><td>keySet()</td><td>返回所有的key的值形成的Set集合</td></tr><tr><td>values()</td><td>返回所有的value的值形成的Collection集合</td></tr></tbody></table><h3 id="2-Map接口实现的类">2. Map接口实现的类</h3><p>主要有HashMap和TreeMap，建议使用HashMap，因为效率更高，而TreeMap有一定的顺序，若希望Map集合里的对象也有一定的顺序，则使用TreeMap实现Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实例化</span><br><span class="hljs-comment">//HashMap</span><br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br></code></pre></td></tr></table></figure><h1>三、 枚举类型</h1><h2 id="1）枚举类的使用">1）枚举类的使用</h2><ol><li>枚举类的理解:类的对象只有有限个,确定的,就为枚举类</li><li>当需要定义一组常量时,强烈建议使用枚举类</li><li>如果枚举类中只有一个对象,则可以作为单例模式的实现方式</li></ol><h2 id="2）使用enum类型来定义常量">2）使用enum类型来定义常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">con</span></span>&#123;<br>       con_A,<br>       con_B,<br>       con_C<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-枚举类的常用方法">3)枚举类的常用方法</h2><table><thead><tr><th>方法名称</th><th>作用</th><th>使用方法</th></tr></thead><tbody><tr><td>values()</td><td>将枚举类型的成员以数组的形式返回(也可以通过该方法获取枚举类类型的成员)</td><td>枚举类型名称.values()</td></tr><tr><td>valuesOf()</td><td>将普通字符串转换为枚举实例</td><td>枚举类型名称.valueOf(“abc”)</td></tr><tr><td>compareTo()</td><td>比较两个枚举对象在定义时的顺序(正值表示在参数在调用该方法的枚举对象之前,负值则是之后)</td><td>枚举对象.compareTo()</td></tr><tr><td>ordinal</td><td>得到枚举成员的位置索引</td><td>枚举对象.ordinal()</td></tr></tbody></table><p><strong>构造函数</strong>在写枚举类构造方法的时候权限修饰符应该为private;</p><h1>四、泛型</h1><h2 id="1）初识泛型">1）初识泛型</h2><p>把元素的类型设计成一个参数,这个参数就是泛型</p><p><strong>如果集合不使用泛型</strong><br><img src="https://img-blog.csdnimg.cn/68c0d9e5ae994fa7b6fe68aac9d031b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>就会出现种种问题</p><p><strong>使用泛型</strong><br><img src="https://img-blog.csdnimg.cn/be934e7a5d4742d2b5ed5dd00c6a31b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>问题迎刃而解</p><p>然后输出(这里复习一下增强for循环和迭代器)<br>问题迎刃而解</p><p>然后输出(这里复习一下增强for循环和迭代器)<br><img src="https://img-blog.csdnimg.cn/9329474c0533440ebf115928046fc335.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><strong>注意点</strong>:集合中&lt;&gt;中填泛型时不能时基本数据类型(比如int),必须是一个类,例如是int需要填包装类Integer</p><h2 id="2）自定义泛型">2）自定义泛型</h2><h3 id="1、泛型类">1、泛型类</h3><p>这里的T相当于一个参数，就当成其他的数据类型一样用<br><img src="https://img-blog.csdnimg.cn/7aa9143c908c48df8647741b1ce412f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/30e83d4922f74deca89cbb8531a87716.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>     <span class="hljs-comment">//如果定义了泛型类，实例化没有指明类的泛型，则认为泛型类型为Object类型</span><br>     <span class="hljs-comment">//要求：如果大家定义了类是带泛型的建议在实例化要指明类的泛型</span><br>     Order order = <span class="hljs-keyword">new</span> Order();<br>     order.setOrderT(<span class="hljs-number">123</span>);<br>     order.setOrderT(<span class="hljs-string">&quot;ABC&quot;</span>);<br>     <span class="hljs-comment">//建议：实例化时指明类的泛型</span><br>     Order&lt;String&gt; order1 = <span class="hljs-keyword">new</span> Order&lt;String&gt;(<span class="hljs-string">&quot;orderAA&quot;</span>)<span class="hljs-comment">//这里有一个构造方法传参，String就是传入类的泛型参数</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果子类在继承带泛型的父类的时候,指明了泛型的类型,则在实例化子类的对象时,不再需要指明泛型</p></li><li><p>静态方法中不能使用泛型</p></li><li><p>异常类不能是泛型类</p></li></ul><h3 id="3）泛型方法">3）泛型方法</h3><p>泛型方法里的泛型参数和泛型类里的泛型参数是没有关系的<br><img src="https://img-blog.csdnimg.cn/d15474f7b5604bd8bb23536964387233.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>上图中因为返回的时List类型的所以还有个List，特别注意标明是泛型方法要有个 &lt; E &gt;<img src="https://img-blog.csdnimg.cn/3ef22290e2d44c9db78b22e335c3d510.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>测试泛型方法</strong><br><img src="https://img-blog.csdnimg.cn/2747ac3308cf487eb0c795e61012ea5d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>泛型方法是可以声明为静态的.原因就是:泛型参数实在调用方法时确定的,并非是在实例化类时确定的</p><h3 id="4）通配符的使用">4）通配符的使用</h3><p><strong>通配符  :   ?</strong><br><img src="https://img-blog.csdnimg.cn/b0914c990d874f71830b8d65c2ed2283.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;<br>   Iterator&lt;?&gt; iterator = list.iterator();<br>   <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>    Object obj = iterator.next;<span class="hljs-comment">//这里当然不能用 ? obj 声明啦</span><br>    System.out.println(obj);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有限制条件的通配符的使用</strong></p><ul><li><p>? extends Person 向下限制,只接受Person类以下的类型</p></li><li><p>? super Person  向下限制,只接受Person类以上的类型</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实例</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(A&lt;? extends List&gt; a)</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//实例</span><br>List&lt;? extends list&gt; list = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c2713d96c08b43d4b74dd41f1960c987.png" alt=""><br>比如在这里 list1 = list5 就会报错</p><h1>五、注解</h1><h2 id="1）初识注解">1）初识注解</h2><p><img src="https://img-blog.csdnimg.cn/8ce3962f19fd425b8075e969920cd5dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/7cfd5e06f6424f8798a66e4eddf0ce04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="2）元注解">2）元注解</h2><p>元注解主要是在定义自定义的注解的时候用<br><img src="https://img-blog.csdnimg.cn/974730ee77f84a9d829754eb1cbede15.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="3）自定义注解">3）自定义注解</h2><p><img src="https://img-blog.csdnimg.cn/6b639f21f7bb494e8b6f55d6dea107d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/175034b2819743e980885c25ef169f22.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span></span>&#123;<br>   <span class="hljs-comment">//注解可以显示赋值，如果没有默认值，我们就必须给注解赋值</span><br>   <span class="hljs-meta">@MyAnnotation2(age = 18,name = &quot;陈帅&quot;)</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>   <span class="hljs-meta">@Target(&#123;Element.TYPE,Elementtype.NETHOD&#125;)</span><br>   <span class="hljs-meta">@Retention(RetenionPolicy.RUNTIME)</span><br>   <span class="hljs-meta">@interface</span> MyAnnotation2&#123;<br>   <span class="hljs-comment">//注解的参数： 参数类型 + 参数名();</span><br>   <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<span class="hljs-comment">//这里设置默认值为空，这样就不用传参了</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1 </span>;<span class="hljs-comment">//设置默认值为-1</span><br>   String[] <span class="hljs-function">schools <span class="hljs-title">default</span><span class="hljs-params">(<span class="hljs-string">&quot;西柚牛逼&quot;</span>,<span class="hljs-string">&quot;Mercury最帅&quot;</span>)</span></span>;    <br>   &#125;<br>  <span class="hljs-meta">@Target(&#123;Element.TYPE,Elementtype.NETHOD&#125;)</span><br>  <span class="hljs-meta">@Retention(RetenionPolicy.RUNTIME)</span><br>  <span class="hljs-meta">@interface</span> MyAnnotation3&#123;<br>  <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>如果有default即有默认值,可以不用赋值</strong></p><h1>六、反射</h1><h2 id="1-关于静态语言和动态语言">1)关于静态语言和动态语言</h2><p><img src="https://img-blog.csdnimg.cn/06b582dc6b7c4367a9c8ea7e61107469.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="2-初识反射">2)初识反射</h2><p><img src="https://img-blog.csdnimg.cn/625231f3ad644f35bbb7545c494424f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/0033de28da924e1097c0248f28883f2f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//什么反射</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>     <span class="hljs-comment">//通过反射获取类的Test的对象</span><br>     Class c1 = class.forName(<span class="hljs-string">&quot;com.kuang.reflection.User&quot;</span>);<span class="hljs-comment">//User在这个位置</span><br>     System.out.println(c1);<br><br>     Class c2 = class.forName(<span class="hljs-string">&quot;com.kuang.reflection.User&quot;</span>);<br>     Class c3 = class.forName(<span class="hljs-string">&quot;com.kuang.reflection.User&quot;</span>);<br>     Class c4 = class.forName(<span class="hljs-string">&quot;com.kuang.reflection.User&quot;</span>);<br>     <br>     <span class="hljs-comment">//一个类在内存中只有一个class类</span><br>     <span class="hljs-comment">//一个类被加载后，类的整个结构都会被封装在class对象中</span><br>      System.out.println(c2.hashcode()); <br>      System.out.println(c3.hashcode()); <br>      System.out.println(c4.hashcode());<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;...&#125;<span class="hljs-comment">//在这里就不详细列出来了</span><br></code></pre></td></tr></table></figure><h2 id="3-获取class的实例">3)获取class的实例</h2><p><img src="https://img-blog.csdnimg.cn/a57496e982f844cdac40a6601605fbbb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>实操获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundExcepion</span>&#123;<br>    Person person = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(<span class="hljs-string">&quot;这个人是&quot;</span> + person.name);<br>    <br>    <span class="hljs-comment">//方式一：通过对象获取</span><br>    Class c1 = person.getClass();<br>    System.out.println(c1.hashcode());<br><br>    <span class="hljs-comment">//方式二：forname获取</span><br>    Class c2 = Class.forname(<span class="hljs-string">&quot;com.reflection.Student&quot;</span>)<br>    System.out.println(c2.hashcode());<br>    <br>    <span class="hljs-comment">//方式三：通过类名.class获得</span><br>    Class c3 = Student.class;<br>    System.out.println(c3.hashcode());<br><br>  &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;...&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h2 id="4-关于类加载器">4)关于类加载器</h2><p><img src="https://img-blog.csdnimg.cn/d8f4ce0e5fc74b6d88bf26853d0f0b27.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得类的信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c1</span> </span>= Class.forname(<span class="hljs-string">&quot;com.kuang.reflection.User&quot;</span>);<br>     User user = <span class="hljs-keyword">new</span> user();<br>     c1 = user.getclass();<br><br>     <span class="hljs-comment">//获取类的名字</span><br>     System.out.println(c1.getName);<span class="hljs-comment">//获取类名 +  包名</span><br>     System.out.println(c1.getSimpleName());<span class="hljs-comment">//获取类名</span><br><br>     <span class="hljs-comment">//获得类的属性</span><br>     Field[] fields = c1.getFields();<span class="hljs-comment">//只能找到public属性的</span><br><br>     fields = c1.getDeclaredFields();<br>     <span class="hljs-keyword">for</span>(Field field : fields)&#123;<br>       System.out.println(field);<br>      <br>     &#125;<br>    <br>     <span class="hljs-comment">//获得类的方法</span><br>     Method[] methods = c1.getMethods();<br>     <span class="hljs-keyword">for</span>(Method method : methods)&#123;<br>       System.out.println(<span class="hljs-string">&quot;正常的&quot;</span>+method);<br>     &#125;<br>    methods = c1.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span>(Method method : method)&#123;<br>       System,out.println(<span class="hljs-string">&quot;getDeclaredMethods&quot;</span>+method);<br>    &#125;<br>    <br>    <span class="hljs-comment">//获取指定方法</span><br>    Method getName = c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>,<span class="hljs-keyword">null</span>);<span class="hljs-comment">//获取getName这个方法  getname方法没有参数</span><br>    Method setName = c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>,String.class);<br>    <span class="hljs-comment">//这里要丢一下参数,编译器才知道你要什么方法   </span><br>    <span class="hljs-comment">//这里是调用setname的String重载，所以要丢一个String.class进去</span><br>    System.out.println(getName);<br>    System.out.println(setName);<br>   &#125;<br><br>   <span class="hljs-comment">//获得指定构造器</span><br>   Constructor[] constructors = c1.getConstructors();<br>   <span class="hljs-keyword">for</span>(Constructor constructor : constructors)&#123;<br>      System.out.println(constructors);<br>   &#125;<br>&#125;<br><br>  <span class="hljs-comment">//获得指定的构造器</span><br>  Constructor declaredConstructor = c1.getDeclaredConstructor(String.class,<span class="hljs-keyword">int</span>.class,<span class="hljs-keyword">int</span>.class);<br>  System.out.println(declaredConstructor);<br></code></pre></td></tr></table></figure><h2 id="5-通过反射创建对象">5)通过反射创建对象</h2><p><img src="https://img-blog.csdnimg.cn/4c7927bffcfe4a9e84f24b8e22f8f998.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException,IllegalAccessException</span>&#123;<br> <span class="hljs-comment">//获取class对象</span><br> Class c1 = Class.forname(<span class="hljs-string">&quot;com.reflection,User&quot;</span>);<br><br> <span class="hljs-comment">//1.普通创建一个对象</span><br> User user = (user)c1.newInstance(); <span class="hljs-comment">//本质是调用了类的无参构造</span><br> System.out.println(user);<br> <br>  <span class="hljs-comment">//2.获得指定的构造器创建对象</span><br>  Constructor declaredConstructor = c1.getDeclaredConstructor(String.class,<span class="hljs-keyword">int</span>.class,<span class="hljs-keyword">int</span>.class);<br>  User user2 = (user)constructor.newInstance(<span class="hljs-string">&quot;陈帅&quot;</span>,<span class="hljs-number">001</span>,<span class="hljs-number">18</span>);  <span class="hljs-comment">//有参构造</span><br>  System.out.println(user2);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5d3aa1cba3ef405e958d7c9bd4eafbcf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">User user3 = (User)c1.newInstance();<br><span class="hljs-comment">//通过反射获取一个方法</span><br>Method setName = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>,String.class);<br><br><span class="hljs-comment">//invoke:激活</span><br><span class="hljs-comment">//（对象，“方法的值”）</span><br>setName.invoke(user3,<span class="hljs-string">&quot;陈帅&quot;</span>);<br>System.out.println(user3.getName());<br><br><span class="hljs-comment">//通过反射操作属性</span><br>User user4 = (User)c1.newInstance();<br>Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">//不要直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true);</span><br>name.setAccessible(<span class="hljs-keyword">true</span>);<br>name.set(user4,<span class="hljs-string">&quot;陈帅牛逼&quot;</span>);<br>System.out.println(user4.getName());<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1ad8e2dc852c4965ae86e77984186978.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>实操</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xingneng</span> </span>&#123;<br>    <span class="hljs-comment">//普通方法调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        user user = <span class="hljs-keyword">new</span> user();<br>        <span class="hljs-keyword">long</span> starTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            user.getName();<br>        &#125;<br>        <span class="hljs-keyword">long</span> endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通方法执行10次&quot;</span>+(endtime-starTime)+ <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反射方法调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        user user = <span class="hljs-keyword">new</span> user();<br>        Class c1 = user.getClass();<br>        Method getName = c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">long</span> starTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>           getName.invoke(user,<span class="hljs-keyword">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射方法执行10次&quot;</span>+(endtime-starTime)+ <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反射方法调用 关闭检测</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        user user = <span class="hljs-keyword">new</span> user();<br>        Class c1 = user.getClass();<br>        Method getName = c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        getName.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">long</span> starTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user,<span class="hljs-keyword">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射方法执行10次&quot;</span>+(endtime-starTime)+ <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, NoSuchMethodException, IllegalAccessException </span>&#123;<br>        test();<br>        test2();<br>        test3();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>程序运行结果<br><img src="https://img-blog.csdnimg.cn/50f06659bbd349dbbbfa73f39a525f7f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_14,color_FFFFFF,t_70,g_se,x_16" alt=""><br>所以关闭检测可以提升程序的效率</p><h2 id="6-反射操作泛型">6)反射操作泛型</h2><p><img src="https://img-blog.csdnimg.cn/545334e3e7e44e99aeaac2040441c4d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/52490f31242f4386affa12a5482e9212.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="7-反射操作注解">7)反射操作注解</h2><p>getAnnotations</p><p>getAnnotation</p><p><img src="https://img-blog.csdnimg.cn/bc10279420594b3c8d16b919d3ca2f71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>七、多线程</h1><h2 id="1、实现多线程">1、实现多线程</h2><p>多线程在我目前开发中用的不算多，这里知识简单的梳理一下多线程的知识点。<br>实现多线程的方法在Java中有两种，一种是继承thread类，还有一种方法就是重写runable方法</p><h3 id="1-、继承thread类">1)、继承thread类</h3><p>这种方法就是写一个类来继承thread类，在这个类中还需要写一个run方法来运行这个线程，然后在主类中就可以创建这个线程然后启动该线程。以代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-comment">//创建一个类继承thread类</span><br><span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread1</span><span class="hljs-params">(String name)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//需要在该线程里面执行的方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行  :  &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>       <br>&#125;<br>&#125;<br><br><span class="hljs-comment">//主类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Thread1 mTh1=<span class="hljs-keyword">new</span> Thread1(<span class="hljs-string">&quot;A&quot;</span>);<span class="hljs-comment">//创建一个线程的对象</span><br>Thread1 mTh2=<span class="hljs-keyword">new</span> Thread1(<span class="hljs-string">&quot;B&quot;</span>);<br>mTh1.start();<span class="hljs-comment">//启动该线程</span><br>mTh2.start();<br> <br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>在线程运行的时候，需要注意下：两个线程启动时，在处理机上是并发运行的，因此线程输出的顺序并不确定。(所以在做PTA上面的题可能多提交几遍说不定就可以了。)</p><h3 id="2-重写Runable接口">2) 重写Runable接口</h3><p>具体需要子类实现Runable接口，然后重写里面的run方法就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-comment">//继承</span><br><span class="hljs-keyword">private</span> String name;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread2</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name=name;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//重写run方法</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行  :  &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Thread2(<span class="hljs-string">&quot;C&quot;</span>)).start();<span class="hljs-comment">//在主类中创建这个线程并且启动</span><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Thread2(<span class="hljs-string">&quot;D&quot;</span>)).start();<br>&#125;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><p>线程有好几种状态，如: 阻塞状态，准备状态等等，这一部分的内容以及关于线程的调度问题具体请参照操作系统部分</p><h2 id="2、多线程常用的函数">2、多线程常用的函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">start() 函数<br><br><span class="hljs-comment">//主要应用于在主类中启动该线程。(需要先new 一个多线程的对象。</span><br><br>sleep()函数<br><br><span class="hljs-comment">//sleep(long millils)  在指定的毫秒数内让线程休眠</span><br><br>join()函数<br><br><span class="hljs-comment">//等待该线程的终止</span><br><br>yield()函数<br><br><span class="hljs-comment">//暂停当前正在执行的线程对象，让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会</span><br><br>setPriority()函数<br><br><span class="hljs-comment">//更改线程的优先级</span><br><br>interrupt()函数<br><br>向线程发出一个中断信号，让线程在无限等待的时候能够抛出，从而结束线程(并不是中断哪个线程)<br><br>wait()函数<br><br><span class="hljs-comment">//Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,</span><br><span class="hljs-comment">//与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj)&#123;...&#125;语句块内。</span><br></code></pre></td></tr></table></figure><h2 id="3、线程同步">3、线程同步</h2><h3 id="1）、synchronized关键字">1）、synchronized关键字</h3><ul><li>synchronized关键字的作用域有二种：</li></ul><ol><li>是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；</li><li>是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</li></ol><ul><li><p>除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；</p></li><li><p>synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；</p></li></ul><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><h1>异常</h1><h1>自动装箱机制</h1><h1>深拷贝 浅拷贝 引用拷贝</h1><h1>I/O</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE</title>
    <link href="/2021/09/01/JavaSE/"/>
    <url>/2021/09/01/JavaSE/</url>
    
    <content type="html"><![CDATA[<h1>Java基础</h1><h2 id="标识符和关键字">标识符和关键字</h2><ul><li>Java所有的组成部分都需要有名字，类名，变量名以及方法名都被称为标识符 ，所有的标识符都应该以英文字母(a-z,A-Z)，美元符($)，或者下划线(_)开头</li><li>首字母之后可以是字母，美元符下划线或数字的任何字符组合</li><li>不能使用关键字作为标识符</li><li>标识符是大小写敏感的</li><li>可用使用中文命名，但是不建议</li></ul><p>下面的标识符是合法的：<br>myName，My_name，Points，$points,_sys_ta，OK，_23b，<em>3</em><br>下面的标识符是非法的：<br>#name，25name，class，&amp;time，if</p><p>Java 9规定：不允许单独使用下划线作为分隔符。<br>Java 的关键字加上goto const true false nulll 一共有53个关键字和保留字，都不能作为Java的标识符。</p><h2 id="Java数据的类型">Java数据的类型</h2><ul><li>基本类型</li><li>引用类型<br><img src="https://img-blog.csdnimg.cn/e6e35e613e2041c69ac93c8df2bc1dc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>注意</strong></li><li>其中float需要float需要这样来声明 float  = 0.1f;float是有限,离散,舍入误差,大约,接近但不等于,因此最好不要用浮点数进行 == 这样的确定是否相等的操作,会有精度的损失,可以采用BigDecimal数学工具类;</li><li>String是引用类型,不是基本类型;</li><li>Java和C不同的是,Java采用Unicode编码,范围是 0-65536;</li><li>布尔类型的初始值为false</li><li>在C语言中，char类型占一个字节，在Java中char类型占2个字节。</li><li>比较字符串时最好使用str.equal()方法进行比较</li></ul><hr><p>注意点<br><img src="https://img-blog.csdnimg.cn/4e8976c0dc134f598ed04186955c3669.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>上图中,false的原因是因为两个字符串在不同的对象中,因此为false,而后一个没有对象,在同一片内存中,因此为true;</p><h2 id="类型转换">类型转换</h2><p>类型转换主要有两种类型转换<br><img src="https://img-blog.csdnimg.cn/310a5a405c97449bbadc22e2ed9d0fc1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>byte只有128位<br>数字间是可以用下划线间隔的,更加方便阅读数字<br><img src="https://img-blog.csdnimg.cn/fead415a853c4ff384b1f8b560ce3574.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="变量">变量</h2><p><img src="https://img-blog.csdnimg.cn/ec452ab51a1f44ddb7c76d484481c458.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>分为实例变量和局部变量</p><ul><li>局部变量直接就可以使用</li><li>实例变量必须通过对象来调用</li><li>加上了static即成为了类变量,跟类一起出现消失,可以直接通过类调用</li></ul><h2 id="常量">常量</h2><p><img src="https://img-blog.csdnimg.cn/08bcf1b5227e4011bbb720bbb034b62c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="运算符">运算符</h2><p><img src="https://img-blog.csdnimg.cn/068a9c341f5e41c7ab75719f26837d7f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>尤其应该注意一下位运算<br>&lt;&lt; 左移一位即 原数*2    ;   左移三位即原数 *2 *2 *2  是次方的关系<br>&lt;&lt; 右移则同理<br><img src="https://img-blog.csdnimg.cn/db8bdfbbb68641eb80bfef61ba8e8929.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><blockquote><p>插入一个idea的快捷键<br>ctrl+D 复制当前行到下一行</p></blockquote><h2 id="关于注释时的参数">关于注释时的参数</h2><ul><li>@author 作者名</li><li>@version 版本号</li><li>@since 指明需要最早的jdk版本</li><li>@param 参数名</li><li>@return 返回值情况</li><li>@异常抛出情况</li></ul><h2 id="输入">输入</h2><p>Java使用Scanner对象进行输入操作<br><img src="https://img-blog.csdnimg.cn/df7cc3e3a47f4176b0bd9d2fe390af13.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span></span>&#123;<br>   <span class="hljs-comment">//创建一个扫描器对象,用于接收键盘数据</span><br>   Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>   System.out.println(<span class="hljs-string">&quot;使用next方式接收:&quot;</span>);<br>   <span class="hljs-comment">//判断用户有没有输入信息,这个在这里没有必要,主要是后面的循环部分用得比较多</span><br>   <span class="hljs-keyword">if</span>(Scanner.hasNext())&#123;<br>   <span class="hljs-comment">//使用next方式进行接收</span><br>     String str = Scanner.next();<span class="hljs-comment">//String str = Scanner.nextLine();</span><br>     System.out.println(<span class="hljs-string">&quot;输出的内容为:&quot;</span>+str);<br>   &#125;<br>   <span class="hljs-comment">//养成好习惯,用完后关闭scanner;</span><br>   scanner.close();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于next()和nextLine()</strong><br>next()会以空格结束,而nextLine()以enter结束,所以可以输入带空格的字符串</p><p>输入单个字符 <strong>char c = sc.next().charAt(0);</strong></p><h2 id="增强for循环">增强for循环</h2><p>增强for循环主要用于输出,因为它没有下表,不方便操作数据<br><img src="https://img-blog.csdnimg.cn/18b541fcfaf641dfac52a9af7fbe3f9d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x:nums)&#123;<br>    System.out.println(x);<br>&#125;<span class="hljs-comment">//这里x表示循环时的数据名称类似i ; nums则是循环的数组名称</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ants:nums[])&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x:ants)&#123;<br>       System.out.println(x);<br>  &#125;<br>&#125;<span class="hljs-comment">//输出二维数组</span><br></code></pre></td></tr></table></figure><h1>方法</h1><p><img src="https://img-blog.csdnimg.cn/981d419a11ca40be9f167b58e742a04d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="重载">重载</h2><p>熟记重载的规则<br><img src="https://img-blog.csdnimg.cn/7c0525834acb4ebdae262068b8c2f14e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="可变参数">可变参数</h2><p><img src="https://img-blog.csdnimg.cn/d36134a7fce94940a6e7484f6812071b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>可变参数的使用<br><img src="https://img-blog.csdnimg.cn/92dccd58cfea49fcaec42f24b9ed7ab2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>其实本质就是数组</strong></p><h1>数组</h1><p>数组和C语言类似，就是声明时有所不同<br><img src="https://img-blog.csdnimg.cn/e135da64d534496189b136dc877ce460.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><strong>Java的内存</strong><br><img src="https://img-blog.csdnimg.cn/2bf98bda1fa84718a7fa2e8c5c52c58b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="数组三种初始化">数组三种初始化</h2><p>即有</p><ol><li>静态初始化</li><li>动态初始化</li><li>隐式初始化<br><img src="https://img-blog.csdnimg.cn/c6773a201d4b4212b8d865274f606f0c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><p><strong>特殊点:</strong> 布尔型的初始为false;</p><p>Java里数组可以通过　<strong>shuzuname.length</strong>　来直接获得长度;</p><h2 id="多维数组">多维数组</h2><p>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>多维数组的其他部分皆于C语言相同,此处不再赘述;</p><h2 id="Arrays类">Arrays类</h2><p><img src="https://img-blog.csdnimg.cn/a6010c745ca744d0bc6874a948705d73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>toString()方法</strong><br><img src="https://img-blog.csdnimg.cn/e27eb4f46d3a444c9e8e04ce1c25d228.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>.sort() 排序方法</strong>  默认为升序;<br><strong>.fill() 填充方法</strong>  参数可以填(数组名,起始点,终止点,待填充的数字) 若不填起始点,终止点则会全部填充</p><h1>面向对象</h1><p><img src="https://img-blog.csdnimg.cn/82a710aae75e4e44aae79715fd167d5d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><strong>本质:以类的方式组织代码,以对象的组织(封装)数据</strong></p><p><strong>三大特性</strong></p><ol><li><p>封装</p></li><li><p>继承</p></li><li><p>多态</p></li></ol><hr><h2 id="类和对象">类和对象</h2><p>emmm…这部分没啥写的</p><blockquote><p>关于静态方法:   静态方法可以直接调用,非静态方法必须将类实例化后才能通过对象调用此方法</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6630c03d3dcf4c8482727a2ba2ea9f3e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><strong>引用传递</strong></p><p>即传参时传递一个对象 相当于指针,在方法中是<strong>可以改变参数</strong>的</p><p><strong>构造器</strong><br>默认有一个无参的,在new对象时就是调用,自己写了有参的之后需要把无参的构造方法加上,不然会损失无参构造.</p><h2 id="封装">封装</h2><p>只需要记住.属性私有(private)<br>则需要getter和setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//getter方法</span><br>   <span class="hljs-keyword">this</span>.age = age;<br>   <span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<span class="hljs-comment">//setter方法</span><br>   <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果是private非静态属性依旧需要new一个对象才能访问</p><h2 id="继承">继承</h2><p><img src="https://img-blog.csdnimg.cn/80d57daec6f94eff9658fd79f8873682.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>java只有单继承:简单的理解 一个儿子一个爸爸,一个爸爸多个儿子</p><p><img src="https://img-blog.csdnimg.cn/bb4aee66deba42269bc802c2ab7b78d7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>所有的类都是继承了object类的</p><p>继承之后,子类可以<strong>直接调用</strong>父类的方法,即使是没有static</p><p><strong>私有</strong>的方法是无法被继承的，即通过super也调<strong>不</strong>了，如上图所示就会报错<br><img src="https://img-blog.csdnimg.cn/18ef23a4825a48ceb99cb2d7d7727d7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>在new子类的时候，也调用了父类的无参构造，在这里   super()；是隐藏代码<br><img src="https://img-blog.csdnimg.cn/146a1e925fa14bc98862a2072e698bfa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>父类的构造器必须在子类构造器的第一行，这里不写也没有关系，反正都是隐藏代码</p><p><strong>super的注意点</strong></p><ol><li>super调用父类的构造方法,必须在构造方法的第一位</li><li>super必须只能出现在子类的方法或者构造方法中</li><li>super和this不能同时调用构造方法</li></ol><p>和 this 比较</p><ol><li>代表的对象不同<br>this：本身调用者这个对象<br>super：代表父类对象的应用</li><li>前提<br>this没有继承也可以使用<br>super：只能在继承关系下才能使用</li><li>构造方法<br>this();本类构造<br>super();父类的构造；</li></ol><h2 id="多态">多态</h2><p><img src="https://img-blog.csdnimg.cn/71db29ee92db4294b98f8727b9740986.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>方法的重写<br>重写都是方法重写和属性无关<img src="https://img-blog.csdnimg.cn/3eb05644954848bc97909be10171bfcc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>如上图，static方法是无法被重写的，相当于两个方法，这时候能调什么方法都看左边是什么类型<br><img src="https://img-blog.csdnimg.cn/2fac47f4ae0c4cf38cd4e9b35e24995e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>重写后一般会有@override注释<br>并且重写只能是public方法，如果是私有方法，则会出现如上图所示的报错</p><p><strong>关于重写</strong></p><ol><li>需要有继承关系，子类重写父类的方法</li><li>方法名必须相同</li><li>修饰符：范围可以扩大但不能缩小 publci &gt; Protected &gt;defalt&gt;private</li><li>抛出的异常：范围可以被缩小，但不能扩大：ClassNotFoundException --&gt;Exception</li><li>子类的方法和父类必要一致，方法体不同</li></ol><hr><p><img src="https://img-blog.csdnimg.cn/3d28d93f36f946e08d935cf4008b29a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>对象能执行那种方法主要看左边是什么类型和右边关系不大 要想调用,可以强制转换<br><img src="https://img-blog.csdnimg.cn/71e545f92fbd4be7a58861efe169e3f5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>如上图：强制转换(上向下)就可以调用了<br><strong>多态注意事项</strong></p><ol><li>多态是方法的多态，属性没有多态</li><li>父类和子类，有联系  类型转换异常 ClassCastException</li><li>存在条件：继承关系，方法需要重写，父类引用指向子类对象 Father f1 = new Son();</li></ol><p><strong>不可以重写的</strong></p><ol><li>static 方法，属于类，它不属于实例</li><li>final常量</li><li>private方法</li></ol><p><strong>instanceof关键字</strong><img src="https://img-blog.csdnimg.cn/a6f01d41808f4acfb0ffd65b216736b9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>instanceof关键字就是用来判断子父类的关系的，值得注意的是再上图中Object是student new出来的所以在Teacher 那里依然是false</p><h2 id="static-详解">static 详解</h2><p><img src="https://img-blog.csdnimg.cn/ff85d48a42c74b50abfb3494f14c0f12.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>简单的来说就是</p><ul><li><p>非可以调静</p></li><li><p>静不可以调非</p></li><li><p>main函数也是静，所以不可以直接调用非静的方法</p></li></ul><p><strong>关于代码块</strong><br><img src="https://img-blog.csdnimg.cn/223115825d5b4e9c9a7143a3d536adcc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>以下顺序是代码执行的顺序</p><ol><li>静 只执行一次</li><li>匿名</li><li>构造方法<br>构造方法竟是最后执行的，令人震惊</li></ol><h2 id="抽象类">抽象类</h2><p><img src="https://img-blog.csdnimg.cn/4b9913a75b954ceab0ef0491ab30caaa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="接口">接口</h2><p><img src="https://img-blog.csdnimg.cn/2b6235ed0a4d488ba5afdf2ba6b9fe61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/356a0a672d6c48fdb4b011d88fd5b7fb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><ul><li><p>接口中的所有定义方法都是抽象的public abstract</p></li><li><p>在接口中常量都是public static final前缀</p></li><li><p>类可以实现接口implements</p></li><li><p>实现了接口中的类,就必须实现接口中的方法</p></li><li><p>接口可以实现多就继承</p></li></ul><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span>,<span class="hljs-title">TimService</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类">内部类</h2><p><img src="https://img-blog.csdnimg.cn/df88ae293d614273bd77ab0ad070bba2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>成员内部类</strong><br><img src="https://img-blog.csdnimg.cn/fa07bb0be2794fc483d400434cad34c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer.Inner inner = outer.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//实例化一个内部类</span><br></code></pre></td></tr></table></figure><p>内部类可以获得外部类的私有属性</p><p><img src="https://img-blog.csdnimg.cn/7e178dbc5da64c1c8d9b897ae802ac92.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>一个Java类中可以有多个class类，但是只能有一个public class类（这不叫内部类）</p><p><strong>静态内部类</strong><br><img src="https://img-blog.csdnimg.cn/0c95a4ee1e054ba6a7b2e4ba277b094a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><strong>局部内部类</strong><br><img src="https://img-blog.csdnimg.cn/2f7d902939434e20b89401cf3bde7d07.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><strong>匿名内部类</strong><br><img src="https://img-blog.csdnimg.cn/2479caca973045f7965e87f169bad1b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="异常">异常</h2><p><img src="https://img-blog.csdnimg.cn/d0f7aed9cd5c4aea973e67698d955aec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/aba73c6f1fd94cbe83399a5221723439.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/6b19ca19ea2b4820827131e1c6eb7911.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>最大就是throwable<img src="https://img-blog.csdnimg.cn/113158eeca0d4cafaee7d8e2c8126da0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/9b7ea35410fd4a63989454daaa6f61bb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/24853f5359e14a16a802aa39c865a8d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="局部内部类"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//try监控区域</span><br>          System.out.println(a/b);<br>       &#125;<span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>          System.out.println(<span class="hljs-string">&quot;程序出现异常，变量b不能为0&quot;</span>);<br>       &#125;<span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//处理善后工作</span><br>          System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>       &#125;<br>     <br>   &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>finally可以不要,一般用于处理关闭IO流的相关操作</p><p>idea快捷键 ctrl+alt+T    try catch包裹代码</p><p><img src="https://img-blog.csdnimg.cn/075d7c2d3c6b4345b3d2f9681b119693.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="自定义异常">自定义异常</h2><p><img src="https://img-blog.csdnimg.cn/c2d45eb5285f466ca34f706235da61d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/30e4c48cf1ba409499e470e9366ce709.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/180592be91c845729f47d99bc5dbaf4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/6ccf4da3daa34ba392ffe2c42475035c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>JavaSE结束，后面开始Java多线程和注解反射</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM</title>
    <link href="/2021/07/15/SSM/"/>
    <url>/2021/07/15/SSM/</url>
    
    <content type="html"><![CDATA[<p>(<strong>写在开头：本文主要依据黑马程序员SSM框架教程PPT资料编写</strong>)</p><h1>一、Spring</h1><h2 id="Spring的基本概念">Spring的基本概念</h2><p>loC  反转控制<br>AOP 面向切面编程</p><h2 id="Spring的快速入门">Spring的快速入门</h2><p><img src="https://img-blog.csdnimg.cn/20210715110221230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="spring的基本开发步骤">spring的基本开发步骤</h3><p>1.导入Spring开发的基本包坐标</p><p>2.编写Dao接口和实现类</p><p>3.创建Spring核心配置文件</p><p>4.在Spring配置文件中配置UserDaoImpl</p><p>5.使用Spring的API获得Bean实例</p><p> <strong>快速入门步骤</strong></p><p>1.导入坐标</p><p>2.创建Bean</p><p>3.创建applicationContext.xml</p><p>4.在配置文件中进行配置</p><p>5.创建ApplicationContext对象getBean</p><h2 id="Spring配置文件">Spring配置文件</h2><h3 id="Bean标签的配置">Bean标签的配置</h3><p> 用于配置对象交由Soring来创建默认的情况下他会调用类中的无参构造函数，如果没有无参构造则不能创建成功</p><h4 id="Bean标签的基本属性">Bean标签的基本属性</h4><p>id :Bean实例在Spring容器中的唯一标识<br>class:Bean的全限定名称</p><p> <strong>Bean标签的范围取值</strong></p><p> scope：指对象的做哟ing范围，取值如下</p><p><img src="https://img-blog.csdnimg.cn/20210715110307817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p><em><strong>scope的取值为singleton时</strong></em></p><p>Bean的实例化个数：1个</p><p>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</p><p>Bean的生命周期：</p><p>  对象创建：当应用加载，创建容器时，对象就被创建了</p><p> 对象运行：只要容器在，对象就就一直活着</p><p>     对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p><p><em><strong>scope的取值为prototype</strong></em></p><p>Bean的实例化个数：多个</p><p>Bean的实例化时机：当调用getBean()方法时实例化Bean</p><p>Bean的生命周期：</p><p>  对象创建：当使用对象时，创建新的对象实例</p><p> 对象运行：只要对对象在使用中，对象就就一直活着</p><p> 对象销毁：当对象长时间不用时，杯Java的垃圾回收器回收了</p><h4 id="Bean的生命周期配置">Bean的生命周期配置</h4><p>init-method:指定类中的初始化方法名称</p><p>destroy-method:指定类中的销毁方法</p><h4 id="Bean实例化三种方式">Bean实例化三种方式</h4><ul><li><p>无参构造方法实例化</p></li><li><p>工厂静态方法实例化</p></li><li><p>工厂实例方法实例化</p></li></ul><br><p>例：工厂实例方法实例化<br><img src="https://img-blog.csdnimg.cn/20210715110940785.png" alt=""></p><br><h4 id="Bean的依赖注入">Bean的依赖注入</h4><p><img src="https://img-blog.csdnimg.cn/20210716163040737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20210716163156941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p><em><strong>依赖注入的具体分析</strong></em></p><p>依赖注入 (Denpendency Injection):它是Spring框架核心IOC的具体实现。</p><p>在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦知识降低他们的依赖的关系，但是并不会消除。例如：业务层任然会调用持久层的方法。</p><p>那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。简单的说，就是坐等框架把持久层的对象储如业务层，而不用我们自己去获取。</p><h4 id="依赖注入的方式">依赖注入的方式</h4><p>思考：怎样将UserDao植入到UserService内部呢？</p><ul><li><p>构造方法</p></li><li><p>set方法</p></li></ul><p><em><strong>1.set方法的注入</strong></em></p><p> <em>普通的set方法注入</em><br><img src="https://img-blog.csdnimg.cn/20210716163400924.png" alt=""><br> <em>P命名空间的注入</em></p><p>P命名空间注入本质也是set方法注入，但比set方法的注入更加的方便，主要体现在配置文件中<br><img src="https://img-blog.csdnimg.cn/20210716163529146.png" alt=""><br>修改注入方式<br><img src="https://img-blog.csdnimg.cn/20210716163547251.png" alt=""><br><em><strong>2.构造注入</strong></em><br><img src="https://img-blog.csdnimg.cn/20210716163921155.png" alt=""></p><h4 id="Bean的依赖注入的数据类型">Bean的依赖注入的数据类型</h4><p>除了对象的引用可以注入，普通的数据类型，集合等都可以在容器中进行注入</p><p>注入数据发的三种数据类型</p><ul><li><p>普通数据类型</p></li><li><p>引用数据类型</p></li><li><p>集合数据类型</p></li></ul><p><strong>引用其他配置文件（分模块开发）</strong></p><p>实际的开发中，Spring的配置内容非常多，这就导致Spring配置之很繁杂且体积很大，所以，可以将部分配置拆解到其他的配置文件中，而在Spring主配置文件通过impor标签进行加载<br><img src="https://img-blog.csdnimg.cn/20210716164427970.png" alt=""></p><h2 id="Spring相关的API">Spring相关的API</h2><h3 id="ApplicationContext的继承体系">ApplicationContext的继承体系</h3><p><strong>applicationContext</strong>:接口类型，代表应用上下文，可以通过其实例获得Spring容器中的Bean对象</p><p><strong>ApplicationContext的实现类</strong></p><ul><li>ClassPathXmlApplicationContext</li></ul><p>他是从类根路径下加载配置文件 （推荐使用）</p><ul><li>FileSystemXmlApplicationContext</li></ul><p>他是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p><ul><li>AnnotationConfigApplicationContext</li></ul><p>使用注解配置容器对象时，需要使用此类来创建Spring容器。它用来读取注解。</p><p><strong>getBean可以通过多种方式进行获取</strong></p><p>app.getBean(“id”)     根据id获取 唯一的</p><p>app.getBean(class)   根据类型获取 不一定唯一</p><h2 id="Spring配置数据源">Spring配置数据源</h2><p><strong>数据源（连接池）的作用</strong></p><p>数据源是为了提高程序性能出现的；实现实例化数据源，初始化部分连接资源；使用连接资源时从数据源中获取；使用我完毕后将连接资源归还给数据源</p><p><strong>常见的数据源（连接池）</strong>：DBCP，C3P0,BoneCP,Druid等<br><br><strong>数据源的开发步骤</strong></p><ul><li><p>导入数据源的坐标和数据库驱动坐标</p></li><li><p>创建数据源对象</p></li><li><p>设置数据源的基本连接数据</p></li><li><p>使用数据源获取连接资源和归还连接资源<br><br><br><strong>1. 手动创建c3p0数据源</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9381de845982cb2ac651c3353ef22dd0.png" alt=""></p><p><strong>2.手动创建Druid数据源</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/a1bcf31bc1ab7ba8abafa2528e0d1951.png" alt=""></p><p><strong>3.从配置文件中获取</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/42c04d69ba553bbf33c3b07d3a28c684.png" alt=""></p><p><strong>由Spring配置数据源</strong></p><p>可以将DataSource的创建权交由Spring容器去完成</p><ol><li>配置Bean<br><img src="https://img-blog.csdnimg.cn/img_convert/84395faaa2296c0d51e2d33be346b021.png" alt=""></li><li>Spring容器产生数据源对象<br><img src="https://img-blog.csdnimg.cn/img_convert/2522a1e673a6c4da03e99945bff3c071.png" alt=""></li></ol><p><strong>注意：</strong> c3p0和druid的bean配置时 他们的需要注入的driver，url等的名字不同，主要取决于他们内部对应的set方法不同，需要注入的名字就是set后面对应的名字</p><p><strong>由spring中加载properties配置文件</strong></p><ol><li>首先需要映入context命名空间和约束路径</li></ol><p>命名空间复制xmlns，在xmlns后面加上:context，最后将bean全部改为context，最后即是</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d20e8074e7909fdf2be0bcae03fb976a.png" alt=""></p><ol start="2"><li>同理约束路径为<br><img src="https://img-blog.csdnimg.cn/img_convert/39a355e6685efdfc9d5202067d487241.png" alt=""></li><li>加载外部的properties文件</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/ca3725cbded1fb476ed14d295cd98eea.png" alt=""></p><p>location即是文件的位置</p><p>使用EL表达式将properties中的数据传入bean</p><p>即  ${key}<br><img src="https://img-blog.csdnimg.cn/img_convert/ce28593edac8bb48ed51ca647ccfceca.png" alt=""></p><ol start="4"><li>最后同上</li></ol><h2 id="Spring注解开发">Spring注解开发</h2><p><strong>Spring的原始注解</strong></p><p>spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p><p>spring的原始注解主要是替代Bean的配置<br><img src="https://img-blog.csdnimg.cn/img_convert/5957bde0abc9d48e9dd1644c7d523f1b.png" alt=""><br>注意：使用注解进行开发时，，需要applicationContext.xml中配置组件扫描，作用时指定哪个包及其子包下需要进行扫描以便识别使用注解配置的类，字段和方法</p><p><img src="https://img-blog.csdnimg.cn/71ea7f70fea148c5b7d74e137ce54359.png" alt=""></p><p>@Value注解</p><p>配合这个表达式使用<br><img src="https://img-blog.csdnimg.cn/53e3f6c76710459998f8cedff5a48a67.png" alt=""></p><p>spring的新注解</p><p><img src="https://img-blog.csdnimg.cn/a487b7aac6fc44839b9fd50ce80675c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>具体实现<br>配置数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//说明这是一个核心配置文件</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-comment">//扫描组件对应着xml中的 &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span>;<br><span class="hljs-comment">//从properties文件中获取那些数据 对应着xml中的 &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">//使用@Value注入值</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException</span>&#123;<br>        ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource;<br>        dataSource.setDriverclass(driver);<br>        dataSource.setJdbcUrl(url);<br>        dataSource.setUser(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Spring集成Junit">Spring集成Junit</h2><p><strong>步骤</strong></p><ol><li>导入spring集成junit的jar包</li><li>使用@Runwith注解替换原来的运行期</li><li>使用@ContextConfiguration指定配置文件或配置类</li><li>使用@Autowired注入需要测试的对象</li><li>创建测试方法进行测试</li></ol><h2 id="Spring与Web环境的集成">Spring与Web环境的集成</h2><ul><li><strong>ApplicationContext应用上下文获取方式</strong></li></ul><p>应用上下文对象是通过new ClasspathXmlApplicationContext (spring配置文件)方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext (spring配置文件)，这样的弊端是配置的时候文件加载多次，应用上下文对象创建多次。</p><p>在Web项目中可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得上下文对象ApplicationContext对象了。</p><p><strong>spring提供获取应用上下文的工具</strong></p><p>Spring提供了一个监听器ContextLoaderListener就是对方法的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获取应用上下文对象。</p><p>所以我们只需要只有两件事</p><ol><li>在Web.XML中配置ContextLoaderListener监听器（导入spring-web坐标）<br><img src="https://img-blog.csdnimg.cn/2e6b4d9b96df40978c503155b3f7a67a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>使用WebApplicationContextUtils获得上下文对象ApplicationContext<br><img src="https://img-blog.csdnimg.cn/e824d22c24f645fb90e40f540815a4b8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ol><h1>二、SpringMVC</h1><h2 id="SpringMVC的简介">SpringMVC的简介</h2><h3 id="概述">概述</h3><p>SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中</p><h3 id="开发步骤">开发步骤</h3><ol><li>导入SpringMVC的相关坐标</li><li>配置SpringMVC核心控制器DispathcerServlet</li><li>创建Controller类和视图页面</li><li>使用注解配置Controller类中业务方法得到映射地址</li><li>配置SpringMVC核心文件Spring-mvc.xml</li><li>客户端发起请求测试</li><li>SpringMVC的执行流程</li></ol><p>图示<br><img src="https://img-blog.csdnimg.cn/e71e4fe33bb5416b9b9f0dbc5d8f3699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>文字</p><p><img src="https://img-blog.csdnimg.cn/4b7f8a4b052e4925a6590d9bac756dc1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="SpringMVC注解解析">SpringMVC注解解析</h2><h3 id="RequestMapping">@RequestMapping</h3><p>作用：用于建立请求 URL 和处理请求方法之间的对应关系<br>位置：<br>类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录<br>方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径<br>属性：<br>value：用于指定请求的URL。它和path属性的作用是一样的<br>method：用于指定请求的方式<br>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样<br>例如：<br>params = {“accountName”}，表示请求参数必须有accountName<br>params = {“moeny!100”}，表示请求参数中money不能是100</p><h3 id="mvc命名空间引入">mvc命名空间引入</h3><p>命名空间：xmlns:context=“<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>”<br>xmlns:mvc=“<a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a>”<br>约束地址：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a><br><a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a><br><a href="http://www.springframework.org/schema/mvc/spring-mvc.xsd">http://www.springframework.org/schema/mvc/spring-mvc.xsd</a></p><h3 id="组件扫描">组件扫描</h3><p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller&quot;/&gt;进行组件扫描。</p><h2 id="SpringMVC的XML配置解析">SpringMVC的XML配置解析</h2><h3 id="视图解析器">视图解析器</h3><p>SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver<br></code></pre></td></tr></table></figure><p><strong>我们可以通过属性注入的方式修改视图的的前后缀</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置内部资源视图解析器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="SpringMVC的相关组件">SpringMVC的相关组件</h3><p>前端控制器：DispatcherServlet<br>处理器映射器：HandlerMapping<br>处理器适配器：HandlerAdapter<br>处理器：Handler<br>视图解析器：View Resolver<br>视图：View</p><h3 id="SpringMVC的注解和配置">SpringMVC的注解和配置</h3><p>请求映射注解：@RequestMapping<br>视图解析器配置：<br>REDIRECT_URL_PREFIX = “redirect:”<br>FORWARD_URL_PREFIX = “forward:”<br>prefix = “”;<br>suffix = “”;</p><h2 id="SpringMVC的数据响应方式">SpringMVC的数据响应方式</h2><p>1） <strong>页面跳转</strong><br>直接返回字符串<br>通过ModelAndView对象返回</p><p>2） <strong>回写数据</strong><br>直接返回字符串<br>返回对象或集合</p><h3 id="页面跳转">页面跳转</h3><ul><li>返回字符串形式<br>直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转<br><img src="https://img-blog.csdnimg.cn/be374d1b7dcb441f90a70f371f60ae2e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>返回ModelAndView对象<br><img src="https://img-blog.csdnimg.cn/eab5373039c2447eac88438b6fc40842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>向request域存储数据<br>A. 通过SpringMVC框架注入的request对象setAttribute()方法设置<br><img src="https://img-blog.csdnimg.cn/dce87c613dc8412b8b85f15c92e06f8f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>B.通过ModelAndView的addObject()方法设置<br><img src="https://img-blog.csdnimg.cn/8b63ba7c31734f7886b47f97db6b64f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ul><h3 id="回写数据">回写数据</h3><p><strong>1.直接返回字符串</strong></p><p>通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void。<br><img src="https://img-blog.csdnimg.cn/e2d553be6a8d481f972793b4dbfe35c0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回。<br><img src="https://img-blog.csdnimg.cn/990d89710ee643a7b924bfa2fab47c91.png" alt=""><br>在异步项目中，客户端与服务器端往往要进行json格式字符串交互，此时我们可以手动拼接json字符串返回。<br><img src="https://img-blog.csdnimg.cn/88ea71aa891147b2a853a40a48ae8262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>上述方式手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换，导入jackson坐标。<br><img src="https://img-blog.csdnimg.cn/3f9d0aa65d8441a9aaa29825b41ddb14.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br><strong>2. 返回对象或集合</strong><br>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：<br><img src="https://img-blog.csdnimg.cn/593bf875e50b45f9bb557a4ce3b7a872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/9956fb64155548f8981fe20039258187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。<br><img src="https://img-blog.csdnimg.cn/eb69021d1d1b46ee941c79ad4e2a2d70.png" alt=""><br>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使用<a href="mvc:annotation-driven">mvc:annotation-driven</a>自动加载 RequestMappingHandlerMapping（处理映射器）和<br>RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用<br><a href="mvc:annotation-driven">mvc:annotation-driven</a>替代注解处理器和适配器的配置。<br>同时使用<a href="mvc:annotation-driven">mvc:annotation-driven</a>默认底层就会集成jackson进行对象或集合的json格式字符串的转换。</p><h2 id="SpringMVC-获得请求数据">SpringMVC 获得请求数据</h2><h3 id="获得请求参数">获得请求参数</h3><p>客户端请求参数的格式是：name=value&amp;name=value… …<br>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p><ul><li>基本类型参数</li><li>POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul><h3 id="获得基本类型参数">获得基本类型参数</h3><p>Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。<br><img src="https://img-blog.csdnimg.cn/f3e2dceb0e614ad18459d6d3e9147a0a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="获得POJO类型参数">获得POJO类型参数</h3><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。<br><img src="https://img-blog.csdnimg.cn/515d88889369428abaa127a60545fcba.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="获得数组类型参数">获得数组类型参数</h3><p>Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。<br><img src="https://img-blog.csdnimg.cn/262a22f5610243d08f53d972096f3808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="获得集合类型参数">获得集合类型参数</h3><p>获得集合参数时，要将集合参数包装到一个POJO中才可以。<br><img src="https://img-blog.csdnimg.cn/15f78bd1a573482ba08dc9d27e4106f9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。<br><img src="https://img-blog.csdnimg.cn/cbfc5ec4c0994e6a808f403866a60fc8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt="1"><br><img src="https://img-blog.csdnimg.cn/c947e3a269f14848acd5288349eacbeb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt="2"><br>注意：通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：<br>在spring-mvc.xml配置文件中指定放行的资源<br>&lt;mvc:resources mapping=“/js/**” location=“/js/”/&gt;<br>使用<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>标签</p><h3 id="请求数据乱码问题">请求数据乱码问题</h3><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。<br><img src="https://img-blog.csdnimg.cn/432424ab457d413282e2b8ad61f180d6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="参数绑定注解-requestParam">参数绑定注解@requestParam</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。<br><img src="https://img-blog.csdnimg.cn/cdb0140cbb15486982ed9a8867fec7ca.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>注解@RequestParam还有如下参数可以使用：</p><ul><li>value：与请求参数名称</li><li>required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错</li><li>defaultValue：当没有指定请求参数时，则使用指定的默认值赋值<br><img src="https://img-blog.csdnimg.cn/85018fd17ca24dd896679ba413594e44.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ul><h3 id="获得Restful风格的参数">获得Restful风格的参数</h3><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：<br>GET：用于获取资源<br>POST：用于新建资源<br>PUT：用于更新资源<br>DELETE：用于删除资源</p><p>例如：</p><ul><li>/user/1    GET ：       得到 id = 1 的 user</li><li>/user/1    DELETE：  删除 id = 1 的 user</li><li>/user/1    PUT：       更新 id = 1 的 user</li><li>/user       POST：      新增 user</li></ul><p>上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。<br><img src="https://img-blog.csdnimg.cn/2b366cbfe7754a7f972f45ce093a1e63.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="自定义类型转换器">自定义类型转换器</h3><ul><li>SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</li><li>但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</li></ul><p>自定义类型转换器的开发步骤：</p><ol><li>定义转换器类实现Converter接口</li><li>在配置文件中声明转换器</li><li>在<annotation-driven>中引用转换器</li></ol><p>第一步：定义转换器类实现Converter接口<br><img src="https://img-blog.csdnimg.cn/716cf7ac78244479a05ffad7bcf0bce8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>第二步：在配置文件中声明转换器<br><img src="https://img-blog.csdnimg.cn/77303542b4bd4017af3eb23e48adfa8c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>第三步：在<annotation-driven>中引用转换器<br><img src="https://img-blog.csdnimg.cn/e0ccfa3301e14ee185ce5b40c14aedb5.png" alt=""></p><h3 id="获得Servlet相关API">获得Servlet相关API</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession<br><img src="https://img-blog.csdnimg.cn/7ebf8f4b4a70417d9a7ed77689353de1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ul><h3 id="获得请求头">获得请求头</h3><p><strong>@RequestHeader</strong></p><p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)<br>@RequestHeader注解的属性如下：</p><ul><li>value：请求头的名称</li><li>required：是否必须携带此请求头<br><img src="https://img-blog.csdnimg.cn/6c1ff3cdb70047ba949a91d2b04b0958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br><strong>@CookieValue</strong><br>使用@CookieValue可以获得指定Cookie的值<br>@CookieValue注解的属性如下：</li><li>value：指定cookie的名称</li><li>required：是否必须携带此cookie<br><img src="https://img-blog.csdnimg.cn/d9e367c8f3914b71920452022feb9018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ul><h3 id="文件上传">文件上传</h3><ul><li>文件上传客户端三要素</li><li>表单项type=“file”</li><li>表单的提交方式是post</li><li>表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data”<br><img src="https://img-blog.csdnimg.cn/b63240a6a76e4525a92ada9ab15d0cef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br>2.文件上传原理</li><li>当form表单修改为多部分表单时，request.getParameter()将失效。</li><li>enctype=“application/x-www-form-urlencoded”时，form表单的正文内容格式是：key=value&amp;key=value&amp;key=value</li><li>当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式：<br><img src="https://img-blog.csdnimg.cn/e9b033b204354e8aba76807f89fb8bb1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ul><h3 id="单文件上传步骤">单文件上传步骤</h3><ol><li>导入fileupload和io坐标</li><li>配置文件上传解析器</li><li>编写文件上传代码</li></ol><h3 id="单文件上传实现">单文件上传实现</h3><ol><li>导入fileupload和io坐标<br><img src="https://img-blog.csdnimg.cn/7efaf2016e28429e9d3635de3221d038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>配置文件上传解析器<br><img src="https://img-blog.csdnimg.cn/beb05768c2ee45f9936ce9beac0b7747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>编写文件上传代码<br><img src="https://img-blog.csdnimg.cn/eaf4d38a7d80401a8ac7c02c900ff56c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></li></ol><h3 id="多文件上传实现">多文件上传实现</h3><p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可<br><img src="https://img-blog.csdnimg.cn/b81abfe757294d3caf33477ee4857c51.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/091e57918d2f439d816eb39bf056bade.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTI2NzQ2NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="SpingMVC拦截器">SpingMVC拦截器</h2><p>Spring MVC 的拦截器类似于 Servlet  开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p><p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。<br><img src="https://img-blog.csdnimg.cn/d42511f560db4662ae411f03f2802a4a.png" alt=""></p><h3 id="拦截器快速入门">拦截器快速入门</h3><p>自定义拦截器很简单，只有如下三步：</p><ul><li>创建拦截器类实现HandlerInterceptor接口</li><li>配置拦截器</li><li>测试拦截器的拦截效果</li></ul><ol><li>创建拦截器类实现HanderInterceptor接口<br><img src="https://img-blog.csdnimg.cn/5c6d8f1e257d477ea5af538769825e80.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>配置拦截器<br><img src="https://img-blog.csdnimg.cn/8178ae803fe946a1bd730812c680eee7.png" alt=""></li><li>测试拦截器的拦截效果(编写目标方法)<br><img src="https://img-blog.csdnimg.cn/4506961bd9814200bbee39159c6a96e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><h3 id="拦截器方法说明">拦截器方法说明</h3><p><img src="https://img-blog.csdnimg.cn/b6e1470a7c224c08957ba1f54a78b6c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="SpringMVC异常处理">SpringMVC异常处理</h2><h3 id="异常处理思路">异常处理思路</h3><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图：<br><img src="https://img-blog.csdnimg.cn/46fa50f2b8ba4b2380212898600593e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="异常处理两种方式">异常处理两种方式</h3><ul><li>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</li><li>实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</li></ul><h3 id="简单异常处理器SimpleMappingExceptionResolver">简单异常处理器SimpleMappingExceptionResolver</h3><p>SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置<br><img src="https://img-blog.csdnimg.cn/108f3112b8494b96b1291345ef7ae81e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="自定义异常处理步骤">自定义异常处理步骤</h3><ul><li>创建异常处理器类实现HandlerExceptionResolver</li><li>配置异常处理器</li><li>编写异常页面</li><li>测试异常跳转</li></ul><ol><li>创建异常处理器类实现HandlerExceptionResolver<br><img src="https://img-blog.csdnimg.cn/15fd2477860e410a9a6ab4310a971c39.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>配置异常处理器<br><img src="https://img-blog.csdnimg.cn/34dfe53644f3401991adc8df5bfa0711.png" alt=""></li><li>编写异常界面<br><img src="https://img-blog.csdnimg.cn/c386286334864ab885334671c5084e38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试异常跳转<br><img src="https://img-blog.csdnimg.cn/7c482c2c432d41028f23d2236eff5e21.png" alt=""></li></ol><h2 id="AOP">AOP</h2><h3 id="AOP简介">AOP简介</h3><h4 id="what-is-AOP">what is AOP</h4><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h3 id="AOP的作用及其优势">AOP的作用及其优势</h3><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强<br>优势：减少重复代码，提高开发效率，并且便于维护</p><h4 id="AOP的底层实现">AOP的底层实现</h4><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h4 id="AOP的动态代理技术">AOP的动态代理技术</h4><p>常用的动态代理技术</p><ul><li>JDK 代理 : 基于接口的动态代理技术</li><li>cglib 代理：基于父类的动态代理技术<br><img src="https://img-blog.csdnimg.cn/597b487129e544ca8433c1addb2c5985.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ul><h4 id="JDK的动态代理">JDK的动态代理</h4><ol><li>目标类接口<br><img src="https://img-blog.csdnimg.cn/7d79d56d680c448f861f52411aa969c6.png" alt=""></li><li>目标类<br><img src="https://img-blog.csdnimg.cn/dcc05f9a4a3442058c0550325c333b4a.png" alt=""></li><li>动态代理代码<br><img src="https://img-blog.csdnimg.cn/5b8282ad19a14c9cad04e18fac8c044a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_16,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>调用代理对象的方法测试<br><img src="https://img-blog.csdnimg.cn/7e15f7efcfde451f973beea01a9f5a76.png" alt=""></li></ol><h4 id="cglib-的动态代理">cglib 的动态代理</h4><ol><li>目标类<br><img src="https://img-blog.csdnimg.cn/7cc6af3d2e7f40a393baab14ff33509a.png" alt=""></li><li>动态代理代码<br><img src="https://img-blog.csdnimg.cn/90060857e1984fca9cc3e27ed7bf64b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>调用代理对象的方法测试<br><img src="https://img-blog.csdnimg.cn/578dad23ff914b4faeb5bc027e1a7e51.png" alt=""></li></ol><h4 id="AOP相关的概念">AOP相关的概念</h4><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p><p>Target（目标对象）：代理的目标对象<br>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类<br>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点<br>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义<br>Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知<br>Aspect（切面）：是切入点和通知（引介）的结合<br>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</p><h4 id="AOP-开发明确的事项">AOP 开发明确的事项</h4><ol><li>需要编写的内容<br>编写核心业务代码（目标类的目标方法）<br>编写切面类，切面类中有通知(增强功能方法)<br>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</li><li>AOP 技术实现的内容<br>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</li><li>AOP 底层使用哪种代理方式<br>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</li></ol><h4 id="AOP知识要点">AOP知识要点</h4><p>aop：面向切面编程<br>aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理<br>aop的重点概念：<br>Pointcut（切入点）：被增强的方法<br>Advice（通知/ 增强）：封装增强业务逻辑的方法<br>Aspect（切面）：切点+通知<br>Weaving（织入）：将切点与通知结合的过程<br>开发明确事项：<br>谁是切点（切点表达式配置）<br>谁是通知（切面类中的增强方法）<br>将切点和通知进行织入配置</p><h3 id="基于XMl的AOP开发">基于XMl的AOP开发</h3><h4 id="快速入门">快速入门</h4><ol><li>导入AOP相关坐标<br><img src="https://img-blog.csdnimg.cn/02d1f1c0ecfd44e2b3f40f22b575e586.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建目标接口和目标类(内部有切点)<br><img src="https://img-blog.csdnimg.cn/b8aaf1eb93124800a5e990e7030221f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建切面类(内部有增强方法)<br><img src="https://img-blog.csdnimg.cn/4fbce9b92d884288a3c86d8a093c3888.png" alt=""></li><li>将目标类和切面类 的对象创建权交给spring<br><img src="https://img-blog.csdnimg.cn/7a12cf2570d0404482d6105f4f5e473a.png" alt=""></li><li>在applicationContext.xml中配置关系<br>导入aop命名空间<br><img src="https://img-blog.csdnimg.cn/ffa56a43dcb54143b09d555ba144db55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""><br>配置切点表达式和前置增强的植入关系<br><img src="https://img-blog.csdnimg.cn/7e520373a68d45939dadef880e3903af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试代码<br><img src="https://img-blog.csdnimg.cn/a3e5afd1a8494d2199e32c308277636d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><h4 id="XML配置AOP详解">XML配置AOP详解</h4><ol><li>切点表达式的写法<br>表达式语法<br><img src="https://img-blog.csdnimg.cn/6cfa85d125844c4c8e504cc63c6dec52.png" alt=""><br>访问修饰符可以省略<br>返回值类型、包名、类名、方法名可以使用星号*  代表任意<br>包名与类名之间一个点 . 代表当前包下的类，两个点 … 表示当前包及其子包下的类<br>参数列表可以使用两个点 … 表示任意个数，任意类型的参数列表<br>such as<br><img src="https://img-blog.csdnimg.cn/2cd6ea67d2014b2097a15999cfa85121.png" alt=""></li><li>通知的类型<br>通知的配置语法<br><img src="https://img-blog.csdnimg.cn/b8d940713ced47589309eca4dbcfe7fc.png" alt=""><br><img src="https://img-blog.csdnimg.cn/d653ff26f203465e876cd05e243498c9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>切点表达式的抽取<br>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。<br><img src="https://img-blog.csdnimg.cn/0f55b30f55ac48e2bb3e86f061b5e6c7.png" alt=""></li></ol><h4 id="知识要点">知识要点</h4><p>aop织入的配置<br><img src="https://img-blog.csdnimg.cn/f5f01f76bd5b47828406c338de16188c.png" alt=""></p><p>通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知<br>切点表达式的写法：<br><img src="https://img-blog.csdnimg.cn/f37dc67e5c48445dacfc1c24e4237254.png" alt=""></p><h3 id="基于注解的AOP开发">基于注解的AOP开发</h3><h4 id="快速入门-2">快速入门</h4><p>基于注解的aop开发步骤：</p><ul><li><p>创建目标接口和目标类（内部有切点）</p></li><li><p>创建切面类（内部有增强方法）</p></li><li><p>将目标类和切面类的对象创建权交给 spring</p></li><li><p>在切面类中使用注解配置织入关系</p></li><li><p>在配置文件中开启组件扫描和 AOP 的自动代理</p></li><li><p>测试</p></li><li><p>创建目标接口和目标类（内部有切点）<br><img src="https://img-blog.csdnimg.cn/f8896412ff9c43c6a88ce1da01280225.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li><li><p>创建切面类<br><img src="https://img-blog.csdnimg.cn/225cb81e24214304b24a4a13596b1494.png" alt=""></p></li><li><p>将目标类和切面类的对象创建权交给 spring<br><img src="https://img-blog.csdnimg.cn/a8ec6e8652ef4ed4b615ab9678b80a24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li><li><p>在切面类中使用注解配置织入关系<br><img src="https://img-blog.csdnimg.cn/b5f21dae22d447d1a3270fedf57b8488.png" alt=""></p></li><li><p>在配置文件中开启组件扫描和 AOP 的自动代理<br><img src="https://img-blog.csdnimg.cn/a9071c431c17487b85768b6f2199083a.png" alt=""></p></li><li><p>测试代码<br><img src="https://img-blog.csdnimg.cn/3eacece3ec2a4a6ba67daae1fbf73663.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li></ul><h4 id="注解配置-AOP-详解">注解配置 AOP 详解</h4><ul><li>注解通知的类型<br>通知的配置语法：@通知注解(“切点表达式&quot;)<br><img src="https://img-blog.csdnimg.cn/ad15f9b2e01b456280c4254393070d1a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>切点表达式的抽取<br>同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：<br><img src="https://img-blog.csdnimg.cn/e3de90ec8a644289aa3986dc099f135c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ul><h4 id="知识要点-2">知识要点</h4><p>注解aop开发步骤</p><ul><li>使用@Aspect标注切面类</li><li>使用@通知注解标注通知方法</li><li>在配置文件中配置aop自动代理<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></li></ul><p>通知注解类型<br><img src="https://img-blog.csdnimg.cn/77ad6c92507f49e197088f5a6f2e7096.png" alt=""></p><h3 id="编程式事物控制相关对象">编程式事物控制相关对象</h3><h4 id="PlatformTransactionManager">PlatformTransactionManager</h4><p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。<br><img src="https://img-blog.csdnimg.cn/1393e4db1d214b42880dfb5fb31aa980.png" alt=""><br>注意：<br>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager<br>Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager</p><h4 id="TransactionDefinition">TransactionDefinition</h4><p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：<br><img src="https://img-blog.csdnimg.cn/aa6d441c4e8542619f25fda9aae1317f.png" alt=""></p><ul><li><p>事务隔离级别<br>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p></li><li><p>ISOLATION_DEFAULT</p></li><li><p>ISOLATION_READ_UNCOMMITTED</p></li><li><p>ISOLATION_READ_COMMITTED</p></li><li><p>ISOLATION_REPEATABLE_READ</p></li><li><p>ISOLATION_SERIALIZABLE</p></li><li><p>事务传播行为</p></li><li><p>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</p></li><li><p>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</p></li><li><p>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</p></li><li><p>REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</p></li><li><p>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p></li><li><p>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</p></li><li><p>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p></li><li><p>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</p></li><li><p>是否只读：建议查询时设置为只读</p></li></ul><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。<br><img src="https://img-blog.csdnimg.cn/8406dde798c24cf18588811363403670.png" alt=""></p><h4 id="知识要点-3">知识要点</h4><p>编程式事务控制三大对象</p><ul><li>PlatformTransactionManager</li><li>TransactionDefinition</li><li>TransactionStatus</li></ul><h3 id="基于-XML-的声明式事务控制">基于 XML 的声明式事务控制</h3><p><strong>什么是声明式事务控制</strong><br>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。<br><strong>声明式事务处理的作用</strong></p><ul><li><p>事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</p></li><li><p>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便<br>注意：Spring 声明式事务控制底层就是AOP。</p></li></ul><h4 id="声明式事务控制的实现">声明式事务控制的实现</h4><ul><li>引入tx命名空间 <img src="https://img-blog.csdnimg.cn/7ab3cf3a98fd4df39019ab46f26dd053.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>配置事务增强<br><img src="https://img-blog.csdnimg.cn/ce9cc82c597c47d1b907380c0cd4e099.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>配置事务AOP织入<br><img src="https://img-blog.csdnimg.cn/ac548a87ed4c48eebffc6d9bf24ffe0a.png" alt=""></li><li>测试事务控制转账业务代码<br><img src="https://img-blog.csdnimg.cn/a702ceb329e14d268f06e44273ae1ad7.png" alt=""></li></ul><h4 id="切点方法的事务参数的配置">切点方法的事务参数的配置</h4><p><img src="https://img-blog.csdnimg.cn/e6c4b56f28984a77b03a4db7f8288b15.png" alt=""><br>其中，<a href="tx:method">tx:method</a> 代表切点方法的事务参数的配置，例如：<br>&lt;tx:method name=“transfer” isolation=“REPEATABLE_READ” propagation=“REQUIRED” timeout=“-1” read-only=“false”/&gt;</p><ul><li><p>name：切点方法名称</p></li><li><p>isolation:事务的隔离级别</p></li><li><p>propogation：事务的传播行为</p></li><li><p>timeout：超时时间</p></li><li><p>read-only：是否只读</p></li></ul><h3 id="基于注解的声明式事务控制">基于注解的声明式事务控制</h3><h4 id="使用注解怕配置声明式事务控制">使用注解怕配置声明式事务控制</h4><ul><li><p>编写AccountDao<br><img src="https://img-blog.csdnimg.cn/894d123f7e524261a6b6886077542a35.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li><li><p>编写AccountService<br><img src="https://img-blog.csdnimg.cn/dc910d02eceb4338957acc4086b7b743.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li><li><p>编写applicationContext.xml配置文件<br><img src="https://img-blog.csdnimg.cn/7779f1dcdb654863b55b0c165a985a9c.png" alt=""></p></li></ul><h4 id="注解配置声明式事务控制解析">注解配置声明式事务控制解析</h4><ul><li><p>使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p></li><li><p>注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p></li><li><p>使用在方法上，不同的方法可以采用不同的事务参数配置。</p></li><li><p>Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt;</p></li></ul><h1>三、Mybatis</h1><h2 id="Mybatis简介">Mybatis简介</h2><h3 id="什么是Mybatis">什么是Mybatis</h3><ul><li>mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li><li>mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</li><li>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。</li></ul><h2 id="Mybatis快速入门">Mybatis快速入门</h2><h3 id="Mybatis开发步骤">Mybatis开发步骤</h3><p>Mybatis官网地址:<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p><ul><li>添加MyBatis的坐标</li><li>创建user数据表</li><li>编写User实体类</li><li>编写映射文件UserMapper.xml</li><li>编写核心文件SqlMapConfig.xml</li><li>编写测试类</li></ul><h3 id="环境搭建">环境搭建</h3><ul><li>导入Mybatis坐标及其他的相关坐标<br><img src="https://img-blog.csdnimg.cn/225158e128ea4e5f9b5453602758a74e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/a212bdab459b46d6a1888e7fd3cae927.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建user表格<br><img src="https://img-blog.csdnimg.cn/43bead460b1547be97ea217221b9e9b9.png" alt=""></li><li>编写user实体<br><img src="https://img-blog.csdnimg.cn/da55da36266f4127b41472521768535e.png" alt=""></li><li>编写UserMapper映射文件<br><img src="https://img-blog.csdnimg.cn/a368a5d98bbc4bfa8ffdf3e1f41b5d5e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>编写Mybatis核心文件<br><img src="https://img-blog.csdnimg.cn/d6b67ec5fb2748b49c3b4106cf8171ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>编写测试代码<br><img src="https://img-blog.csdnimg.cn/05b415fa27f84132a03fcf1c63ef54bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ul><h2 id="Mybatis映射文件概述">Mybatis映射文件概述</h2><p><img src="https://img-blog.csdnimg.cn/aad594d3007d46d2bb5dc5b177bf7bf6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="Mybatis的增删改查操作">Mybatis的增删改查操作</h2><h3 id="插入数据操作">插入数据操作</h3><ul><li>编写UserMapper映射文件<br><img src="https://img-blog.csdnimg.cn/bccd584e23e44a8f9a40ba4a66e81e2d.png" alt=""></li><li>编写插入实体的User的代码<br><img src="https://img-blog.csdnimg.cn/b9fde840bf8044d393f2dc4279a70e38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>插入操作需要注意的问题</li><li>插入语句使用insert标签</li><li>在映射文件中使用parameterType属性指定要插入的数据类型</li><li>Sql语句中使用#{实体属性名}方式引用实体中的属性值</li><li>插入操作使用的API是sqlSession.insert(“<a href="http://xn--eqrzj591h57w.id">命名空间.id</a>”,实体对象);</li><li>插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit()</li></ul><h3 id="修改数据操作">修改数据操作</h3><ul><li><p>编写UserMapper的映射文件<img src="https://img-blog.csdnimg.cn/2cfad8f0631b4caf92eaab9350924833.png" alt=""></p></li><li><p>编写修改 实体User的代码<img src="https://img-blog.csdnimg.cn/6cbdffb9cd524e81a5de7ed773e4ef17.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li><li><p>修改操作需要注意的问题</p></li><li><p>修改语句使用update标签</p></li><li><p>修改操作使用的API是sqlSession.update(“<a href="http://xn--eqrzj591h57w.id">命名空间.id</a>”,实体对象);</p></li></ul><h3 id="删除数据操作">删除数据操作</h3><ol><li><p>编写UserMapper的映射文件<br><img src="https://img-blog.csdnimg.cn/b7db8b877fdb4e14a62c8ee5a31c8e9c.png" alt=""></p></li><li><p>编写删除数据的代码<img src="https://img-blog.csdnimg.cn/63448c5b51dc4c3a84747ea5e25bf699.png" alt=""></p></li><li><p>删除操作需注意问题</p></li></ol><ul><li><p>删除语句使用delete标签</p></li><li><p>Sql语句中使用#{任意字符串}方式引用传递的单个参数</p></li><li><p>删除操作使用的API是sqlSession.delete(“<a href="http://xn--eqrzj591h57w.id">命名空间.id</a>”,Object);</p></li></ul><h3 id="知识小结">知识小结</h3><p>增删改查映射配置与API：<br><strong>查询数据：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">List<span class="hljs-tag">&lt;<span class="hljs-name">User</span>&gt;</span> userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>&gt;</span> <br>           select * from User    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSession.insert(&quot;userMapper.add&quot;, user);<br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>&gt;</span>   <br>         insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修改数据：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSession.update(&quot;userMapper.update&quot;, user);<br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>&gt;</span><br>            update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSession.delete(&quot;userMapper.delete&quot;,3);<br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            delete from user where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis核心配置文件概述">Mybatis核心配置文件概述</h2><h3 id="Mybatis核心配置文件的层级关系">Mybatis核心配置文件的层级关系</h3><p><img src="https://img-blog.csdnimg.cn/2eb7dbb054a643e386e8b479007d3458.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_13,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="Mybatis常用配置文件解析">Mybatis常用配置文件解析</h3><h4 id="environment标签">environment标签</h4><p>数据库环境的配置，支持多环境配置<br><img src="https://img-blog.csdnimg.cn/d2cbeb9afd984ca2b3ae1a310f4f1c7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>其中，事务管理器（transactionManager）类型有<strong>两种：</strong></p><ul><li>JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</li><li>MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。<br>默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false来阻止它默认的关闭行为。</li></ul><p>其中，数据源（dataSource）类型有<strong>三种：</strong></p><ul><li>UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</li><li>POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</li><li>JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI<br>上下文的引用。</li></ul><h4 id="mapper标签">mapper标签</h4><p>该标签的作用是加载映射的，加载方式有如下几种：</p><ul><li><p>使用相对于类路径的资源引用，例如：<mapperresource="org/mybatis/builder/AuthorMapper.xml"/></p></li><li><p>使用完全限定资源定位符（URL），例如：<mapperurl="file:///var/mappers/AuthorMapper.xml"/></p></li><li><p>使用映射器接口实现类的完全限定类名，例如：<mapperclass="org.mybatis.builder.AuthorMapper"/></p></li><li><p>将包内的映射器接口实现全部注册为映射器，例如：<package name="org.mybatis.builder"/></p></li></ul><h4 id="Properties标签">Properties标签</h4><p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件<br><img src="https://img-blog.csdnimg.cn/72516f858758455690e3d8ca8d6c8da4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h4 id="typeAliases标签">typeAliases标签</h4><p>类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下<img src="https://img-blog.csdnimg.cn/4343e89b90724414853772d3272d7d24.png" alt=""></p><p>配置typeAliases，为com.itheima.domain.User定义别名为user<img src="https://img-blog.csdnimg.cn/15e38df494db4a40a50a525960a0ce6d.png" alt=""><br>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名<img src="https://img-blog.csdnimg.cn/0d9690527d8849658aad22c7feae916f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_16,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h4 id="知识小结-2">知识小结</h4><p><img src="https://img-blog.csdnimg.cn/eaa67ee5a7a84a7aa8ff90641af17568.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/cf8422297d1d47ae95e5bbfe1336f9f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="Mybatis相应的API">Mybatis相应的API</h3><h4 id="SqlSession工厂构建器SqlSessionFactoryBuilder">SqlSession工厂构建器SqlSessionFactoryBuilder</h4><p>常用API：SqlSessionFactory  build(InputStream inputStream)<br>通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象<img src="https://img-blog.csdnimg.cn/b8fdea1de07a400da906212d5d9be0be.png" alt=""></p><p>其中， Resources 工具类，这个类在 <a href="http://org.apache.ibatis.io">org.apache.ibatis.io</a> 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p><h4 id="SqlSession工厂对象SqlSessionFactory">SqlSession工厂对象SqlSessionFactory</h4><p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：<br><img src="https://img-blog.csdnimg.cn/d30d95b8cf3541d092a53db93666966f.png" alt=""></p><h4 id="SqlSession会话对象">SqlSession会话对象</h4><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。<br>执行语句的方法主要有：<img src="https://img-blog.csdnimg.cn/fd1559ea74cc438eab1a64d46a5abea1.png" alt=""></p><p>操作事务的方法主要有： <img src="https://img-blog.csdnimg.cn/de415019464e41d583a217585437e0e5.png" alt=""></p><h2 id="MyBatis的Dao层实现">MyBatis的Dao层实现</h2><h3 id="传统开发方式">传统开发方式</h3><ol><li><p>编写UserDao接口<img src="https://img-blog.csdnimg.cn/193a2fe2fafe4389aaa7a42e71c5581e.png" alt=""></p></li><li><p>编写UserDaoImpl实现<img src="https://img-blog.csdnimg.cn/51aa877c88844a93a60b1b460a7870b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p></li><li><p>测试传统方式<img src="https://img-blog.csdnimg.cn/c522d5a567c140ee886a3021a7c23995.png" alt=""></p></li></ol><h3 id="代理开发方式">代理开发方式</h3><ul><li>代理开发方式介绍<br>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。<br>Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。<br>Mapper 接口开发需要遵循以下规范：<br>1、 Mapper.xml文件中的namespace与mapper接口的全限定名相同<br>2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同<br>3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同<br>4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li><li>编写UserMapper接口<img src="https://img-blog.csdnimg.cn/e3189f1a722d436ab9d61833d35a2fb1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试代理方法<img src="https://img-blog.csdnimg.cn/da1ba5b48ea5495996a344e1fdcd26ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ul><h3 id="知识小结-3">知识小结</h3><p><img src="https://img-blog.csdnimg.cn/3e9e85e6f6914b7ca1a2a04e80c464ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="Mybatis映射文件深入">Mybatis映射文件深入</h2><h3 id="动态sql语句">动态sql语句</h3><p><strong>1. 概述</strong><br>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。<br><strong>2. 动态语句之if</strong><br>我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。<br><img src="https://img-blog.csdnimg.cn/8b5a41f45185499a9e7c046d69d2d430.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br>当查询条件id和username都存在时，控制台打印的sql语句如下：<img src="https://img-blog.csdnimg.cn/cf279a20875d426b820f66505dbcb555.png" alt=""><br>当查询条件只有id存在时，控制台打印的sql语句如下：<img src="https://img-blog.csdnimg.cn/edfb53af732641f69002baeb8474381c.png" alt=""><br><strong>动态 SQL  之foreach</strong><br>循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。<img src="https://img-blog.csdnimg.cn/a0b68833b0c342cb8832c1ceedfc5140.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>测试代码片段如下：<img src="https://img-blog.csdnimg.cn/ea525e7cba5b4ba79789e7680d097c8a.png" alt=""><br>foreach标签的属性含义如下：<br><foreach>标签用于遍历集合，它的属性：</p><ul><li>collection：代表要遍历的集合元素，注意编写时不要写#{}</li><li>open：代表语句的开始部分</li><li>close：代表结束部分</li><li>item：代表遍历集合的每个元素，生成的变量名</li><li>sperator：代表分隔符</li></ul><h3 id="SQL片段抽取">SQL片段抽取</h3><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的<img src="https://img-blog.csdnimg.cn/2bdfdc078f5f429e8de44df484791ac2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="知识小结-4">知识小结</h3><p>MyBatis映射文件配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select&gt;：查询<br>&lt;insert&gt;：插入<br>&lt;update&gt;：修改<br>&lt;delete&gt;：删除<br>&lt;where&gt;：where条件<br>&lt;<span class="hljs-keyword">if</span>&gt;：<span class="hljs-keyword">if</span>判断<br>&lt;foreach&gt;：循环<br>&lt;sql&gt;：sql片段抽取<br></code></pre></td></tr></table></figure><h2 id="Mybatis核心文件深入">Mybatis核心文件深入</h2><h3 id="typeHandlers标签">typeHandlers标签</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。<br><img src="https://img-blog.csdnimg.cn/d47d38f1defb4d9d86a236e133dcb8e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。</p><p><strong>开发步骤：</strong></p><ol><li>定义转换类继承类BaseTypeHandler<T></li><li>覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，</li><li>getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法</li><li>在MyBatis核心配置文件中进行注册</li><li>测试转换是否正确<img src="https://img-blog.csdnimg.cn/bed28e4fe8ca43578029481d8bb5adba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><p><img src="https://img-blog.csdnimg.cn/d1cc363925e04dca83a3349995555e01.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="plugins标签">plugins标签</h3><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据<br><strong>开发步骤：</strong></p><ol><li>导入通用PageHelper的坐标</li><li>在mybatis核心配置文件中配置PageHelper插件</li><li>测试分页数据获取</li></ol><p>导入通用PageHelper坐标<img src="https://img-blog.csdnimg.cn/8dcea71496d44080a82997e0eed5a530.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>在mybatis核心配置文件中配置PageHelper插件<img src="https://img-blog.csdnimg.cn/ad6dc90750b7478a964eb48a83760e46.png" alt=""><br>测试分页代码实现<img src="https://img-blog.csdnimg.cn/3ea7f69dcca34363b09a0cadec40d6d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>获得分页相关的其他参数<img src="https://img-blog.csdnimg.cn/94b75747b4874e70987c4fcea91a224d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="知识小结-5">知识小结</h3><p>MyBatis核心配置文件常用标签：<br>1、properties标签：该标签可以加载外部的properties文件<br>2、typeAliases标签：设置类型别名<br>3、environments标签：数据源环境配置标签<br>4、typeHandlers标签：配置自定义类型处理器<br>5、plugins标签：配置MyBatis的插件</p><h2 id="Mybatis的多表操作">Mybatis的多表操作</h2><h3 id="一对一查询">一对一查询</h3><ol><li>一对一查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户<img src="https://img-blog.csdnimg.cn/f26fcdd3b8a740dea3fec531f9acff2a.png" alt=""></li><li>一对一查询的语句<br>对应的sql语句：select *  from orders o,user u where <a href="http://o.uid=u.id">o.uid=u.id</a>;<br>查询的结果如下：<img src="https://img-blog.csdnimg.cn/0968cc81b2ba484eb785a1c5e93624ad.png" alt=""></li><li>创建Order和User实体<img src="https://img-blog.csdnimg.cn/ae4d24f609e94fce9737dc5a6465ebcc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建OrderMapper接口<br><img src="https://img-blog.csdnimg.cn/4c1b39fb8ae34d019d257b6a2bc3730b.png" alt=""></li><li>配置OrderMapper.xml<img src="https://img-blog.csdnimg.cn/81e3f21081df4ed3a5eecea75adcf8fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>其中resultMap还可以配置如下：<img src="https://img-blog.csdnimg.cn/526e4c58701b4f9aaef6029dee7b1cfc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试结果<img src="https://img-blog.csdnimg.cn/e87dd5d63e604ffd9e96924093aaea9e.png" alt=""></li></ol><h3 id="一对多查询">一对多查询</h3><ol><li>一对多查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单<img src="https://img-blog.csdnimg.cn/1f61004f263c49aab77f4059c90e37d8.png" alt=""></li><li>一对多查询的语句<br>对应的sql语句：select *,<a href="http://o.id">o.id</a> oid from user u left join orders o on u.id=o.uid;<br>查询的结果如下：<img src="https://img-blog.csdnimg.cn/f4cac2e6e9be44149d4dbfeae0247bd9.png" alt=""></li><li>修改User实体<img src="https://img-blog.csdnimg.cn/90bcbc81caff4e58b4152e0bca4e1f0b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建UserMapper接口<img src="https://img-blog.csdnimg.cn/9040b43c412042f79f2fb5e3d10c0fd8.png" alt=""></li><li>配置UserMapper.xml<img src="https://img-blog.csdnimg.cn/bf4547942f3a4a83ac3a8cd7802f64fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试结果<img src="https://img-blog.csdnimg.cn/44b9d2df06ed4b46b4972b5b7c933ade.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><h3 id="多对多查询">多对多查询</h3><ol><li>多对多查询的模型<br>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用<br>多对多查询的需求：查询用户同时查询出该用户的所有角色<img src="https://img-blog.csdnimg.cn/66ef638df034407b8dba74b85bfdcda9.png" alt=""></li><li>多对多查询的语句<br>对应的sql语句：select u.<em>,r.</em>,<a href="http://r.id">r.id</a> rid from user u left join user_role ur on u.id=ur.user_id<br>inner join role r on ur.role_id=<a href="http://r.id">r.id</a>;<br>查询的结果如下：<img src="https://img-blog.csdnimg.cn/49aa165292704626916ae145ae9abd21.png" alt=""></li><li>创建Role实体，修改User实体<img src="https://img-blog.csdnimg.cn/269937e7fa3443079f28b280bce2033e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>添加UserMapper接口方法<img src="https://img-blog.csdnimg.cn/b5845dd85fc240aca7d58d11360d0e8e.png" alt=""></li><li>配置UserMapper.xml<img src="https://img-blog.csdnimg.cn/1abb4415bcdd465a8fc7db301dbb6f74.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="">6.  测试结果<br><img src="https://img-blog.csdnimg.cn/e0c8ebb538c84239b25a876e166f8a6a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><h3 id="知识小结-6">知识小结</h3><p>MyBatis多表配置方式：<br>一对一配置：使用 &lt; resultMap &gt; 做配置<br>一对多配置：使用&lt; resultMap &gt; + &lt; collection &gt;做配置<br>多对多配置：使用&lt; resultMap &gt; + &lt; collection &gt;做配置</p><h2 id="Mybatis注解开发">Mybatis注解开发</h2><h3 id="常用注解">常用注解</h3><p>这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper<br>映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。</p><p>@Insert：实现新增<br>@Update：实现更新<br>@Delete：实现删除<br>@Select：实现查询<br>@Result：实现结果集封装<br>@Results：可以与@Result 一起使用，封装多个结果集<br>@One：实现一对一结果集封装<br>@Many：实现一对多结果集封装</p><h3 id="MyBatis的增删改查">MyBatis的增删改查</h3><p>我们完成简单的user表的增删改查的操作<br><img src="https://img-blog.csdnimg.cn/9481606329ca45c1a3a678b0ece92d43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/a911324b4fb845678cd25b69a6913ff7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/1efa92bdab904438b1c6a474abd28630.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可<img src="https://img-blog.csdnimg.cn/a36cd22878694de884820c5894ccb27c.png" alt=""><br>或者指定扫描包含映射关系的接口所在的包也可以<img src="https://img-blog.csdnimg.cn/fd377d801b00491a8d53aad562367062.png" alt=""></p><h3 id="MyBatis的注解实现复杂映射开发">MyBatis的注解实现复杂映射开发</h3><p>实现复杂关系映射之前我们可以在映射文件中通过配置<resultMap>来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置<img src="https://img-blog.csdnimg.cn/0335c8ed633348d3b3b7732c2f145198.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br><img src="https://img-blog.csdnimg.cn/5482d132aefc4e94a9ce341c12c09720.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="一对一查询-2">一对一查询</h3><ol><li>一对一查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户<img src="https://img-blog.csdnimg.cn/081a29ea48b14dc792109fea857fc698.png" alt=""></li><li>一对一查询的语句<br>对应的sql语句：<br>select * from orders;<br>select * from user where id=查询出订单的uid;<br>查询的结果如下：<img src="https://img-blog.csdnimg.cn/6f3bdc24f77441209e2b41f7b9bca5c7.png" alt=""></li><li>创建Order和User实体<img src="https://img-blog.csdnimg.cn/ffce0836056b4b91a93f4fe52fdc0a3a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_19,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建OrderMapper接口<br><img src="https://img-blog.csdnimg.cn/ead61cec330240df96727bd60a3c490b.png" alt=""></li><li>使用注解配置Mapper<br><img src="https://img-blog.csdnimg.cn/61a2d2ed5a124e8ebfd0e32395964895.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试结果<br><img src="https://img-blog.csdnimg.cn/a5cdf7b707c34729a1b0a0abdbed0740.png" alt=""></li></ol><h3 id="一对多查询-2">一对多查询</h3><ol><li>一对多查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单<img src="https://img-blog.csdnimg.cn/dcb974cd7cdf4503923ce7108df14b97.png" alt=""></li><li>一对多查询的语句<br>对应的sql语句：<br>select * from user;<br>select * from orders where uid=查询出用户的id;<br>查询的结果如下：<img src="https://img-blog.csdnimg.cn/7248fb5f424540058d5b26cc623c1aa7.png" alt=""></li><li>修改User实体<br><img src="https://img-blog.csdnimg.cn/0dd5a78fabda4f68b4c32342fd29321c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>创建UserMapper接口<br><img src="https://img-blog.csdnimg.cn/ee9f2624473b4651bbf382784556080c.png" alt=""></li><li>使用注解配置Mapper<img src="https://img-blog.csdnimg.cn/2ee2a3b29fb7443c93be52c59070a0ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试结果<img src="https://img-blog.csdnimg.cn/f9e6747f5fda474f9af72e3fd1c2153c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><h3 id="多对多查询-2">多对多查询</h3><ol><li>多对多查询的模型<br>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用<br>多对多查询的需求：查询用户同时查询出该用户的所有角色<img src="https://img-blog.csdnimg.cn/9ca29a1f088945e3955650791d152e65.png" alt=""></li><li>多对多查询的语句<br>对应的sql语句：<br>select * from user;<br>select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id<br>查询的结果如下：<img src="https://img-blog.csdnimg.cn/c5be8d6050ab425980e9acab7a13368a.png" alt=""></li><li>创建Role实体，修改User实体<img src="https://img-blog.csdnimg.cn/c99aaadbf66346098e5c20fc7b10118a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>添加UserMapper接口方法<img src="https://img-blog.csdnimg.cn/fa5fdbafd71247a7b05640bc16e4dd36.png" alt=""></li><li>使用注解配置Mapper<img src="https://img-blog.csdnimg.cn/81e3e446872148e5a5126d122895a1aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li><li>测试结果<img src="https://img-blog.csdnimg.cn/092b7e2fbcae454da6ed1cad3015f72b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWVyY3VyeTIuIDA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></li></ol><h2>至此为全部的SSM笔记.</h2>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>mybatis</tag>
      
      <tag>springMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
